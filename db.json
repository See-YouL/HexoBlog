{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1685281341440},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1685282720505},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1685282720505},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1685282720507},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1685282720505},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1685282720508},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1685282720508},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1685282720507},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1685282720508},{"_id":"themes/next/_config.yml","hash":"dafcef6c1424ae3df108f4312d9e60abf591fe88","modified":1685334378187},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1685282720508},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1685282720513},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1685282720527},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1685282720505},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1685282720506},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1685282720506},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1685282720506},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1685282720507},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1685282720507},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1685282720507},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1685282720507},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1685282720507},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1685282720507},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1685282720507},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1685282720509},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1685282720509},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1685282720509},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1685282720509},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1685282720509},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1685282720509},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1685282720510},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1685282720510},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1685282720510},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1685282720515},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1685282720515},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1685282720515},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1685282720515},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1685282720515},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1685282720516},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1685282720515},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1685282720516},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1685282720516},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1685282720516},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1685282720516},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1685282720516},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1685282720516},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1685282720517},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1685282720517},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1685282720517},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1685282720517},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1685282720517},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1685282720517},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1685282720517},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1685282720517},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1685282720517},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1685282720529},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1685282720518},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1685282720526},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1685282720526},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1685282720526},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1685282720526},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1685282720526},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1685282720526},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1685282720506},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1685282720506},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1685282720506},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1685282720506},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1685282720510},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1685282720510},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1685282720510},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1685282720510},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1685282720511},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1685282720511},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1685282720511},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1685282720512},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1685282720512},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1685282720513},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1685282720513},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1685282720513},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1685282720513},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1685282720528},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1685282720527},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1685282720528},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1685282720528},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1685282720528},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1685282720529},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1685282720528},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1685282720529},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1685282720529},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1685282720529},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1685282720529},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1685282720529},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1685282720529},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1685282720530},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1685282720529},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1685282720530},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1685282720530},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1685282720530},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1685282720530},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1685282720529},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1685282720530},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1685282720540},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1685282720544},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1685282720544},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1685282720544},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1685282720545},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1685282720545},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1685282720545},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1685282720545},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1685282720545},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1685282720546},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1685282720545},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1685282720546},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1685282720546},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1685282720546},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1685282720546},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1685282720546},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1685282720546},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1685282720547},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1685282720547},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1685282720547},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1685282720548},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1685282720548},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1685282720518},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1685282720518},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1685282720518},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1685282720518},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1685282720518},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1685282720519},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1685282720521},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1685282720520},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1685282720521},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1685282720521},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1685282720523},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1685282720521},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1685282720523},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1685282720525},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1685282720523},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1685282720524},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1685282720525},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1685282720527},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1685282720527},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1685282720527},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1685282720527},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1685282720527},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1685282720527},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1685282720528},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1685282720528},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1685282720528},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1685282720528},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1685282720528},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1685282720543},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1685282720544},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1685282720544},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1685282720544},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1685282720544},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1685282720547},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1685282720547},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1685282720550},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1685282720550},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1685282720519},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1685282720518},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1685282720519},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1685282720519},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1685282720519},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1685282720519},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1685282720519},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1685282720519},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1685282720520},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1685282720519},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1685282720520},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1685282720520},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1685282720520},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1685282720520},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1685282720520},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1685282720521},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1685282720520},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1685282720521},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1685282720521},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1685282720521},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1685282720521},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1685282720521},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1685282720521},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1685282720523},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1685282720523},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1685282720523},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1685282720523},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1685282720523},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1685282720524},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1685282720523},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1685282720524},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1685282720524},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1685282720524},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1685282720524},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1685282720524},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1685282720524},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1685282720525},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1685282720525},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1685282720524},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1685282720525},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1685282720525},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1685282720524},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1685282720525},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1685282720525},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1685282720525},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1685282720526},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1685282720526},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1685282720530},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1685282720526},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1685282720530},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1685282720535},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1685282720540},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1685282720535},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1685282720530},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1685282720538},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1685282720538},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1685282720538},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1685282720539},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1685282720533},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1685282720539},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1685282720540},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1685282720539},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1685282720541},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1685282720539},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1685282720541},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1685282720543},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1685282720543},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1685282720549},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1685282720548},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1685282720532},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1685282720532},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1685282720532},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1685282720532},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1685282720532},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1685282720533},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1685282720533},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1685282720531},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1685282720533},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1685282720533},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1685282720533},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1685282720533},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1685282720533},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1685282720534},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1685282720533},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1685282720534},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1685282720534},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1685282720534},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1685282720534},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1685282720535},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1685282720534},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1685282720535},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1685282720535},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1685282720535},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1685282720535},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1685282720536},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1685282720536},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1685282720537},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1685282720537},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1685282720537},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1685282720537},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1685282720537},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1685282720538},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1685282720538},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1685282720539},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1685282720538},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1685282720539},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1685282720539},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1685282720539},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1685282720540},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1685282720540},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1685282720540},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1685282720540},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1685282720549},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1685282720549},{"_id":"public/2023/05/28/hello-world/index.html","hash":"bb302c7da79ac29741a7b903d3ec4aab0fbc296f","modified":1706383540490},{"_id":"public/archives/index.html","hash":"47e6e96ad52f4444dec674dcd989610e0b32f9b5","modified":1706383540490},{"_id":"public/archives/2023/index.html","hash":"411fd7d9d327ed2443c0b4d02e86f59b25673cc9","modified":1706383540490},{"_id":"public/archives/2023/05/index.html","hash":"03a0cc4d15e1e91791a6c14209a46f4d301d0e2d","modified":1706383540490},{"_id":"public/index.html","hash":"3ef0a7f90d6c069178b989776a3de63b018aff0d","modified":1706768164273},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1685283731990},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1685283731990},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1685283731990},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1685283731990},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1685283731990},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1685283731990},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1685283731990},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1685283731990},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1685283731990},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1685283731990},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1685283731990},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1685283731990},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1685283731990},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1685283731990},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1685283731990},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1685283731990},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1685283731990},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1685283731990},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1685283731990},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1685283731990},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1685283731990},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1685283731990},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1685283731990},{"_id":"public/css/main.css","hash":"24a4cc713921bd076ab4850c63ae8176220adde1","modified":1685283731990},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1685283731990},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1685283731990},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1685283731990},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1685283731990},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1685283731990},{"_id":"source/_posts/ARM嵌入式复习笔记.md","hash":"4103fc361b0aa57d114555d90b04fd82743d608c","modified":1685334004747},{"_id":"public/tags/嵌入式/index.html","hash":"357438ab770a6b3383671ab7fbf39ecf3f72b0df","modified":1706383540490},{"_id":"public/2023/05/29/ARM嵌入式复习笔记/index.html","hash":"c6cff722ff51067702650228864d4a6e0147eb53","modified":1706383540490},{"_id":"public/tags/Embedded/index.html","hash":"ccb8be381179307289d2ff42958ce8f3dc22784d","modified":1685333970224},{"_id":"source/_posts/test.md","hash":"c9b1b5b02b396503bb0d3342b11f17e0b0e365da","modified":1685333641928},{"_id":"public/2023/05/29/test/index.html","hash":"6c184e654f2796168b65b523977863285166756d","modified":1685333970224},{"_id":"public/tags/test/index.html","hash":"e6eb233cc0fc8c827fc3095e62c7b91712df3379","modified":1685333970224},{"_id":"source/tags/index.md","hash":"c5ffa40185a39cd5773f88a2f5efaf3149c48ade","modified":1685333962061},{"_id":"public/tags/index.html","hash":"b0094fefacb345bee68a9e7ff7ec12acba1aadef","modified":1706383540490},{"_id":"source/_posts/修改WindowsTerminal默认启动路径.md","hash":"405f2cb539cf5fd28c6efcaa0bbf357ef4b028e5","modified":1685364817842},{"_id":"source/_posts/修改Poershell默认启动路径.md","hash":"7b103d4520a781f87c13b452a91eefacdb5f5e38","modified":1685364757519},{"_id":"public/2023/05/29/修改Poershell默认启动路径/index.html","hash":"aa20b604ee08ef0de61582802fd8e9f101e728c5","modified":1706383540490},{"_id":"public/2023/05/29/修改WindowsTerminal默认启动路径/index.html","hash":"f06e81164d7bb265ce2ac1f72a778d7bfcb97578","modified":1706383540490},{"_id":"public/tags/Windows/index.html","hash":"7ce6370202b99531e5e55d9cd2404768624319f6","modified":1706383540490},{"_id":"source/_posts/Hexo添加标签.md","hash":"088048cf2152c953cf8b49f0834d7aac809e8710","modified":1685367182958},{"_id":"public/tags/博客/index.html","hash":"9ac4c08990bab6ab4ff1b656d7b7910d235b526d","modified":1706383540490},{"_id":"public/2023/05/29/Hexo添加标签/index.html","hash":"aef47ff5c66149903ca17af127834246d1f6dd85","modified":1706383540490},{"_id":"source/_posts/配置虚拟机通过主机代理.md","hash":"ac086e60063c3939d4b57ff04af62f0b79e1fd06","modified":1705426840674},{"_id":"public/2024/01/06/配置虚拟机通过主机代理/index.html","hash":"636e3c2c4d5360137e543fd6434fbeddb5dc1858","modified":1706383540490},{"_id":"public/archives/2024/index.html","hash":"fc02f3bb4f7bcdff78f1d8ac81dc54847821311f","modified":1706383540490},{"_id":"public/archives/2024/01/index.html","hash":"d9ec33161865527dd6960f9b6b6299fb3eb25518","modified":1706383540490},{"_id":"source/_posts/Git代理命令.md","hash":"72414db0e61ea7ab6a752afd736ec264cc0f59f1","modified":1705171544084},{"_id":"public/2024/01/14/Git代理命令/index.html","hash":"75cf4485b635a4d28ee322053b03d0ecbb90a775","modified":1706383540490},{"_id":"public/tags/Git/index.html","hash":"3234b6f53911296dc8ed6267108309cce54d2605","modified":1706383540490},{"_id":"public/tags/虚拟机/index.html","hash":"6b0eafd6032400ff55f2910f8f8ad5d38c3855a0","modified":1706383540490},{"_id":"source/_posts/Git常用命令.md","hash":"bf9fa2cf5c0365fe9498ff70539ae791c4042ecd","modified":1705428764186},{"_id":"public/2024/01/17/Git常用命令/index.html","hash":"729f6c7d8d4914864a5662349716edcf749c7a6d","modified":1706383540490},{"_id":"source/_posts/STM32F103学习笔记.md","hash":"884fc51273128b6f4736cf552f3dd4044ba0b842","modified":1706517717574},{"_id":"public/2024/01/17/STM32F103学习笔记/index.html","hash":"4d131667672d03d0d5393d46eaf8bb0b103e0f7a","modified":1706517881078},{"_id":"source/_posts/波特率与比特率.md","hash":"31b3a9ef0af94036f16cf3943db06abfafe277d6","modified":1705478671989},{"_id":"public/tags/通信/index.html","hash":"850273264a148b52f17468e7774d3f42aba75336","modified":1706383540490},{"_id":"public/2024/01/17/波特率与比特率/index.html","hash":"362f283e8f76a412d646eb9315b0a22376574490","modified":1706383540490},{"_id":"source/_posts/Doxygen常用注释语法.md","hash":"1603a4c84eef28c10b2dd1970edf53396595e200","modified":1706253655542},{"_id":"public/archives/page/2/index.html","hash":"68973f2265a26b3bc2d27328aebafdad77f010a2","modified":1706383540490},{"_id":"public/page/2/index.html","hash":"b313d5d2e9866b972b489316b6d8673b857ec969","modified":1706383540490},{"_id":"public/2024/01/26/Doxygen常用注释语法/index.html","hash":"d3fc2d2af2c6fcfa5ecde87f4960ed8ff78dbe0c","modified":1706383540490},{"_id":"public/tags/Doxygen/index.html","hash":"2ca9a9b506b8fece2b44e7ba99f57be6c6e0ae39","modified":1706383540490},{"_id":"source/_posts/取消Vscode在输入符号时自动补全.md","hash":"85b19ae331b3e9535d348cf9e38ce72a9c38511d","modified":1706359910185},{"_id":"public/2024/01/27/取消Vscode在输入符号时自动补全/index.html","hash":"0187855b03c84b77d9e90e23ae8fd3674e7ac325","modified":1706383540490},{"_id":"public/tags/Vscode/index.html","hash":"5a115aa7495f83335f3d5348a23897de81e2f356","modified":1706383540490},{"_id":"source/_posts/Vscode常用快捷键.md","hash":"4d6d38d8849157a78b08192cec5ed808e17e42be","modified":1706768006840},{"_id":"public/2024/01/27/Vscode常用快捷键/index.html","hash":"a6906f100a0c12c200fa5bf554cf7cd37ddb2c4a","modified":1706768164273},{"_id":"source/_posts/增加Vscode引用路径.md","hash":"d8e94706ba9b34017c56f5afaa2e31a9ef727afd","modified":1706371850086},{"_id":"public/2024/01/27/增加Vscode引用路径/index.html","hash":"7ceaa77533096eaf8c1b685f5ca22399ad234a2c","modified":1706383540490},{"_id":"source/_posts/配置Vscode与STM32串口连接.md","hash":"06cab82a61d6a2cd2dc680996d62c6eca024ffc3","modified":1706383533140},{"_id":"public/2024/01/28/配置Vscode与STM32串口连接/index.html","hash":"4b42177ada1eb38785839161af32aa3438facfde","modified":1706383540490}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2023-05-29T04:18:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-05-29 12:18:26\ntype: \"tags\"\n---\n","updated":"2023-05-29T04:19:22.061Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cli8cbya200003k97hzm79ui7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-05-28T13:42:21.440Z","updated":"2023-05-28T13:42:21.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli7if65y0000r097bbggc071","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\">Quick Start</h2>\n<h3 id=\"create-a new post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to remote sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\">Quick Start</h2>\n<h3 id=\"create-a new post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to remote sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"ARM嵌入式复习笔记","date":"2023-05-29T03:37:03.000Z","_content":"\n\n## 填空\n\n### 嵌入式系统概念填空\n\n1. 嵌入式系统是以**应用系统**为中心，以**计算机为基础**，**软硬件可裁剪**，~~适应应用系统对功能、可靠性、成本、体积、功耗严格要求~~的**专用**计算机系统。\n2. ARM处理器是ARM公司设计的基于RISC架构的**32位**高性能微处理器，一般采用**哈佛**总线结构，具有高速指令缓存和数据缓存，指令长度固定且多级流水线执行。\n\n### 工作频率填空\n\n1. Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，**APB1总线的最高工作频率为36MHz。**\n2. Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，**APB2总线的最高工作频率为72MHz。**\n3. Cortex-M3**内核的最高工作时钟频率为72MHz。**\n\n### 时钟填空\n\n1. 32F103的系统时钟SYSCLK可以来自**HSI（内部高速时钟）、HSE（外部高速时钟）和PLL（锁相环）**三个时钟源中的一个。\n2. 当STM32F103外接8MHz的晶体时，若使内核达到最高工作时钟频率，PLL的倍频系数应设置为9倍。\n3. STM32F103外接的**32768Hz晶体主要用来为芯片内部的RTC部件提供时钟源。**\n\nPLL倍频系数的设置\n\n```tex\n计算步骤如下：\n系统时钟SYSCLK = (输入时钟频率) × (PLL倍频系数)\n72 MHz = 8 MHz × 9\n因此，PLL的倍频系数应设置为9倍\n```\n\n### 存储器填空\n\n1. STM32F103芯片是**32位**的微控制器，**可寻址存储空间的大小为4GB。**\n2. STM32F103芯片可寻址存储空间的大小为 4GB，分为 8个512MB的存储块。\n3. 当BOOT0 = 0时，STM32F103上电后，用户程序将从Flash存储器启动。\n\n### GPIO填空\n\n1. STM32F103ZET6芯片包含**7 个16位**的通用目的输入/输出口（GPIO）。。\n2. STM32F103ZET6芯片共有**112根GPIO引脚**，可从其中**任选16根**作为外部中断输入口。\n\n### 中断填空\n\n1. STM32F103微控制器具有**10个异常和60个中断**，**中断优先级为16 级**。\n2. STM32F103微控制器的EXTI模块有**16个连接GPIO的外部中断线**，对应**16个外部中断向量**。\n3. STM32F103微控制器共**有3个串口**，其中**USART1的工作时钟源来自于APB2总线** 。\n4. STM32F103微控制器共有**3个串口**，其中**USART2的工作时钟源来自于APB1总线** 。\n\n### ADC填空\n\n1. STM32F103微控制器的ADC模块**支持单次和连续转换模式**。\n2. STM32F103微控制器的ADC模块**分辨率为12位**，**最小转换时间为1.17微妙**\n3. STM32F103的ADC1有16个外部模拟输入通道，**分辨率为12 位。**\n4. STM32F103的ADC的**分辨率为12位**，**最高转换速率是1MHz**\n\n### 操作系统填空\n\n1. 嵌入式操作系统根据各个任务的要求，进行内存管理、多任务管理、资源管理、任务调度、消息管理和异常处理等工作。\n2. uC/OS-II操作系统是一个**源代码公开、可移植、可固化、可裁剪、可配置式**的实时多任务操作系统，**最多可支持255个任务**。\n3. 在uC/OS-II操作系统中，通过**互斥信号量**可实现对共享资源的**抢占式访问**。\n\n## 简答\n\n### 嵌入式系统概念简答\n\n#### 从技术角度来说什么是嵌入式系统？8051单片机应用系统是否属于嵌入式系统？\n\n1. 嵌入式系统是**以应用系统为中心**，**以计算机为基础**，**软硬件可裁剪**，~~适应应用系统对功能、可靠性、成本、体积、功耗严格要求~~的**专用计算机系统**\n2. 8051单片机应用系统**可以**被归类为嵌入式系统。\n\n#### 嵌入式实时操作系统中的“实时性”指的是什么？\n\n1. 实时性是**系统对外部事件的及时响应和任务的及时完成能力。** *实时性可以分为硬实时和软实时两种类型。*\n2. 硬实时要求系统在严格的时间约束下，对外部事件作出及时的响应。**任务的截止时间是固定的，任何超出时间限制的情况都可能导致系统功能失效或系统崩溃。**\n3. 软实时要求系统尽可能在特定的时间约束下，对外部事件作出及时的响应，但允许偶尔的违反时间限制。**任务的截止时间相对宽松，系统可以容忍一定程度的任务响应时间超出。**\n\n### 时钟简答\n\n#### STM32F103微控制器的工作时钟源有哪几种？各时钟源的频率范围分别是多少？\n\n1. **HSI（High-Speed Internal）高速内部时钟**：频率为8MHz。\n2. **HSE（High-Speed External）高速外部时钟**：频率范围通常为4MHz至16MHz。\n3. **PLL（Phase-Locked Loop）锁相环时钟**：可以使用HSI或HSE作为输入时钟源，并通过倍频系数进行倍频。具体的频率范围取决于倍频系数的设置。\n\n#### 在STM32F103内部的时钟树中，锁相环PLL有什么用途？\n\n1. **时钟倍频**：PLL可以将输入时钟频率倍增，提供更高的系统时钟频率。\n2. **稳定时钟源**：PLL可以提供更稳定的时钟源，减小时钟的抖动和波动。\n3. **系统时钟源**：在STM32F103中，PLL经常被配置为系统时钟源（SYSCLK），即整个微控制器系统的主要时钟源。\n\n#### 嵌入式系统中的启动代码（startup_stm32f10x_hd.s）程序的功能是什么？\n\n1. **初始化向量表**：启动代码会定义和初始化微控制器的向量表，其中包含了中断处理函数的入口地址。向量表的初始化是确保中断处理能够正确触发和执行的重要步骤。\n2. **初始化堆栈和堆栈指针**：启动代码会设置初始堆栈指针，指向程序的堆栈空间。这是确保函数调用和中断处理正常工作的必要步骤。\n3. **初始化系统时钟**：启动代码会进行系统时钟的初始化，包括配置时钟源、设置时钟分频器等操作，以确保系统在正确的时钟频率下运行。\n4. **初始化存储器和外设**：启动代码可能包括对存储器和外设的初始化操作，例如设置存储器映射、配置外设寄存器等。\n5. **调用主函数**：启动代码最终会调用应用程序的主函数（如`main`函数），使应用程序正式开始执行。\n\n#### STM32F103微控制器的最小系统由哪几部分构成？\n\n1. **STM32F103微控制器芯片**：这是系统的核心部分，包含了CPU、存储器、外设等功能模块。\n2. **时钟源**：最小系统需要提供适当的时钟源，以驱动微控制器的各个部分。常见的时钟源包括晶体振荡器、外部时钟源或者内部时钟源。\n3. **复位电路**：复位电路用于在系统上电或者复位时将微控制器置于初始状态。它通常由复位按钮、电容和电阻等组成。\n4. **电源管理电路**：为STM32F103微控制器提供稳定的电源供应，并对电源进行滤波和保护。这包括电源连接器、电源滤波电容、稳压器等。\n5. **外部连接器**：用于与外部设备或外部电路进行连接，包括通信接口（如UART、SPI、I2C）、GPIO引脚、ADC输入等。\n\n#### STM32F103微控制器有哪几种启动模式？如何来配置系统启动模式？\n\n1. **主启动模式（Main Boot Mode）**：在主启动模式下，微控制器从FLASH存储器的起始地址处开始执行代码。\n2. **系统存储器模式（System Memory Boot Mode）**：在系统存储器模式下，微控制器从内部的系统存储器（一般为ROM或者Flash）的起始地址处开始执行代码。\n3. **内存模式（RAM Boot Mode）**：在内存模式下，微控制器从系统RAM中的特定地址处开始执行代码。\n\n系统启动模式的配置是通过BOOT pins（BOOT0和BOOT1）的状态来实现的。这些引脚通常通过跳线帽或者外部电平转换器与微控制器连接。\n\n具体的配置方式如下：\n\n- 如果BOOT0引脚为高电平，那么微控制器将进入内存模式。\n- 如果BOOT0引脚为低电平（接地），那么微控制器将根据BOOT1引脚的状态来选择启动模式。\n  - 如果BOOT1引脚也为低电平，那么微控制器将进入主启动模式。\n  - 如果BOOT1引脚为高电平，那么微控制器将进入系统存储器模式。\n\n### 存储器简答\n\n#### 什么是存储器重映射？STM32F103微控制器的哪些存储区域需要进行存储器重映射？\n\n存储器重映射**是指将某些存储器区域的物理地址重新映射到不同的逻辑地址的过程。**\n\n在STM32F103微控制器中，存储器重映射主要涉及以下两个存储区域：\n\n1. **系统存储器（System Memory）**：系统存储器包含了微控制器的启动代码和ROM固件库。在存储器重映射时，系统存储器的物理地址将被映射到内部的ROM或者Flash存储器的起始地址，使得系统可以从内部存储器中执行代码。\n\n2. **外部SRAM（External SRAM）**：STM32F103微控制器具有一些器件型号支持外部SRAM的扩展。在存储器重映射时，外部SRAM的物理地址可以被映射到微控制器的内部存储器的地址空间中，使得外部SRAM可以像内部存储器一样被访问和使用。\n\n### 中断简答\n\n#### STM32F103微控制器的异常和中断有什么区别？优先级最高的是哪个异常/中断？\n\n在STM32F103微控制器中，异常和中断是两种不同的事件处理机制，它们有以下区别：\n\n1. **异常（Exception）**：异常是指**由于指令执行或系统事件引起的处理器中断。它们通常表示了一些严重的错误或特殊情况，需要立即处理。**~~异常包括复位、非屏蔽中断（如硬件故障）、系统调试异常等。异常的处理优先级高于中断。~~\n\n2. **中断（Interrupt）**：中断是指**外部设备或特定事件触发的处理器中断。它们通常表示了一些需要优先处理的异步事件**，如外部输入信号、定时器溢出等。中断可以根据优先级配置，并**可被屏蔽或使能。**\n\n在STM32F103微控制器中，优先级最高的异常是**复位（Reset）**异常。复位异常在系统上电或者复位时触发，用于将系统重置到初始状态。它的优先级最高，无法被屏蔽。\n\n### GPIO简答\n\n#### STM32F103微控制器的GPIO有哪几种工作模式？GPIO作按键输入时应选择哪种工作模式？\n\n1. **输入模式（Input Mode）**：将GPIO配置为输入模式，用于读取外部信号或按键的状态。可以选择不同的输入模式，如**浮空输入、上拉输入和下拉输入**，以适应不同的电路连接方式。\n2. **输出模式（Output Mode）**：将GPIO配置为输出模式，用于控制外部设备或驱动器。输出模式可以选择**推挽输出、开漏输出、推挽输出带上拉或下拉等**。\n3. **复用功能模式（Alternate Function Mode）**：将GPIO配置为复用功能模式，可以使用GPIO引脚来实现其他外设功能，如串口、定时器、SPI等。\n4. **模拟模式（Analog Mode）**：将GPIO配置为模拟模式，用于连接模拟信号输入或输出。\n\n当GPIO用作按键输入时，应选择**输入模式**。可以根据实际情况选择浮空输入、上拉输入或下拉输入，以确保按键的状态能够正确读取。*浮空输入适用于按键有外部上拉或下拉电阻的情况，上拉输入适用于按键接地时为低电平，下拉输入适用于按键接VCC时为高电平的情况。*具体的选择取决于按键连接电路的设计和要求。\n\n\n#### 请用端口输出数据寄存器(ODR )，编写控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平的语句\n\n要使用端口输出数据寄存器（ODR）控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平，可以使用以下语句：\n\n```c\nGPIOC->ODR |= GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5; // 设置PC3、PC4、PC5引脚为高电平\nGPIOC->ODR &= ~(GPIO_ODR_ODR0 | GPIO_ODR_ODR1 | GPIO_ODR_ODR2); // 设置PC0、PC1、PC2引脚为低电平\n```\n\n#### 请用端口置位/清零寄存器(BSRR )，编写控制GPIOB口的PB0-PB5引脚输出高电平，其它引脚保持不变的语句\n\n要使用端口置位/清零寄存器（BSRR）控制GPIOB口的PB0-PB5引脚输出高电平，同时保持其他引脚状态不变，可以使用以下语句：\n\n```c\nGPIOB->BSRR = GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5; // 设置PB0-PB5引脚为高电平\n```\n\n#### 请用端口清零寄存器(BRR )，编写控制GPIOD口的PD0-PD3引脚输出低电平，其它引脚保持不变的语句\n\n要使用端口清零寄存器（BRR）控制GPIOD口的PD0-PD3引脚输出低电平，同时保持其他引脚状态不变，可以使用以下语句：\n\n```c\nGPIOD->BRR = GPIO_BRR_BR0 | GPIO_BRR_BR1 | GPIO_BRR_BR2 | GPIO_BRR_BR3; // 设置PD0-PD3引脚为低电平\n```\n\n#### 简述STM32F103微控制器的GPIO相关各个寄存器的含义和作用\n\n1. GPIO配置寄存器（GPIOx_CRL和GPIOx_CRH）：用于配置GPIO引脚的工作模式、输入/输出类型、输出速度和上下拉等特性。\n2. 端口输入数据寄存器（GPIOx_IDR）：用于读取GPIO引脚的输入状态，包括输入高低电平。\n3. 端口输出数据寄存器（GPIOx_ODR）：用于设置或读取GPIO引脚的输出状态，可以控制引脚的高低电平。\n4. 端口状态寄存器（GPIOx_SR）：用于读取GPIO引脚的状态标志位，包括引脚的输入状态、输出状态和事件状态等。\n5. 端口配置锁定寄存器（GPIOx_LCKR）：用于锁定GPIO引脚的配置，防止误操作修改引脚的配置设置。\n6. 端口复位寄存器（GPIOx_BRR）：用于通过写入引脚位控制寄存器（BRR）的对应位，将GPIO引脚置为低电平，实现引脚的复位操作。\n\n#### 对比分析STM32寄存器编程和库函数编程两种编程方式的特点\n\n1. 寄存器编程方式：\n   - 直接操作硬件寄存器：寄存器编程方式直接操作硬件寄存器，能够直接控制硬件的各个功能和特性。\n   - 精确控制：通过寄存器编程可以对硬件进行细粒度的控制，可以灵活地配置和调整各种参数，满足特定的需求。\n   - 低层访问：寄存器编程是对硬件的直接访问，属于底层编程方式，对硬件细节要求较高，需要更多的了解和掌握。\n   - 更高的性能：由于直接操作寄存器，避免了函数调用和库函数的开销，寄存器编程方式可以获得更高的性能和响应速度。\n2. 库函数编程方式：\n   - 抽象封装：库函数编程方式通过提供封装好的函数接口，屏蔽了底层的寄存器操作细节，提供了更高层次的抽象。\n   - 简化开发：库函数提供了丰富的功能库，包括GPIO、定时器、串口等模块，简化了开发者的工作，减少了代码量。\n   - 更高的可移植性：库函数编程方式抽象了底层硬件细节，使得代码更具可移植性，可以在不同的芯片和平台上进行移植和复用。\n   - 需要更多的资源：库函数需要占用一定的存储空间，同时运行时需要更多的内存资源，因此对于资源有限的嵌入式系统可能需要权衡。\n\n综上所述，寄存器编程方式适用于对硬件控制要求高、对性能要求高的场景，需要更底层的控制和精确配置；而库函数编程方式则适用于快速开发、提高可移植性和简化开发流程的场景。选择哪种编程方式取决于具体的需求和开发环境。\n\n### 中断\n\n#### 简述STM32F103嵌套向量中断控制器（NVIC）的作用和特点\n\nSTM32F103嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）是STM32F103微控制器中负责管理和控制中断的重要模块。它的作用是**协调和处理各种中断请求，并根据中断的优先级和状态进行中断服务程序的调度。**\n\n以下是STM32F103 NVIC的主要特点和作用：\n\n1. 中断优先级管理：NVIC支持对各个中断通道的优先级进行配置和管理。中断通道的优先级可以根据应用需求进行设置，以确保关键的中断能够得到及时响应。\n2. 嵌套中断支持：NVIC支持嵌套中断的处理。当一个中断正在处理时，如果有更高优先级的中断请求到达，NVIC会暂时中断当前中断的处理，优先处理更高优先级的中断请求。这种机制确保了关键中断的实时性和优先级的保障。\n3. 中断向量表：NVIC维护着中断向量表，用于存储中断服务程序的入口地址。每个中断通道都对应着中断向量表中的一个位置，当中断请求到达时，NVIC会根据中断通道找到对应的中断服务程序并执行。\n4. 中断使能和屏蔽：NVIC提供了使能和屏蔽中断的功能。通过设置相应的控制寄存器，可以启用或禁用特定的中断通道，以满足应用的需求。\n5. 中断状态管理：NVIC能够管理中断的状态，包括中断挂起、中断激活和中断标志等。这些状态信息可以帮助开发者更好地管理和调试中断程序。\n\n#### 简述STM32F103的NVIC中断优先级分组方法和优先级划分\n\nSTM32F103的NVIC中断优先级分组方法和优先级划分主要通过两个寄存器来配置：~~NVIC_IPR（Interrupt Priority Register）和NVIC_ISER（Interrupt Set Enable Register）。~~\n\n1. 中断优先级分组方法：\n   - STM32F103支持4种中断优先级分组方式，即分为Group 0、Group 1、Group 2和Group 3。不同的分组方式决定了优先级位数的分配。\n   - ~~通过SCB_AIRCR（Application Interrupt and Reset Control Register）寄存器的位[10:8]来配置中断优先级分组方法。~~\n2. 优先级划分：\n   - 在STM32F103中，中断的优先级范围是从0（最高优先级）到15（最低优先级）。数字越小，优先级越高。\n   - 根据选择的中断优先级分组方式，优先级位数的分配有所不同。以下是各个分组方式下的优先级划分情况：\n     - Group 0：全局抢占式优先级分组，优先级分配为4位。\n     - Group 1：1位抢占式优先级和3位子优先级，优先级分配为3位抢占优先级和1位子优先级。\n     - Group 2：2位抢占式优先级和2位子优先级，优先级分配为2位抢占优先级和2位子优先级。\n     - Group 3：3位抢占式优先级和1位子优先级，优先级分配为1位抢占优先级和3位子优先级。\n\n通过配置NVIC_IPR寄存器，可以为每个中断通道分配相应的抢占式优先级和子优先级。优先级越高的中断在发生时将优先得到处理，而优先级相同的中断将按照先到先服务（FIFO）的顺序进行处理。\n\n需要注意的是，在STM32F103中，具有相同优先级的中断中，越靠近中断向量表的位置的中断具有更高的优先级。因此，在进行中断优先级划分时，需要根据中断的重要性和实时性要求进行合理的分配。\n\n#### 简述STM32F103的NVIC中断优先级分组中抢占优先级和响应优先级的区别\n\n1. 抢占优先级（Preemption Priority）：\n   - 抢占优先级指的是中断发生时，当前正在执行的中断能否被其他中断打断。具有较高抢占优先级的中断可以打断正在执行的低优先级中断，优先获得处理器的控制权。\n   - 抢占优先级的数值越小，表示优先级越高，能够打断的中断范围越广。\n\n2. 响应优先级（Subpriority）：\n   - 响应优先级指的是在同一抢占优先级下，多个中断同时请求服务时的优先级排序。具有较高响应优先级的中断将首先得到处理器的服务。\n   - 响应优先级的数值越小，表示优先级越高。\n\n\n#### 假定设置中断优先级组为2，然后设置：中断3（ RTC 中断）的抢占优先级为2，响应优先级为1；中断6（外部中断0）的抢占优先级为3，响应优先级为0；中断7（外部中断1）的抢占优先级为2，响应优先级为0。写出这3个中断的优先级顺序。\n\n根据您提供的中断优先级设置，结合中断优先级分组为2，可以确定以下中断的优先级顺序：\n\n1. 中断3（RTC中断）的优先级：抢占优先级 2，响应优先级 1。\n2. 中断6（外部中断0）的优先级：抢占优先级 3，响应优先级 0。\n3. 中断7（外部中断1）的优先级：抢占优先级 2，响应优先级 0。\n\n根据中断优先级的设置规则：\n\n- 具有较高的抢占优先级的中断可以打断正在执行的低优先级中断。\n- 在相同抢占优先级下，具有较高的响应优先级的中断将首先得到处理器的服务。\n\n根据上述设置，优先级顺序为：\n\n1. 中断6（外部中断0）：抢占优先级 3，响应优先级 0。\n2. 中断7（外部中断1）：抢占优先级 2，响应优先级 0。\n3. 中断3（RTC中断）：抢占优先级 2，响应优先级 1。\n\n因此，中断6（外部中断0）具有最高优先级，中断3（RTC中断）具有次高优先级，中断7（外部中断1）具有最低优先级。\n\n### 定时器/计数器简答\n\n#### STM32F103微控制器的常规定时器分为哪3种?\n\n1. TIM1（定时器1）：这是一个高级定时器，具有较复杂的功能和多路输出通道，可用于实现高级的定时和PWM控制。\n2. TIM2（定时器2）：这是一个通用定时器，具有基本的定时功能，可用于一般的定时和计数应用。\n3. TIM3（定时器3）：这是一个通用定时器，与TIM2类似，也具有基本的定时和计数功能，可广泛应用于定时和计数需求。\n\n#### STM32F103微控制器的高级定时器和通用定时器的功能主要有什么区别？\n\n高级定时器（如TIM1）：\n\n1. 多路输出通道：高级定时器通常具有多个输出通道，可以用于实现更复杂的PWM控制和输出信号。\n2. 高级控制功能：高级定时器提供更多的高级控制功能，如编码器模式、输入捕获、输出比较、PWM生成等，能够满足更复杂的定时和控制需求。\n3. 高精度定时：高级定时器通常具有更高的计数精度和更大的计数范围，可以实现更精确的定时操作。\n\n通用定时器（如TIM2、TIM3等）：\n\n1. 基本定时功能：通用定时器提供基本的定时和计数功能，能够满足常见的定时需求。\n2. 灵活性和易用性：通用定时器的配置和使用相对简单，适用于一般的定时和计数应用。\n3. 低功耗模式：通用定时器通常支持低功耗模式，可以在需要时降低功耗，延长电池寿命。\n\n总体而言，高级定时器具有更多的高级功能和扩展性，适用于复杂的定时和控制需求，而通用定时器则更适用于常见的定时和计数应用，并具有简单易用和低功耗的特点。选择合适的定时器取决于具体的应用需求和功能要求。\n\n#### STM32F103定时器的计数器模式有哪3种?\n\n1. 向上计数模式（Up Counter Mode）：定时器从0开始计数，逐渐增加，直到计数值达到设定的上限值（比如自动重载值），然后重新从0开始计数。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。\n2. 向下计数模式（Down Counter Mode）：定时器从设定的上限值（比如自动重载值）开始计数，逐渐减小，直到计数值为0。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。\n3. 中央对齐模式（Center-aligned Mode）：定时器在向上计数和向下计数之间来回切换，计数器值会在自动重载值的一半处反向。这种模式下的计数器可以产生对称的波形，对于一些特定的应用场景如PWM输出很有用。\n\n### ADC简答\n\n#### 简述STM32F103的ADC规则通道组和注入通道组之间的关系\n\n**规则通道组是用于常规的模数转换，它可以配置多个通道进行连续的模数转换。**规则通道组的转换顺序可以根据需要进行设置，可以按照顺序依次转换多个通道的模拟输入信号。\n\n**注入通道组则是用于特定的应用场景，如精确的采样或触发转换。注入通道组可以单独配置一个或多个通道进行模数转换**，并且可以使用特定的触发源来触发转换。\n\n规则通道组和注入通道组之间是相互独立的，它们有各自独立的转换序列和设置。在配置时，可以选择使用规则通道组、注入通道组或两者同时使用，以满足不同的应用需求。\n\n总结而言，规则通道组和注入通道组是用于不同的模数转换应用场景的两种通道组，可以根据具体需求配置和使用。\n\n### 串口简答\n\n#### 简述如何判断STM32F103的串口是否完成数据发送和接收\n\n1. 发送完成标志位（TXE）：通过读取串口状态寄存器（SR）中的TXE标志位来判断是否完成数据发送。当TXE标志位为1时，表示发送缓冲器为空，可以继续发送数据；当TXE标志位为0时，表示发送缓冲器正在发送数据，还未完成发送。\n2. 数据接收完成标志位（RXNE）：通过读取串口状态寄存器（SR）中的RXNE标志位来判断是否完成数据接收。当RXNE标志位为1时，表示接收缓冲器中已有接收到的数据，可以读取；当RXNE标志位为0时，表示接收缓冲器为空，还未有新的数据接收。\n\n可以使用相关的寄存器和标志位来进行判断，具体操作如下：\n\n1. 判断发送完成：**通过检查USART_SR寄存器中的TXE标志位，当TXE为1时，表示发送完成。**\n2. 判断数据接收完成：**通过检查USART_SR寄存器中的RXNE标志位，当RXNE为1时，表示数据接收完成。**\n\n#### 串行通信分为异步通信和同步通信，简述异步通信和同步通信的区别\n\n异步通信和同步通信是两种不同的串行通信方式，它们的区别在于*数据传输的时钟信号的处理方式和数据帧的组织方式。*\n\n异步通信：\n\n- 异步通信**使用两个信号线，分别是数据线（TXD和RXD）和单个的时钟信号线（通常为波特率时钟）。**\n- 数据的传输是基于起始位、数据位、奇偶校验位和停止位构成的数据帧进行的。**每个数据帧之间没有固定的时间间隔。**\n- **发送端和接收端的时钟频率可以略有差异**，因此需要在接收端通过起始位的边沿检测来同步数据。\n- 异步通信**适用于短距离和低速率的通信**，例如串口通信。\n\n同步通信：\n\n- 同步通信**使用单独的时钟信号线来同步数据的传输**，也称为时钟同步通信。\n- 数据的传输是基于固定的时钟信号来同步发送和接收的。数据被切分成多个连续的数据帧，**每个数据帧的长度和时钟信号的周期相对应。**\n- **发送端和接收端的时钟频率必须保持一致**，以确保数据的正确接收。\n- 同步通信**适用于高速率和长距离的通信**，例如以太网通信和SPI通信。\n\n总结：\n异步通信和同步通信的主要区别在于时钟信号的处理方式和数据帧的组织方式。\n**异步通信使用单个时钟信号和数据帧的起始位、数据位、奇偶校验位和停止位进行数据传输，而同步通信则使用单独的时钟信号来同步数据的传输，数据被切分成连续的数据帧并通过固定的时钟信号周期来同步发送和接收。**\n\n### 操作系统简答\n\n#### uC/OS-II操作系统中，信号量和互斥信号量在功能上的主要区别是什么？\n\n1. 信号量（Semaphore）：\n   - 信号量是一种**用于控制对资源的访问的机制，可以用来表示可用资源的数量。**\n   - 信号量可以实现资源的共享和同步，**允许多个任务对同一资源进行访问。**\n   - 信号量有两种类型：**二进制信号量和计数信号量。**\n   - *二进制信号量的值只能为0或1，用于实现互斥访问，即只允许一个任务访问资源。*\n   - *计数信号量的值可以是任意非负整数，用于表示可用资源的数量。*\n   - 任务可以**通过等待信号量来获取资源**，*如果资源不可用，则任务会被阻塞，直到资源可用为止。*\n2. 互斥信号量（Mutex）：\n   - 互斥信号量是一种**特殊的信号量，用于实现互斥访问共享资源。**\n   - 互斥信号量可以**保证同一时间只有一个任务可以访问共享资源**，避免了多个任务同时访问导致的数据竞争和冲突。\n   - 互斥信号量*在任务访问共享资源之前需要进行获取（P操作），在任务使用完资源后需要进行释放（V操作）。*\n   - 如果互斥信号量已经被一个任务获取，*其他任务尝试获取该互斥信号量时会被阻塞，直到互斥信号量被释放。*\n\n总结：\n\n信号量用于控制对资源的访问，可以实现资源的共享和同步；\n\n而互斥信号量是一种特殊的信号量，用于实现互斥访问共享资源，确保同一时间只有一个任务可以访问共享资源。\n\n互斥信号量是信号量的一种特殊形式，用于解决共享资源的互斥访问问题。\n\n#### uC/OS-II操作系统中，信号量和消息邮箱在功能上的主要区别是什么？\n\n1. 信号量（Semaphore）：\n   - 信号量用于控制对资源的访问和同步任务的执行顺序。\n   - 信号量可以表示可用资源的数量，任务可以通过等待信号量来获取资源，如果资源不可用，则任务会被阻塞，直到资源可用为止。\n   - 信号量的值可以是任意非负整数，可以用来表示资源的数量或者某种条件的满足情况。\n   - 信号量可以用于实现资源的共享和同步，多个任务可以同时等待和释放同一个信号量。\n2. 消息邮箱（Message Mailbox）：\n   - 消息邮箱用于在任务之间传递消息和数据。\n   - 消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。\n   - 任务可以通过发送消息到邮箱来向其他任务传递数据，也可以通过接收消息来获取其他任务发送的数据。\n   - 消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。\n\n总结：\n\n**信号量用于控制资源的访问和同步任务的执行顺序，多个任务可以同时等待和释放同一个信号量；而消息邮箱用于在任务之间传递消息和数据，具有缓冲区的功能，可以存储多个消息。信号量更适用于控制资源的共享和同步，而消息邮箱更适用于任务间的数据传递和通信。**\n\n#### uC/OS-II操作系统中，消息邮箱和消息队列在功能上的主要区别是什么？\n\n1. 消息邮箱（Message Mailbox）：\n   - 消息邮箱用于在任务之间传递消息和数据。\n   - 消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。\n   - 发送任务通过发送消息到邮箱来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。\n   - 消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。\n2. 消息队列（Message Queue）：\n   - 消息队列用于在任务之间传递消息和数据。\n   - 消息队列可以存储一个或多个消息，每个消息可以是一个可变长度的数据结构。\n   - 发送任务通过发送消息到队列来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。\n   - 消息队列具有先进先出（FIFO）的特性，保证消息按照发送的顺序进行接收。\n\n总结：\n\n**消息邮箱和消息队列都用于任务间的消息传递和数据通信，但它们在消息存储方式和特性上有所不同。消息邮箱适用于固定长度的消息存储和同步发送和接收任务的操作，而消息队列适用于可变长度的消息存储和按照发送顺序进行接收的操作。**\n\n## 程序设计\n\n### GPIO程序设计\n\n#### 采用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁，闪烁周期约为1s，采用软件延时方法。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOB的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\n    // 配置PB5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOB, &GPIO_InitStructure);\n}\n\n// 这部分考试时候可不写\n// 延时函数，使用软件延时\nvoid Delay(uint32_t nCount)\n{\n    for (volatile uint32_t i = 0; i < nCount; i++)\n    {\n        for (volatile uint32_t j = 0; j < 1000; j++)\n        {\n            // 空操作，用于延时\n        }\n    }\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    while (1)\n    {\n        // 控制LED灯亮\n        GPIO_SetBits(GPIOB, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n\n        // 控制LED灯灭\n        GPIO_ResetBits(GPIOB, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOB的PB5引脚为推挽输出模式。然后，在`main()`函数中，通过循环控制LED灯周期性地闪烁。通过调用`GPIO_SetBits()`和`GPIO_ResetBits()`函数来控制PB5引脚的电平，实现LED灯的亮和灭。通过调用`Delay()`函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现LED灯的周期性闪烁。\n\n#### 采用库函数编写通用GPIO控制程序，实现PB5和PE5控制的2个LED灯交替闪烁，闪烁周期约为1s。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现PB5和PE5控制的两个LED灯交替闪烁的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOB和GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PB5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOB, &GPIO_InitStructure);\n\n    // 配置PE5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\n// 考试时可不写\n// 延时函数，使用软件延时\nvoid Delay(uint32_t nCount)\n{\n    for (volatile uint32_t i = 0; i < nCount; i++)\n    {\n        for (volatile uint32_t j = 0; j < 1000; j++)\n        {\n            // 空操作，用于延时\n        }\n    }\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    while (1)\n    {\n        // 控制PB5引脚为高电平，PE5引脚为低电平\n        GPIO_SetBits(GPIOB, GPIO_Pin_5);\n        GPIO_ResetBits(GPIOE, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n\n        // 控制PB5引脚为低电平，PE5引脚为高电平\n        GPIO_ResetBits(GPIOB, GPIO_Pin_5);\n        GPIO_SetBits(GPIOE, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOB的PB5引脚和GPIOE的PE5引脚为推挽输出模式。然后，在`main()`函数中，通过循环控制两个LED灯的交替闪烁。通过调用`GPIO_SetBits()`和`GPIO_ResetBits()`函数来控制PB5和PE5引脚的电平，实现LED灯的亮和灭。通过调用`Delay()`函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现两个LED灯的交替闪烁。\n\n#### 采用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮功能，8个LED由PE0~PE7控制，低电平点亮。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PE0~PE7引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |\n                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    while (1)\n    {\n        // 依次点亮8个LED，通过循环和位运算实现\n        for (int i = 0; i < 8; i++)\n        {\n            // 将对应的引脚设置为低电平，点亮LED\n            GPIO_ResetBits(GPIOE, (1 << i));\n\n            // 延时一段时间\n            for (volatile int j = 0; j < 1000000; j++)\n            {\n                // 空操作，用于延时\n            }\n\n            // 将对应的引脚设置为高电平，熄灭LED\n            GPIO_SetBits(GPIOE, (1 << i));\n        }\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOE的PE0~PE7引脚为推挽输出模式。然后，在`main()`函数中，通过循环依次点亮8个LED。通过循环和位运算，将对应的引脚设置为低电平，点亮LED，并延时一段时间。然后将对应的引脚设置为高电平，熄灭LED。循环执行这个过程，就可以实现8个LED的循环依次点亮的效果。\n\n#### 采用库函数编写通用GPIO控制程序，实现PC口（PC0~PC7）控制1位共阳极数码管循环显示数字0~9的功能，每个数字显示停留时间约为1s。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现PC口控制1位共阳极数码管循环显示数字0~9的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// 数码管数字编码表\nconst uint8_t digitCode[] = {\n    0x3F,  // 0\n    0x06,  // 1\n    0x5B,  // 2\n    0x4F,  // 3\n    0x66,  // 4\n    0x6D,  // 5\n    0x7D,  // 6\n    0x07,  // 7\n    0x7F,  // 8\n    0x6F   // 9\n};\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOC的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n\n    // 配置PC0~PC7引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |\n                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOC, &GPIO_InitStructure);\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    uint8_t digit = 0;  // 当前显示的数字\n\n    while (1)\n    {\n        // 根据当前数字设置PC0~PC7引脚的输出状态\n        GPIO_Write(GPIOC, digitCode[digit]);\n\n        // 延时一段时间\n        for (volatile int i = 0; i < 1000000; i++)\n        {\n            // 空操作，用于延时\n        }\n\n        // 切换到下一个数字\n        digit++;\n        if (digit > 9)\n        {\n            digit = 0;\n        }\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOC的PC0~PC7引脚为推挽输出模式。然后，在`main()`函数中，通过循环依次显示数字0~9。在每个循环中，根据当前数字设置PC0~PC7引脚的输出状态，通过写入相应的数码管数字编码。然后延时一段时间，切换到下一个数字，再次循环显示。通过这个过程，可以实现PC口控制1位共阳极数码管循环显示数字0~9的功能。\n\n### EXTI程序设计\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（下降沿中断）将LED灯状态取反。（写出PE2外部中断初始化代码和外部中断服务函数的代码）\n\n下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOC和GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PC5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOC, &GPIO_InitStructure);\n\n    // 配置PE2引脚为上拉输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\n// 外部中断初始化函数\nvoid EXTI_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    EXTI_InitTypeDef EXTI_InitStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能AFIO的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 配置PE2引脚为中断输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  // 下拉输入\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n\n    // 配置外部中断线路\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);\n\n    // 配置外部中断参数\n    EXTI_InitStructure.EXTI_Line = EXTI_Line2;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  // 下降沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;  // 抢占优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;         // 响应优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n// 外部中断服务函数\nvoid EXTI2_IRQHandler(void)\n{\n    if (EXTI_GetITStatus(EXTI_Line2) != RESET)\n    {\n        // 等待一段时间消除抖动\n        for (volatile int i = 0; i < 100000; i++)\n        {\n            // 空操作，用于延时\n        }\n\n        // 检查按键是否按下（下降沿触发）\n        if (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_2) == RESET)\n        {\n            // 反转LED灯状态\n            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));\n        }\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(EXTI_Line2);\n    }\n}\n\n```\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PE4）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（上升沿中断）将LED灯状态取反。（写出PE4外部中断初始化代码和外部中断服务函数的代码）\n\n下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOC和GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PC5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOC, &GPIO_InitStructure);\n\n    // 配置PE4引脚为上拉输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\n// 外部中断初始化函数\nvoid EXTI_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    EXTI_InitTypeDef EXTI_InitStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能AFIO的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 配置PE4引脚为中断输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  // 下拉输入\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n\n    // 配置外部中断线路\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource4);\n\n    // 配置外部中断参数\n    EXTI_InitStructure.EXTI_Line = EXTI_Line4;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 上升沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;  // 抢占优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;         // 响应优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n// 外部中断服务函数\nvoid EXTI4_IRQHandler(void)\n{\n    if (EXTI_GetITStatus(EXTI_Line4) != RESET)\n    {\n        // 等待一段时间消除抖动\n        for (volatile int i = 0; i < 100000; i++)\n        {\n            // 空操作，用于延时\n        }\n\n        // 检查按键是否按下（上升沿触发）\n        if (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_4) == SET)\n        {\n            // 反转LED灯状态\n            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));\n        }\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(EXTI_Line4);\n    }\n}\n\n```\n\n#### 补充 : (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)是什么含义\n\n```tex\n在之前的案例中，`(BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`是一个表达式，用于取反GPIOC的第5个引脚（即PC5）的输出状态。\n\n`GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`函数用于读取GPIOC的第5个引脚（即PC5）的输出状态，返回值为0或1，表示引脚的电平状态。\n\n`(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`中的`(1 - ...)`部分将读取的引脚状态取反，即如果引脚的输出为0，则结果为1，如果引脚的输出为1，则结果为0。\n\n最外层的`(BitAction)`则将取反后的结果转换为`BitAction`类型，`BitAction`是一个枚举类型，表示引脚的状态，取值可以是`Bit_RESET`（低电平）或`Bit_SET`（高电平）。\n\n因此，`(BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`的含义是将GPIOC的第5个引脚的输出状态取反，并将结果转换为`BitAction`类型，用于控制该引脚的输出状态。\n```\n\n### TIM\n\n#### 采用库函数编写通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为3\n\n下面是使用库函数编写的通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，并设置中断优先级为抢占优先级2，响应优先级3的代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// 定时器TIM2初始化函数\nvoid TIM2_Init(void)\n{\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能TIM2的时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n\n    // 配置定时器TIM2\n    TIM_TimeBaseStructure.TIM_Period = 999;  // 计数器自动重装值\n    TIM_TimeBaseStructure.TIM_Prescaler = 7199;  // 预分频值\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  // 加计数模式\n    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  // 时钟分频\n    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;\n    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);\n\n    // 配置TIM2的更新中断\n    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;  // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;         // 响应优先级为3\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    // 使能定时器TIM2\n    TIM_Cmd(TIM2, ENABLE);\n}\n\n// 定时器TIM2中断服务函数\nvoid TIM2_IRQHandler(void)\n{\n    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)\n    {\n        // 在此处理定时器中断相关的操作\n\n        // 清除中断标志位\n        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);\n    }\n}\n```\n\n请注意，以上代码只是TIM2定时器的初始化和中断处理部分，你还需要在主函数中调用`TIM2_Init()`函数进行初始化，并启用全局中断。\n\n#### 采用库函数编写通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，中断抢占优先级为1，响应优先级为2。\n\n下面是使用库函数编写的通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，并设置中断优先级为抢占优先级1，响应优先级2的代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// 定时器TIM3初始化函数\nvoid TIM3_Init(void)\n{\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能TIM3的时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);\n\n    // 配置定时器TIM3\n    TIM_TimeBaseStructure.TIM_Period = 9999;  // 计数器自动重装值\n    TIM_TimeBaseStructure.TIM_Prescaler = 7199;  // 预分频值\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  // 加计数模式\n    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  // 时钟分频\n    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;\n    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);\n\n    // 配置TIM3的更新中断\n    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;  // 抢占优先级为1\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;         // 响应优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    // 使能定时器TIM3\n    TIM_Cmd(TIM3, ENABLE);\n}\n\n// 定时器TIM3中断服务函数\nvoid TIM3_IRQHandler(void)\n{\n    if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)\n    {\n        // 在此处理定时器中断相关的操作\n\n        // 清除中断标志位\n        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);\n    }\n}\n```\n\n请注意，以上代码只是TIM3定时器的初始化和中断处理部分，你还需要在主函数中调用`TIM3_Init()`函数进行初始化，并启用全局中断。\n\n#### 补充 : 计算TIM_TimeBaseStructure.TIM_Period(计数器自动重装载值)\n\n```tex\n在上个案例中，`TIM_TimeBaseStructure.TIM_Period`的值设置为9999，是为了实现100ms的定时时间。\n\n定时器的计数器值会在0到TIM_Period之间循环计数，当计数器达到TIM_Period时，就会产生更新事件（溢出），并触发中断（如果使能了中断）。因此，定时器的定时时间可以通过设置TIM_Period的值来控制。\n\n在STM32F103微控制器中，定时器的计数器位数是16位，因此最大计数值为65535。要计算TIM_Period的值以实现100ms的定时，可以使用以下公式：\n\nTIM_Period = (定时时间 / 计数周期) - 1\n\n其中，定时时间是以秒为单位，计数周期是定时器的预分频值与定时器时钟频率之间的比例关系。在这个案例中，预分频值为7199（`TIM_TimeBaseStructure.TIM_Prescaler = 7199`），定时器时钟频率为72 MHz。\n\n计算过程如下：\n\n计数周期 = 预分频值 + 1 = 7199 + 1 = 7200\n定时时间 = 0.1 秒（100ms）\n\nTIM_Period = (0.1 / 7200) - 1 = 0.0000138888 - 1 ≈ 1388\n\n因为TIM_Period是一个16位的无符号整数，所以需要确保计算出的值在16位的范围内。在这种情况下，取TIM_Period = 1388是一个合适的值，可以实现约100ms的定时。\n```\n\n### 综合题\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示\n\n题目\n采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示。要求：\n（1）写出按键外部中断初始化代码，初始化为上升沿触发中断。\n（2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。\n\n下面是针对上述要求的示例代码：\n\n```c\n#include \"stm32f10x.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_exti.h\"\n#include \"stm32f10x_usart.h\"\n\n// 定义按键引脚和外部中断线\n#define BUTTON_PIN GPIO_Pin_3\n#define BUTTON_PORT GPIOC\n#define BUTTON_EXTI_LINE EXTI_Line3\n\n// 定义串口2引脚和相关参数\n#define USART_TX_PIN GPIO_Pin_2\n#define USART_RX_PIN GPIO_Pin_3\n#define USART_PORT GPIOA\n#define USART USART2\n\n// 全局变量，记录按键次数\nvolatile uint32_t buttonPressCount = 0;\n\n// 函数声明\nvoid EXTI_Configuration(void);\nvoid USART_Configuration(void);\nvoid USART_SendDataString(uint8_t* data);\n\nint main(void)\n{\n    // 初始化外部中断\n    EXTI_Configuration();\n\n    // 初始化串口2\n    USART_Configuration();\n\n    while (1)\n    {\n        // 主循环中不需要做其他操作\n    }\n}\n\n// （1）写出按键外部中断初始化代码，初始化为上升沿触发中断。\nvoid EXTI_Configuration(void)\n{\n    // 使能GPIOC时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n\n    // 配置按键引脚为输入模式\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; // 上拉输入\n    GPIO_Init(BUTTON_PORT, &GPIO_InitStructure);\n\n    // 使能AFIO时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 连接外部中断线到按键引脚\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);\n\n    // 配置外部中断线为上升沿触发中断\n    EXTI_InitTypeDef EXTI_InitStructure;\n    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; // 上升沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 使能外部中断通道\n    NVIC_InitTypeDef NVIC_InitStructure;\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;        // 响应优先级为3\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n\n// （2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。\nvoid USART_Configuration(void)\n{\n    // 使能GPIOA时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\n    // 使能USART2时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);\n\n    // 配置USART引脚为复用功能\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(USART_PORT, &GPIO_InitStructure);\n\n    // 配置USART参数\n\n\n    USART_InitTypeDef USART_InitStructure;\n    USART_InitStructure.USART_BaudRate = 19200;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Tx; // 仅发送模式\n    USART_Init(USART, &USART_InitStructure);\n\n    // 使能USART\n    USART_Cmd(USART, ENABLE);\n}\n\n// （3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。\nvoid EXTI3_IRQHandler(void)\n{\n    // 检查按键外部中断是否发生\n    if (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)\n    {\n        // 延时一段时间，防止抖动\n        for (volatile uint32_t i = 0; i < 100000; i++);\n\n        // 记录按键次数\n        buttonPressCount++;\n\n        // 发送按键次数到串口\n        char countStr[10];\n        sprintf(countStr, \"Press count: %lu\\r\\n\", buttonPressCount);\n        USART_SendDataString((uint8_t*)countStr);\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);\n    }\n}\n\nvoid USART_SendDataString(uint8_t* data)\n{\n    while (*data)\n    {\n        USART_SendData(USART, *data++);\n        while (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);\n    }\n}\n```\n\n以上代码实现了对PC3按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口2将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为上升沿触发中断，串口2被初始化为波特率为19200bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口2发送出去。\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示\n\n题目 :\n\n采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示。要求：\n\n（1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。\n\n下面是针对上述要求的示例代码：\n\n```c\n#include \"stm32f10x.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_exti.h\"\n#include \"stm32f10x_usart.h\"\n\n// 定义按键引脚和外部中断线\n#define BUTTON_PIN GPIO_Pin_2\n#define BUTTON_PORT GPIOE\n#define BUTTON_EXTI_LINE EXTI_Line2\n\n// 定义串口1引脚和相关参数\n#define USART_TX_PIN GPIO_Pin_9\n#define USART_RX_PIN GPIO_Pin_10\n#define USART_PORT GPIOA\n#define USART USART1\n\n// 全局变量，记录按键次数\nvolatile uint32_t buttonPressCount = 0;\n\n// 函数声明\nvoid EXTI_Configuration(void);\nvoid USART_Configuration(void);\nvoid USART_SendDataString(uint8_t* data);\n\nint main(void)\n{\n    // 初始化外部中断\n    EXTI_Configuration();\n\n    // 初始化串口1\n    USART_Configuration();\n\n    while (1)\n    {\n        // 主循环中不需要做其他操作\n    }\n}\n\n// （1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。\nvoid EXTI_Configuration(void)\n{\n    // 使能GPIOE时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置按键引脚为输入模式\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; // 下拉输入\n    GPIO_Init(BUTTON_PORT, &GPIO_InitStructure);\n\n    // 使能AFIO时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 连接外部中断线到按键引脚\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);\n\n    // 配置外部中断线为下降沿触发中断\n    EXTI_InitTypeDef EXTI_InitStructure;\n    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; // 下降沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 使能外部中断通道\n    NVIC_InitTypeDef NVIC_InitStructure;\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;        // 响应优先级为3\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\nvoid USART_Configuration(void)\n{\n    // 使能GPIOA时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\n    // 使能USART1时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\n    // 配置USART引脚为复用功能\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(USART_PORT, &GPIO_InitStructure);\n\n    // 配置USART参数\n\n\n    USART_InitTypeDef USART_InitStructure;\n    USART_InitStructure.USART_BaudRate = 9600;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Tx; // 仅发送模式\n    USART_Init(USART, &USART_InitStructure);\n\n    // 使能USART\n    USART_Cmd(USART, ENABLE);\n}\n\n// （3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。\nvoid EXTI2_IRQHandler(void)\n{\n    // 检查按键外部中断是否发生\n    if (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)\n    {\n        // 延时一段时间，防止抖动\n        for (volatile uint32_t i = 0; i < 100000; i++);\n\n        // 记录按键次数\n        buttonPressCount++;\n\n        // 发送按键次数到串口\n        char countStr[10];\n        sprintf(countStr, \"Press count: %lu\\r\\n\", buttonPressCount);\n        USART_SendDataString((uint8_t*)countStr);\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);\n    }\n}\n\nvoid USART_SendDataString(uint8_t* data)\n{\n    while (*data)\n    {\n        USART_SendData(USART, *data++);\n        while (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);\n    }\n}\n```\n\n以上代码实现了对PE2按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口1将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为下降沿触发中断，串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口1发送出去。\n\n#### 采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示\n\n采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示。要求：\n\n（1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\n（3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。\n\n下面是针对上述要求的示例代码：\n\n```c\n#include \"stm32f10x.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_usart.h\"\n#include \"stm32f10x_tim.h\"\n\n// 定义串口1引脚和相关参数\n#define USART_TX_PIN GPIO_Pin_9\n#define USART_RX_PIN GPIO_Pin_10\n#define USART_PORT GPIOA\n#define USART USART1\n\n// 定义定时器TIM2参数\n#define TIM_PERIOD 7199\n#define TIM_PRESCALER 7199\n\n// 全局变量，记录中断次数计数值\nvolatile uint8_t interruptCount = 0;\n\n// 函数声明\nvoid TIM2_Configuration(void);\nvoid USART_Configuration(void);\nvoid USART_SendDataString(uint8_t* data);\n\nint main(void)\n{\n    // 初始化定时器TIM2\n    TIM2_Configuration();\n\n    // 初始化串口1\n    USART_Configuration();\n\n    while (1)\n    {\n        // 主循环中不需要做其他操作\n    }\n}\n\n// （1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。\nvoid TIM2_Configuration(void)\n{\n    // 使能TIM2时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n\n    // 初始化TIM2参数\n    TIM_TimeBaseInitTypeDef TIM_InitStructure;\n    TIM_InitStructure.TIM_Period = TIM_PERIOD;\n    TIM_InitStructure.TIM_Prescaler = TIM_PRESCALER;\n    TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;\n    TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;\n    TIM_InitStructure.TIM_RepetitionCounter = 0;\n    TIM_TimeBaseInit(TIM2, &TIM_InitStructure);\n\n    // 配置TIM2中断优先级\n    NVIC_InitTypeDef NVIC_InitStructure;\n    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;        // 响应优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    // 使能TIM2更新中断\n    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\n\n    // 启动定时器TIM2\n    TIM_Cmd(TIM2, ENABLE);\n}\n\n// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\nvoid USART_Configuration(void)\n{\n    // 使能GPIOA时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\n    // 使能USART1时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\n    // 配置USART引脚为复用功能\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(USART_PORT, &GPIO_InitStructure);\n\n    // 配置USART参数\n    USART_InitTypeDef USART_InitStructure;\n    USART_InitStructure.USART_BaudRate = 9600;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Tx; // 仅\n\n发送模式\n    USART_Init(USART, &USART_InitStructure);\n\n    // 使能USART\n    USART_Cmd(USART, ENABLE);\n}\n\n// （3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。\nvoid USART_SendDataString(uint8_t* data)\n{\n    while (*data)\n    {\n        USART_SendData(USART, *data++);\n        while (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);\n    }\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    // 检查TIM2更新中断是否发生\n    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)\n    {\n        // 延时一段时间，防止按键抖动\n        for (volatile uint32_t i = 0; i < 100000; i++);\n\n        // 增加中断次数计数值\n        interruptCount++;\n\n        // 发送中断次数到串口\n        char countStr[10];\n        sprintf(countStr, \"Interrupt count: %d\\r\\n\", interruptCount);\n        USART_SendDataString((uint8_t*)countStr);\n\n        // 清除中断标志位\n        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);\n    }\n}\n```\n\n以上代码实现了对PE2按键的外部中断响应，每次中断发生时会记录中断次数计数值，并通过串口1将其发送给上位机的串口助手进行显示。定时器TIM2被初始化为定时1s，通过中断实现定时功能。串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。在TIM2的中断服务函数中，会进行一段延时以防止按键抖动，然后记录中断次数计数值并通过串口1发送出去。\n\n## 程序分析\n\n### 题一\n\n基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：\n\n```c\nint main (void)\n{\n    BSPInit();\n    OSInit();\n    OSTaskCreate(TaskLED,  (void *)0,  &TaskLEDStk[TASK_STK_SIZE - 1],  9); \n\tOSTaskCreate(TaskKEY,  (void *)0,  &TaskKEYStk[TASK_STK_SIZE - 1],  10);\n    OSStart();\n    return 0;\n}\n\nvoid  TaskLED(void *pdata)            //LED控制任务\n{\n    INT8U err;\n    sem01 = OSSemCreate(0);\n    while (1)\n    {\n        OSSemPend(sem01,0,&err);\t\n\t\tLED(1, LEDON);             \n\t\tOSTimeDlyHMSM(0, 0, 1, 0); \n\t\tLED(1, LEDOFF);            \n\t\tOSTimeDlyHMSM(0, 0, 1, 0);\n    }\n} \n\nvoid  TaskKEY(void *pdata)         //按键检测任务\n{   \n    while (1) \n    {  \n       while(KEY1!=0)\t          \n           {  OSTimeDly(1); }\n\t   OSSemPost(sem01);\t\t\t\t        \n\t   while(KEY1==0)\t\n           { OSTimeDly(1); }   \n    }    \n}\n```\n\n回答下面问题：\n（1）程序中任务TaskLED和TaskKEY的优先级是多少？其中优先级较高的是哪个任务?\n（2）程序中任务TaskLED和TaskKEY之间采用了哪种事件通信机制？采用该事件实现的功能是资源同步还是行为同步？\n（3）任务TaskLED调用OSSemPend(sem,0,&err)函数后，将进入哪种状态？满足什么条件后退出该状态？\n\n\n(1) 程序中任务TaskLED的优先级为9，任务TaskKEY的优先级为10。优先级较高的任务是TaskKEY。\n\n```c\n// 通过OSTaskCreate() 的最后一个参数判断优先级\nOSTaskCreate(TaskLED,  (void *)0,  &TaskLEDStk[TASK_STK_SIZE - 1],  9); // TaskLED 优先级为9\nOSTaskCreate(TaskKEY,  (void *)0,  &TaskKEYStk[TASK_STK_SIZE - 1],  10); // TaskKEY 优先级为10\n```\n\n(2) 程序中任务TaskLED和TaskKEY之间采用了信号量（sem01）作为事件通信机制。该事件实现的功能是资源同步，用于TaskKEY任务向TaskLED任务发出信号。\n\n程序中使用了信号量sem01作为事件通信机制。TaskKEY任务通过OSSemPost()函数向sem01信号量发出信号，而TaskLED任务通过OSSemPend()函数等待sem01信号量的触发。这种事件通信机制用于任务之间的同步操作\n\n```c\nvoid  TaskLED(void *pdata)            //LED控制任务\n{\n    INT8U err;\n    sem01 = OSSemCreate(0);\n    while (1)\n    {\n        OSSemPend(sem01,0,&err); // TaskLED 通过 OSSemPend() 等待 sem01 信号量的触发\n\t\tLED(1, LEDON);             \n\t\tOSTimeDlyHMSM(0, 0, 1, 0); \n\t\tLED(1, LEDOFF);            \n\t\tOSTimeDlyHMSM(0, 0, 1, 0);\n    }\n} \n\nvoid  TaskKEY(void *pdata)         //按键检测任务\n{   \n    while (1) \n    {  \n       while(KEY1!=0)\t          \n           {  OSTimeDly(1); }\n\t   OSSemPost(sem01); // TaskKEY 通过 OSSemPost() 向 sem01 信号量发出信号\n\t   while(KEY1==0)\t\n           { OSTimeDly(1); }   \n    }    \n}\n```\n\n(3) 任务TaskLED调用OSSemPend(sem, 0, &err)函数后，将进入等待状态（阻塞状态）。TaskLED任务将等待sem01信号量的触发，即等待TaskKEY任务通过OSSemPost()函数释放sem01信号量。当TaskKEY任务调用OSSemPost()函数释放sem01信号量后，TaskLED任务会退出等待状态，并开始执行LED控制代码。\n\n分析\n\n```tex\n 当TaskLED任务调用OSSemPend(sem01, 0, &err)函数后，将进入等待状态（阻塞状态）。该函数的第二个参数为0，表示如果sem01信号量当前不可用，则任务会被阻塞而进入等待状态。任务会一直等待，直到sem01信号量可用或超时（在此情况下不会超时，因为第二个参数为0）。\n\n满足以下条件之一后，TaskLED任务将退出等待状态：\n\n    当TaskKEY任务调用OSSemPost()函数释放sem01信号量时，TaskLED任务会检测到sem01信号量可用，从而退出等待状态。\n    如果TaskLED任务的阻塞期间发生了其他中断或事件，导致任务切换，则当TaskLED任务再次运行时，会重新检查sem01信号量的可用性，并根据情况决定是否退出等待状态。\n```\n\n### 题二\n\n基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：\n\n```c\nint main（void）\n{\nOSInit();\nOSTaskCreate(task1, (void *)0, &task1Stk[TASK_STK_SIZE - 1],  12 );\nOSTaskCreate(task2, (void *)0, &task2Stk[TASK_STK_SIZE - 1],  9 );\nOSTaskCreate(task3, (void *)0, &task3Stk[TASK_STK_SIZE - 1],  6);\nOSStart();\n}\n\nvoid task1（）\n{\t\nClearScreen();                    //LCD清屏\nLCD_Printf(“ task1 \\n”);            //LCD显示字符串 \nOSTimeDly(200);\n}\n\nvoid task2（）\n{\t\nClearScreen();\nLCD_Printf(“ task2 \\n”);            //LCD显示字符串\nOSTimeDly(300);\n}\n\nvoid task3（）\n{\t\nClearScreen();\nLCD_Printf(“ task3 \\n”);            //LCD显示字符串\nOSTimeDly(500);\n}\n```\n\n回答下面问题：\n（1）程序中三个任务task1、task2、task3的优先级分别为什么，其中优先级最高的是哪个任务？         。\n（2）uC/OS-II操作系统中，按照任务的执行方式可分为哪几种类型？本程序中任务task1、task2、task3属于其中哪一种？\n（3）uC/OS-II操作系统中，任务有哪几种状态？本程序中任务调用OSTimeDly( )函数后，将进入哪种状态？\n（4）在LCD上的显示结果为：\n第一次：                  \t      第二次：                  \t\n第三次：                  \t      第四次：                  \t\n第五次：                  \t      第六次：                  \t\n\n(1) 程序中三个任务task1、task2、task3的优先级分别为：12、9、6。优先级数值越小，优先级越高。因此，优先级最高的任务是task3。\n\n(2) uC/OS-II操作系统中，按照任务的执行方式可分为两种类型：抢占式任务和非抢占式任务。本程序中的任务task1、task2、task3属于非抢占式任务，因为它们在任务执行期间不会被其他优先级更高的任务打断。\n\n(3) uC/OS-II操作系统中，任务有四种状态：就绪状态（READY）、运行状态（RUNNING）、阻塞状态（BLOCKED）和挂起状态（SUSPENDED）。本程序中，任务调用OSTimeDly()函数后，任务将进入阻塞状态。OSTimeDly()函数会使任务延迟一段指定的时间，任务在此期间将处于阻塞状态，不会被调度执行。\n\n(4) 在LCD上的显示结果为：\n第一次： task1                   \t  第二次： task2\n第三次： task3                   \t  第四次： task1\n第五次： task2                   \t  第六次： task3\n\n分析\n\n```tex\n根据程序的执行逻辑，任务task1、task2、task3依次执行，每个任务都会先清屏，然后在LCD上显示对应的任务名，并通过OSTimeDly()函数延迟一定时间。因此，首次执行时LCD上会显示\"task1\"，然后延迟200个时钟节拍，接着显示\"task2\"，再延迟300个时钟节拍，最后显示\"task3\"，再延迟500个时钟节拍。之后，任务会不断循环执行，按照相同的顺序在LCD上显示任务名，并延迟指定的时间。\n```\n","source":"_posts/ARM嵌入式复习笔记.md","raw":"---\ntitle: ARM嵌入式复习笔记\ndate: 2023-05-29 11:37:03\ntags: 嵌入式\n---\n\n\n## 填空\n\n### 嵌入式系统概念填空\n\n1. 嵌入式系统是以**应用系统**为中心，以**计算机为基础**，**软硬件可裁剪**，~~适应应用系统对功能、可靠性、成本、体积、功耗严格要求~~的**专用**计算机系统。\n2. ARM处理器是ARM公司设计的基于RISC架构的**32位**高性能微处理器，一般采用**哈佛**总线结构，具有高速指令缓存和数据缓存，指令长度固定且多级流水线执行。\n\n### 工作频率填空\n\n1. Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，**APB1总线的最高工作频率为36MHz。**\n2. Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，**APB2总线的最高工作频率为72MHz。**\n3. Cortex-M3**内核的最高工作时钟频率为72MHz。**\n\n### 时钟填空\n\n1. 32F103的系统时钟SYSCLK可以来自**HSI（内部高速时钟）、HSE（外部高速时钟）和PLL（锁相环）**三个时钟源中的一个。\n2. 当STM32F103外接8MHz的晶体时，若使内核达到最高工作时钟频率，PLL的倍频系数应设置为9倍。\n3. STM32F103外接的**32768Hz晶体主要用来为芯片内部的RTC部件提供时钟源。**\n\nPLL倍频系数的设置\n\n```tex\n计算步骤如下：\n系统时钟SYSCLK = (输入时钟频率) × (PLL倍频系数)\n72 MHz = 8 MHz × 9\n因此，PLL的倍频系数应设置为9倍\n```\n\n### 存储器填空\n\n1. STM32F103芯片是**32位**的微控制器，**可寻址存储空间的大小为4GB。**\n2. STM32F103芯片可寻址存储空间的大小为 4GB，分为 8个512MB的存储块。\n3. 当BOOT0 = 0时，STM32F103上电后，用户程序将从Flash存储器启动。\n\n### GPIO填空\n\n1. STM32F103ZET6芯片包含**7 个16位**的通用目的输入/输出口（GPIO）。。\n2. STM32F103ZET6芯片共有**112根GPIO引脚**，可从其中**任选16根**作为外部中断输入口。\n\n### 中断填空\n\n1. STM32F103微控制器具有**10个异常和60个中断**，**中断优先级为16 级**。\n2. STM32F103微控制器的EXTI模块有**16个连接GPIO的外部中断线**，对应**16个外部中断向量**。\n3. STM32F103微控制器共**有3个串口**，其中**USART1的工作时钟源来自于APB2总线** 。\n4. STM32F103微控制器共有**3个串口**，其中**USART2的工作时钟源来自于APB1总线** 。\n\n### ADC填空\n\n1. STM32F103微控制器的ADC模块**支持单次和连续转换模式**。\n2. STM32F103微控制器的ADC模块**分辨率为12位**，**最小转换时间为1.17微妙**\n3. STM32F103的ADC1有16个外部模拟输入通道，**分辨率为12 位。**\n4. STM32F103的ADC的**分辨率为12位**，**最高转换速率是1MHz**\n\n### 操作系统填空\n\n1. 嵌入式操作系统根据各个任务的要求，进行内存管理、多任务管理、资源管理、任务调度、消息管理和异常处理等工作。\n2. uC/OS-II操作系统是一个**源代码公开、可移植、可固化、可裁剪、可配置式**的实时多任务操作系统，**最多可支持255个任务**。\n3. 在uC/OS-II操作系统中，通过**互斥信号量**可实现对共享资源的**抢占式访问**。\n\n## 简答\n\n### 嵌入式系统概念简答\n\n#### 从技术角度来说什么是嵌入式系统？8051单片机应用系统是否属于嵌入式系统？\n\n1. 嵌入式系统是**以应用系统为中心**，**以计算机为基础**，**软硬件可裁剪**，~~适应应用系统对功能、可靠性、成本、体积、功耗严格要求~~的**专用计算机系统**\n2. 8051单片机应用系统**可以**被归类为嵌入式系统。\n\n#### 嵌入式实时操作系统中的“实时性”指的是什么？\n\n1. 实时性是**系统对外部事件的及时响应和任务的及时完成能力。** *实时性可以分为硬实时和软实时两种类型。*\n2. 硬实时要求系统在严格的时间约束下，对外部事件作出及时的响应。**任务的截止时间是固定的，任何超出时间限制的情况都可能导致系统功能失效或系统崩溃。**\n3. 软实时要求系统尽可能在特定的时间约束下，对外部事件作出及时的响应，但允许偶尔的违反时间限制。**任务的截止时间相对宽松，系统可以容忍一定程度的任务响应时间超出。**\n\n### 时钟简答\n\n#### STM32F103微控制器的工作时钟源有哪几种？各时钟源的频率范围分别是多少？\n\n1. **HSI（High-Speed Internal）高速内部时钟**：频率为8MHz。\n2. **HSE（High-Speed External）高速外部时钟**：频率范围通常为4MHz至16MHz。\n3. **PLL（Phase-Locked Loop）锁相环时钟**：可以使用HSI或HSE作为输入时钟源，并通过倍频系数进行倍频。具体的频率范围取决于倍频系数的设置。\n\n#### 在STM32F103内部的时钟树中，锁相环PLL有什么用途？\n\n1. **时钟倍频**：PLL可以将输入时钟频率倍增，提供更高的系统时钟频率。\n2. **稳定时钟源**：PLL可以提供更稳定的时钟源，减小时钟的抖动和波动。\n3. **系统时钟源**：在STM32F103中，PLL经常被配置为系统时钟源（SYSCLK），即整个微控制器系统的主要时钟源。\n\n#### 嵌入式系统中的启动代码（startup_stm32f10x_hd.s）程序的功能是什么？\n\n1. **初始化向量表**：启动代码会定义和初始化微控制器的向量表，其中包含了中断处理函数的入口地址。向量表的初始化是确保中断处理能够正确触发和执行的重要步骤。\n2. **初始化堆栈和堆栈指针**：启动代码会设置初始堆栈指针，指向程序的堆栈空间。这是确保函数调用和中断处理正常工作的必要步骤。\n3. **初始化系统时钟**：启动代码会进行系统时钟的初始化，包括配置时钟源、设置时钟分频器等操作，以确保系统在正确的时钟频率下运行。\n4. **初始化存储器和外设**：启动代码可能包括对存储器和外设的初始化操作，例如设置存储器映射、配置外设寄存器等。\n5. **调用主函数**：启动代码最终会调用应用程序的主函数（如`main`函数），使应用程序正式开始执行。\n\n#### STM32F103微控制器的最小系统由哪几部分构成？\n\n1. **STM32F103微控制器芯片**：这是系统的核心部分，包含了CPU、存储器、外设等功能模块。\n2. **时钟源**：最小系统需要提供适当的时钟源，以驱动微控制器的各个部分。常见的时钟源包括晶体振荡器、外部时钟源或者内部时钟源。\n3. **复位电路**：复位电路用于在系统上电或者复位时将微控制器置于初始状态。它通常由复位按钮、电容和电阻等组成。\n4. **电源管理电路**：为STM32F103微控制器提供稳定的电源供应，并对电源进行滤波和保护。这包括电源连接器、电源滤波电容、稳压器等。\n5. **外部连接器**：用于与外部设备或外部电路进行连接，包括通信接口（如UART、SPI、I2C）、GPIO引脚、ADC输入等。\n\n#### STM32F103微控制器有哪几种启动模式？如何来配置系统启动模式？\n\n1. **主启动模式（Main Boot Mode）**：在主启动模式下，微控制器从FLASH存储器的起始地址处开始执行代码。\n2. **系统存储器模式（System Memory Boot Mode）**：在系统存储器模式下，微控制器从内部的系统存储器（一般为ROM或者Flash）的起始地址处开始执行代码。\n3. **内存模式（RAM Boot Mode）**：在内存模式下，微控制器从系统RAM中的特定地址处开始执行代码。\n\n系统启动模式的配置是通过BOOT pins（BOOT0和BOOT1）的状态来实现的。这些引脚通常通过跳线帽或者外部电平转换器与微控制器连接。\n\n具体的配置方式如下：\n\n- 如果BOOT0引脚为高电平，那么微控制器将进入内存模式。\n- 如果BOOT0引脚为低电平（接地），那么微控制器将根据BOOT1引脚的状态来选择启动模式。\n  - 如果BOOT1引脚也为低电平，那么微控制器将进入主启动模式。\n  - 如果BOOT1引脚为高电平，那么微控制器将进入系统存储器模式。\n\n### 存储器简答\n\n#### 什么是存储器重映射？STM32F103微控制器的哪些存储区域需要进行存储器重映射？\n\n存储器重映射**是指将某些存储器区域的物理地址重新映射到不同的逻辑地址的过程。**\n\n在STM32F103微控制器中，存储器重映射主要涉及以下两个存储区域：\n\n1. **系统存储器（System Memory）**：系统存储器包含了微控制器的启动代码和ROM固件库。在存储器重映射时，系统存储器的物理地址将被映射到内部的ROM或者Flash存储器的起始地址，使得系统可以从内部存储器中执行代码。\n\n2. **外部SRAM（External SRAM）**：STM32F103微控制器具有一些器件型号支持外部SRAM的扩展。在存储器重映射时，外部SRAM的物理地址可以被映射到微控制器的内部存储器的地址空间中，使得外部SRAM可以像内部存储器一样被访问和使用。\n\n### 中断简答\n\n#### STM32F103微控制器的异常和中断有什么区别？优先级最高的是哪个异常/中断？\n\n在STM32F103微控制器中，异常和中断是两种不同的事件处理机制，它们有以下区别：\n\n1. **异常（Exception）**：异常是指**由于指令执行或系统事件引起的处理器中断。它们通常表示了一些严重的错误或特殊情况，需要立即处理。**~~异常包括复位、非屏蔽中断（如硬件故障）、系统调试异常等。异常的处理优先级高于中断。~~\n\n2. **中断（Interrupt）**：中断是指**外部设备或特定事件触发的处理器中断。它们通常表示了一些需要优先处理的异步事件**，如外部输入信号、定时器溢出等。中断可以根据优先级配置，并**可被屏蔽或使能。**\n\n在STM32F103微控制器中，优先级最高的异常是**复位（Reset）**异常。复位异常在系统上电或者复位时触发，用于将系统重置到初始状态。它的优先级最高，无法被屏蔽。\n\n### GPIO简答\n\n#### STM32F103微控制器的GPIO有哪几种工作模式？GPIO作按键输入时应选择哪种工作模式？\n\n1. **输入模式（Input Mode）**：将GPIO配置为输入模式，用于读取外部信号或按键的状态。可以选择不同的输入模式，如**浮空输入、上拉输入和下拉输入**，以适应不同的电路连接方式。\n2. **输出模式（Output Mode）**：将GPIO配置为输出模式，用于控制外部设备或驱动器。输出模式可以选择**推挽输出、开漏输出、推挽输出带上拉或下拉等**。\n3. **复用功能模式（Alternate Function Mode）**：将GPIO配置为复用功能模式，可以使用GPIO引脚来实现其他外设功能，如串口、定时器、SPI等。\n4. **模拟模式（Analog Mode）**：将GPIO配置为模拟模式，用于连接模拟信号输入或输出。\n\n当GPIO用作按键输入时，应选择**输入模式**。可以根据实际情况选择浮空输入、上拉输入或下拉输入，以确保按键的状态能够正确读取。*浮空输入适用于按键有外部上拉或下拉电阻的情况，上拉输入适用于按键接地时为低电平，下拉输入适用于按键接VCC时为高电平的情况。*具体的选择取决于按键连接电路的设计和要求。\n\n\n#### 请用端口输出数据寄存器(ODR )，编写控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平的语句\n\n要使用端口输出数据寄存器（ODR）控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平，可以使用以下语句：\n\n```c\nGPIOC->ODR |= GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5; // 设置PC3、PC4、PC5引脚为高电平\nGPIOC->ODR &= ~(GPIO_ODR_ODR0 | GPIO_ODR_ODR1 | GPIO_ODR_ODR2); // 设置PC0、PC1、PC2引脚为低电平\n```\n\n#### 请用端口置位/清零寄存器(BSRR )，编写控制GPIOB口的PB0-PB5引脚输出高电平，其它引脚保持不变的语句\n\n要使用端口置位/清零寄存器（BSRR）控制GPIOB口的PB0-PB5引脚输出高电平，同时保持其他引脚状态不变，可以使用以下语句：\n\n```c\nGPIOB->BSRR = GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5; // 设置PB0-PB5引脚为高电平\n```\n\n#### 请用端口清零寄存器(BRR )，编写控制GPIOD口的PD0-PD3引脚输出低电平，其它引脚保持不变的语句\n\n要使用端口清零寄存器（BRR）控制GPIOD口的PD0-PD3引脚输出低电平，同时保持其他引脚状态不变，可以使用以下语句：\n\n```c\nGPIOD->BRR = GPIO_BRR_BR0 | GPIO_BRR_BR1 | GPIO_BRR_BR2 | GPIO_BRR_BR3; // 设置PD0-PD3引脚为低电平\n```\n\n#### 简述STM32F103微控制器的GPIO相关各个寄存器的含义和作用\n\n1. GPIO配置寄存器（GPIOx_CRL和GPIOx_CRH）：用于配置GPIO引脚的工作模式、输入/输出类型、输出速度和上下拉等特性。\n2. 端口输入数据寄存器（GPIOx_IDR）：用于读取GPIO引脚的输入状态，包括输入高低电平。\n3. 端口输出数据寄存器（GPIOx_ODR）：用于设置或读取GPIO引脚的输出状态，可以控制引脚的高低电平。\n4. 端口状态寄存器（GPIOx_SR）：用于读取GPIO引脚的状态标志位，包括引脚的输入状态、输出状态和事件状态等。\n5. 端口配置锁定寄存器（GPIOx_LCKR）：用于锁定GPIO引脚的配置，防止误操作修改引脚的配置设置。\n6. 端口复位寄存器（GPIOx_BRR）：用于通过写入引脚位控制寄存器（BRR）的对应位，将GPIO引脚置为低电平，实现引脚的复位操作。\n\n#### 对比分析STM32寄存器编程和库函数编程两种编程方式的特点\n\n1. 寄存器编程方式：\n   - 直接操作硬件寄存器：寄存器编程方式直接操作硬件寄存器，能够直接控制硬件的各个功能和特性。\n   - 精确控制：通过寄存器编程可以对硬件进行细粒度的控制，可以灵活地配置和调整各种参数，满足特定的需求。\n   - 低层访问：寄存器编程是对硬件的直接访问，属于底层编程方式，对硬件细节要求较高，需要更多的了解和掌握。\n   - 更高的性能：由于直接操作寄存器，避免了函数调用和库函数的开销，寄存器编程方式可以获得更高的性能和响应速度。\n2. 库函数编程方式：\n   - 抽象封装：库函数编程方式通过提供封装好的函数接口，屏蔽了底层的寄存器操作细节，提供了更高层次的抽象。\n   - 简化开发：库函数提供了丰富的功能库，包括GPIO、定时器、串口等模块，简化了开发者的工作，减少了代码量。\n   - 更高的可移植性：库函数编程方式抽象了底层硬件细节，使得代码更具可移植性，可以在不同的芯片和平台上进行移植和复用。\n   - 需要更多的资源：库函数需要占用一定的存储空间，同时运行时需要更多的内存资源，因此对于资源有限的嵌入式系统可能需要权衡。\n\n综上所述，寄存器编程方式适用于对硬件控制要求高、对性能要求高的场景，需要更底层的控制和精确配置；而库函数编程方式则适用于快速开发、提高可移植性和简化开发流程的场景。选择哪种编程方式取决于具体的需求和开发环境。\n\n### 中断\n\n#### 简述STM32F103嵌套向量中断控制器（NVIC）的作用和特点\n\nSTM32F103嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）是STM32F103微控制器中负责管理和控制中断的重要模块。它的作用是**协调和处理各种中断请求，并根据中断的优先级和状态进行中断服务程序的调度。**\n\n以下是STM32F103 NVIC的主要特点和作用：\n\n1. 中断优先级管理：NVIC支持对各个中断通道的优先级进行配置和管理。中断通道的优先级可以根据应用需求进行设置，以确保关键的中断能够得到及时响应。\n2. 嵌套中断支持：NVIC支持嵌套中断的处理。当一个中断正在处理时，如果有更高优先级的中断请求到达，NVIC会暂时中断当前中断的处理，优先处理更高优先级的中断请求。这种机制确保了关键中断的实时性和优先级的保障。\n3. 中断向量表：NVIC维护着中断向量表，用于存储中断服务程序的入口地址。每个中断通道都对应着中断向量表中的一个位置，当中断请求到达时，NVIC会根据中断通道找到对应的中断服务程序并执行。\n4. 中断使能和屏蔽：NVIC提供了使能和屏蔽中断的功能。通过设置相应的控制寄存器，可以启用或禁用特定的中断通道，以满足应用的需求。\n5. 中断状态管理：NVIC能够管理中断的状态，包括中断挂起、中断激活和中断标志等。这些状态信息可以帮助开发者更好地管理和调试中断程序。\n\n#### 简述STM32F103的NVIC中断优先级分组方法和优先级划分\n\nSTM32F103的NVIC中断优先级分组方法和优先级划分主要通过两个寄存器来配置：~~NVIC_IPR（Interrupt Priority Register）和NVIC_ISER（Interrupt Set Enable Register）。~~\n\n1. 中断优先级分组方法：\n   - STM32F103支持4种中断优先级分组方式，即分为Group 0、Group 1、Group 2和Group 3。不同的分组方式决定了优先级位数的分配。\n   - ~~通过SCB_AIRCR（Application Interrupt and Reset Control Register）寄存器的位[10:8]来配置中断优先级分组方法。~~\n2. 优先级划分：\n   - 在STM32F103中，中断的优先级范围是从0（最高优先级）到15（最低优先级）。数字越小，优先级越高。\n   - 根据选择的中断优先级分组方式，优先级位数的分配有所不同。以下是各个分组方式下的优先级划分情况：\n     - Group 0：全局抢占式优先级分组，优先级分配为4位。\n     - Group 1：1位抢占式优先级和3位子优先级，优先级分配为3位抢占优先级和1位子优先级。\n     - Group 2：2位抢占式优先级和2位子优先级，优先级分配为2位抢占优先级和2位子优先级。\n     - Group 3：3位抢占式优先级和1位子优先级，优先级分配为1位抢占优先级和3位子优先级。\n\n通过配置NVIC_IPR寄存器，可以为每个中断通道分配相应的抢占式优先级和子优先级。优先级越高的中断在发生时将优先得到处理，而优先级相同的中断将按照先到先服务（FIFO）的顺序进行处理。\n\n需要注意的是，在STM32F103中，具有相同优先级的中断中，越靠近中断向量表的位置的中断具有更高的优先级。因此，在进行中断优先级划分时，需要根据中断的重要性和实时性要求进行合理的分配。\n\n#### 简述STM32F103的NVIC中断优先级分组中抢占优先级和响应优先级的区别\n\n1. 抢占优先级（Preemption Priority）：\n   - 抢占优先级指的是中断发生时，当前正在执行的中断能否被其他中断打断。具有较高抢占优先级的中断可以打断正在执行的低优先级中断，优先获得处理器的控制权。\n   - 抢占优先级的数值越小，表示优先级越高，能够打断的中断范围越广。\n\n2. 响应优先级（Subpriority）：\n   - 响应优先级指的是在同一抢占优先级下，多个中断同时请求服务时的优先级排序。具有较高响应优先级的中断将首先得到处理器的服务。\n   - 响应优先级的数值越小，表示优先级越高。\n\n\n#### 假定设置中断优先级组为2，然后设置：中断3（ RTC 中断）的抢占优先级为2，响应优先级为1；中断6（外部中断0）的抢占优先级为3，响应优先级为0；中断7（外部中断1）的抢占优先级为2，响应优先级为0。写出这3个中断的优先级顺序。\n\n根据您提供的中断优先级设置，结合中断优先级分组为2，可以确定以下中断的优先级顺序：\n\n1. 中断3（RTC中断）的优先级：抢占优先级 2，响应优先级 1。\n2. 中断6（外部中断0）的优先级：抢占优先级 3，响应优先级 0。\n3. 中断7（外部中断1）的优先级：抢占优先级 2，响应优先级 0。\n\n根据中断优先级的设置规则：\n\n- 具有较高的抢占优先级的中断可以打断正在执行的低优先级中断。\n- 在相同抢占优先级下，具有较高的响应优先级的中断将首先得到处理器的服务。\n\n根据上述设置，优先级顺序为：\n\n1. 中断6（外部中断0）：抢占优先级 3，响应优先级 0。\n2. 中断7（外部中断1）：抢占优先级 2，响应优先级 0。\n3. 中断3（RTC中断）：抢占优先级 2，响应优先级 1。\n\n因此，中断6（外部中断0）具有最高优先级，中断3（RTC中断）具有次高优先级，中断7（外部中断1）具有最低优先级。\n\n### 定时器/计数器简答\n\n#### STM32F103微控制器的常规定时器分为哪3种?\n\n1. TIM1（定时器1）：这是一个高级定时器，具有较复杂的功能和多路输出通道，可用于实现高级的定时和PWM控制。\n2. TIM2（定时器2）：这是一个通用定时器，具有基本的定时功能，可用于一般的定时和计数应用。\n3. TIM3（定时器3）：这是一个通用定时器，与TIM2类似，也具有基本的定时和计数功能，可广泛应用于定时和计数需求。\n\n#### STM32F103微控制器的高级定时器和通用定时器的功能主要有什么区别？\n\n高级定时器（如TIM1）：\n\n1. 多路输出通道：高级定时器通常具有多个输出通道，可以用于实现更复杂的PWM控制和输出信号。\n2. 高级控制功能：高级定时器提供更多的高级控制功能，如编码器模式、输入捕获、输出比较、PWM生成等，能够满足更复杂的定时和控制需求。\n3. 高精度定时：高级定时器通常具有更高的计数精度和更大的计数范围，可以实现更精确的定时操作。\n\n通用定时器（如TIM2、TIM3等）：\n\n1. 基本定时功能：通用定时器提供基本的定时和计数功能，能够满足常见的定时需求。\n2. 灵活性和易用性：通用定时器的配置和使用相对简单，适用于一般的定时和计数应用。\n3. 低功耗模式：通用定时器通常支持低功耗模式，可以在需要时降低功耗，延长电池寿命。\n\n总体而言，高级定时器具有更多的高级功能和扩展性，适用于复杂的定时和控制需求，而通用定时器则更适用于常见的定时和计数应用，并具有简单易用和低功耗的特点。选择合适的定时器取决于具体的应用需求和功能要求。\n\n#### STM32F103定时器的计数器模式有哪3种?\n\n1. 向上计数模式（Up Counter Mode）：定时器从0开始计数，逐渐增加，直到计数值达到设定的上限值（比如自动重载值），然后重新从0开始计数。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。\n2. 向下计数模式（Down Counter Mode）：定时器从设定的上限值（比如自动重载值）开始计数，逐渐减小，直到计数值为0。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。\n3. 中央对齐模式（Center-aligned Mode）：定时器在向上计数和向下计数之间来回切换，计数器值会在自动重载值的一半处反向。这种模式下的计数器可以产生对称的波形，对于一些特定的应用场景如PWM输出很有用。\n\n### ADC简答\n\n#### 简述STM32F103的ADC规则通道组和注入通道组之间的关系\n\n**规则通道组是用于常规的模数转换，它可以配置多个通道进行连续的模数转换。**规则通道组的转换顺序可以根据需要进行设置，可以按照顺序依次转换多个通道的模拟输入信号。\n\n**注入通道组则是用于特定的应用场景，如精确的采样或触发转换。注入通道组可以单独配置一个或多个通道进行模数转换**，并且可以使用特定的触发源来触发转换。\n\n规则通道组和注入通道组之间是相互独立的，它们有各自独立的转换序列和设置。在配置时，可以选择使用规则通道组、注入通道组或两者同时使用，以满足不同的应用需求。\n\n总结而言，规则通道组和注入通道组是用于不同的模数转换应用场景的两种通道组，可以根据具体需求配置和使用。\n\n### 串口简答\n\n#### 简述如何判断STM32F103的串口是否完成数据发送和接收\n\n1. 发送完成标志位（TXE）：通过读取串口状态寄存器（SR）中的TXE标志位来判断是否完成数据发送。当TXE标志位为1时，表示发送缓冲器为空，可以继续发送数据；当TXE标志位为0时，表示发送缓冲器正在发送数据，还未完成发送。\n2. 数据接收完成标志位（RXNE）：通过读取串口状态寄存器（SR）中的RXNE标志位来判断是否完成数据接收。当RXNE标志位为1时，表示接收缓冲器中已有接收到的数据，可以读取；当RXNE标志位为0时，表示接收缓冲器为空，还未有新的数据接收。\n\n可以使用相关的寄存器和标志位来进行判断，具体操作如下：\n\n1. 判断发送完成：**通过检查USART_SR寄存器中的TXE标志位，当TXE为1时，表示发送完成。**\n2. 判断数据接收完成：**通过检查USART_SR寄存器中的RXNE标志位，当RXNE为1时，表示数据接收完成。**\n\n#### 串行通信分为异步通信和同步通信，简述异步通信和同步通信的区别\n\n异步通信和同步通信是两种不同的串行通信方式，它们的区别在于*数据传输的时钟信号的处理方式和数据帧的组织方式。*\n\n异步通信：\n\n- 异步通信**使用两个信号线，分别是数据线（TXD和RXD）和单个的时钟信号线（通常为波特率时钟）。**\n- 数据的传输是基于起始位、数据位、奇偶校验位和停止位构成的数据帧进行的。**每个数据帧之间没有固定的时间间隔。**\n- **发送端和接收端的时钟频率可以略有差异**，因此需要在接收端通过起始位的边沿检测来同步数据。\n- 异步通信**适用于短距离和低速率的通信**，例如串口通信。\n\n同步通信：\n\n- 同步通信**使用单独的时钟信号线来同步数据的传输**，也称为时钟同步通信。\n- 数据的传输是基于固定的时钟信号来同步发送和接收的。数据被切分成多个连续的数据帧，**每个数据帧的长度和时钟信号的周期相对应。**\n- **发送端和接收端的时钟频率必须保持一致**，以确保数据的正确接收。\n- 同步通信**适用于高速率和长距离的通信**，例如以太网通信和SPI通信。\n\n总结：\n异步通信和同步通信的主要区别在于时钟信号的处理方式和数据帧的组织方式。\n**异步通信使用单个时钟信号和数据帧的起始位、数据位、奇偶校验位和停止位进行数据传输，而同步通信则使用单独的时钟信号来同步数据的传输，数据被切分成连续的数据帧并通过固定的时钟信号周期来同步发送和接收。**\n\n### 操作系统简答\n\n#### uC/OS-II操作系统中，信号量和互斥信号量在功能上的主要区别是什么？\n\n1. 信号量（Semaphore）：\n   - 信号量是一种**用于控制对资源的访问的机制，可以用来表示可用资源的数量。**\n   - 信号量可以实现资源的共享和同步，**允许多个任务对同一资源进行访问。**\n   - 信号量有两种类型：**二进制信号量和计数信号量。**\n   - *二进制信号量的值只能为0或1，用于实现互斥访问，即只允许一个任务访问资源。*\n   - *计数信号量的值可以是任意非负整数，用于表示可用资源的数量。*\n   - 任务可以**通过等待信号量来获取资源**，*如果资源不可用，则任务会被阻塞，直到资源可用为止。*\n2. 互斥信号量（Mutex）：\n   - 互斥信号量是一种**特殊的信号量，用于实现互斥访问共享资源。**\n   - 互斥信号量可以**保证同一时间只有一个任务可以访问共享资源**，避免了多个任务同时访问导致的数据竞争和冲突。\n   - 互斥信号量*在任务访问共享资源之前需要进行获取（P操作），在任务使用完资源后需要进行释放（V操作）。*\n   - 如果互斥信号量已经被一个任务获取，*其他任务尝试获取该互斥信号量时会被阻塞，直到互斥信号量被释放。*\n\n总结：\n\n信号量用于控制对资源的访问，可以实现资源的共享和同步；\n\n而互斥信号量是一种特殊的信号量，用于实现互斥访问共享资源，确保同一时间只有一个任务可以访问共享资源。\n\n互斥信号量是信号量的一种特殊形式，用于解决共享资源的互斥访问问题。\n\n#### uC/OS-II操作系统中，信号量和消息邮箱在功能上的主要区别是什么？\n\n1. 信号量（Semaphore）：\n   - 信号量用于控制对资源的访问和同步任务的执行顺序。\n   - 信号量可以表示可用资源的数量，任务可以通过等待信号量来获取资源，如果资源不可用，则任务会被阻塞，直到资源可用为止。\n   - 信号量的值可以是任意非负整数，可以用来表示资源的数量或者某种条件的满足情况。\n   - 信号量可以用于实现资源的共享和同步，多个任务可以同时等待和释放同一个信号量。\n2. 消息邮箱（Message Mailbox）：\n   - 消息邮箱用于在任务之间传递消息和数据。\n   - 消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。\n   - 任务可以通过发送消息到邮箱来向其他任务传递数据，也可以通过接收消息来获取其他任务发送的数据。\n   - 消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。\n\n总结：\n\n**信号量用于控制资源的访问和同步任务的执行顺序，多个任务可以同时等待和释放同一个信号量；而消息邮箱用于在任务之间传递消息和数据，具有缓冲区的功能，可以存储多个消息。信号量更适用于控制资源的共享和同步，而消息邮箱更适用于任务间的数据传递和通信。**\n\n#### uC/OS-II操作系统中，消息邮箱和消息队列在功能上的主要区别是什么？\n\n1. 消息邮箱（Message Mailbox）：\n   - 消息邮箱用于在任务之间传递消息和数据。\n   - 消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。\n   - 发送任务通过发送消息到邮箱来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。\n   - 消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。\n2. 消息队列（Message Queue）：\n   - 消息队列用于在任务之间传递消息和数据。\n   - 消息队列可以存储一个或多个消息，每个消息可以是一个可变长度的数据结构。\n   - 发送任务通过发送消息到队列来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。\n   - 消息队列具有先进先出（FIFO）的特性，保证消息按照发送的顺序进行接收。\n\n总结：\n\n**消息邮箱和消息队列都用于任务间的消息传递和数据通信，但它们在消息存储方式和特性上有所不同。消息邮箱适用于固定长度的消息存储和同步发送和接收任务的操作，而消息队列适用于可变长度的消息存储和按照发送顺序进行接收的操作。**\n\n## 程序设计\n\n### GPIO程序设计\n\n#### 采用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁，闪烁周期约为1s，采用软件延时方法。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOB的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\n    // 配置PB5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOB, &GPIO_InitStructure);\n}\n\n// 这部分考试时候可不写\n// 延时函数，使用软件延时\nvoid Delay(uint32_t nCount)\n{\n    for (volatile uint32_t i = 0; i < nCount; i++)\n    {\n        for (volatile uint32_t j = 0; j < 1000; j++)\n        {\n            // 空操作，用于延时\n        }\n    }\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    while (1)\n    {\n        // 控制LED灯亮\n        GPIO_SetBits(GPIOB, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n\n        // 控制LED灯灭\n        GPIO_ResetBits(GPIOB, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOB的PB5引脚为推挽输出模式。然后，在`main()`函数中，通过循环控制LED灯周期性地闪烁。通过调用`GPIO_SetBits()`和`GPIO_ResetBits()`函数来控制PB5引脚的电平，实现LED灯的亮和灭。通过调用`Delay()`函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现LED灯的周期性闪烁。\n\n#### 采用库函数编写通用GPIO控制程序，实现PB5和PE5控制的2个LED灯交替闪烁，闪烁周期约为1s。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现PB5和PE5控制的两个LED灯交替闪烁的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOB和GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PB5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOB, &GPIO_InitStructure);\n\n    // 配置PE5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\n// 考试时可不写\n// 延时函数，使用软件延时\nvoid Delay(uint32_t nCount)\n{\n    for (volatile uint32_t i = 0; i < nCount; i++)\n    {\n        for (volatile uint32_t j = 0; j < 1000; j++)\n        {\n            // 空操作，用于延时\n        }\n    }\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    while (1)\n    {\n        // 控制PB5引脚为高电平，PE5引脚为低电平\n        GPIO_SetBits(GPIOB, GPIO_Pin_5);\n        GPIO_ResetBits(GPIOE, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n\n        // 控制PB5引脚为低电平，PE5引脚为高电平\n        GPIO_ResetBits(GPIOB, GPIO_Pin_5);\n        GPIO_SetBits(GPIOE, GPIO_Pin_5);\n\n        // 延时约1s\n        Delay(1000);\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOB的PB5引脚和GPIOE的PE5引脚为推挽输出模式。然后，在`main()`函数中，通过循环控制两个LED灯的交替闪烁。通过调用`GPIO_SetBits()`和`GPIO_ResetBits()`函数来控制PB5和PE5引脚的电平，实现LED灯的亮和灭。通过调用`Delay()`函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现两个LED灯的交替闪烁。\n\n#### 采用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮功能，8个LED由PE0~PE7控制，低电平点亮。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PE0~PE7引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |\n                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    while (1)\n    {\n        // 依次点亮8个LED，通过循环和位运算实现\n        for (int i = 0; i < 8; i++)\n        {\n            // 将对应的引脚设置为低电平，点亮LED\n            GPIO_ResetBits(GPIOE, (1 << i));\n\n            // 延时一段时间\n            for (volatile int j = 0; j < 1000000; j++)\n            {\n                // 空操作，用于延时\n            }\n\n            // 将对应的引脚设置为高电平，熄灭LED\n            GPIO_SetBits(GPIOE, (1 << i));\n        }\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOE的PE0~PE7引脚为推挽输出模式。然后，在`main()`函数中，通过循环依次点亮8个LED。通过循环和位运算，将对应的引脚设置为低电平，点亮LED，并延时一段时间。然后将对应的引脚设置为高电平，熄灭LED。循环执行这个过程，就可以实现8个LED的循环依次点亮的效果。\n\n#### 采用库函数编写通用GPIO控制程序，实现PC口（PC0~PC7）控制1位共阳极数码管循环显示数字0~9的功能，每个数字显示停留时间约为1s。程序应包括GPIO初始化函数和主函数main（）代码\n\n以下是使用库函数编写通用GPIO控制程序，实现PC口控制1位共阳极数码管循环显示数字0~9的示例代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// 数码管数字编码表\nconst uint8_t digitCode[] = {\n    0x3F,  // 0\n    0x06,  // 1\n    0x5B,  // 2\n    0x4F,  // 3\n    0x66,  // 4\n    0x6D,  // 5\n    0x7D,  // 6\n    0x07,  // 7\n    0x7F,  // 8\n    0x6F   // 9\n};\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOC的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n\n    // 配置PC0~PC7引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |\n                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOC, &GPIO_InitStructure);\n}\n\nint main(void)\n{\n    // 初始化GPIO\n    GPIO_Init();\n\n    uint8_t digit = 0;  // 当前显示的数字\n\n    while (1)\n    {\n        // 根据当前数字设置PC0~PC7引脚的输出状态\n        GPIO_Write(GPIOC, digitCode[digit]);\n\n        // 延时一段时间\n        for (volatile int i = 0; i < 1000000; i++)\n        {\n            // 空操作，用于延时\n        }\n\n        // 切换到下一个数字\n        digit++;\n        if (digit > 9)\n        {\n            digit = 0;\n        }\n    }\n}\n```\n\n上述代码中，首先在`GPIO_Init()`函数中初始化了GPIOC的PC0~PC7引脚为推挽输出模式。然后，在`main()`函数中，通过循环依次显示数字0~9。在每个循环中，根据当前数字设置PC0~PC7引脚的输出状态，通过写入相应的数码管数字编码。然后延时一段时间，切换到下一个数字，再次循环显示。通过这个过程，可以实现PC口控制1位共阳极数码管循环显示数字0~9的功能。\n\n### EXTI程序设计\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（下降沿中断）将LED灯状态取反。（写出PE2外部中断初始化代码和外部中断服务函数的代码）\n\n下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOC和GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PC5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOC, &GPIO_InitStructure);\n\n    // 配置PE2引脚为上拉输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\n// 外部中断初始化函数\nvoid EXTI_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    EXTI_InitTypeDef EXTI_InitStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能AFIO的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 配置PE2引脚为中断输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  // 下拉输入\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n\n    // 配置外部中断线路\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);\n\n    // 配置外部中断参数\n    EXTI_InitStructure.EXTI_Line = EXTI_Line2;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  // 下降沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;  // 抢占优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;         // 响应优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n// 外部中断服务函数\nvoid EXTI2_IRQHandler(void)\n{\n    if (EXTI_GetITStatus(EXTI_Line2) != RESET)\n    {\n        // 等待一段时间消除抖动\n        for (volatile int i = 0; i < 100000; i++)\n        {\n            // 空操作，用于延时\n        }\n\n        // 检查按键是否按下（下降沿触发）\n        if (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_2) == RESET)\n        {\n            // 反转LED灯状态\n            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));\n        }\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(EXTI_Line2);\n    }\n}\n\n```\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PE4）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（上升沿中断）将LED灯状态取反。（写出PE4外部中断初始化代码和外部中断服务函数的代码）\n\n下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// GPIO初始化函数\nvoid GPIO_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    // 使能GPIOC和GPIOE的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置PC5引脚为推挽输出\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOC, &GPIO_InitStructure);\n\n    // 配置PE4引脚为上拉输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n}\n\n// 外部中断初始化函数\nvoid EXTI_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    EXTI_InitTypeDef EXTI_InitStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能AFIO的时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 配置PE4引脚为中断输入\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  // 下拉输入\n    GPIO_Init(GPIOE, &GPIO_InitStructure);\n\n    // 配置外部中断线路\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource4);\n\n    // 配置外部中断参数\n    EXTI_InitStructure.EXTI_Line = EXTI_Line4;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 上升沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;  // 抢占优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;         // 响应优先级为0\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n// 外部中断服务函数\nvoid EXTI4_IRQHandler(void)\n{\n    if (EXTI_GetITStatus(EXTI_Line4) != RESET)\n    {\n        // 等待一段时间消除抖动\n        for (volatile int i = 0; i < 100000; i++)\n        {\n            // 空操作，用于延时\n        }\n\n        // 检查按键是否按下（上升沿触发）\n        if (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_4) == SET)\n        {\n            // 反转LED灯状态\n            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));\n        }\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(EXTI_Line4);\n    }\n}\n\n```\n\n#### 补充 : (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)是什么含义\n\n```tex\n在之前的案例中，`(BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`是一个表达式，用于取反GPIOC的第5个引脚（即PC5）的输出状态。\n\n`GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`函数用于读取GPIOC的第5个引脚（即PC5）的输出状态，返回值为0或1，表示引脚的电平状态。\n\n`(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`中的`(1 - ...)`部分将读取的引脚状态取反，即如果引脚的输出为0，则结果为1，如果引脚的输出为1，则结果为0。\n\n最外层的`(BitAction)`则将取反后的结果转换为`BitAction`类型，`BitAction`是一个枚举类型，表示引脚的状态，取值可以是`Bit_RESET`（低电平）或`Bit_SET`（高电平）。\n\n因此，`(BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)`的含义是将GPIOC的第5个引脚的输出状态取反，并将结果转换为`BitAction`类型，用于控制该引脚的输出状态。\n```\n\n### TIM\n\n#### 采用库函数编写通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为3\n\n下面是使用库函数编写的通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，并设置中断优先级为抢占优先级2，响应优先级3的代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// 定时器TIM2初始化函数\nvoid TIM2_Init(void)\n{\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能TIM2的时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n\n    // 配置定时器TIM2\n    TIM_TimeBaseStructure.TIM_Period = 999;  // 计数器自动重装值\n    TIM_TimeBaseStructure.TIM_Prescaler = 7199;  // 预分频值\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  // 加计数模式\n    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  // 时钟分频\n    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;\n    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);\n\n    // 配置TIM2的更新中断\n    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;  // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;         // 响应优先级为3\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    // 使能定时器TIM2\n    TIM_Cmd(TIM2, ENABLE);\n}\n\n// 定时器TIM2中断服务函数\nvoid TIM2_IRQHandler(void)\n{\n    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)\n    {\n        // 在此处理定时器中断相关的操作\n\n        // 清除中断标志位\n        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);\n    }\n}\n```\n\n请注意，以上代码只是TIM2定时器的初始化和中断处理部分，你还需要在主函数中调用`TIM2_Init()`函数进行初始化，并启用全局中断。\n\n#### 采用库函数编写通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，中断抢占优先级为1，响应优先级为2。\n\n下面是使用库函数编写的通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，并设置中断优先级为抢占优先级1，响应优先级2的代码：\n\n```c\n#include \"stm32f10x.h\"  // 包含STM32F103系列的头文件\n\n// 定时器TIM3初始化函数\nvoid TIM3_Init(void)\n{\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n\n    // 使能TIM3的时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);\n\n    // 配置定时器TIM3\n    TIM_TimeBaseStructure.TIM_Period = 9999;  // 计数器自动重装值\n    TIM_TimeBaseStructure.TIM_Prescaler = 7199;  // 预分频值\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  // 加计数模式\n    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  // 时钟分频\n    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;\n    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);\n\n    // 配置TIM3的更新中断\n    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);\n\n    // 配置中断优先级\n    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;  // 抢占优先级为1\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;         // 响应优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    // 使能定时器TIM3\n    TIM_Cmd(TIM3, ENABLE);\n}\n\n// 定时器TIM3中断服务函数\nvoid TIM3_IRQHandler(void)\n{\n    if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)\n    {\n        // 在此处理定时器中断相关的操作\n\n        // 清除中断标志位\n        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);\n    }\n}\n```\n\n请注意，以上代码只是TIM3定时器的初始化和中断处理部分，你还需要在主函数中调用`TIM3_Init()`函数进行初始化，并启用全局中断。\n\n#### 补充 : 计算TIM_TimeBaseStructure.TIM_Period(计数器自动重装载值)\n\n```tex\n在上个案例中，`TIM_TimeBaseStructure.TIM_Period`的值设置为9999，是为了实现100ms的定时时间。\n\n定时器的计数器值会在0到TIM_Period之间循环计数，当计数器达到TIM_Period时，就会产生更新事件（溢出），并触发中断（如果使能了中断）。因此，定时器的定时时间可以通过设置TIM_Period的值来控制。\n\n在STM32F103微控制器中，定时器的计数器位数是16位，因此最大计数值为65535。要计算TIM_Period的值以实现100ms的定时，可以使用以下公式：\n\nTIM_Period = (定时时间 / 计数周期) - 1\n\n其中，定时时间是以秒为单位，计数周期是定时器的预分频值与定时器时钟频率之间的比例关系。在这个案例中，预分频值为7199（`TIM_TimeBaseStructure.TIM_Prescaler = 7199`），定时器时钟频率为72 MHz。\n\n计算过程如下：\n\n计数周期 = 预分频值 + 1 = 7199 + 1 = 7200\n定时时间 = 0.1 秒（100ms）\n\nTIM_Period = (0.1 / 7200) - 1 = 0.0000138888 - 1 ≈ 1388\n\n因为TIM_Period是一个16位的无符号整数，所以需要确保计算出的值在16位的范围内。在这种情况下，取TIM_Period = 1388是一个合适的值，可以实现约100ms的定时。\n```\n\n### 综合题\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示\n\n题目\n采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示。要求：\n（1）写出按键外部中断初始化代码，初始化为上升沿触发中断。\n（2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。\n\n下面是针对上述要求的示例代码：\n\n```c\n#include \"stm32f10x.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_exti.h\"\n#include \"stm32f10x_usart.h\"\n\n// 定义按键引脚和外部中断线\n#define BUTTON_PIN GPIO_Pin_3\n#define BUTTON_PORT GPIOC\n#define BUTTON_EXTI_LINE EXTI_Line3\n\n// 定义串口2引脚和相关参数\n#define USART_TX_PIN GPIO_Pin_2\n#define USART_RX_PIN GPIO_Pin_3\n#define USART_PORT GPIOA\n#define USART USART2\n\n// 全局变量，记录按键次数\nvolatile uint32_t buttonPressCount = 0;\n\n// 函数声明\nvoid EXTI_Configuration(void);\nvoid USART_Configuration(void);\nvoid USART_SendDataString(uint8_t* data);\n\nint main(void)\n{\n    // 初始化外部中断\n    EXTI_Configuration();\n\n    // 初始化串口2\n    USART_Configuration();\n\n    while (1)\n    {\n        // 主循环中不需要做其他操作\n    }\n}\n\n// （1）写出按键外部中断初始化代码，初始化为上升沿触发中断。\nvoid EXTI_Configuration(void)\n{\n    // 使能GPIOC时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);\n\n    // 配置按键引脚为输入模式\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; // 上拉输入\n    GPIO_Init(BUTTON_PORT, &GPIO_InitStructure);\n\n    // 使能AFIO时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 连接外部中断线到按键引脚\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);\n\n    // 配置外部中断线为上升沿触发中断\n    EXTI_InitTypeDef EXTI_InitStructure;\n    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; // 上升沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 使能外部中断通道\n    NVIC_InitTypeDef NVIC_InitStructure;\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;        // 响应优先级为3\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n\n// （2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。\nvoid USART_Configuration(void)\n{\n    // 使能GPIOA时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\n    // 使能USART2时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);\n\n    // 配置USART引脚为复用功能\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(USART_PORT, &GPIO_InitStructure);\n\n    // 配置USART参数\n\n\n    USART_InitTypeDef USART_InitStructure;\n    USART_InitStructure.USART_BaudRate = 19200;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Tx; // 仅发送模式\n    USART_Init(USART, &USART_InitStructure);\n\n    // 使能USART\n    USART_Cmd(USART, ENABLE);\n}\n\n// （3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。\nvoid EXTI3_IRQHandler(void)\n{\n    // 检查按键外部中断是否发生\n    if (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)\n    {\n        // 延时一段时间，防止抖动\n        for (volatile uint32_t i = 0; i < 100000; i++);\n\n        // 记录按键次数\n        buttonPressCount++;\n\n        // 发送按键次数到串口\n        char countStr[10];\n        sprintf(countStr, \"Press count: %lu\\r\\n\", buttonPressCount);\n        USART_SendDataString((uint8_t*)countStr);\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);\n    }\n}\n\nvoid USART_SendDataString(uint8_t* data)\n{\n    while (*data)\n    {\n        USART_SendData(USART, *data++);\n        while (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);\n    }\n}\n```\n\n以上代码实现了对PC3按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口2将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为上升沿触发中断，串口2被初始化为波特率为19200bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口2发送出去。\n\n#### 采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示\n\n题目 :\n\n采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示。要求：\n\n（1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。\n\n下面是针对上述要求的示例代码：\n\n```c\n#include \"stm32f10x.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_exti.h\"\n#include \"stm32f10x_usart.h\"\n\n// 定义按键引脚和外部中断线\n#define BUTTON_PIN GPIO_Pin_2\n#define BUTTON_PORT GPIOE\n#define BUTTON_EXTI_LINE EXTI_Line2\n\n// 定义串口1引脚和相关参数\n#define USART_TX_PIN GPIO_Pin_9\n#define USART_RX_PIN GPIO_Pin_10\n#define USART_PORT GPIOA\n#define USART USART1\n\n// 全局变量，记录按键次数\nvolatile uint32_t buttonPressCount = 0;\n\n// 函数声明\nvoid EXTI_Configuration(void);\nvoid USART_Configuration(void);\nvoid USART_SendDataString(uint8_t* data);\n\nint main(void)\n{\n    // 初始化外部中断\n    EXTI_Configuration();\n\n    // 初始化串口1\n    USART_Configuration();\n\n    while (1)\n    {\n        // 主循环中不需要做其他操作\n    }\n}\n\n// （1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。\nvoid EXTI_Configuration(void)\n{\n    // 使能GPIOE时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);\n\n    // 配置按键引脚为输入模式\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; // 下拉输入\n    GPIO_Init(BUTTON_PORT, &GPIO_InitStructure);\n\n    // 使能AFIO时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n\n    // 连接外部中断线到按键引脚\n    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);\n\n    // 配置外部中断线为下降沿触发中断\n    EXTI_InitTypeDef EXTI_InitStructure;\n    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;\n    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;\n    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; // 下降沿触发\n    EXTI_InitStructure.EXTI_LineCmd = ENABLE;\n    EXTI_Init(&EXTI_InitStructure);\n\n    // 使能外部中断通道\n    NVIC_InitTypeDef NVIC_InitStructure;\n    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;        // 响应优先级为3\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n}\n\n// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\nvoid USART_Configuration(void)\n{\n    // 使能GPIOA时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\n    // 使能USART1时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\n    // 配置USART引脚为复用功能\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(USART_PORT, &GPIO_InitStructure);\n\n    // 配置USART参数\n\n\n    USART_InitTypeDef USART_InitStructure;\n    USART_InitStructure.USART_BaudRate = 9600;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Tx; // 仅发送模式\n    USART_Init(USART, &USART_InitStructure);\n\n    // 使能USART\n    USART_Cmd(USART, ENABLE);\n}\n\n// （3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。\nvoid EXTI2_IRQHandler(void)\n{\n    // 检查按键外部中断是否发生\n    if (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)\n    {\n        // 延时一段时间，防止抖动\n        for (volatile uint32_t i = 0; i < 100000; i++);\n\n        // 记录按键次数\n        buttonPressCount++;\n\n        // 发送按键次数到串口\n        char countStr[10];\n        sprintf(countStr, \"Press count: %lu\\r\\n\", buttonPressCount);\n        USART_SendDataString((uint8_t*)countStr);\n\n        // 清除中断标志位\n        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);\n    }\n}\n\nvoid USART_SendDataString(uint8_t* data)\n{\n    while (*data)\n    {\n        USART_SendData(USART, *data++);\n        while (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);\n    }\n}\n```\n\n以上代码实现了对PE2按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口1将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为下降沿触发中断，串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口1发送出去。\n\n#### 采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示\n\n采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示。要求：\n\n（1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\n（3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。\n\n下面是针对上述要求的示例代码：\n\n```c\n#include \"stm32f10x.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_usart.h\"\n#include \"stm32f10x_tim.h\"\n\n// 定义串口1引脚和相关参数\n#define USART_TX_PIN GPIO_Pin_9\n#define USART_RX_PIN GPIO_Pin_10\n#define USART_PORT GPIOA\n#define USART USART1\n\n// 定义定时器TIM2参数\n#define TIM_PERIOD 7199\n#define TIM_PRESCALER 7199\n\n// 全局变量，记录中断次数计数值\nvolatile uint8_t interruptCount = 0;\n\n// 函数声明\nvoid TIM2_Configuration(void);\nvoid USART_Configuration(void);\nvoid USART_SendDataString(uint8_t* data);\n\nint main(void)\n{\n    // 初始化定时器TIM2\n    TIM2_Configuration();\n\n    // 初始化串口1\n    USART_Configuration();\n\n    while (1)\n    {\n        // 主循环中不需要做其他操作\n    }\n}\n\n// （1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。\nvoid TIM2_Configuration(void)\n{\n    // 使能TIM2时钟\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n\n    // 初始化TIM2参数\n    TIM_TimeBaseInitTypeDef TIM_InitStructure;\n    TIM_InitStructure.TIM_Period = TIM_PERIOD;\n    TIM_InitStructure.TIM_Prescaler = TIM_PRESCALER;\n    TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;\n    TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;\n    TIM_InitStructure.TIM_RepetitionCounter = 0;\n    TIM_TimeBaseInit(TIM2, &TIM_InitStructure);\n\n    // 配置TIM2中断优先级\n    NVIC_InitTypeDef NVIC_InitStructure;\n    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 抢占优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;        // 响应优先级为2\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    // 使能TIM2更新中断\n    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);\n\n    // 启动定时器TIM2\n    TIM_Cmd(TIM2, ENABLE);\n}\n\n// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。\nvoid USART_Configuration(void)\n{\n    // 使能GPIOA时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\n    // 使能USART1时钟\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\n    // 配置USART引脚为复用功能\n    GPIO_InitTypeDef GPIO_InitStructure;\n    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(USART_PORT, &GPIO_InitStructure);\n\n    // 配置USART参数\n    USART_InitTypeDef USART_InitStructure;\n    USART_InitStructure.USART_BaudRate = 9600;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Tx; // 仅\n\n发送模式\n    USART_Init(USART, &USART_InitStructure);\n\n    // 使能USART\n    USART_Cmd(USART, ENABLE);\n}\n\n// （3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。\nvoid USART_SendDataString(uint8_t* data)\n{\n    while (*data)\n    {\n        USART_SendData(USART, *data++);\n        while (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);\n    }\n}\n\nvoid TIM2_IRQHandler(void)\n{\n    // 检查TIM2更新中断是否发生\n    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)\n    {\n        // 延时一段时间，防止按键抖动\n        for (volatile uint32_t i = 0; i < 100000; i++);\n\n        // 增加中断次数计数值\n        interruptCount++;\n\n        // 发送中断次数到串口\n        char countStr[10];\n        sprintf(countStr, \"Interrupt count: %d\\r\\n\", interruptCount);\n        USART_SendDataString((uint8_t*)countStr);\n\n        // 清除中断标志位\n        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);\n    }\n}\n```\n\n以上代码实现了对PE2按键的外部中断响应，每次中断发生时会记录中断次数计数值，并通过串口1将其发送给上位机的串口助手进行显示。定时器TIM2被初始化为定时1s，通过中断实现定时功能。串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。在TIM2的中断服务函数中，会进行一段延时以防止按键抖动，然后记录中断次数计数值并通过串口1发送出去。\n\n## 程序分析\n\n### 题一\n\n基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：\n\n```c\nint main (void)\n{\n    BSPInit();\n    OSInit();\n    OSTaskCreate(TaskLED,  (void *)0,  &TaskLEDStk[TASK_STK_SIZE - 1],  9); \n\tOSTaskCreate(TaskKEY,  (void *)0,  &TaskKEYStk[TASK_STK_SIZE - 1],  10);\n    OSStart();\n    return 0;\n}\n\nvoid  TaskLED(void *pdata)            //LED控制任务\n{\n    INT8U err;\n    sem01 = OSSemCreate(0);\n    while (1)\n    {\n        OSSemPend(sem01,0,&err);\t\n\t\tLED(1, LEDON);             \n\t\tOSTimeDlyHMSM(0, 0, 1, 0); \n\t\tLED(1, LEDOFF);            \n\t\tOSTimeDlyHMSM(0, 0, 1, 0);\n    }\n} \n\nvoid  TaskKEY(void *pdata)         //按键检测任务\n{   \n    while (1) \n    {  \n       while(KEY1!=0)\t          \n           {  OSTimeDly(1); }\n\t   OSSemPost(sem01);\t\t\t\t        \n\t   while(KEY1==0)\t\n           { OSTimeDly(1); }   \n    }    \n}\n```\n\n回答下面问题：\n（1）程序中任务TaskLED和TaskKEY的优先级是多少？其中优先级较高的是哪个任务?\n（2）程序中任务TaskLED和TaskKEY之间采用了哪种事件通信机制？采用该事件实现的功能是资源同步还是行为同步？\n（3）任务TaskLED调用OSSemPend(sem,0,&err)函数后，将进入哪种状态？满足什么条件后退出该状态？\n\n\n(1) 程序中任务TaskLED的优先级为9，任务TaskKEY的优先级为10。优先级较高的任务是TaskKEY。\n\n```c\n// 通过OSTaskCreate() 的最后一个参数判断优先级\nOSTaskCreate(TaskLED,  (void *)0,  &TaskLEDStk[TASK_STK_SIZE - 1],  9); // TaskLED 优先级为9\nOSTaskCreate(TaskKEY,  (void *)0,  &TaskKEYStk[TASK_STK_SIZE - 1],  10); // TaskKEY 优先级为10\n```\n\n(2) 程序中任务TaskLED和TaskKEY之间采用了信号量（sem01）作为事件通信机制。该事件实现的功能是资源同步，用于TaskKEY任务向TaskLED任务发出信号。\n\n程序中使用了信号量sem01作为事件通信机制。TaskKEY任务通过OSSemPost()函数向sem01信号量发出信号，而TaskLED任务通过OSSemPend()函数等待sem01信号量的触发。这种事件通信机制用于任务之间的同步操作\n\n```c\nvoid  TaskLED(void *pdata)            //LED控制任务\n{\n    INT8U err;\n    sem01 = OSSemCreate(0);\n    while (1)\n    {\n        OSSemPend(sem01,0,&err); // TaskLED 通过 OSSemPend() 等待 sem01 信号量的触发\n\t\tLED(1, LEDON);             \n\t\tOSTimeDlyHMSM(0, 0, 1, 0); \n\t\tLED(1, LEDOFF);            \n\t\tOSTimeDlyHMSM(0, 0, 1, 0);\n    }\n} \n\nvoid  TaskKEY(void *pdata)         //按键检测任务\n{   \n    while (1) \n    {  \n       while(KEY1!=0)\t          \n           {  OSTimeDly(1); }\n\t   OSSemPost(sem01); // TaskKEY 通过 OSSemPost() 向 sem01 信号量发出信号\n\t   while(KEY1==0)\t\n           { OSTimeDly(1); }   \n    }    \n}\n```\n\n(3) 任务TaskLED调用OSSemPend(sem, 0, &err)函数后，将进入等待状态（阻塞状态）。TaskLED任务将等待sem01信号量的触发，即等待TaskKEY任务通过OSSemPost()函数释放sem01信号量。当TaskKEY任务调用OSSemPost()函数释放sem01信号量后，TaskLED任务会退出等待状态，并开始执行LED控制代码。\n\n分析\n\n```tex\n 当TaskLED任务调用OSSemPend(sem01, 0, &err)函数后，将进入等待状态（阻塞状态）。该函数的第二个参数为0，表示如果sem01信号量当前不可用，则任务会被阻塞而进入等待状态。任务会一直等待，直到sem01信号量可用或超时（在此情况下不会超时，因为第二个参数为0）。\n\n满足以下条件之一后，TaskLED任务将退出等待状态：\n\n    当TaskKEY任务调用OSSemPost()函数释放sem01信号量时，TaskLED任务会检测到sem01信号量可用，从而退出等待状态。\n    如果TaskLED任务的阻塞期间发生了其他中断或事件，导致任务切换，则当TaskLED任务再次运行时，会重新检查sem01信号量的可用性，并根据情况决定是否退出等待状态。\n```\n\n### 题二\n\n基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：\n\n```c\nint main（void）\n{\nOSInit();\nOSTaskCreate(task1, (void *)0, &task1Stk[TASK_STK_SIZE - 1],  12 );\nOSTaskCreate(task2, (void *)0, &task2Stk[TASK_STK_SIZE - 1],  9 );\nOSTaskCreate(task3, (void *)0, &task3Stk[TASK_STK_SIZE - 1],  6);\nOSStart();\n}\n\nvoid task1（）\n{\t\nClearScreen();                    //LCD清屏\nLCD_Printf(“ task1 \\n”);            //LCD显示字符串 \nOSTimeDly(200);\n}\n\nvoid task2（）\n{\t\nClearScreen();\nLCD_Printf(“ task2 \\n”);            //LCD显示字符串\nOSTimeDly(300);\n}\n\nvoid task3（）\n{\t\nClearScreen();\nLCD_Printf(“ task3 \\n”);            //LCD显示字符串\nOSTimeDly(500);\n}\n```\n\n回答下面问题：\n（1）程序中三个任务task1、task2、task3的优先级分别为什么，其中优先级最高的是哪个任务？         。\n（2）uC/OS-II操作系统中，按照任务的执行方式可分为哪几种类型？本程序中任务task1、task2、task3属于其中哪一种？\n（3）uC/OS-II操作系统中，任务有哪几种状态？本程序中任务调用OSTimeDly( )函数后，将进入哪种状态？\n（4）在LCD上的显示结果为：\n第一次：                  \t      第二次：                  \t\n第三次：                  \t      第四次：                  \t\n第五次：                  \t      第六次：                  \t\n\n(1) 程序中三个任务task1、task2、task3的优先级分别为：12、9、6。优先级数值越小，优先级越高。因此，优先级最高的任务是task3。\n\n(2) uC/OS-II操作系统中，按照任务的执行方式可分为两种类型：抢占式任务和非抢占式任务。本程序中的任务task1、task2、task3属于非抢占式任务，因为它们在任务执行期间不会被其他优先级更高的任务打断。\n\n(3) uC/OS-II操作系统中，任务有四种状态：就绪状态（READY）、运行状态（RUNNING）、阻塞状态（BLOCKED）和挂起状态（SUSPENDED）。本程序中，任务调用OSTimeDly()函数后，任务将进入阻塞状态。OSTimeDly()函数会使任务延迟一段指定的时间，任务在此期间将处于阻塞状态，不会被调度执行。\n\n(4) 在LCD上的显示结果为：\n第一次： task1                   \t  第二次： task2\n第三次： task3                   \t  第四次： task1\n第五次： task2                   \t  第六次： task3\n\n分析\n\n```tex\n根据程序的执行逻辑，任务task1、task2、task3依次执行，每个任务都会先清屏，然后在LCD上显示对应的任务名，并通过OSTimeDly()函数延迟一定时间。因此，首次执行时LCD上会显示\"task1\"，然后延迟200个时钟节拍，接着显示\"task2\"，再延迟300个时钟节拍，最后显示\"task3\"，再延迟500个时钟节拍。之后，任务会不断循环执行，按照相同的顺序在LCD上显示任务名，并延迟指定的时间。\n```\n","slug":"ARM嵌入式复习笔记","published":1,"updated":"2023-05-29T04:20:04.747Z","_id":"cli8bhb6a0000zs974go4f538","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"填空\">填空</h2>\n<h3 id=\"嵌入式系统概念填空\">嵌入式系统概念填空</h3>\n<ol>\n<li>嵌入式系统是以<strong>应用系统</strong>为中心，以<strong>计算机为基础</strong>，<strong>软硬件可裁剪</strong>，<s>适应应用系统对功能、可靠性、成本、体积、功耗严格要求</s>的<strong>专用</strong>计算机系统。</li>\n<li>ARM处理器是ARM公司设计的基于RISC架构的<strong>32位</strong>高性能微处理器，一般采用<strong>哈佛</strong>总线结构，具有高速指令缓存和数据缓存，指令长度固定且多级流水线执行。</li>\n</ol>\n<h3 id=\"工作频率填空\">工作频率填空</h3>\n<ol>\n<li>Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，<strong>APB1总线的最高工作频率为36MHz。</strong></li>\n<li>Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，<strong>APB2总线的最高工作频率为72MHz。</strong></li>\n<li>Cortex-M3<strong>内核的最高工作时钟频率为72MHz。</strong></li>\n</ol>\n<h3 id=\"时钟填空\">时钟填空</h3>\n<ol>\n<li>32F103的系统时钟SYSCLK可以来自**HSI（内部高速时钟）、HSE（外部高速时钟）和PLL（锁相环）**三个时钟源中的一个。</li>\n<li>当STM32F103外接8MHz的晶体时，若使内核达到最高工作时钟频率，PLL的倍频系数应设置为9倍。</li>\n<li>STM32F103外接的<strong>32768Hz晶体主要用来为芯片内部的RTC部件提供时钟源。</strong></li>\n</ol>\n<p>PLL倍频系数的设置</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算步骤如下：</span><br><span class=\"line\">系统时钟SYSCLK = (输入时钟频率) × (PLL倍频系数)</span><br><span class=\"line\">72 MHz = 8 MHz × 9</span><br><span class=\"line\">因此，PLL的倍频系数应设置为9倍</span><br></pre></td></tr></table></figure>\n<h3 id=\"存储器填空\">存储器填空</h3>\n<ol>\n<li>STM32F103芯片是<strong>32位</strong>的微控制器，<strong>可寻址存储空间的大小为4GB。</strong></li>\n<li>STM32F103芯片可寻址存储空间的大小为 4GB，分为 8个512MB的存储块。</li>\n<li>当BOOT0 = 0时，STM32F103上电后，用户程序将从Flash存储器启动。</li>\n</ol>\n<h3 id=\"gpio填空\">GPIO填空</h3>\n<ol>\n<li>STM32F103ZET6芯片包含<strong>7 个16位</strong>的通用目的输入/输出口（GPIO）。。</li>\n<li>STM32F103ZET6芯片共有<strong>112根GPIO引脚</strong>，可从其中<strong>任选16根</strong>作为外部中断输入口。</li>\n</ol>\n<h3 id=\"中断填空\">中断填空</h3>\n<ol>\n<li>STM32F103微控制器具有<strong>10个异常和60个中断</strong>，<strong>中断优先级为16 级</strong>。</li>\n<li>STM32F103微控制器的EXTI模块有<strong>16个连接GPIO的外部中断线</strong>，对应<strong>16个外部中断向量</strong>。</li>\n<li>STM32F103微控制器共<strong>有3个串口</strong>，其中<strong>USART1的工作时钟源来自于APB2总线</strong> 。</li>\n<li>STM32F103微控制器共有<strong>3个串口</strong>，其中<strong>USART2的工作时钟源来自于APB1总线</strong> 。</li>\n</ol>\n<h3 id=\"adc填空\">ADC填空</h3>\n<ol>\n<li>STM32F103微控制器的ADC模块<strong>支持单次和连续转换模式</strong>。</li>\n<li>STM32F103微控制器的ADC模块<strong>分辨率为12位</strong>，<strong>最小转换时间为1.17微妙</strong></li>\n<li>STM32F103的ADC1有16个外部模拟输入通道，<strong>分辨率为12 位。</strong></li>\n<li>STM32F103的ADC的<strong>分辨率为12位</strong>，<strong>最高转换速率是1MHz</strong></li>\n</ol>\n<h3 id=\"操作系统填空\">操作系统填空</h3>\n<ol>\n<li>嵌入式操作系统根据各个任务的要求，进行内存管理、多任务管理、资源管理、任务调度、消息管理和异常处理等工作。</li>\n<li>uC/OS-II操作系统是一个<strong>源代码公开、可移植、可固化、可裁剪、可配置式</strong>的实时多任务操作系统，<strong>最多可支持255个任务</strong>。</li>\n<li>在uC/OS-II操作系统中，通过<strong>互斥信号量</strong>可实现对共享资源的<strong>抢占式访问</strong>。</li>\n</ol>\n<h2 id=\"简答\">简答</h2>\n<h3 id=\"嵌入式系统概念简答\">嵌入式系统概念简答</h3>\n<h4 id=\"从技术角度来说什么是嵌入式系统？8051单片机应用系统是否属于嵌入式系统？\">从技术角度来说什么是嵌入式系统？8051单片机应用系统是否属于嵌入式系统？</h4>\n<ol>\n<li>嵌入式系统是<strong>以应用系统为中心</strong>，<strong>以计算机为基础</strong>，<strong>软硬件可裁剪</strong>，<s>适应应用系统对功能、可靠性、成本、体积、功耗严格要求</s>的<strong>专用计算机系统</strong></li>\n<li>8051单片机应用系统<strong>可以</strong>被归类为嵌入式系统。</li>\n</ol>\n<h4 id=\"嵌入式实时操作系统中的“实时性”指的是什么？\">嵌入式实时操作系统中的“实时性”指的是什么？</h4>\n<ol>\n<li>实时性是<strong>系统对外部事件的及时响应和任务的及时完成能力。</strong> <em>实时性可以分为硬实时和软实时两种类型。</em></li>\n<li>硬实时要求系统在严格的时间约束下，对外部事件作出及时的响应。<strong>任务的截止时间是固定的，任何超出时间限制的情况都可能导致系统功能失效或系统崩溃。</strong></li>\n<li>软实时要求系统尽可能在特定的时间约束下，对外部事件作出及时的响应，但允许偶尔的违反时间限制。<strong>任务的截止时间相对宽松，系统可以容忍一定程度的任务响应时间超出。</strong></li>\n</ol>\n<h3 id=\"时钟简答\">时钟简答</h3>\n<h4 id=\"stm32f103微控制器的工作时钟源有哪几种？各时钟源的频率范围分别是多少？\">STM32F103微控制器的工作时钟源有哪几种？各时钟源的频率范围分别是多少？</h4>\n<ol>\n<li><strong>HSI（High-Speed Internal）高速内部时钟</strong>：频率为8MHz。</li>\n<li><strong>HSE（High-Speed External）高速外部时钟</strong>：频率范围通常为4MHz至16MHz。</li>\n<li><strong>PLL（Phase-Locked Loop）锁相环时钟</strong>：可以使用HSI或HSE作为输入时钟源，并通过倍频系数进行倍频。具体的频率范围取决于倍频系数的设置。</li>\n</ol>\n<h4 id=\"在stm32f103内部的时钟树中，锁相环pll有什么用途？\">在STM32F103内部的时钟树中，锁相环PLL有什么用途？</h4>\n<ol>\n<li><strong>时钟倍频</strong>：PLL可以将输入时钟频率倍增，提供更高的系统时钟频率。</li>\n<li><strong>稳定时钟源</strong>：PLL可以提供更稳定的时钟源，减小时钟的抖动和波动。</li>\n<li><strong>系统时钟源</strong>：在STM32F103中，PLL经常被配置为系统时钟源（SYSCLK），即整个微控制器系统的主要时钟源。</li>\n</ol>\n<h4 id=\"嵌入式系统中的启动代码（startup_stm32f10x_hds）程序的功能是什么？\">嵌入式系统中的启动代码（startup_stm32f10x_hd.s）程序的功能是什么？</h4>\n<ol>\n<li><strong>初始化向量表</strong>：启动代码会定义和初始化微控制器的向量表，其中包含了中断处理函数的入口地址。向量表的初始化是确保中断处理能够正确触发和执行的重要步骤。</li>\n<li><strong>初始化堆栈和堆栈指针</strong>：启动代码会设置初始堆栈指针，指向程序的堆栈空间。这是确保函数调用和中断处理正常工作的必要步骤。</li>\n<li><strong>初始化系统时钟</strong>：启动代码会进行系统时钟的初始化，包括配置时钟源、设置时钟分频器等操作，以确保系统在正确的时钟频率下运行。</li>\n<li><strong>初始化存储器和外设</strong>：启动代码可能包括对存储器和外设的初始化操作，例如设置存储器映射、配置外设寄存器等。</li>\n<li><strong>调用主函数</strong>：启动代码最终会调用应用程序的主函数（如<code>main</code>函数），使应用程序正式开始执行。</li>\n</ol>\n<h4 id=\"stm32f103微控制器的最小系统由哪几部分构成？\">STM32F103微控制器的最小系统由哪几部分构成？</h4>\n<ol>\n<li><strong>STM32F103微控制器芯片</strong>：这是系统的核心部分，包含了CPU、存储器、外设等功能模块。</li>\n<li><strong>时钟源</strong>：最小系统需要提供适当的时钟源，以驱动微控制器的各个部分。常见的时钟源包括晶体振荡器、外部时钟源或者内部时钟源。</li>\n<li><strong>复位电路</strong>：复位电路用于在系统上电或者复位时将微控制器置于初始状态。它通常由复位按钮、电容和电阻等组成。</li>\n<li><strong>电源管理电路</strong>：为STM32F103微控制器提供稳定的电源供应，并对电源进行滤波和保护。这包括电源连接器、电源滤波电容、稳压器等。</li>\n<li><strong>外部连接器</strong>：用于与外部设备或外部电路进行连接，包括通信接口（如UART、SPI、I2C）、GPIO引脚、ADC输入等。</li>\n</ol>\n<h4 id=\"stm32f103微控制器有哪几种启动模式？如何来配置系统启动模式？\">STM32F103微控制器有哪几种启动模式？如何来配置系统启动模式？</h4>\n<ol>\n<li><strong>主启动模式（Main Boot Mode）</strong>：在主启动模式下，微控制器从FLASH存储器的起始地址处开始执行代码。</li>\n<li><strong>系统存储器模式（System Memory Boot Mode）</strong>：在系统存储器模式下，微控制器从内部的系统存储器（一般为ROM或者Flash）的起始地址处开始执行代码。</li>\n<li><strong>内存模式（RAM Boot Mode）</strong>：在内存模式下，微控制器从系统RAM中的特定地址处开始执行代码。</li>\n</ol>\n<p>系统启动模式的配置是通过BOOT pins（BOOT0和BOOT1）的状态来实现的。这些引脚通常通过跳线帽或者外部电平转换器与微控制器连接。</p>\n<p>具体的配置方式如下：</p>\n<ul>\n<li>如果BOOT0引脚为高电平，那么微控制器将进入内存模式。</li>\n<li>如果BOOT0引脚为低电平（接地），那么微控制器将根据BOOT1引脚的状态来选择启动模式。\n<ul>\n<li>如果BOOT1引脚也为低电平，那么微控制器将进入主启动模式。</li>\n<li>如果BOOT1引脚为高电平，那么微控制器将进入系统存储器模式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存储器简答\">存储器简答</h3>\n<h4 id=\"什么是存储器重映射？stm32f103微控制器的哪些存储区域需要进行存储器重映射？\">什么是存储器重映射？STM32F103微控制器的哪些存储区域需要进行存储器重映射？</h4>\n<p>存储器重映射<strong>是指将某些存储器区域的物理地址重新映射到不同的逻辑地址的过程。</strong></p>\n<p>在STM32F103微控制器中，存储器重映射主要涉及以下两个存储区域：</p>\n<ol>\n<li>\n<p><strong>系统存储器（System Memory）</strong>：系统存储器包含了微控制器的启动代码和ROM固件库。在存储器重映射时，系统存储器的物理地址将被映射到内部的ROM或者Flash存储器的起始地址，使得系统可以从内部存储器中执行代码。</p>\n</li>\n<li>\n<p><strong>外部SRAM（External SRAM）</strong>：STM32F103微控制器具有一些器件型号支持外部SRAM的扩展。在存储器重映射时，外部SRAM的物理地址可以被映射到微控制器的内部存储器的地址空间中，使得外部SRAM可以像内部存储器一样被访问和使用。</p>\n</li>\n</ol>\n<h3 id=\"中断简答\">中断简答</h3>\n<h4 id=\"stm32f103微控制器的异常和中断有什么区别？优先级最高的是哪个异常/中断？\">STM32F103微控制器的异常和中断有什么区别？优先级最高的是哪个异常/中断？</h4>\n<p>在STM32F103微控制器中，异常和中断是两种不同的事件处理机制，它们有以下区别：</p>\n<ol>\n<li>\n<p><strong>异常（Exception）</strong>：异常是指<strong>由于指令执行或系统事件引起的处理器中断。它们通常表示了一些严重的错误或特殊情况，需要立即处理。</strong><s>异常包括复位、非屏蔽中断（如硬件故障）、系统调试异常等。异常的处理优先级高于中断。</s></p>\n</li>\n<li>\n<p><strong>中断（Interrupt）</strong>：中断是指<strong>外部设备或特定事件触发的处理器中断。它们通常表示了一些需要优先处理的异步事件</strong>，如外部输入信号、定时器溢出等。中断可以根据优先级配置，并<strong>可被屏蔽或使能。</strong></p>\n</li>\n</ol>\n<p>在STM32F103微控制器中，优先级最高的异常是**复位（Reset）**异常。复位异常在系统上电或者复位时触发，用于将系统重置到初始状态。它的优先级最高，无法被屏蔽。</p>\n<h3 id=\"gpio简答\">GPIO简答</h3>\n<h4 id=\"stm32f103微控制器的gpio有哪几种工作模式？gpio作按键输入时应选择哪种工作模式？\">STM32F103微控制器的GPIO有哪几种工作模式？GPIO作按键输入时应选择哪种工作模式？</h4>\n<ol>\n<li><strong>输入模式（Input Mode）</strong>：将GPIO配置为输入模式，用于读取外部信号或按键的状态。可以选择不同的输入模式，如<strong>浮空输入、上拉输入和下拉输入</strong>，以适应不同的电路连接方式。</li>\n<li><strong>输出模式（Output Mode）</strong>：将GPIO配置为输出模式，用于控制外部设备或驱动器。输出模式可以选择<strong>推挽输出、开漏输出、推挽输出带上拉或下拉等</strong>。</li>\n<li><strong>复用功能模式（Alternate Function Mode）</strong>：将GPIO配置为复用功能模式，可以使用GPIO引脚来实现其他外设功能，如串口、定时器、SPI等。</li>\n<li><strong>模拟模式（Analog Mode）</strong>：将GPIO配置为模拟模式，用于连接模拟信号输入或输出。</li>\n</ol>\n<p>当GPIO用作按键输入时，应选择<strong>输入模式</strong>。可以根据实际情况选择浮空输入、上拉输入或下拉输入，以确保按键的状态能够正确读取。*浮空输入适用于按键有外部上拉或下拉电阻的情况，上拉输入适用于按键接地时为低电平，下拉输入适用于按键接VCC时为高电平的情况。*具体的选择取决于按键连接电路的设计和要求。</p>\n<h4 id=\"请用端口输出数据寄存器(odr-)，编写控制gpioc口的pc3-pc5引脚输出高电平，其它引脚输出低电平的语句\">请用端口输出数据寄存器(ODR )，编写控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平的语句</h4>\n<p>要使用端口输出数据寄存器（ODR）控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平，可以使用以下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOC-&gt;ODR |= GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5; <span class=\"comment\">// 设置PC3、PC4、PC5引脚为高电平</span></span><br><span class=\"line\">GPIOC-&gt;ODR &amp;= ~(GPIO_ODR_ODR0 | GPIO_ODR_ODR1 | GPIO_ODR_ODR2); <span class=\"comment\">// 设置PC0、PC1、PC2引脚为低电平</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"请用端口置位/清零寄存器(bsrr-)，编写控制gpiob口的pb0-pb5引脚输出高电平，其它引脚保持不变的语句\">请用端口置位/清零寄存器(BSRR )，编写控制GPIOB口的PB0-PB5引脚输出高电平，其它引脚保持不变的语句</h4>\n<p>要使用端口置位/清零寄存器（BSRR）控制GPIOB口的PB0-PB5引脚输出高电平，同时保持其他引脚状态不变，可以使用以下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOB-&gt;BSRR = GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5; <span class=\"comment\">// 设置PB0-PB5引脚为高电平</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"请用端口清零寄存器(brr-)，编写控制gpiod口的pd0-pd3引脚输出低电平，其它引脚保持不变的语句\">请用端口清零寄存器(BRR )，编写控制GPIOD口的PD0-PD3引脚输出低电平，其它引脚保持不变的语句</h4>\n<p>要使用端口清零寄存器（BRR）控制GPIOD口的PD0-PD3引脚输出低电平，同时保持其他引脚状态不变，可以使用以下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOD-&gt;BRR = GPIO_BRR_BR0 | GPIO_BRR_BR1 | GPIO_BRR_BR2 | GPIO_BRR_BR3; <span class=\"comment\">// 设置PD0-PD3引脚为低电平</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"简述stm32f103微控制器的gpio相关各个寄存器的含义和作用\">简述STM32F103微控制器的GPIO相关各个寄存器的含义和作用</h4>\n<ol>\n<li>GPIO配置寄存器（GPIOx_CRL和GPIOx_CRH）：用于配置GPIO引脚的工作模式、输入/输出类型、输出速度和上下拉等特性。</li>\n<li>端口输入数据寄存器（GPIOx_IDR）：用于读取GPIO引脚的输入状态，包括输入高低电平。</li>\n<li>端口输出数据寄存器（GPIOx_ODR）：用于设置或读取GPIO引脚的输出状态，可以控制引脚的高低电平。</li>\n<li>端口状态寄存器（GPIOx_SR）：用于读取GPIO引脚的状态标志位，包括引脚的输入状态、输出状态和事件状态等。</li>\n<li>端口配置锁定寄存器（GPIOx_LCKR）：用于锁定GPIO引脚的配置，防止误操作修改引脚的配置设置。</li>\n<li>端口复位寄存器（GPIOx_BRR）：用于通过写入引脚位控制寄存器（BRR）的对应位，将GPIO引脚置为低电平，实现引脚的复位操作。</li>\n</ol>\n<h4 id=\"对比分析stm32寄存器编程和库函数编程两种编程方式的特点\">对比分析STM32寄存器编程和库函数编程两种编程方式的特点</h4>\n<ol>\n<li>寄存器编程方式：\n<ul>\n<li>直接操作硬件寄存器：寄存器编程方式直接操作硬件寄存器，能够直接控制硬件的各个功能和特性。</li>\n<li>精确控制：通过寄存器编程可以对硬件进行细粒度的控制，可以灵活地配置和调整各种参数，满足特定的需求。</li>\n<li>低层访问：寄存器编程是对硬件的直接访问，属于底层编程方式，对硬件细节要求较高，需要更多的了解和掌握。</li>\n<li>更高的性能：由于直接操作寄存器，避免了函数调用和库函数的开销，寄存器编程方式可以获得更高的性能和响应速度。</li>\n</ul>\n</li>\n<li>库函数编程方式：\n<ul>\n<li>抽象封装：库函数编程方式通过提供封装好的函数接口，屏蔽了底层的寄存器操作细节，提供了更高层次的抽象。</li>\n<li>简化开发：库函数提供了丰富的功能库，包括GPIO、定时器、串口等模块，简化了开发者的工作，减少了代码量。</li>\n<li>更高的可移植性：库函数编程方式抽象了底层硬件细节，使得代码更具可移植性，可以在不同的芯片和平台上进行移植和复用。</li>\n<li>需要更多的资源：库函数需要占用一定的存储空间，同时运行时需要更多的内存资源，因此对于资源有限的嵌入式系统可能需要权衡。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，寄存器编程方式适用于对硬件控制要求高、对性能要求高的场景，需要更底层的控制和精确配置；而库函数编程方式则适用于快速开发、提高可移植性和简化开发流程的场景。选择哪种编程方式取决于具体的需求和开发环境。</p>\n<h3 id=\"中断\">中断</h3>\n<h4 id=\"简述stm32f103嵌套向量中断控制器（nvic）的作用和特点\">简述STM32F103嵌套向量中断控制器（NVIC）的作用和特点</h4>\n<p>STM32F103嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）是STM32F103微控制器中负责管理和控制中断的重要模块。它的作用是<strong>协调和处理各种中断请求，并根据中断的优先级和状态进行中断服务程序的调度。</strong></p>\n<p>以下是STM32F103 NVIC的主要特点和作用：</p>\n<ol>\n<li>中断优先级管理：NVIC支持对各个中断通道的优先级进行配置和管理。中断通道的优先级可以根据应用需求进行设置，以确保关键的中断能够得到及时响应。</li>\n<li>嵌套中断支持：NVIC支持嵌套中断的处理。当一个中断正在处理时，如果有更高优先级的中断请求到达，NVIC会暂时中断当前中断的处理，优先处理更高优先级的中断请求。这种机制确保了关键中断的实时性和优先级的保障。</li>\n<li>中断向量表：NVIC维护着中断向量表，用于存储中断服务程序的入口地址。每个中断通道都对应着中断向量表中的一个位置，当中断请求到达时，NVIC会根据中断通道找到对应的中断服务程序并执行。</li>\n<li>中断使能和屏蔽：NVIC提供了使能和屏蔽中断的功能。通过设置相应的控制寄存器，可以启用或禁用特定的中断通道，以满足应用的需求。</li>\n<li>中断状态管理：NVIC能够管理中断的状态，包括中断挂起、中断激活和中断标志等。这些状态信息可以帮助开发者更好地管理和调试中断程序。</li>\n</ol>\n<h4 id=\"简述stm32f103的nvic中断优先级分组方法和优先级划分\">简述STM32F103的NVIC中断优先级分组方法和优先级划分</h4>\n<p>STM32F103的NVIC中断优先级分组方法和优先级划分主要通过两个寄存器来配置：<s>NVIC_IPR（Interrupt Priority Register）和NVIC_ISER（Interrupt Set Enable Register）。</s></p>\n<ol>\n<li>中断优先级分组方法：\n<ul>\n<li>STM32F103支持4种中断优先级分组方式，即分为Group 0、Group 1、Group 2和Group 3。不同的分组方式决定了优先级位数的分配。</li>\n<li><s>通过SCB_AIRCR（Application Interrupt and Reset Control Register）寄存器的位[10:8]来配置中断优先级分组方法。</s></li>\n</ul>\n</li>\n<li>优先级划分：\n<ul>\n<li>在STM32F103中，中断的优先级范围是从0（最高优先级）到15（最低优先级）。数字越小，优先级越高。</li>\n<li>根据选择的中断优先级分组方式，优先级位数的分配有所不同。以下是各个分组方式下的优先级划分情况：\n<ul>\n<li>Group 0：全局抢占式优先级分组，优先级分配为4位。</li>\n<li>Group 1：1位抢占式优先级和3位子优先级，优先级分配为3位抢占优先级和1位子优先级。</li>\n<li>Group 2：2位抢占式优先级和2位子优先级，优先级分配为2位抢占优先级和2位子优先级。</li>\n<li>Group 3：3位抢占式优先级和1位子优先级，优先级分配为1位抢占优先级和3位子优先级。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>通过配置NVIC_IPR寄存器，可以为每个中断通道分配相应的抢占式优先级和子优先级。优先级越高的中断在发生时将优先得到处理，而优先级相同的中断将按照先到先服务（FIFO）的顺序进行处理。</p>\n<p>需要注意的是，在STM32F103中，具有相同优先级的中断中，越靠近中断向量表的位置的中断具有更高的优先级。因此，在进行中断优先级划分时，需要根据中断的重要性和实时性要求进行合理的分配。</p>\n<h4 id=\"简述stm32f103的nvic中断优先级分组中抢占优先级和响应优先级的区别\">简述STM32F103的NVIC中断优先级分组中抢占优先级和响应优先级的区别</h4>\n<ol>\n<li>\n<p>抢占优先级（Preemption Priority）：</p>\n<ul>\n<li>抢占优先级指的是中断发生时，当前正在执行的中断能否被其他中断打断。具有较高抢占优先级的中断可以打断正在执行的低优先级中断，优先获得处理器的控制权。</li>\n<li>抢占优先级的数值越小，表示优先级越高，能够打断的中断范围越广。</li>\n</ul>\n</li>\n<li>\n<p>响应优先级（Subpriority）：</p>\n<ul>\n<li>响应优先级指的是在同一抢占优先级下，多个中断同时请求服务时的优先级排序。具有较高响应优先级的中断将首先得到处理器的服务。</li>\n<li>响应优先级的数值越小，表示优先级越高。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"假定设置中断优先级组为2，然后设置：中断3（-rtc 中断）的抢占优先级为2，响应优先级为1；中断6（外部中断0）的抢占优先级为3，响应优先级为0；中断7（外部中断1）的抢占优先级为2，响应优先级为0。写出这3个中断的优先级顺序。\">假定设置中断优先级组为2，然后设置：中断3（ RTC 中断）的抢占优先级为2，响应优先级为1；中断6（外部中断0）的抢占优先级为3，响应优先级为0；中断7（外部中断1）的抢占优先级为2，响应优先级为0。写出这3个中断的优先级顺序。</h4>\n<p>根据您提供的中断优先级设置，结合中断优先级分组为2，可以确定以下中断的优先级顺序：</p>\n<ol>\n<li>中断3（RTC中断）的优先级：抢占优先级 2，响应优先级 1。</li>\n<li>中断6（外部中断0）的优先级：抢占优先级 3，响应优先级 0。</li>\n<li>中断7（外部中断1）的优先级：抢占优先级 2，响应优先级 0。</li>\n</ol>\n<p>根据中断优先级的设置规则：</p>\n<ul>\n<li>具有较高的抢占优先级的中断可以打断正在执行的低优先级中断。</li>\n<li>在相同抢占优先级下，具有较高的响应优先级的中断将首先得到处理器的服务。</li>\n</ul>\n<p>根据上述设置，优先级顺序为：</p>\n<ol>\n<li>中断6（外部中断0）：抢占优先级 3，响应优先级 0。</li>\n<li>中断7（外部中断1）：抢占优先级 2，响应优先级 0。</li>\n<li>中断3（RTC中断）：抢占优先级 2，响应优先级 1。</li>\n</ol>\n<p>因此，中断6（外部中断0）具有最高优先级，中断3（RTC中断）具有次高优先级，中断7（外部中断1）具有最低优先级。</p>\n<h3 id=\"定时器/计数器简答\">定时器/计数器简答</h3>\n<h4 id=\"stm32f103微控制器的常规定时器分为哪3种?\">STM32F103微控制器的常规定时器分为哪3种?</h4>\n<ol>\n<li>TIM1（定时器1）：这是一个高级定时器，具有较复杂的功能和多路输出通道，可用于实现高级的定时和PWM控制。</li>\n<li>TIM2（定时器2）：这是一个通用定时器，具有基本的定时功能，可用于一般的定时和计数应用。</li>\n<li>TIM3（定时器3）：这是一个通用定时器，与TIM2类似，也具有基本的定时和计数功能，可广泛应用于定时和计数需求。</li>\n</ol>\n<h4 id=\"stm32f103微控制器的高级定时器和通用定时器的功能主要有什么区别？\">STM32F103微控制器的高级定时器和通用定时器的功能主要有什么区别？</h4>\n<p>高级定时器（如TIM1）：</p>\n<ol>\n<li>多路输出通道：高级定时器通常具有多个输出通道，可以用于实现更复杂的PWM控制和输出信号。</li>\n<li>高级控制功能：高级定时器提供更多的高级控制功能，如编码器模式、输入捕获、输出比较、PWM生成等，能够满足更复杂的定时和控制需求。</li>\n<li>高精度定时：高级定时器通常具有更高的计数精度和更大的计数范围，可以实现更精确的定时操作。</li>\n</ol>\n<p>通用定时器（如TIM2、TIM3等）：</p>\n<ol>\n<li>基本定时功能：通用定时器提供基本的定时和计数功能，能够满足常见的定时需求。</li>\n<li>灵活性和易用性：通用定时器的配置和使用相对简单，适用于一般的定时和计数应用。</li>\n<li>低功耗模式：通用定时器通常支持低功耗模式，可以在需要时降低功耗，延长电池寿命。</li>\n</ol>\n<p>总体而言，高级定时器具有更多的高级功能和扩展性，适用于复杂的定时和控制需求，而通用定时器则更适用于常见的定时和计数应用，并具有简单易用和低功耗的特点。选择合适的定时器取决于具体的应用需求和功能要求。</p>\n<h4 id=\"stm32f103定时器的计数器模式有哪3种?\">STM32F103定时器的计数器模式有哪3种?</h4>\n<ol>\n<li>向上计数模式（Up Counter Mode）：定时器从0开始计数，逐渐增加，直到计数值达到设定的上限值（比如自动重载值），然后重新从0开始计数。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。</li>\n<li>向下计数模式（Down Counter Mode）：定时器从设定的上限值（比如自动重载值）开始计数，逐渐减小，直到计数值为0。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。</li>\n<li>中央对齐模式（Center-aligned Mode）：定时器在向上计数和向下计数之间来回切换，计数器值会在自动重载值的一半处反向。这种模式下的计数器可以产生对称的波形，对于一些特定的应用场景如PWM输出很有用。</li>\n</ol>\n<h3 id=\"adc简答\">ADC简答</h3>\n<h4 id=\"简述stm32f103的adc规则通道组和注入通道组之间的关系\">简述STM32F103的ADC规则通道组和注入通道组之间的关系</h4>\n<p>**规则通道组是用于常规的模数转换，它可以配置多个通道进行连续的模数转换。**规则通道组的转换顺序可以根据需要进行设置，可以按照顺序依次转换多个通道的模拟输入信号。</p>\n<p><strong>注入通道组则是用于特定的应用场景，如精确的采样或触发转换。注入通道组可以单独配置一个或多个通道进行模数转换</strong>，并且可以使用特定的触发源来触发转换。</p>\n<p>规则通道组和注入通道组之间是相互独立的，它们有各自独立的转换序列和设置。在配置时，可以选择使用规则通道组、注入通道组或两者同时使用，以满足不同的应用需求。</p>\n<p>总结而言，规则通道组和注入通道组是用于不同的模数转换应用场景的两种通道组，可以根据具体需求配置和使用。</p>\n<h3 id=\"串口简答\">串口简答</h3>\n<h4 id=\"简述如何判断stm32f103的串口是否完成数据发送和接收\">简述如何判断STM32F103的串口是否完成数据发送和接收</h4>\n<ol>\n<li>发送完成标志位（TXE）：通过读取串口状态寄存器（SR）中的TXE标志位来判断是否完成数据发送。当TXE标志位为1时，表示发送缓冲器为空，可以继续发送数据；当TXE标志位为0时，表示发送缓冲器正在发送数据，还未完成发送。</li>\n<li>数据接收完成标志位（RXNE）：通过读取串口状态寄存器（SR）中的RXNE标志位来判断是否完成数据接收。当RXNE标志位为1时，表示接收缓冲器中已有接收到的数据，可以读取；当RXNE标志位为0时，表示接收缓冲器为空，还未有新的数据接收。</li>\n</ol>\n<p>可以使用相关的寄存器和标志位来进行判断，具体操作如下：</p>\n<ol>\n<li>判断发送完成：<strong>通过检查USART_SR寄存器中的TXE标志位，当TXE为1时，表示发送完成。</strong></li>\n<li>判断数据接收完成：<strong>通过检查USART_SR寄存器中的RXNE标志位，当RXNE为1时，表示数据接收完成。</strong></li>\n</ol>\n<h4 id=\"串行通信分为异步通信和同步通信，简述异步通信和同步通信的区别\">串行通信分为异步通信和同步通信，简述异步通信和同步通信的区别</h4>\n<p>异步通信和同步通信是两种不同的串行通信方式，它们的区别在于<em>数据传输的时钟信号的处理方式和数据帧的组织方式。</em></p>\n<p>异步通信：</p>\n<ul>\n<li>异步通信<strong>使用两个信号线，分别是数据线（TXD和RXD）和单个的时钟信号线（通常为波特率时钟）。</strong></li>\n<li>数据的传输是基于起始位、数据位、奇偶校验位和停止位构成的数据帧进行的。<strong>每个数据帧之间没有固定的时间间隔。</strong></li>\n<li><strong>发送端和接收端的时钟频率可以略有差异</strong>，因此需要在接收端通过起始位的边沿检测来同步数据。</li>\n<li>异步通信<strong>适用于短距离和低速率的通信</strong>，例如串口通信。</li>\n</ul>\n<p>同步通信：</p>\n<ul>\n<li>同步通信<strong>使用单独的时钟信号线来同步数据的传输</strong>，也称为时钟同步通信。</li>\n<li>数据的传输是基于固定的时钟信号来同步发送和接收的。数据被切分成多个连续的数据帧，<strong>每个数据帧的长度和时钟信号的周期相对应。</strong></li>\n<li><strong>发送端和接收端的时钟频率必须保持一致</strong>，以确保数据的正确接收。</li>\n<li>同步通信<strong>适用于高速率和长距离的通信</strong>，例如以太网通信和SPI通信。</li>\n</ul>\n<p>总结：<br>\n异步通信和同步通信的主要区别在于时钟信号的处理方式和数据帧的组织方式。<br>\n<strong>异步通信使用单个时钟信号和数据帧的起始位、数据位、奇偶校验位和停止位进行数据传输，而同步通信则使用单独的时钟信号来同步数据的传输，数据被切分成连续的数据帧并通过固定的时钟信号周期来同步发送和接收。</strong></p>\n<h3 id=\"操作系统简答\">操作系统简答</h3>\n<h4 id=\"uc/os-ii操作系统中，信号量和互斥信号量在功能上的主要区别是什么？\">uC/OS-II操作系统中，信号量和互斥信号量在功能上的主要区别是什么？</h4>\n<ol>\n<li>信号量（Semaphore）：\n<ul>\n<li>信号量是一种<strong>用于控制对资源的访问的机制，可以用来表示可用资源的数量。</strong></li>\n<li>信号量可以实现资源的共享和同步，<strong>允许多个任务对同一资源进行访问。</strong></li>\n<li>信号量有两种类型：<strong>二进制信号量和计数信号量。</strong></li>\n<li><em>二进制信号量的值只能为0或1，用于实现互斥访问，即只允许一个任务访问资源。</em></li>\n<li><em>计数信号量的值可以是任意非负整数，用于表示可用资源的数量。</em></li>\n<li>任务可以<strong>通过等待信号量来获取资源</strong>，<em>如果资源不可用，则任务会被阻塞，直到资源可用为止。</em></li>\n</ul>\n</li>\n<li>互斥信号量（Mutex）：\n<ul>\n<li>互斥信号量是一种<strong>特殊的信号量，用于实现互斥访问共享资源。</strong></li>\n<li>互斥信号量可以<strong>保证同一时间只有一个任务可以访问共享资源</strong>，避免了多个任务同时访问导致的数据竞争和冲突。</li>\n<li>互斥信号量<em>在任务访问共享资源之前需要进行获取（P操作），在任务使用完资源后需要进行释放（V操作）。</em></li>\n<li>如果互斥信号量已经被一个任务获取，<em>其他任务尝试获取该互斥信号量时会被阻塞，直到互斥信号量被释放。</em></li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<p>信号量用于控制对资源的访问，可以实现资源的共享和同步；</p>\n<p>而互斥信号量是一种特殊的信号量，用于实现互斥访问共享资源，确保同一时间只有一个任务可以访问共享资源。</p>\n<p>互斥信号量是信号量的一种特殊形式，用于解决共享资源的互斥访问问题。</p>\n<h4 id=\"uc/os-ii操作系统中，信号量和消息邮箱在功能上的主要区别是什么？\">uC/OS-II操作系统中，信号量和消息邮箱在功能上的主要区别是什么？</h4>\n<ol>\n<li>信号量（Semaphore）：\n<ul>\n<li>信号量用于控制对资源的访问和同步任务的执行顺序。</li>\n<li>信号量可以表示可用资源的数量，任务可以通过等待信号量来获取资源，如果资源不可用，则任务会被阻塞，直到资源可用为止。</li>\n<li>信号量的值可以是任意非负整数，可以用来表示资源的数量或者某种条件的满足情况。</li>\n<li>信号量可以用于实现资源的共享和同步，多个任务可以同时等待和释放同一个信号量。</li>\n</ul>\n</li>\n<li>消息邮箱（Message Mailbox）：\n<ul>\n<li>消息邮箱用于在任务之间传递消息和数据。</li>\n<li>消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。</li>\n<li>任务可以通过发送消息到邮箱来向其他任务传递数据，也可以通过接收消息来获取其他任务发送的数据。</li>\n<li>消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<p><strong>信号量用于控制资源的访问和同步任务的执行顺序，多个任务可以同时等待和释放同一个信号量；而消息邮箱用于在任务之间传递消息和数据，具有缓冲区的功能，可以存储多个消息。信号量更适用于控制资源的共享和同步，而消息邮箱更适用于任务间的数据传递和通信。</strong></p>\n<h4 id=\"uc/os-ii操作系统中，消息邮箱和消息队列在功能上的主要区别是什么？\">uC/OS-II操作系统中，消息邮箱和消息队列在功能上的主要区别是什么？</h4>\n<ol>\n<li>消息邮箱（Message Mailbox）：\n<ul>\n<li>消息邮箱用于在任务之间传递消息和数据。</li>\n<li>消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。</li>\n<li>发送任务通过发送消息到邮箱来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。</li>\n<li>消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。</li>\n</ul>\n</li>\n<li>消息队列（Message Queue）：\n<ul>\n<li>消息队列用于在任务之间传递消息和数据。</li>\n<li>消息队列可以存储一个或多个消息，每个消息可以是一个可变长度的数据结构。</li>\n<li>发送任务通过发送消息到队列来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。</li>\n<li>消息队列具有先进先出（FIFO）的特性，保证消息按照发送的顺序进行接收。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<p><strong>消息邮箱和消息队列都用于任务间的消息传递和数据通信，但它们在消息存储方式和特性上有所不同。消息邮箱适用于固定长度的消息存储和同步发送和接收任务的操作，而消息队列适用于可变长度的消息存储和按照发送顺序进行接收的操作。</strong></p>\n<h2 id=\"程序设计\">程序设计</h2>\n<h3 id=\"gpio程序设计\">GPIO程序设计</h3>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现pb5控制led灯周期闪烁，闪烁周期约为1s，采用软件延时方法。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁，闪烁周期约为1s，采用软件延时方法。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOB的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PB5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这部分考试时候可不写</span></span><br><span class=\"line\"><span class=\"comment\">// 延时函数，使用软件延时</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> nCount)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; nCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 控制LED灯亮</span></span><br><span class=\"line\">        GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 控制LED灯灭</span></span><br><span class=\"line\">        GPIO_ResetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOB的PB5引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环控制LED灯周期性地闪烁。通过调用<code>GPIO_SetBits()</code>和<code>GPIO_ResetBits()</code>函数来控制PB5引脚的电平，实现LED灯的亮和灭。通过调用<code>Delay()</code>函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现LED灯的周期性闪烁。</p>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现pb5和pe5控制的2个led灯交替闪烁，闪烁周期约为1s。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现PB5和PE5控制的2个LED灯交替闪烁，闪烁周期约为1s。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现PB5和PE5控制的两个LED灯交替闪烁的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOB和GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PB5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 考试时可不写</span></span><br><span class=\"line\"><span class=\"comment\">// 延时函数，使用软件延时</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> nCount)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; nCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 控制PB5引脚为高电平，PE5引脚为低电平</span></span><br><span class=\"line\">        GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\">        GPIO_ResetBits(GPIOE, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 控制PB5引脚为低电平，PE5引脚为高电平</span></span><br><span class=\"line\">        GPIO_ResetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\">        GPIO_SetBits(GPIOE, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOB的PB5引脚和GPIOE的PE5引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环控制两个LED灯的交替闪烁。通过调用<code>GPIO_SetBits()</code>和<code>GPIO_ResetBits()</code>函数来控制PB5和PE5引脚的电平，实现LED灯的亮和灭。通过调用<code>Delay()</code>函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现两个LED灯的交替闪烁。</p>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现8个led循环依次点亮功能，8个led由pe0~pe7控制，低电平点亮。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮功能，8个LED由PE0~PE7控制，低电平点亮。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE0~PE7引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |</span><br><span class=\"line\">                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 依次点亮8个LED，通过循环和位运算实现</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将对应的引脚设置为低电平，点亮LED</span></span><br><span class=\"line\">            GPIO_ResetBits(GPIOE, (<span class=\"number\">1</span> &lt;&lt; i));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 延时一段时间</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000000</span>; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将对应的引脚设置为高电平，熄灭LED</span></span><br><span class=\"line\">            GPIO_SetBits(GPIOE, (<span class=\"number\">1</span> &lt;&lt; i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOE的PE0~PE7引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环依次点亮8个LED。通过循环和位运算，将对应的引脚设置为低电平，点亮LED，并延时一段时间。然后将对应的引脚设置为高电平，熄灭LED。循环执行这个过程，就可以实现8个LED的循环依次点亮的效果。</p>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现pc口（pc0~pc7）控制1位共阳极数码管循环显示数字0~9的功能，每个数字显示停留时间约为1s。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现PC口（PC0~PC7）控制1位共阳极数码管循环显示数字0~9的功能，每个数字显示停留时间约为1s。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现PC口控制1位共阳极数码管循环显示数字0~9的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数码管数字编码表</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">uint8_t</span> digitCode[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0x3F</span>,  <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"number\">0x06</span>,  <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"number\">0x5B</span>,  <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"number\">0x4F</span>,  <span class=\"comment\">// 3</span></span><br><span class=\"line\">    <span class=\"number\">0x66</span>,  <span class=\"comment\">// 4</span></span><br><span class=\"line\">    <span class=\"number\">0x6D</span>,  <span class=\"comment\">// 5</span></span><br><span class=\"line\">    <span class=\"number\">0x7D</span>,  <span class=\"comment\">// 6</span></span><br><span class=\"line\">    <span class=\"number\">0x07</span>,  <span class=\"comment\">// 7</span></span><br><span class=\"line\">    <span class=\"number\">0x7F</span>,  <span class=\"comment\">// 8</span></span><br><span class=\"line\">    <span class=\"number\">0x6F</span>   <span class=\"comment\">// 9</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PC0~PC7引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |</span><br><span class=\"line\">                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> digit = <span class=\"number\">0</span>;  <span class=\"comment\">// 当前显示的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据当前数字设置PC0~PC7引脚的输出状态</span></span><br><span class=\"line\">        GPIO_Write(GPIOC, digitCode[digit]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 切换到下一个数字</span></span><br><span class=\"line\">        digit++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digit &gt; <span class=\"number\">9</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            digit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOC的PC0~PC7引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环依次显示数字0~9。在每个循环中，根据当前数字设置PC0~PC7引脚的输出状态，通过写入相应的数码管数字编码。然后延时一段时间，切换到下一个数字，再次循环显示。通过这个过程，可以实现PC口控制1位共阳极数码管循环显示数字0~9的功能。</p>\n<h3 id=\"exti程序设计\">EXTI程序设计</h3>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pe2）的响应，用led灯（pc5）状态反映按键的按下，每次按键按下时（下降沿中断）将led灯状态取反。（写出pe2外部中断初始化代码和外部中断服务函数的代码）\">采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（下降沿中断）将LED灯状态取反。（写出PE2外部中断初始化代码和外部中断服务函数的代码）</h4>\n<p>下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC和GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PC5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE2引脚为上拉输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE2引脚为中断输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  <span class=\"comment\">// 下拉输入</span></span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线路</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断参数</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = EXTI_Line2;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  <span class=\"comment\">// 下降沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x00</span>;  <span class=\"comment\">// 抢占优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x00</span>;         <span class=\"comment\">// 响应优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(EXTI_Line2) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待一段时间消除抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查按键是否按下（下降沿触发）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_2) == RESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反转LED灯状态</span></span><br><span class=\"line\">            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(<span class=\"number\">1</span> - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(EXTI_Line2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pe4）的响应，用led灯（pc5）状态反映按键的按下，每次按键按下时（上升沿中断）将led灯状态取反。（写出pe4外部中断初始化代码和外部中断服务函数的代码）\">采用库函数编写程序，实现对按键的外部中断输入（PE4）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（上升沿中断）将LED灯状态取反。（写出PE4外部中断初始化代码和外部中断服务函数的代码）</h4>\n<p>下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC和GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PC5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE4引脚为上拉输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE4引脚为中断输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  <span class=\"comment\">// 下拉输入</span></span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线路</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource4);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断参数</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = EXTI_Line4;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  <span class=\"comment\">// 上升沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x00</span>;  <span class=\"comment\">// 抢占优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x00</span>;         <span class=\"comment\">// 响应优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI4_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(EXTI_Line4) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待一段时间消除抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查按键是否按下（上升沿触发）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_4) == SET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反转LED灯状态</span></span><br><span class=\"line\">            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(<span class=\"number\">1</span> - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(EXTI_Line4);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充-: (bitaction)(1 - gpio_readoutputdatabit(gpioc, gpio_pin_5)是什么含义\">补充 : (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)是什么含义</h4>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在之前的案例中，`(BitAction)(1 - GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`是一个表达式，用于取反GPIOC的第5个引脚（即PC5）的输出状态。</span><br><span class=\"line\"></span><br><span class=\"line\">`GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`函数用于读取GPIOC的第5个引脚（即PC5）的输出状态，返回值为0或1，表示引脚的电平状态。</span><br><span class=\"line\"></span><br><span class=\"line\">`(1 - GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`中的`(1 - ...)`部分将读取的引脚状态取反，即如果引脚的输出为0，则结果为1，如果引脚的输出为1，则结果为0。</span><br><span class=\"line\"></span><br><span class=\"line\">最外层的`(BitAction)`则将取反后的结果转换为`BitAction`类型，`BitAction`是一个枚举类型，表示引脚的状态，取值可以是`Bit<span class=\"built_in\">_</span>RESET`（低电平）或`Bit<span class=\"built_in\">_</span>SET`（高电平）。</span><br><span class=\"line\"></span><br><span class=\"line\">因此，`(BitAction)(1 - GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`的含义是将GPIOC的第5个引脚的输出状态取反，并将结果转换为`BitAction`类型，用于控制该引脚的输出状态。</span><br></pre></td></tr></table></figure>\n<h3 id=\"tim\">TIM</h3>\n<h4 id=\"采用库函数编写通用定时器tim2的初始化程序，设置定时器tim2的预分频值为7199，定时时间为10ms，加计数模式，使能tim2的刷新中断，中断抢占优先级为2，响应优先级为3\">采用库函数编写通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为3</h4>\n<p>下面是使用库函数编写的通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，并设置中断优先级为抢占优先级2，响应优先级3的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM2初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM2的时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置定时器TIM2</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Period = <span class=\"number\">999</span>;  <span class=\"comment\">// 计数器自动重装值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Prescaler = <span class=\"number\">7199</span>;  <span class=\"comment\">// 预分频值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class=\"comment\">// 加计数模式</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  <span class=\"comment\">// 时钟分频</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_RepetitionCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置TIM2的更新中断</span></span><br><span class=\"line\">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>;  <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x03</span>;         <span class=\"comment\">// 响应优先级为3</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能定时器TIM2</span></span><br><span class=\"line\">    TIM_Cmd(TIM2, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM2中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在此处理定时器中断相关的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，以上代码只是TIM2定时器的初始化和中断处理部分，你还需要在主函数中调用<code>TIM2_Init()</code>函数进行初始化，并启用全局中断。</p>\n<h4 id=\"采用库函数编写通用定时器tim3的初始化程序，设置定时器tim3的预分频值为7199，定时时间为100ms，加计数模式，使能tim3的刷新中断，中断抢占优先级为1，响应优先级为2。\">采用库函数编写通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，中断抢占优先级为1，响应优先级为2。</h4>\n<p>下面是使用库函数编写的通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，并设置中断优先级为抢占优先级1，响应优先级2的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM3初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM3_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM3的时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置定时器TIM3</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Period = <span class=\"number\">9999</span>;  <span class=\"comment\">// 计数器自动重装值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Prescaler = <span class=\"number\">7199</span>;  <span class=\"comment\">// 预分频值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class=\"comment\">// 加计数模式</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  <span class=\"comment\">// 时钟分频</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_RepetitionCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置TIM3的更新中断</span></span><br><span class=\"line\">    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x01</span>;  <span class=\"comment\">// 抢占优先级为1</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x02</span>;         <span class=\"comment\">// 响应优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能定时器TIM3</span></span><br><span class=\"line\">    TIM_Cmd(TIM3, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM3中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM3_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在此处理定时器中断相关的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，以上代码只是TIM3定时器的初始化和中断处理部分，你还需要在主函数中调用<code>TIM3_Init()</code>函数进行初始化，并启用全局中断。</p>\n<h4 id=\"补充-: 计算tim_timebasestructuretim_period(计数器自动重装载值)\">补充 : 计算TIM_TimeBaseStructure.TIM_Period(计数器自动重装载值)</h4>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在上个案例中，`TIM<span class=\"built_in\">_</span>TimeBaseStructure.TIM<span class=\"built_in\">_</span>Period`的值设置为9999，是为了实现100ms的定时时间。</span><br><span class=\"line\"></span><br><span class=\"line\">定时器的计数器值会在0到TIM<span class=\"built_in\">_</span>Period之间循环计数，当计数器达到TIM<span class=\"built_in\">_</span>Period时，就会产生更新事件（溢出），并触发中断（如果使能了中断）。因此，定时器的定时时间可以通过设置TIM<span class=\"built_in\">_</span>Period的值来控制。</span><br><span class=\"line\"></span><br><span class=\"line\">在STM32F103微控制器中，定时器的计数器位数是16位，因此最大计数值为65535。要计算TIM<span class=\"built_in\">_</span>Period的值以实现100ms的定时，可以使用以下公式：</span><br><span class=\"line\"></span><br><span class=\"line\">TIM<span class=\"built_in\">_</span>Period = (定时时间 / 计数周期) - 1</span><br><span class=\"line\"></span><br><span class=\"line\">其中，定时时间是以秒为单位，计数周期是定时器的预分频值与定时器时钟频率之间的比例关系。在这个案例中，预分频值为7199（`TIM<span class=\"built_in\">_</span>TimeBaseStructure.TIM<span class=\"built_in\">_</span>Prescaler = 7199`），定时器时钟频率为72 MHz。</span><br><span class=\"line\"></span><br><span class=\"line\">计算过程如下：</span><br><span class=\"line\"></span><br><span class=\"line\">计数周期 = 预分频值 + 1 = 7199 + 1 = 7200</span><br><span class=\"line\">定时时间 = 0.1 秒（100ms）</span><br><span class=\"line\"></span><br><span class=\"line\">TIM<span class=\"built_in\">_</span>Period = (0.1 / 7200) - 1 = 0.0000138888 - 1 ≈ 1388</span><br><span class=\"line\"></span><br><span class=\"line\">因为TIM<span class=\"built_in\">_</span>Period是一个16位的无符号整数，所以需要确保计算出的值在16位的范围内。在这种情况下，取TIM<span class=\"built_in\">_</span>Period = 1388是一个合适的值，可以实现约100ms的定时。</span><br></pre></td></tr></table></figure>\n<h3 id=\"综合题\">综合题</h3>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pc3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示\">采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示</h4>\n<p>题目<br>\n采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示。要求：<br>\n（1）写出按键外部中断初始化代码，初始化为上升沿触发中断。<br>\n（2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。<br>\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。</p>\n<p>下面是针对上述要求的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_exti.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义按键引脚和外部中断线</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PIN GPIO_Pin_3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PORT GPIOC</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_EXTI_LINE EXTI_Line3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义串口2引脚和相关参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_PIN GPIO_Pin_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_RX_PIN GPIO_Pin_3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_PORT GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART USART2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量，记录按键次数</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> buttonPressCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化外部中断</span></span><br><span class=\"line\">    EXTI_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口2</span></span><br><span class=\"line\">    USART_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主循环中不需要做其他操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （1）写出按键外部中断初始化代码，初始化为上升沿触发中断。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置按键引脚为输入模式</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class=\"comment\">// 上拉输入</span></span><br><span class=\"line\">    GPIO_Init(BUTTON_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接外部中断线到按键引脚</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线为上升沿触发中断</span></span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; <span class=\"comment\">// 上升沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能外部中断通道</span></span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>; <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x03</span>;        <span class=\"comment\">// 响应优先级为3</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOA时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART2时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART引脚为复用功能</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class=\"comment\">// 复用推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(USART_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = <span class=\"number\">19200</span>;</span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Tx; <span class=\"comment\">// 仅发送模式</span></span><br><span class=\"line\">    USART_Init(USART, &amp;USART_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART</span></span><br><span class=\"line\">    USART_Cmd(USART, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI3_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查按键外部中断是否发生</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间，防止抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 记录按键次数</span></span><br><span class=\"line\">        buttonPressCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送按键次数到串口</span></span><br><span class=\"line\">        <span class=\"type\">char</span> countStr[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(countStr, <span class=\"string\">&quot;Press count: %lu\\r\\n&quot;</span>, buttonPressCount);</span><br><span class=\"line\">        USART_SendDataString((<span class=\"type\">uint8_t</span>*)countStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        USART_SendData(USART, *data++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对PC3按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口2将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为上升沿触发中断，串口2被初始化为波特率为19200bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口2发送出去。</p>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pe2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示\">采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示</h4>\n<p>题目 :</p>\n<p>采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示。要求：</p>\n<p>（1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。<br>\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。<br>\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。</p>\n<p>下面是针对上述要求的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_exti.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义按键引脚和外部中断线</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PIN GPIO_Pin_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PORT GPIOE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_EXTI_LINE EXTI_Line2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义串口1引脚和相关参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_PIN GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_RX_PIN GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_PORT GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART USART1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量，记录按键次数</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> buttonPressCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化外部中断</span></span><br><span class=\"line\">    EXTI_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口1</span></span><br><span class=\"line\">    USART_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主循环中不需要做其他操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOE时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置按键引脚为输入模式</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; <span class=\"comment\">// 下拉输入</span></span><br><span class=\"line\">    GPIO_Init(BUTTON_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接外部中断线到按键引脚</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线为下降沿触发中断</span></span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; <span class=\"comment\">// 下降沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能外部中断通道</span></span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>; <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x03</span>;        <span class=\"comment\">// 响应优先级为3</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOA时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART1时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART引脚为复用功能</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class=\"comment\">// 复用推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(USART_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = <span class=\"number\">9600</span>;</span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Tx; <span class=\"comment\">// 仅发送模式</span></span><br><span class=\"line\">    USART_Init(USART, &amp;USART_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART</span></span><br><span class=\"line\">    USART_Cmd(USART, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查按键外部中断是否发生</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间，防止抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 记录按键次数</span></span><br><span class=\"line\">        buttonPressCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送按键次数到串口</span></span><br><span class=\"line\">        <span class=\"type\">char</span> countStr[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(countStr, <span class=\"string\">&quot;Press count: %lu\\r\\n&quot;</span>, buttonPressCount);</span><br><span class=\"line\">        USART_SendDataString((<span class=\"type\">uint8_t</span>*)countStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        USART_SendData(USART, *data++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对PE2按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口1将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为下降沿触发中断，串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口1发送出去。</p>\n<h4 id=\"采用库函数编写程序，实现定时器tim2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示\">采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示</h4>\n<p>采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示。要求：</p>\n<p>（1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。<br>\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。<br>\n（3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。</p>\n<p>下面是针对上述要求的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_tim.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义串口1引脚和相关参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_PIN GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_RX_PIN GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_PORT GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART USART1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义定时器TIM2参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TIM_PERIOD 7199</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TIM_PRESCALER 7199</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量，记录中断次数计数值</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">uint8_t</span> interruptCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化定时器TIM2</span></span><br><span class=\"line\">    TIM2_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口1</span></span><br><span class=\"line\">    USART_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主循环中不需要做其他操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM2时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化TIM2参数</span></span><br><span class=\"line\">    TIM_TimeBaseInitTypeDef TIM_InitStructure;</span><br><span class=\"line\">    TIM_InitStructure.TIM_Period = TIM_PERIOD;</span><br><span class=\"line\">    TIM_InitStructure.TIM_Prescaler = TIM_PRESCALER;</span><br><span class=\"line\">    TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class=\"line\">    TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class=\"line\">    TIM_InitStructure.TIM_RepetitionCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TIM_TimeBaseInit(TIM2, &amp;TIM_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置TIM2中断优先级</span></span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>; <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x02</span>;        <span class=\"comment\">// 响应优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM2更新中断</span></span><br><span class=\"line\">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动定时器TIM2</span></span><br><span class=\"line\">    TIM_Cmd(TIM2, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOA时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART1时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART引脚为复用功能</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class=\"comment\">// 复用推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(USART_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART参数</span></span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = <span class=\"number\">9600</span>;</span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Tx; <span class=\"comment\">// 仅</span></span><br><span class=\"line\"></span><br><span class=\"line\">发送模式</span><br><span class=\"line\">    USART_Init(USART, &amp;USART_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART</span></span><br><span class=\"line\">    USART_Cmd(USART, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        USART_SendData(USART, *data++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查TIM2更新中断是否发生</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间，防止按键抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 增加中断次数计数值</span></span><br><span class=\"line\">        interruptCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送中断次数到串口</span></span><br><span class=\"line\">        <span class=\"type\">char</span> countStr[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(countStr, <span class=\"string\">&quot;Interrupt count: %d\\r\\n&quot;</span>, interruptCount);</span><br><span class=\"line\">        USART_SendDataString((<span class=\"type\">uint8_t</span>*)countStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对PE2按键的外部中断响应，每次中断发生时会记录中断次数计数值，并通过串口1将其发送给上位机的串口助手进行显示。定时器TIM2被初始化为定时1s，通过中断实现定时功能。串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。在TIM2的中断服务函数中，会进行一段延时以防止按键抖动，然后记录中断次数计数值并通过串口1发送出去。</p>\n<h2 id=\"程序分析\">程序分析</h2>\n<h3 id=\"题一\">题一</h3>\n<p>基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BSPInit();</span><br><span class=\"line\">    OSInit();</span><br><span class=\"line\">    OSTaskCreate(TaskLED,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskLEDStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">9</span>); </span><br><span class=\"line\">\tOSTaskCreate(TaskKEY,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskKEYStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">10</span>);</span><br><span class=\"line\">    OSStart();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskLED</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>            <span class=\"comment\">//LED控制任务</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    INT8U err;</span><br><span class=\"line\">    sem01 = OSSemCreate(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OSSemPend(sem01,<span class=\"number\">0</span>,&amp;err);\t</span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDON);             </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>); </span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDOFF);            </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskKEY</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>         <span class=\"comment\">//按键检测任务</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(KEY1!=<span class=\"number\">0</span>)\t          </span><br><span class=\"line\">           &#123;  OSTimeDly(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">\t   OSSemPost(sem01);\t\t\t\t        </span><br><span class=\"line\">\t   <span class=\"keyword\">while</span>(KEY1==<span class=\"number\">0</span>)\t</span><br><span class=\"line\">           &#123; OSTimeDly(<span class=\"number\">1</span>); &#125;   </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回答下面问题：<br>\n（1）程序中任务TaskLED和TaskKEY的优先级是多少？其中优先级较高的是哪个任务?<br>\n（2）程序中任务TaskLED和TaskKEY之间采用了哪种事件通信机制？采用该事件实现的功能是资源同步还是行为同步？<br>\n（3）任务TaskLED调用OSSemPend(sem,0,&amp;err)函数后，将进入哪种状态？满足什么条件后退出该状态？</p>\n<p>(1) 程序中任务TaskLED的优先级为9，任务TaskKEY的优先级为10。优先级较高的任务是TaskKEY。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过OSTaskCreate() 的最后一个参数判断优先级</span></span><br><span class=\"line\">OSTaskCreate(TaskLED,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskLEDStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">9</span>); <span class=\"comment\">// TaskLED 优先级为9</span></span><br><span class=\"line\">OSTaskCreate(TaskKEY,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskKEYStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">10</span>); <span class=\"comment\">// TaskKEY 优先级为10</span></span><br></pre></td></tr></table></figure>\n<p>(2) 程序中任务TaskLED和TaskKEY之间采用了信号量（sem01）作为事件通信机制。该事件实现的功能是资源同步，用于TaskKEY任务向TaskLED任务发出信号。</p>\n<p>程序中使用了信号量sem01作为事件通信机制。TaskKEY任务通过OSSemPost()函数向sem01信号量发出信号，而TaskLED任务通过OSSemPend()函数等待sem01信号量的触发。这种事件通信机制用于任务之间的同步操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskLED</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>            <span class=\"comment\">//LED控制任务</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    INT8U err;</span><br><span class=\"line\">    sem01 = OSSemCreate(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OSSemPend(sem01,<span class=\"number\">0</span>,&amp;err); <span class=\"comment\">// TaskLED 通过 OSSemPend() 等待 sem01 信号量的触发</span></span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDON);             </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>); </span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDOFF);            </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskKEY</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>         <span class=\"comment\">//按键检测任务</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(KEY1!=<span class=\"number\">0</span>)\t          </span><br><span class=\"line\">           &#123;  OSTimeDly(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">\t   OSSemPost(sem01); <span class=\"comment\">// TaskKEY 通过 OSSemPost() 向 sem01 信号量发出信号</span></span><br><span class=\"line\">\t   <span class=\"keyword\">while</span>(KEY1==<span class=\"number\">0</span>)\t</span><br><span class=\"line\">           &#123; OSTimeDly(<span class=\"number\">1</span>); &#125;   </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(3) 任务TaskLED调用OSSemPend(sem, 0, &amp;err)函数后，将进入等待状态（阻塞状态）。TaskLED任务将等待sem01信号量的触发，即等待TaskKEY任务通过OSSemPost()函数释放sem01信号量。当TaskKEY任务调用OSSemPost()函数释放sem01信号量后，TaskLED任务会退出等待状态，并开始执行LED控制代码。</p>\n<p>分析</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 当TaskLED任务调用OSSemPend(sem01, 0, <span class=\"built_in\">&amp;</span>err)函数后，将进入等待状态（阻塞状态）。该函数的第二个参数为0，表示如果sem01信号量当前不可用，则任务会被阻塞而进入等待状态。任务会一直等待，直到sem01信号量可用或超时（在此情况下不会超时，因为第二个参数为0）。</span><br><span class=\"line\"></span><br><span class=\"line\">满足以下条件之一后，TaskLED任务将退出等待状态：</span><br><span class=\"line\"></span><br><span class=\"line\">    当TaskKEY任务调用OSSemPost()函数释放sem01信号量时，TaskLED任务会检测到sem01信号量可用，从而退出等待状态。</span><br><span class=\"line\">    如果TaskLED任务的阻塞期间发生了其他中断或事件，导致任务切换，则当TaskLED任务再次运行时，会重新检查sem01信号量的可用性，并根据情况决定是否退出等待状态。</span><br></pre></td></tr></table></figure>\n<h3 id=\"题二\">题二</h3>\n<p>基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main（<span class=\"type\">void</span>）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">OSInit();</span><br><span class=\"line\">OSTaskCreate(task1, (<span class=\"type\">void</span> *)<span class=\"number\">0</span>, &amp;task1Stk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">12</span> );</span><br><span class=\"line\">OSTaskCreate(task2, (<span class=\"type\">void</span> *)<span class=\"number\">0</span>, &amp;task2Stk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">9</span> );</span><br><span class=\"line\">OSTaskCreate(task3, (<span class=\"type\">void</span> *)<span class=\"number\">0</span>, &amp;task3Stk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">6</span>);</span><br><span class=\"line\">OSStart();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> task1（）</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">ClearScreen();                    <span class=\"comment\">//LCD清屏</span></span><br><span class=\"line\">LCD_Printf(“ task1 \\n”);            <span class=\"comment\">//LCD显示字符串 </span></span><br><span class=\"line\">OSTimeDly(<span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> task2（）</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">ClearScreen();</span><br><span class=\"line\">LCD_Printf(“ task2 \\n”);            <span class=\"comment\">//LCD显示字符串</span></span><br><span class=\"line\">OSTimeDly(<span class=\"number\">300</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> task3（）</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">ClearScreen();</span><br><span class=\"line\">LCD_Printf(“ task3 \\n”);            <span class=\"comment\">//LCD显示字符串</span></span><br><span class=\"line\">OSTimeDly(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回答下面问题：<br>\n（1）程序中三个任务task1、task2、task3的优先级分别为什么，其中优先级最高的是哪个任务？         。<br>\n（2）uC/OS-II操作系统中，按照任务的执行方式可分为哪几种类型？本程序中任务task1、task2、task3属于其中哪一种？<br>\n（3）uC/OS-II操作系统中，任务有哪几种状态？本程序中任务调用OSTimeDly( )函数后，将进入哪种状态？<br>\n（4）在LCD上的显示结果为：<br>\n第一次：                  \t      第二次：                  \t<br>\n第三次：                  \t      第四次：                  \t<br>\n第五次：                  \t      第六次：</p>\n<p>(1) 程序中三个任务task1、task2、task3的优先级分别为：12、9、6。优先级数值越小，优先级越高。因此，优先级最高的任务是task3。</p>\n<p>(2) uC/OS-II操作系统中，按照任务的执行方式可分为两种类型：抢占式任务和非抢占式任务。本程序中的任务task1、task2、task3属于非抢占式任务，因为它们在任务执行期间不会被其他优先级更高的任务打断。</p>\n<p>(3) uC/OS-II操作系统中，任务有四种状态：就绪状态（READY）、运行状态（RUNNING）、阻塞状态（BLOCKED）和挂起状态（SUSPENDED）。本程序中，任务调用OSTimeDly()函数后，任务将进入阻塞状态。OSTimeDly()函数会使任务延迟一段指定的时间，任务在此期间将处于阻塞状态，不会被调度执行。</p>\n<p>(4) 在LCD上的显示结果为：<br>\n第一次： task1                   \t  第二次： task2<br>\n第三次： task3                   \t  第四次： task1<br>\n第五次： task2                   \t  第六次： task3</p>\n<p>分析</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据程序的执行逻辑，任务task1、task2、task3依次执行，每个任务都会先清屏，然后在LCD上显示对应的任务名，并通过OSTimeDly()函数延迟一定时间。因此，首次执行时LCD上会显示&quot;task1&quot;，然后延迟200个时钟节拍，接着显示&quot;task2&quot;，再延迟300个时钟节拍，最后显示&quot;task3&quot;，再延迟500个时钟节拍。之后，任务会不断循环执行，按照相同的顺序在LCD上显示任务名，并延迟指定的时间。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"填空\">填空</h2>\n<h3 id=\"嵌入式系统概念填空\">嵌入式系统概念填空</h3>\n<ol>\n<li>嵌入式系统是以<strong>应用系统</strong>为中心，以<strong>计算机为基础</strong>，<strong>软硬件可裁剪</strong>，<s>适应应用系统对功能、可靠性、成本、体积、功耗严格要求</s>的<strong>专用</strong>计算机系统。</li>\n<li>ARM处理器是ARM公司设计的基于RISC架构的<strong>32位</strong>高性能微处理器，一般采用<strong>哈佛</strong>总线结构，具有高速指令缓存和数据缓存，指令长度固定且多级流水线执行。</li>\n</ol>\n<h3 id=\"工作频率填空\">工作频率填空</h3>\n<ol>\n<li>Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，<strong>APB1总线的最高工作频率为36MHz。</strong></li>\n<li>Cortex-M3内核CPU通过总线阵列和高性能总线（AHB）以及AHB-APB总线桥与两类APB总线相连接，即APB1总线和APB2总线，<strong>APB2总线的最高工作频率为72MHz。</strong></li>\n<li>Cortex-M3<strong>内核的最高工作时钟频率为72MHz。</strong></li>\n</ol>\n<h3 id=\"时钟填空\">时钟填空</h3>\n<ol>\n<li>32F103的系统时钟SYSCLK可以来自**HSI（内部高速时钟）、HSE（外部高速时钟）和PLL（锁相环）**三个时钟源中的一个。</li>\n<li>当STM32F103外接8MHz的晶体时，若使内核达到最高工作时钟频率，PLL的倍频系数应设置为9倍。</li>\n<li>STM32F103外接的<strong>32768Hz晶体主要用来为芯片内部的RTC部件提供时钟源。</strong></li>\n</ol>\n<p>PLL倍频系数的设置</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算步骤如下：</span><br><span class=\"line\">系统时钟SYSCLK = (输入时钟频率) × (PLL倍频系数)</span><br><span class=\"line\">72 MHz = 8 MHz × 9</span><br><span class=\"line\">因此，PLL的倍频系数应设置为9倍</span><br></pre></td></tr></table></figure>\n<h3 id=\"存储器填空\">存储器填空</h3>\n<ol>\n<li>STM32F103芯片是<strong>32位</strong>的微控制器，<strong>可寻址存储空间的大小为4GB。</strong></li>\n<li>STM32F103芯片可寻址存储空间的大小为 4GB，分为 8个512MB的存储块。</li>\n<li>当BOOT0 = 0时，STM32F103上电后，用户程序将从Flash存储器启动。</li>\n</ol>\n<h3 id=\"gpio填空\">GPIO填空</h3>\n<ol>\n<li>STM32F103ZET6芯片包含<strong>7 个16位</strong>的通用目的输入/输出口（GPIO）。。</li>\n<li>STM32F103ZET6芯片共有<strong>112根GPIO引脚</strong>，可从其中<strong>任选16根</strong>作为外部中断输入口。</li>\n</ol>\n<h3 id=\"中断填空\">中断填空</h3>\n<ol>\n<li>STM32F103微控制器具有<strong>10个异常和60个中断</strong>，<strong>中断优先级为16 级</strong>。</li>\n<li>STM32F103微控制器的EXTI模块有<strong>16个连接GPIO的外部中断线</strong>，对应<strong>16个外部中断向量</strong>。</li>\n<li>STM32F103微控制器共<strong>有3个串口</strong>，其中<strong>USART1的工作时钟源来自于APB2总线</strong> 。</li>\n<li>STM32F103微控制器共有<strong>3个串口</strong>，其中<strong>USART2的工作时钟源来自于APB1总线</strong> 。</li>\n</ol>\n<h3 id=\"adc填空\">ADC填空</h3>\n<ol>\n<li>STM32F103微控制器的ADC模块<strong>支持单次和连续转换模式</strong>。</li>\n<li>STM32F103微控制器的ADC模块<strong>分辨率为12位</strong>，<strong>最小转换时间为1.17微妙</strong></li>\n<li>STM32F103的ADC1有16个外部模拟输入通道，<strong>分辨率为12 位。</strong></li>\n<li>STM32F103的ADC的<strong>分辨率为12位</strong>，<strong>最高转换速率是1MHz</strong></li>\n</ol>\n<h3 id=\"操作系统填空\">操作系统填空</h3>\n<ol>\n<li>嵌入式操作系统根据各个任务的要求，进行内存管理、多任务管理、资源管理、任务调度、消息管理和异常处理等工作。</li>\n<li>uC/OS-II操作系统是一个<strong>源代码公开、可移植、可固化、可裁剪、可配置式</strong>的实时多任务操作系统，<strong>最多可支持255个任务</strong>。</li>\n<li>在uC/OS-II操作系统中，通过<strong>互斥信号量</strong>可实现对共享资源的<strong>抢占式访问</strong>。</li>\n</ol>\n<h2 id=\"简答\">简答</h2>\n<h3 id=\"嵌入式系统概念简答\">嵌入式系统概念简答</h3>\n<h4 id=\"从技术角度来说什么是嵌入式系统？8051单片机应用系统是否属于嵌入式系统？\">从技术角度来说什么是嵌入式系统？8051单片机应用系统是否属于嵌入式系统？</h4>\n<ol>\n<li>嵌入式系统是<strong>以应用系统为中心</strong>，<strong>以计算机为基础</strong>，<strong>软硬件可裁剪</strong>，<s>适应应用系统对功能、可靠性、成本、体积、功耗严格要求</s>的<strong>专用计算机系统</strong></li>\n<li>8051单片机应用系统<strong>可以</strong>被归类为嵌入式系统。</li>\n</ol>\n<h4 id=\"嵌入式实时操作系统中的“实时性”指的是什么？\">嵌入式实时操作系统中的“实时性”指的是什么？</h4>\n<ol>\n<li>实时性是<strong>系统对外部事件的及时响应和任务的及时完成能力。</strong> <em>实时性可以分为硬实时和软实时两种类型。</em></li>\n<li>硬实时要求系统在严格的时间约束下，对外部事件作出及时的响应。<strong>任务的截止时间是固定的，任何超出时间限制的情况都可能导致系统功能失效或系统崩溃。</strong></li>\n<li>软实时要求系统尽可能在特定的时间约束下，对外部事件作出及时的响应，但允许偶尔的违反时间限制。<strong>任务的截止时间相对宽松，系统可以容忍一定程度的任务响应时间超出。</strong></li>\n</ol>\n<h3 id=\"时钟简答\">时钟简答</h3>\n<h4 id=\"stm32f103微控制器的工作时钟源有哪几种？各时钟源的频率范围分别是多少？\">STM32F103微控制器的工作时钟源有哪几种？各时钟源的频率范围分别是多少？</h4>\n<ol>\n<li><strong>HSI（High-Speed Internal）高速内部时钟</strong>：频率为8MHz。</li>\n<li><strong>HSE（High-Speed External）高速外部时钟</strong>：频率范围通常为4MHz至16MHz。</li>\n<li><strong>PLL（Phase-Locked Loop）锁相环时钟</strong>：可以使用HSI或HSE作为输入时钟源，并通过倍频系数进行倍频。具体的频率范围取决于倍频系数的设置。</li>\n</ol>\n<h4 id=\"在stm32f103内部的时钟树中，锁相环pll有什么用途？\">在STM32F103内部的时钟树中，锁相环PLL有什么用途？</h4>\n<ol>\n<li><strong>时钟倍频</strong>：PLL可以将输入时钟频率倍增，提供更高的系统时钟频率。</li>\n<li><strong>稳定时钟源</strong>：PLL可以提供更稳定的时钟源，减小时钟的抖动和波动。</li>\n<li><strong>系统时钟源</strong>：在STM32F103中，PLL经常被配置为系统时钟源（SYSCLK），即整个微控制器系统的主要时钟源。</li>\n</ol>\n<h4 id=\"嵌入式系统中的启动代码（startup_stm32f10x_hds）程序的功能是什么？\">嵌入式系统中的启动代码（startup_stm32f10x_hd.s）程序的功能是什么？</h4>\n<ol>\n<li><strong>初始化向量表</strong>：启动代码会定义和初始化微控制器的向量表，其中包含了中断处理函数的入口地址。向量表的初始化是确保中断处理能够正确触发和执行的重要步骤。</li>\n<li><strong>初始化堆栈和堆栈指针</strong>：启动代码会设置初始堆栈指针，指向程序的堆栈空间。这是确保函数调用和中断处理正常工作的必要步骤。</li>\n<li><strong>初始化系统时钟</strong>：启动代码会进行系统时钟的初始化，包括配置时钟源、设置时钟分频器等操作，以确保系统在正确的时钟频率下运行。</li>\n<li><strong>初始化存储器和外设</strong>：启动代码可能包括对存储器和外设的初始化操作，例如设置存储器映射、配置外设寄存器等。</li>\n<li><strong>调用主函数</strong>：启动代码最终会调用应用程序的主函数（如<code>main</code>函数），使应用程序正式开始执行。</li>\n</ol>\n<h4 id=\"stm32f103微控制器的最小系统由哪几部分构成？\">STM32F103微控制器的最小系统由哪几部分构成？</h4>\n<ol>\n<li><strong>STM32F103微控制器芯片</strong>：这是系统的核心部分，包含了CPU、存储器、外设等功能模块。</li>\n<li><strong>时钟源</strong>：最小系统需要提供适当的时钟源，以驱动微控制器的各个部分。常见的时钟源包括晶体振荡器、外部时钟源或者内部时钟源。</li>\n<li><strong>复位电路</strong>：复位电路用于在系统上电或者复位时将微控制器置于初始状态。它通常由复位按钮、电容和电阻等组成。</li>\n<li><strong>电源管理电路</strong>：为STM32F103微控制器提供稳定的电源供应，并对电源进行滤波和保护。这包括电源连接器、电源滤波电容、稳压器等。</li>\n<li><strong>外部连接器</strong>：用于与外部设备或外部电路进行连接，包括通信接口（如UART、SPI、I2C）、GPIO引脚、ADC输入等。</li>\n</ol>\n<h4 id=\"stm32f103微控制器有哪几种启动模式？如何来配置系统启动模式？\">STM32F103微控制器有哪几种启动模式？如何来配置系统启动模式？</h4>\n<ol>\n<li><strong>主启动模式（Main Boot Mode）</strong>：在主启动模式下，微控制器从FLASH存储器的起始地址处开始执行代码。</li>\n<li><strong>系统存储器模式（System Memory Boot Mode）</strong>：在系统存储器模式下，微控制器从内部的系统存储器（一般为ROM或者Flash）的起始地址处开始执行代码。</li>\n<li><strong>内存模式（RAM Boot Mode）</strong>：在内存模式下，微控制器从系统RAM中的特定地址处开始执行代码。</li>\n</ol>\n<p>系统启动模式的配置是通过BOOT pins（BOOT0和BOOT1）的状态来实现的。这些引脚通常通过跳线帽或者外部电平转换器与微控制器连接。</p>\n<p>具体的配置方式如下：</p>\n<ul>\n<li>如果BOOT0引脚为高电平，那么微控制器将进入内存模式。</li>\n<li>如果BOOT0引脚为低电平（接地），那么微控制器将根据BOOT1引脚的状态来选择启动模式。\n<ul>\n<li>如果BOOT1引脚也为低电平，那么微控制器将进入主启动模式。</li>\n<li>如果BOOT1引脚为高电平，那么微控制器将进入系统存储器模式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存储器简答\">存储器简答</h3>\n<h4 id=\"什么是存储器重映射？stm32f103微控制器的哪些存储区域需要进行存储器重映射？\">什么是存储器重映射？STM32F103微控制器的哪些存储区域需要进行存储器重映射？</h4>\n<p>存储器重映射<strong>是指将某些存储器区域的物理地址重新映射到不同的逻辑地址的过程。</strong></p>\n<p>在STM32F103微控制器中，存储器重映射主要涉及以下两个存储区域：</p>\n<ol>\n<li>\n<p><strong>系统存储器（System Memory）</strong>：系统存储器包含了微控制器的启动代码和ROM固件库。在存储器重映射时，系统存储器的物理地址将被映射到内部的ROM或者Flash存储器的起始地址，使得系统可以从内部存储器中执行代码。</p>\n</li>\n<li>\n<p><strong>外部SRAM（External SRAM）</strong>：STM32F103微控制器具有一些器件型号支持外部SRAM的扩展。在存储器重映射时，外部SRAM的物理地址可以被映射到微控制器的内部存储器的地址空间中，使得外部SRAM可以像内部存储器一样被访问和使用。</p>\n</li>\n</ol>\n<h3 id=\"中断简答\">中断简答</h3>\n<h4 id=\"stm32f103微控制器的异常和中断有什么区别？优先级最高的是哪个异常/中断？\">STM32F103微控制器的异常和中断有什么区别？优先级最高的是哪个异常/中断？</h4>\n<p>在STM32F103微控制器中，异常和中断是两种不同的事件处理机制，它们有以下区别：</p>\n<ol>\n<li>\n<p><strong>异常（Exception）</strong>：异常是指<strong>由于指令执行或系统事件引起的处理器中断。它们通常表示了一些严重的错误或特殊情况，需要立即处理。</strong><s>异常包括复位、非屏蔽中断（如硬件故障）、系统调试异常等。异常的处理优先级高于中断。</s></p>\n</li>\n<li>\n<p><strong>中断（Interrupt）</strong>：中断是指<strong>外部设备或特定事件触发的处理器中断。它们通常表示了一些需要优先处理的异步事件</strong>，如外部输入信号、定时器溢出等。中断可以根据优先级配置，并<strong>可被屏蔽或使能。</strong></p>\n</li>\n</ol>\n<p>在STM32F103微控制器中，优先级最高的异常是**复位（Reset）**异常。复位异常在系统上电或者复位时触发，用于将系统重置到初始状态。它的优先级最高，无法被屏蔽。</p>\n<h3 id=\"gpio简答\">GPIO简答</h3>\n<h4 id=\"stm32f103微控制器的gpio有哪几种工作模式？gpio作按键输入时应选择哪种工作模式？\">STM32F103微控制器的GPIO有哪几种工作模式？GPIO作按键输入时应选择哪种工作模式？</h4>\n<ol>\n<li><strong>输入模式（Input Mode）</strong>：将GPIO配置为输入模式，用于读取外部信号或按键的状态。可以选择不同的输入模式，如<strong>浮空输入、上拉输入和下拉输入</strong>，以适应不同的电路连接方式。</li>\n<li><strong>输出模式（Output Mode）</strong>：将GPIO配置为输出模式，用于控制外部设备或驱动器。输出模式可以选择<strong>推挽输出、开漏输出、推挽输出带上拉或下拉等</strong>。</li>\n<li><strong>复用功能模式（Alternate Function Mode）</strong>：将GPIO配置为复用功能模式，可以使用GPIO引脚来实现其他外设功能，如串口、定时器、SPI等。</li>\n<li><strong>模拟模式（Analog Mode）</strong>：将GPIO配置为模拟模式，用于连接模拟信号输入或输出。</li>\n</ol>\n<p>当GPIO用作按键输入时，应选择<strong>输入模式</strong>。可以根据实际情况选择浮空输入、上拉输入或下拉输入，以确保按键的状态能够正确读取。*浮空输入适用于按键有外部上拉或下拉电阻的情况，上拉输入适用于按键接地时为低电平，下拉输入适用于按键接VCC时为高电平的情况。*具体的选择取决于按键连接电路的设计和要求。</p>\n<h4 id=\"请用端口输出数据寄存器(odr-)，编写控制gpioc口的pc3-pc5引脚输出高电平，其它引脚输出低电平的语句\">请用端口输出数据寄存器(ODR )，编写控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平的语句</h4>\n<p>要使用端口输出数据寄存器（ODR）控制GPIOC口的PC3-PC5引脚输出高电平，其它引脚输出低电平，可以使用以下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOC-&gt;ODR |= GPIO_ODR_ODR3 | GPIO_ODR_ODR4 | GPIO_ODR_ODR5; <span class=\"comment\">// 设置PC3、PC4、PC5引脚为高电平</span></span><br><span class=\"line\">GPIOC-&gt;ODR &amp;= ~(GPIO_ODR_ODR0 | GPIO_ODR_ODR1 | GPIO_ODR_ODR2); <span class=\"comment\">// 设置PC0、PC1、PC2引脚为低电平</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"请用端口置位/清零寄存器(bsrr-)，编写控制gpiob口的pb0-pb5引脚输出高电平，其它引脚保持不变的语句\">请用端口置位/清零寄存器(BSRR )，编写控制GPIOB口的PB0-PB5引脚输出高电平，其它引脚保持不变的语句</h4>\n<p>要使用端口置位/清零寄存器（BSRR）控制GPIOB口的PB0-PB5引脚输出高电平，同时保持其他引脚状态不变，可以使用以下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOB-&gt;BSRR = GPIO_BSRR_BS0 | GPIO_BSRR_BS1 | GPIO_BSRR_BS2 | GPIO_BSRR_BS3 | GPIO_BSRR_BS4 | GPIO_BSRR_BS5; <span class=\"comment\">// 设置PB0-PB5引脚为高电平</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"请用端口清零寄存器(brr-)，编写控制gpiod口的pd0-pd3引脚输出低电平，其它引脚保持不变的语句\">请用端口清零寄存器(BRR )，编写控制GPIOD口的PD0-PD3引脚输出低电平，其它引脚保持不变的语句</h4>\n<p>要使用端口清零寄存器（BRR）控制GPIOD口的PD0-PD3引脚输出低电平，同时保持其他引脚状态不变，可以使用以下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOD-&gt;BRR = GPIO_BRR_BR0 | GPIO_BRR_BR1 | GPIO_BRR_BR2 | GPIO_BRR_BR3; <span class=\"comment\">// 设置PD0-PD3引脚为低电平</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"简述stm32f103微控制器的gpio相关各个寄存器的含义和作用\">简述STM32F103微控制器的GPIO相关各个寄存器的含义和作用</h4>\n<ol>\n<li>GPIO配置寄存器（GPIOx_CRL和GPIOx_CRH）：用于配置GPIO引脚的工作模式、输入/输出类型、输出速度和上下拉等特性。</li>\n<li>端口输入数据寄存器（GPIOx_IDR）：用于读取GPIO引脚的输入状态，包括输入高低电平。</li>\n<li>端口输出数据寄存器（GPIOx_ODR）：用于设置或读取GPIO引脚的输出状态，可以控制引脚的高低电平。</li>\n<li>端口状态寄存器（GPIOx_SR）：用于读取GPIO引脚的状态标志位，包括引脚的输入状态、输出状态和事件状态等。</li>\n<li>端口配置锁定寄存器（GPIOx_LCKR）：用于锁定GPIO引脚的配置，防止误操作修改引脚的配置设置。</li>\n<li>端口复位寄存器（GPIOx_BRR）：用于通过写入引脚位控制寄存器（BRR）的对应位，将GPIO引脚置为低电平，实现引脚的复位操作。</li>\n</ol>\n<h4 id=\"对比分析stm32寄存器编程和库函数编程两种编程方式的特点\">对比分析STM32寄存器编程和库函数编程两种编程方式的特点</h4>\n<ol>\n<li>寄存器编程方式：\n<ul>\n<li>直接操作硬件寄存器：寄存器编程方式直接操作硬件寄存器，能够直接控制硬件的各个功能和特性。</li>\n<li>精确控制：通过寄存器编程可以对硬件进行细粒度的控制，可以灵活地配置和调整各种参数，满足特定的需求。</li>\n<li>低层访问：寄存器编程是对硬件的直接访问，属于底层编程方式，对硬件细节要求较高，需要更多的了解和掌握。</li>\n<li>更高的性能：由于直接操作寄存器，避免了函数调用和库函数的开销，寄存器编程方式可以获得更高的性能和响应速度。</li>\n</ul>\n</li>\n<li>库函数编程方式：\n<ul>\n<li>抽象封装：库函数编程方式通过提供封装好的函数接口，屏蔽了底层的寄存器操作细节，提供了更高层次的抽象。</li>\n<li>简化开发：库函数提供了丰富的功能库，包括GPIO、定时器、串口等模块，简化了开发者的工作，减少了代码量。</li>\n<li>更高的可移植性：库函数编程方式抽象了底层硬件细节，使得代码更具可移植性，可以在不同的芯片和平台上进行移植和复用。</li>\n<li>需要更多的资源：库函数需要占用一定的存储空间，同时运行时需要更多的内存资源，因此对于资源有限的嵌入式系统可能需要权衡。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，寄存器编程方式适用于对硬件控制要求高、对性能要求高的场景，需要更底层的控制和精确配置；而库函数编程方式则适用于快速开发、提高可移植性和简化开发流程的场景。选择哪种编程方式取决于具体的需求和开发环境。</p>\n<h3 id=\"中断\">中断</h3>\n<h4 id=\"简述stm32f103嵌套向量中断控制器（nvic）的作用和特点\">简述STM32F103嵌套向量中断控制器（NVIC）的作用和特点</h4>\n<p>STM32F103嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）是STM32F103微控制器中负责管理和控制中断的重要模块。它的作用是<strong>协调和处理各种中断请求，并根据中断的优先级和状态进行中断服务程序的调度。</strong></p>\n<p>以下是STM32F103 NVIC的主要特点和作用：</p>\n<ol>\n<li>中断优先级管理：NVIC支持对各个中断通道的优先级进行配置和管理。中断通道的优先级可以根据应用需求进行设置，以确保关键的中断能够得到及时响应。</li>\n<li>嵌套中断支持：NVIC支持嵌套中断的处理。当一个中断正在处理时，如果有更高优先级的中断请求到达，NVIC会暂时中断当前中断的处理，优先处理更高优先级的中断请求。这种机制确保了关键中断的实时性和优先级的保障。</li>\n<li>中断向量表：NVIC维护着中断向量表，用于存储中断服务程序的入口地址。每个中断通道都对应着中断向量表中的一个位置，当中断请求到达时，NVIC会根据中断通道找到对应的中断服务程序并执行。</li>\n<li>中断使能和屏蔽：NVIC提供了使能和屏蔽中断的功能。通过设置相应的控制寄存器，可以启用或禁用特定的中断通道，以满足应用的需求。</li>\n<li>中断状态管理：NVIC能够管理中断的状态，包括中断挂起、中断激活和中断标志等。这些状态信息可以帮助开发者更好地管理和调试中断程序。</li>\n</ol>\n<h4 id=\"简述stm32f103的nvic中断优先级分组方法和优先级划分\">简述STM32F103的NVIC中断优先级分组方法和优先级划分</h4>\n<p>STM32F103的NVIC中断优先级分组方法和优先级划分主要通过两个寄存器来配置：<s>NVIC_IPR（Interrupt Priority Register）和NVIC_ISER（Interrupt Set Enable Register）。</s></p>\n<ol>\n<li>中断优先级分组方法：\n<ul>\n<li>STM32F103支持4种中断优先级分组方式，即分为Group 0、Group 1、Group 2和Group 3。不同的分组方式决定了优先级位数的分配。</li>\n<li><s>通过SCB_AIRCR（Application Interrupt and Reset Control Register）寄存器的位[10:8]来配置中断优先级分组方法。</s></li>\n</ul>\n</li>\n<li>优先级划分：\n<ul>\n<li>在STM32F103中，中断的优先级范围是从0（最高优先级）到15（最低优先级）。数字越小，优先级越高。</li>\n<li>根据选择的中断优先级分组方式，优先级位数的分配有所不同。以下是各个分组方式下的优先级划分情况：\n<ul>\n<li>Group 0：全局抢占式优先级分组，优先级分配为4位。</li>\n<li>Group 1：1位抢占式优先级和3位子优先级，优先级分配为3位抢占优先级和1位子优先级。</li>\n<li>Group 2：2位抢占式优先级和2位子优先级，优先级分配为2位抢占优先级和2位子优先级。</li>\n<li>Group 3：3位抢占式优先级和1位子优先级，优先级分配为1位抢占优先级和3位子优先级。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>通过配置NVIC_IPR寄存器，可以为每个中断通道分配相应的抢占式优先级和子优先级。优先级越高的中断在发生时将优先得到处理，而优先级相同的中断将按照先到先服务（FIFO）的顺序进行处理。</p>\n<p>需要注意的是，在STM32F103中，具有相同优先级的中断中，越靠近中断向量表的位置的中断具有更高的优先级。因此，在进行中断优先级划分时，需要根据中断的重要性和实时性要求进行合理的分配。</p>\n<h4 id=\"简述stm32f103的nvic中断优先级分组中抢占优先级和响应优先级的区别\">简述STM32F103的NVIC中断优先级分组中抢占优先级和响应优先级的区别</h4>\n<ol>\n<li>\n<p>抢占优先级（Preemption Priority）：</p>\n<ul>\n<li>抢占优先级指的是中断发生时，当前正在执行的中断能否被其他中断打断。具有较高抢占优先级的中断可以打断正在执行的低优先级中断，优先获得处理器的控制权。</li>\n<li>抢占优先级的数值越小，表示优先级越高，能够打断的中断范围越广。</li>\n</ul>\n</li>\n<li>\n<p>响应优先级（Subpriority）：</p>\n<ul>\n<li>响应优先级指的是在同一抢占优先级下，多个中断同时请求服务时的优先级排序。具有较高响应优先级的中断将首先得到处理器的服务。</li>\n<li>响应优先级的数值越小，表示优先级越高。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"假定设置中断优先级组为2，然后设置：中断3（-rtc 中断）的抢占优先级为2，响应优先级为1；中断6（外部中断0）的抢占优先级为3，响应优先级为0；中断7（外部中断1）的抢占优先级为2，响应优先级为0。写出这3个中断的优先级顺序。\">假定设置中断优先级组为2，然后设置：中断3（ RTC 中断）的抢占优先级为2，响应优先级为1；中断6（外部中断0）的抢占优先级为3，响应优先级为0；中断7（外部中断1）的抢占优先级为2，响应优先级为0。写出这3个中断的优先级顺序。</h4>\n<p>根据您提供的中断优先级设置，结合中断优先级分组为2，可以确定以下中断的优先级顺序：</p>\n<ol>\n<li>中断3（RTC中断）的优先级：抢占优先级 2，响应优先级 1。</li>\n<li>中断6（外部中断0）的优先级：抢占优先级 3，响应优先级 0。</li>\n<li>中断7（外部中断1）的优先级：抢占优先级 2，响应优先级 0。</li>\n</ol>\n<p>根据中断优先级的设置规则：</p>\n<ul>\n<li>具有较高的抢占优先级的中断可以打断正在执行的低优先级中断。</li>\n<li>在相同抢占优先级下，具有较高的响应优先级的中断将首先得到处理器的服务。</li>\n</ul>\n<p>根据上述设置，优先级顺序为：</p>\n<ol>\n<li>中断6（外部中断0）：抢占优先级 3，响应优先级 0。</li>\n<li>中断7（外部中断1）：抢占优先级 2，响应优先级 0。</li>\n<li>中断3（RTC中断）：抢占优先级 2，响应优先级 1。</li>\n</ol>\n<p>因此，中断6（外部中断0）具有最高优先级，中断3（RTC中断）具有次高优先级，中断7（外部中断1）具有最低优先级。</p>\n<h3 id=\"定时器/计数器简答\">定时器/计数器简答</h3>\n<h4 id=\"stm32f103微控制器的常规定时器分为哪3种?\">STM32F103微控制器的常规定时器分为哪3种?</h4>\n<ol>\n<li>TIM1（定时器1）：这是一个高级定时器，具有较复杂的功能和多路输出通道，可用于实现高级的定时和PWM控制。</li>\n<li>TIM2（定时器2）：这是一个通用定时器，具有基本的定时功能，可用于一般的定时和计数应用。</li>\n<li>TIM3（定时器3）：这是一个通用定时器，与TIM2类似，也具有基本的定时和计数功能，可广泛应用于定时和计数需求。</li>\n</ol>\n<h4 id=\"stm32f103微控制器的高级定时器和通用定时器的功能主要有什么区别？\">STM32F103微控制器的高级定时器和通用定时器的功能主要有什么区别？</h4>\n<p>高级定时器（如TIM1）：</p>\n<ol>\n<li>多路输出通道：高级定时器通常具有多个输出通道，可以用于实现更复杂的PWM控制和输出信号。</li>\n<li>高级控制功能：高级定时器提供更多的高级控制功能，如编码器模式、输入捕获、输出比较、PWM生成等，能够满足更复杂的定时和控制需求。</li>\n<li>高精度定时：高级定时器通常具有更高的计数精度和更大的计数范围，可以实现更精确的定时操作。</li>\n</ol>\n<p>通用定时器（如TIM2、TIM3等）：</p>\n<ol>\n<li>基本定时功能：通用定时器提供基本的定时和计数功能，能够满足常见的定时需求。</li>\n<li>灵活性和易用性：通用定时器的配置和使用相对简单，适用于一般的定时和计数应用。</li>\n<li>低功耗模式：通用定时器通常支持低功耗模式，可以在需要时降低功耗，延长电池寿命。</li>\n</ol>\n<p>总体而言，高级定时器具有更多的高级功能和扩展性，适用于复杂的定时和控制需求，而通用定时器则更适用于常见的定时和计数应用，并具有简单易用和低功耗的特点。选择合适的定时器取决于具体的应用需求和功能要求。</p>\n<h4 id=\"stm32f103定时器的计数器模式有哪3种?\">STM32F103定时器的计数器模式有哪3种?</h4>\n<ol>\n<li>向上计数模式（Up Counter Mode）：定时器从0开始计数，逐渐增加，直到计数值达到设定的上限值（比如自动重载值），然后重新从0开始计数。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。</li>\n<li>向下计数模式（Down Counter Mode）：定时器从设定的上限值（比如自动重载值）开始计数，逐渐减小，直到计数值为0。在该模式下，定时器的输出信号可以用于生成定时中断或驱动其他外设。</li>\n<li>中央对齐模式（Center-aligned Mode）：定时器在向上计数和向下计数之间来回切换，计数器值会在自动重载值的一半处反向。这种模式下的计数器可以产生对称的波形，对于一些特定的应用场景如PWM输出很有用。</li>\n</ol>\n<h3 id=\"adc简答\">ADC简答</h3>\n<h4 id=\"简述stm32f103的adc规则通道组和注入通道组之间的关系\">简述STM32F103的ADC规则通道组和注入通道组之间的关系</h4>\n<p>**规则通道组是用于常规的模数转换，它可以配置多个通道进行连续的模数转换。**规则通道组的转换顺序可以根据需要进行设置，可以按照顺序依次转换多个通道的模拟输入信号。</p>\n<p><strong>注入通道组则是用于特定的应用场景，如精确的采样或触发转换。注入通道组可以单独配置一个或多个通道进行模数转换</strong>，并且可以使用特定的触发源来触发转换。</p>\n<p>规则通道组和注入通道组之间是相互独立的，它们有各自独立的转换序列和设置。在配置时，可以选择使用规则通道组、注入通道组或两者同时使用，以满足不同的应用需求。</p>\n<p>总结而言，规则通道组和注入通道组是用于不同的模数转换应用场景的两种通道组，可以根据具体需求配置和使用。</p>\n<h3 id=\"串口简答\">串口简答</h3>\n<h4 id=\"简述如何判断stm32f103的串口是否完成数据发送和接收\">简述如何判断STM32F103的串口是否完成数据发送和接收</h4>\n<ol>\n<li>发送完成标志位（TXE）：通过读取串口状态寄存器（SR）中的TXE标志位来判断是否完成数据发送。当TXE标志位为1时，表示发送缓冲器为空，可以继续发送数据；当TXE标志位为0时，表示发送缓冲器正在发送数据，还未完成发送。</li>\n<li>数据接收完成标志位（RXNE）：通过读取串口状态寄存器（SR）中的RXNE标志位来判断是否完成数据接收。当RXNE标志位为1时，表示接收缓冲器中已有接收到的数据，可以读取；当RXNE标志位为0时，表示接收缓冲器为空，还未有新的数据接收。</li>\n</ol>\n<p>可以使用相关的寄存器和标志位来进行判断，具体操作如下：</p>\n<ol>\n<li>判断发送完成：<strong>通过检查USART_SR寄存器中的TXE标志位，当TXE为1时，表示发送完成。</strong></li>\n<li>判断数据接收完成：<strong>通过检查USART_SR寄存器中的RXNE标志位，当RXNE为1时，表示数据接收完成。</strong></li>\n</ol>\n<h4 id=\"串行通信分为异步通信和同步通信，简述异步通信和同步通信的区别\">串行通信分为异步通信和同步通信，简述异步通信和同步通信的区别</h4>\n<p>异步通信和同步通信是两种不同的串行通信方式，它们的区别在于<em>数据传输的时钟信号的处理方式和数据帧的组织方式。</em></p>\n<p>异步通信：</p>\n<ul>\n<li>异步通信<strong>使用两个信号线，分别是数据线（TXD和RXD）和单个的时钟信号线（通常为波特率时钟）。</strong></li>\n<li>数据的传输是基于起始位、数据位、奇偶校验位和停止位构成的数据帧进行的。<strong>每个数据帧之间没有固定的时间间隔。</strong></li>\n<li><strong>发送端和接收端的时钟频率可以略有差异</strong>，因此需要在接收端通过起始位的边沿检测来同步数据。</li>\n<li>异步通信<strong>适用于短距离和低速率的通信</strong>，例如串口通信。</li>\n</ul>\n<p>同步通信：</p>\n<ul>\n<li>同步通信<strong>使用单独的时钟信号线来同步数据的传输</strong>，也称为时钟同步通信。</li>\n<li>数据的传输是基于固定的时钟信号来同步发送和接收的。数据被切分成多个连续的数据帧，<strong>每个数据帧的长度和时钟信号的周期相对应。</strong></li>\n<li><strong>发送端和接收端的时钟频率必须保持一致</strong>，以确保数据的正确接收。</li>\n<li>同步通信<strong>适用于高速率和长距离的通信</strong>，例如以太网通信和SPI通信。</li>\n</ul>\n<p>总结：<br>\n异步通信和同步通信的主要区别在于时钟信号的处理方式和数据帧的组织方式。<br>\n<strong>异步通信使用单个时钟信号和数据帧的起始位、数据位、奇偶校验位和停止位进行数据传输，而同步通信则使用单独的时钟信号来同步数据的传输，数据被切分成连续的数据帧并通过固定的时钟信号周期来同步发送和接收。</strong></p>\n<h3 id=\"操作系统简答\">操作系统简答</h3>\n<h4 id=\"uc/os-ii操作系统中，信号量和互斥信号量在功能上的主要区别是什么？\">uC/OS-II操作系统中，信号量和互斥信号量在功能上的主要区别是什么？</h4>\n<ol>\n<li>信号量（Semaphore）：\n<ul>\n<li>信号量是一种<strong>用于控制对资源的访问的机制，可以用来表示可用资源的数量。</strong></li>\n<li>信号量可以实现资源的共享和同步，<strong>允许多个任务对同一资源进行访问。</strong></li>\n<li>信号量有两种类型：<strong>二进制信号量和计数信号量。</strong></li>\n<li><em>二进制信号量的值只能为0或1，用于实现互斥访问，即只允许一个任务访问资源。</em></li>\n<li><em>计数信号量的值可以是任意非负整数，用于表示可用资源的数量。</em></li>\n<li>任务可以<strong>通过等待信号量来获取资源</strong>，<em>如果资源不可用，则任务会被阻塞，直到资源可用为止。</em></li>\n</ul>\n</li>\n<li>互斥信号量（Mutex）：\n<ul>\n<li>互斥信号量是一种<strong>特殊的信号量，用于实现互斥访问共享资源。</strong></li>\n<li>互斥信号量可以<strong>保证同一时间只有一个任务可以访问共享资源</strong>，避免了多个任务同时访问导致的数据竞争和冲突。</li>\n<li>互斥信号量<em>在任务访问共享资源之前需要进行获取（P操作），在任务使用完资源后需要进行释放（V操作）。</em></li>\n<li>如果互斥信号量已经被一个任务获取，<em>其他任务尝试获取该互斥信号量时会被阻塞，直到互斥信号量被释放。</em></li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<p>信号量用于控制对资源的访问，可以实现资源的共享和同步；</p>\n<p>而互斥信号量是一种特殊的信号量，用于实现互斥访问共享资源，确保同一时间只有一个任务可以访问共享资源。</p>\n<p>互斥信号量是信号量的一种特殊形式，用于解决共享资源的互斥访问问题。</p>\n<h4 id=\"uc/os-ii操作系统中，信号量和消息邮箱在功能上的主要区别是什么？\">uC/OS-II操作系统中，信号量和消息邮箱在功能上的主要区别是什么？</h4>\n<ol>\n<li>信号量（Semaphore）：\n<ul>\n<li>信号量用于控制对资源的访问和同步任务的执行顺序。</li>\n<li>信号量可以表示可用资源的数量，任务可以通过等待信号量来获取资源，如果资源不可用，则任务会被阻塞，直到资源可用为止。</li>\n<li>信号量的值可以是任意非负整数，可以用来表示资源的数量或者某种条件的满足情况。</li>\n<li>信号量可以用于实现资源的共享和同步，多个任务可以同时等待和释放同一个信号量。</li>\n</ul>\n</li>\n<li>消息邮箱（Message Mailbox）：\n<ul>\n<li>消息邮箱用于在任务之间传递消息和数据。</li>\n<li>消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。</li>\n<li>任务可以通过发送消息到邮箱来向其他任务传递数据，也可以通过接收消息来获取其他任务发送的数据。</li>\n<li>消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<p><strong>信号量用于控制资源的访问和同步任务的执行顺序，多个任务可以同时等待和释放同一个信号量；而消息邮箱用于在任务之间传递消息和数据，具有缓冲区的功能，可以存储多个消息。信号量更适用于控制资源的共享和同步，而消息邮箱更适用于任务间的数据传递和通信。</strong></p>\n<h4 id=\"uc/os-ii操作系统中，消息邮箱和消息队列在功能上的主要区别是什么？\">uC/OS-II操作系统中，消息邮箱和消息队列在功能上的主要区别是什么？</h4>\n<ol>\n<li>消息邮箱（Message Mailbox）：\n<ul>\n<li>消息邮箱用于在任务之间传递消息和数据。</li>\n<li>消息邮箱可以存储一个或多个消息，每个消息可以是一个固定长度的数据结构。</li>\n<li>发送任务通过发送消息到邮箱来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。</li>\n<li>消息邮箱具有缓冲区的功能，当邮箱已满时，发送任务会被阻塞，直到有空间可用；当邮箱为空时，接收任务会被阻塞，直到有消息可接收。</li>\n</ul>\n</li>\n<li>消息队列（Message Queue）：\n<ul>\n<li>消息队列用于在任务之间传递消息和数据。</li>\n<li>消息队列可以存储一个或多个消息，每个消息可以是一个可变长度的数据结构。</li>\n<li>发送任务通过发送消息到队列来向其他任务传递数据，接收任务通过接收消息来获取其他任务发送的数据。</li>\n<li>消息队列具有先进先出（FIFO）的特性，保证消息按照发送的顺序进行接收。</li>\n</ul>\n</li>\n</ol>\n<p>总结：</p>\n<p><strong>消息邮箱和消息队列都用于任务间的消息传递和数据通信，但它们在消息存储方式和特性上有所不同。消息邮箱适用于固定长度的消息存储和同步发送和接收任务的操作，而消息队列适用于可变长度的消息存储和按照发送顺序进行接收的操作。</strong></p>\n<h2 id=\"程序设计\">程序设计</h2>\n<h3 id=\"gpio程序设计\">GPIO程序设计</h3>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现pb5控制led灯周期闪烁，闪烁周期约为1s，采用软件延时方法。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁，闪烁周期约为1s，采用软件延时方法。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现PB5控制LED灯周期闪烁的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOB的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PB5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这部分考试时候可不写</span></span><br><span class=\"line\"><span class=\"comment\">// 延时函数，使用软件延时</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> nCount)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; nCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 控制LED灯亮</span></span><br><span class=\"line\">        GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 控制LED灯灭</span></span><br><span class=\"line\">        GPIO_ResetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOB的PB5引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环控制LED灯周期性地闪烁。通过调用<code>GPIO_SetBits()</code>和<code>GPIO_ResetBits()</code>函数来控制PB5引脚的电平，实现LED灯的亮和灭。通过调用<code>Delay()</code>函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现LED灯的周期性闪烁。</p>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现pb5和pe5控制的2个led灯交替闪烁，闪烁周期约为1s。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现PB5和PE5控制的2个LED灯交替闪烁，闪烁周期约为1s。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现PB5和PE5控制的两个LED灯交替闪烁的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOB和GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PB5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 考试时可不写</span></span><br><span class=\"line\"><span class=\"comment\">// 延时函数，使用软件延时</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> nCount)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; nCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 控制PB5引脚为高电平，PE5引脚为低电平</span></span><br><span class=\"line\">        GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\">        GPIO_ResetBits(GPIOE, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 控制PB5引脚为低电平，PE5引脚为高电平</span></span><br><span class=\"line\">        GPIO_ResetBits(GPIOB, GPIO_Pin_5);</span><br><span class=\"line\">        GPIO_SetBits(GPIOE, GPIO_Pin_5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时约1s</span></span><br><span class=\"line\">        Delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOB的PB5引脚和GPIOE的PE5引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环控制两个LED灯的交替闪烁。通过调用<code>GPIO_SetBits()</code>和<code>GPIO_ResetBits()</code>函数来控制PB5和PE5引脚的电平，实现LED灯的亮和灭。通过调用<code>Delay()</code>函数进行软件延时，延时约1秒的时间。循环执行这个过程，就可以实现两个LED灯的交替闪烁。</p>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现8个led循环依次点亮功能，8个led由pe0~pe7控制，低电平点亮。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮功能，8个LED由PE0~PE7控制，低电平点亮。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现8个LED循环依次点亮的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE0~PE7引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |</span><br><span class=\"line\">                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 依次点亮8个LED，通过循环和位运算实现</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将对应的引脚设置为低电平，点亮LED</span></span><br><span class=\"line\">            GPIO_ResetBits(GPIOE, (<span class=\"number\">1</span> &lt;&lt; i));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 延时一段时间</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000000</span>; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将对应的引脚设置为高电平，熄灭LED</span></span><br><span class=\"line\">            GPIO_SetBits(GPIOE, (<span class=\"number\">1</span> &lt;&lt; i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOE的PE0~PE7引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环依次点亮8个LED。通过循环和位运算，将对应的引脚设置为低电平，点亮LED，并延时一段时间。然后将对应的引脚设置为高电平，熄灭LED。循环执行这个过程，就可以实现8个LED的循环依次点亮的效果。</p>\n<h4 id=\"采用库函数编写通用gpio控制程序，实现pc口（pc0~pc7）控制1位共阳极数码管循环显示数字0~9的功能，每个数字显示停留时间约为1s。程序应包括gpio初始化函数和主函数main（）代码\">采用库函数编写通用GPIO控制程序，实现PC口（PC0~PC7）控制1位共阳极数码管循环显示数字0~9的功能，每个数字显示停留时间约为1s。程序应包括GPIO初始化函数和主函数main（）代码</h4>\n<p>以下是使用库函数编写通用GPIO控制程序，实现PC口控制1位共阳极数码管循环显示数字0~9的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数码管数字编码表</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">uint8_t</span> digitCode[] = &#123;</span><br><span class=\"line\">    <span class=\"number\">0x3F</span>,  <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"number\">0x06</span>,  <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"number\">0x5B</span>,  <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"number\">0x4F</span>,  <span class=\"comment\">// 3</span></span><br><span class=\"line\">    <span class=\"number\">0x66</span>,  <span class=\"comment\">// 4</span></span><br><span class=\"line\">    <span class=\"number\">0x6D</span>,  <span class=\"comment\">// 5</span></span><br><span class=\"line\">    <span class=\"number\">0x7D</span>,  <span class=\"comment\">// 6</span></span><br><span class=\"line\">    <span class=\"number\">0x07</span>,  <span class=\"comment\">// 7</span></span><br><span class=\"line\">    <span class=\"number\">0x7F</span>,  <span class=\"comment\">// 8</span></span><br><span class=\"line\">    <span class=\"number\">0x6F</span>   <span class=\"comment\">// 9</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PC0~PC7引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |</span><br><span class=\"line\">                                  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化GPIO</span></span><br><span class=\"line\">    GPIO_Init();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> digit = <span class=\"number\">0</span>;  <span class=\"comment\">// 当前显示的数字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据当前数字设置PC0~PC7引脚的输出状态</span></span><br><span class=\"line\">        GPIO_Write(GPIOC, digitCode[digit]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 切换到下一个数字</span></span><br><span class=\"line\">        digit++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digit &gt; <span class=\"number\">9</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            digit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，首先在<code>GPIO_Init()</code>函数中初始化了GPIOC的PC0~PC7引脚为推挽输出模式。然后，在<code>main()</code>函数中，通过循环依次显示数字0~9。在每个循环中，根据当前数字设置PC0~PC7引脚的输出状态，通过写入相应的数码管数字编码。然后延时一段时间，切换到下一个数字，再次循环显示。通过这个过程，可以实现PC口控制1位共阳极数码管循环显示数字0~9的功能。</p>\n<h3 id=\"exti程序设计\">EXTI程序设计</h3>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pe2）的响应，用led灯（pc5）状态反映按键的按下，每次按键按下时（下降沿中断）将led灯状态取反。（写出pe2外部中断初始化代码和外部中断服务函数的代码）\">采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（下降沿中断）将LED灯状态取反。（写出PE2外部中断初始化代码和外部中断服务函数的代码）</h4>\n<p>下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC和GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PC5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE2引脚为上拉输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE2引脚为中断输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  <span class=\"comment\">// 下拉输入</span></span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线路</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断参数</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = EXTI_Line2;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  <span class=\"comment\">// 下降沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x00</span>;  <span class=\"comment\">// 抢占优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x00</span>;         <span class=\"comment\">// 响应优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(EXTI_Line2) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待一段时间消除抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查按键是否按下（下降沿触发）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_2) == RESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反转LED灯状态</span></span><br><span class=\"line\">            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(<span class=\"number\">1</span> - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(EXTI_Line2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pe4）的响应，用led灯（pc5）状态反映按键的按下，每次按键按下时（上升沿中断）将led灯状态取反。（写出pe4外部中断初始化代码和外部中断服务函数的代码）\">采用库函数编写程序，实现对按键的外部中断输入（PE4）的响应，用LED灯（PC5）状态反映按键的按下，每次按键按下时（上升沿中断）将LED灯状态取反。（写出PE4外部中断初始化代码和外部中断服务函数的代码）</h4>\n<p>下面是使用库函数编写的程序示例，实现对按键的外部中断输入的响应，用LED灯状态反映按键的按下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC和GPIOE的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PC5引脚为推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE4引脚为上拉输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO的时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置PE4引脚为中断输入</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;  <span class=\"comment\">// 下拉输入</span></span><br><span class=\"line\">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线路</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource4);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断参数</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = EXTI_Line4;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  <span class=\"comment\">// 上升沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x00</span>;  <span class=\"comment\">// 抢占优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x00</span>;         <span class=\"comment\">// 响应优先级为0</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外部中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI4_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(EXTI_Line4) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待一段时间消除抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 空操作，用于延时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查按键是否按下（上升沿触发）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_4) == SET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反转LED灯状态</span></span><br><span class=\"line\">            GPIO_WriteBit(GPIOC, GPIO_Pin_5, (BitAction)(<span class=\"number\">1</span> - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(EXTI_Line4);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充-: (bitaction)(1 - gpio_readoutputdatabit(gpioc, gpio_pin_5)是什么含义\">补充 : (BitAction)(1 - GPIO_ReadOutputDataBit(GPIOC, GPIO_Pin_5)是什么含义</h4>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在之前的案例中，`(BitAction)(1 - GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`是一个表达式，用于取反GPIOC的第5个引脚（即PC5）的输出状态。</span><br><span class=\"line\"></span><br><span class=\"line\">`GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`函数用于读取GPIOC的第5个引脚（即PC5）的输出状态，返回值为0或1，表示引脚的电平状态。</span><br><span class=\"line\"></span><br><span class=\"line\">`(1 - GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`中的`(1 - ...)`部分将读取的引脚状态取反，即如果引脚的输出为0，则结果为1，如果引脚的输出为1，则结果为0。</span><br><span class=\"line\"></span><br><span class=\"line\">最外层的`(BitAction)`则将取反后的结果转换为`BitAction`类型，`BitAction`是一个枚举类型，表示引脚的状态，取值可以是`Bit<span class=\"built_in\">_</span>RESET`（低电平）或`Bit<span class=\"built_in\">_</span>SET`（高电平）。</span><br><span class=\"line\"></span><br><span class=\"line\">因此，`(BitAction)(1 - GPIO<span class=\"built_in\">_</span>ReadOutputDataBit(GPIOC, GPIO<span class=\"built_in\">_</span>Pin<span class=\"built_in\">_</span>5)`的含义是将GPIOC的第5个引脚的输出状态取反，并将结果转换为`BitAction`类型，用于控制该引脚的输出状态。</span><br></pre></td></tr></table></figure>\n<h3 id=\"tim\">TIM</h3>\n<h4 id=\"采用库函数编写通用定时器tim2的初始化程序，设置定时器tim2的预分频值为7199，定时时间为10ms，加计数模式，使能tim2的刷新中断，中断抢占优先级为2，响应优先级为3\">采用库函数编写通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为3</h4>\n<p>下面是使用库函数编写的通用定时器TIM2的初始化程序，设置定时器TIM2的预分频值为7199，定时时间为10ms，加计数模式，使能TIM2的刷新中断，并设置中断优先级为抢占优先级2，响应优先级3的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM2初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM2的时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置定时器TIM2</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Period = <span class=\"number\">999</span>;  <span class=\"comment\">// 计数器自动重装值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Prescaler = <span class=\"number\">7199</span>;  <span class=\"comment\">// 预分频值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class=\"comment\">// 加计数模式</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  <span class=\"comment\">// 时钟分频</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_RepetitionCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置TIM2的更新中断</span></span><br><span class=\"line\">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>;  <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x03</span>;         <span class=\"comment\">// 响应优先级为3</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能定时器TIM2</span></span><br><span class=\"line\">    TIM_Cmd(TIM2, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM2中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在此处理定时器中断相关的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，以上代码只是TIM2定时器的初始化和中断处理部分，你还需要在主函数中调用<code>TIM2_Init()</code>函数进行初始化，并启用全局中断。</p>\n<h4 id=\"采用库函数编写通用定时器tim3的初始化程序，设置定时器tim3的预分频值为7199，定时时间为100ms，加计数模式，使能tim3的刷新中断，中断抢占优先级为1，响应优先级为2。\">采用库函数编写通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，中断抢占优先级为1，响应优先级为2。</h4>\n<p>下面是使用库函数编写的通用定时器TIM3的初始化程序，设置定时器TIM3的预分频值为7199，定时时间为100ms，加计数模式，使能TIM3的刷新中断，并设置中断优先级为抢占优先级1，响应优先级2的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span>  <span class=\"comment\">// 包含STM32F103系列的头文件</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM3初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM3_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM3的时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置定时器TIM3</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Period = <span class=\"number\">9999</span>;  <span class=\"comment\">// 计数器自动重装值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_Prescaler = <span class=\"number\">7199</span>;  <span class=\"comment\">// 预分频值</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class=\"comment\">// 加计数模式</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  <span class=\"comment\">// 时钟分频</span></span><br><span class=\"line\">    TIM_TimeBaseStructure.TIM_RepetitionCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置TIM3的更新中断</span></span><br><span class=\"line\">    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置中断优先级</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x01</span>;  <span class=\"comment\">// 抢占优先级为1</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x02</span>;         <span class=\"comment\">// 响应优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能定时器TIM3</span></span><br><span class=\"line\">    TIM_Cmd(TIM3, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器TIM3中断服务函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM3_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在此处理定时器中断相关的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，以上代码只是TIM3定时器的初始化和中断处理部分，你还需要在主函数中调用<code>TIM3_Init()</code>函数进行初始化，并启用全局中断。</p>\n<h4 id=\"补充-: 计算tim_timebasestructuretim_period(计数器自动重装载值)\">补充 : 计算TIM_TimeBaseStructure.TIM_Period(计数器自动重装载值)</h4>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在上个案例中，`TIM<span class=\"built_in\">_</span>TimeBaseStructure.TIM<span class=\"built_in\">_</span>Period`的值设置为9999，是为了实现100ms的定时时间。</span><br><span class=\"line\"></span><br><span class=\"line\">定时器的计数器值会在0到TIM<span class=\"built_in\">_</span>Period之间循环计数，当计数器达到TIM<span class=\"built_in\">_</span>Period时，就会产生更新事件（溢出），并触发中断（如果使能了中断）。因此，定时器的定时时间可以通过设置TIM<span class=\"built_in\">_</span>Period的值来控制。</span><br><span class=\"line\"></span><br><span class=\"line\">在STM32F103微控制器中，定时器的计数器位数是16位，因此最大计数值为65535。要计算TIM<span class=\"built_in\">_</span>Period的值以实现100ms的定时，可以使用以下公式：</span><br><span class=\"line\"></span><br><span class=\"line\">TIM<span class=\"built_in\">_</span>Period = (定时时间 / 计数周期) - 1</span><br><span class=\"line\"></span><br><span class=\"line\">其中，定时时间是以秒为单位，计数周期是定时器的预分频值与定时器时钟频率之间的比例关系。在这个案例中，预分频值为7199（`TIM<span class=\"built_in\">_</span>TimeBaseStructure.TIM<span class=\"built_in\">_</span>Prescaler = 7199`），定时器时钟频率为72 MHz。</span><br><span class=\"line\"></span><br><span class=\"line\">计算过程如下：</span><br><span class=\"line\"></span><br><span class=\"line\">计数周期 = 预分频值 + 1 = 7199 + 1 = 7200</span><br><span class=\"line\">定时时间 = 0.1 秒（100ms）</span><br><span class=\"line\"></span><br><span class=\"line\">TIM<span class=\"built_in\">_</span>Period = (0.1 / 7200) - 1 = 0.0000138888 - 1 ≈ 1388</span><br><span class=\"line\"></span><br><span class=\"line\">因为TIM<span class=\"built_in\">_</span>Period是一个16位的无符号整数，所以需要确保计算出的值在16位的范围内。在这种情况下，取TIM<span class=\"built_in\">_</span>Period = 1388是一个合适的值，可以实现约100ms的定时。</span><br></pre></td></tr></table></figure>\n<h3 id=\"综合题\">综合题</h3>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pc3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示\">采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示</h4>\n<p>题目<br>\n采用库函数编写程序，实现对按键的外部中断输入（PC3）的响应，每次按键按下时记录按下的次数，并通过串口2将按键次数传送给上位机的串口助手显示。要求：<br>\n（1）写出按键外部中断初始化代码，初始化为上升沿触发中断。<br>\n（2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。<br>\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。</p>\n<p>下面是针对上述要求的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_exti.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义按键引脚和外部中断线</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PIN GPIO_Pin_3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PORT GPIOC</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_EXTI_LINE EXTI_Line3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义串口2引脚和相关参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_PIN GPIO_Pin_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_RX_PIN GPIO_Pin_3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_PORT GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART USART2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量，记录按键次数</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> buttonPressCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化外部中断</span></span><br><span class=\"line\">    EXTI_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口2</span></span><br><span class=\"line\">    USART_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主循环中不需要做其他操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （1）写出按键外部中断初始化代码，初始化为上升沿触发中断。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOC时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置按键引脚为输入模式</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class=\"comment\">// 上拉输入</span></span><br><span class=\"line\">    GPIO_Init(BUTTON_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接外部中断线到按键引脚</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线为上升沿触发中断</span></span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; <span class=\"comment\">// 上升沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能外部中断通道</span></span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>; <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x03</span>;        <span class=\"comment\">// 响应优先级为3</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）写出串口2的初始化代码，初始化串口2的波特率为19200bps，8位数据位，1位停止位，PA2作为发送端，PA3作为接收端。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOA时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART2时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART引脚为复用功能</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class=\"comment\">// 复用推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(USART_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = <span class=\"number\">19200</span>;</span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Tx; <span class=\"comment\">// 仅发送模式</span></span><br><span class=\"line\">    USART_Init(USART, &amp;USART_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART</span></span><br><span class=\"line\">    USART_Cmd(USART, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）编写按键的外部中断服务函数，完成按键次数计数和串口2向上位机发送计数值的功能。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI3_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查按键外部中断是否发生</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间，防止抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 记录按键次数</span></span><br><span class=\"line\">        buttonPressCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送按键次数到串口</span></span><br><span class=\"line\">        <span class=\"type\">char</span> countStr[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(countStr, <span class=\"string\">&quot;Press count: %lu\\r\\n&quot;</span>, buttonPressCount);</span><br><span class=\"line\">        USART_SendDataString((<span class=\"type\">uint8_t</span>*)countStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        USART_SendData(USART, *data++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对PC3按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口2将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为上升沿触发中断，串口2被初始化为波特率为19200bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口2发送出去。</p>\n<h4 id=\"采用库函数编写程序，实现对按键的外部中断输入（pe2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示\">采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示</h4>\n<p>题目 :</p>\n<p>采用库函数编写程序，实现对按键的外部中断输入（PE2）的响应，每次按键按下时记录按下的次数，并通过串口1将按键次数传送给上位机的串口助手显示。要求：</p>\n<p>（1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。<br>\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。<br>\n（3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。</p>\n<p>下面是针对上述要求的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_exti.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义按键引脚和外部中断线</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PIN GPIO_Pin_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_PORT GPIOE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUTTON_EXTI_LINE EXTI_Line2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义串口1引脚和相关参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_PIN GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_RX_PIN GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_PORT GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART USART1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量，记录按键次数</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> buttonPressCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化外部中断</span></span><br><span class=\"line\">    EXTI_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口1</span></span><br><span class=\"line\">    USART_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主循环中不需要做其他操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （1）写出按键的外部中断初始化代码，初始化为下降沿触发中断。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOE时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置按键引脚为输入模式</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = BUTTON_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; <span class=\"comment\">// 下拉输入</span></span><br><span class=\"line\">    GPIO_Init(BUTTON_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能AFIO时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接外部中断线到按键引脚</span></span><br><span class=\"line\">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置外部中断线为下降沿触发中断</span></span><br><span class=\"line\">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class=\"line\">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; <span class=\"comment\">// 下降沿触发</span></span><br><span class=\"line\">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class=\"line\">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能外部中断通道</span></span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>; <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x03</span>;        <span class=\"comment\">// 响应优先级为3</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOA时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART1时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART引脚为复用功能</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class=\"comment\">// 复用推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(USART_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = <span class=\"number\">9600</span>;</span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Tx; <span class=\"comment\">// 仅发送模式</span></span><br><span class=\"line\">    USART_Init(USART, &amp;USART_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART</span></span><br><span class=\"line\">    USART_Cmd(USART, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）编写按键的外部中断服务函数，完成按键次数计数和串口1向上位机发送计数值的功能。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查按键外部中断是否发生</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (EXTI_GetITStatus(BUTTON_EXTI_LINE) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间，防止抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 记录按键次数</span></span><br><span class=\"line\">        buttonPressCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送按键次数到串口</span></span><br><span class=\"line\">        <span class=\"type\">char</span> countStr[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(countStr, <span class=\"string\">&quot;Press count: %lu\\r\\n&quot;</span>, buttonPressCount);</span><br><span class=\"line\">        USART_SendDataString((<span class=\"type\">uint8_t</span>*)countStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        EXTI_ClearITPendingBit(BUTTON_EXTI_LINE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        USART_SendData(USART, *data++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对PE2按键的外部中断响应，每次按键按下时会记录按下的次数，并通过串口1将按键次数发送给上位机的串口助手进行显示。在初始化时，外部中断被配置为下降沿触发中断，串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。按键的外部中断服务函数中，会先进行一段延时以避免按键抖动，然后记录按键次数并将其通过串口1发送出去。</p>\n<h4 id=\"采用库函数编写程序，实现定时器tim2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示\">采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示</h4>\n<p>采用库函数编写程序，实现定时器TIM2定时1s，每次定时中断时，通过串口1将中断次数计数值（0~99）发送给上位机的串口助手显示。要求：</p>\n<p>（1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。<br>\n（2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。<br>\n（3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。</p>\n<p>下面是针对上述要求的示例代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_tim.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义串口1引脚和相关参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_PIN GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_RX_PIN GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_PORT GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART USART1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义定时器TIM2参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TIM_PERIOD 7199</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TIM_PRESCALER 7199</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量，记录中断次数计数值</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">uint8_t</span> interruptCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化定时器TIM2</span></span><br><span class=\"line\">    TIM2_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口1</span></span><br><span class=\"line\">    USART_Configuration();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主循环中不需要做其他操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （1）写出定时器TIM2的初始化程序，设置TIM2的预分频值为7199，加计数模式，使能TIM2的刷新中断，中断抢占优先级为2，响应优先级为2。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM2时钟</span></span><br><span class=\"line\">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化TIM2参数</span></span><br><span class=\"line\">    TIM_TimeBaseInitTypeDef TIM_InitStructure;</span><br><span class=\"line\">    TIM_InitStructure.TIM_Period = TIM_PERIOD;</span><br><span class=\"line\">    TIM_InitStructure.TIM_Prescaler = TIM_PRESCALER;</span><br><span class=\"line\">    TIM_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class=\"line\">    TIM_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class=\"line\">    TIM_InitStructure.TIM_RepetitionCounter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    TIM_TimeBaseInit(TIM2, &amp;TIM_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置TIM2中断优先级</span></span><br><span class=\"line\">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">0x02</span>; <span class=\"comment\">// 抢占优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">0x02</span>;        <span class=\"comment\">// 响应优先级为2</span></span><br><span class=\"line\">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能TIM2更新中断</span></span><br><span class=\"line\">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动定时器TIM2</span></span><br><span class=\"line\">    TIM_Cmd(TIM2, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）写出串口1的初始化代码，初始化串口1的波特率为9600bps，8位数据位，1位停止位，PA9作为发送端，PA10作为接收端。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使能GPIOA时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART1时钟</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART引脚为复用功能</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = USART_TX_PIN | USART_RX_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class=\"comment\">// 复用推挽输出</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(USART_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置USART参数</span></span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = <span class=\"number\">9600</span>;</span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Tx; <span class=\"comment\">// 仅</span></span><br><span class=\"line\"></span><br><span class=\"line\">发送模式</span><br><span class=\"line\">    USART_Init(USART, &amp;USART_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能USART</span></span><br><span class=\"line\">    USART_Cmd(USART, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）编写TIM2的中断服务函数，完成定时通过串口1向上位机发送中断次数计数值（0~99）的功能。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_SendDataString</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*data)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        USART_SendData(USART, *data++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (USART_GetFlagStatus(USART, USART_FLAG_TXE) == RESET);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">TIM2_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查TIM2更新中断是否发生</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 延时一段时间，防止按键抖动</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 增加中断次数计数值</span></span><br><span class=\"line\">        interruptCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送中断次数到串口</span></span><br><span class=\"line\">        <span class=\"type\">char</span> countStr[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(countStr, <span class=\"string\">&quot;Interrupt count: %d\\r\\n&quot;</span>, interruptCount);</span><br><span class=\"line\">        USART_SendDataString((<span class=\"type\">uint8_t</span>*)countStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了对PE2按键的外部中断响应，每次中断发生时会记录中断次数计数值，并通过串口1将其发送给上位机的串口助手进行显示。定时器TIM2被初始化为定时1s，通过中断实现定时功能。串口1被初始化为波特率为9600bps、8位数据位、1位停止位的配置。在TIM2的中断服务函数中，会进行一段延时以防止按键抖动，然后记录中断次数计数值并通过串口1发送出去。</p>\n<h2 id=\"程序分析\">程序分析</h2>\n<h3 id=\"题一\">题一</h3>\n<p>基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BSPInit();</span><br><span class=\"line\">    OSInit();</span><br><span class=\"line\">    OSTaskCreate(TaskLED,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskLEDStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">9</span>); </span><br><span class=\"line\">\tOSTaskCreate(TaskKEY,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskKEYStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">10</span>);</span><br><span class=\"line\">    OSStart();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskLED</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>            <span class=\"comment\">//LED控制任务</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    INT8U err;</span><br><span class=\"line\">    sem01 = OSSemCreate(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OSSemPend(sem01,<span class=\"number\">0</span>,&amp;err);\t</span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDON);             </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>); </span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDOFF);            </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskKEY</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>         <span class=\"comment\">//按键检测任务</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(KEY1!=<span class=\"number\">0</span>)\t          </span><br><span class=\"line\">           &#123;  OSTimeDly(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">\t   OSSemPost(sem01);\t\t\t\t        </span><br><span class=\"line\">\t   <span class=\"keyword\">while</span>(KEY1==<span class=\"number\">0</span>)\t</span><br><span class=\"line\">           &#123; OSTimeDly(<span class=\"number\">1</span>); &#125;   </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回答下面问题：<br>\n（1）程序中任务TaskLED和TaskKEY的优先级是多少？其中优先级较高的是哪个任务?<br>\n（2）程序中任务TaskLED和TaskKEY之间采用了哪种事件通信机制？采用该事件实现的功能是资源同步还是行为同步？<br>\n（3）任务TaskLED调用OSSemPend(sem,0,&amp;err)函数后，将进入哪种状态？满足什么条件后退出该状态？</p>\n<p>(1) 程序中任务TaskLED的优先级为9，任务TaskKEY的优先级为10。优先级较高的任务是TaskKEY。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过OSTaskCreate() 的最后一个参数判断优先级</span></span><br><span class=\"line\">OSTaskCreate(TaskLED,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskLEDStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">9</span>); <span class=\"comment\">// TaskLED 优先级为9</span></span><br><span class=\"line\">OSTaskCreate(TaskKEY,  (<span class=\"type\">void</span> *)<span class=\"number\">0</span>,  &amp;TaskKEYStk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">10</span>); <span class=\"comment\">// TaskKEY 优先级为10</span></span><br></pre></td></tr></table></figure>\n<p>(2) 程序中任务TaskLED和TaskKEY之间采用了信号量（sem01）作为事件通信机制。该事件实现的功能是资源同步，用于TaskKEY任务向TaskLED任务发出信号。</p>\n<p>程序中使用了信号量sem01作为事件通信机制。TaskKEY任务通过OSSemPost()函数向sem01信号量发出信号，而TaskLED任务通过OSSemPend()函数等待sem01信号量的触发。这种事件通信机制用于任务之间的同步操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskLED</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>            <span class=\"comment\">//LED控制任务</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    INT8U err;</span><br><span class=\"line\">    sem01 = OSSemCreate(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OSSemPend(sem01,<span class=\"number\">0</span>,&amp;err); <span class=\"comment\">// TaskLED 通过 OSSemPend() 等待 sem01 信号量的触发</span></span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDON);             </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>); </span><br><span class=\"line\">\t\tLED(<span class=\"number\">1</span>, LEDOFF);            </span><br><span class=\"line\">\t\tOSTimeDlyHMSM(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">TaskKEY</span><span class=\"params\">(<span class=\"type\">void</span> *pdata)</span>         <span class=\"comment\">//按键检测任务</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">while</span>(KEY1!=<span class=\"number\">0</span>)\t          </span><br><span class=\"line\">           &#123;  OSTimeDly(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">\t   OSSemPost(sem01); <span class=\"comment\">// TaskKEY 通过 OSSemPost() 向 sem01 信号量发出信号</span></span><br><span class=\"line\">\t   <span class=\"keyword\">while</span>(KEY1==<span class=\"number\">0</span>)\t</span><br><span class=\"line\">           &#123; OSTimeDly(<span class=\"number\">1</span>); &#125;   </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(3) 任务TaskLED调用OSSemPend(sem, 0, &amp;err)函数后，将进入等待状态（阻塞状态）。TaskLED任务将等待sem01信号量的触发，即等待TaskKEY任务通过OSSemPost()函数释放sem01信号量。当TaskKEY任务调用OSSemPost()函数释放sem01信号量后，TaskLED任务会退出等待状态，并开始执行LED控制代码。</p>\n<p>分析</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 当TaskLED任务调用OSSemPend(sem01, 0, <span class=\"built_in\">&amp;</span>err)函数后，将进入等待状态（阻塞状态）。该函数的第二个参数为0，表示如果sem01信号量当前不可用，则任务会被阻塞而进入等待状态。任务会一直等待，直到sem01信号量可用或超时（在此情况下不会超时，因为第二个参数为0）。</span><br><span class=\"line\"></span><br><span class=\"line\">满足以下条件之一后，TaskLED任务将退出等待状态：</span><br><span class=\"line\"></span><br><span class=\"line\">    当TaskKEY任务调用OSSemPost()函数释放sem01信号量时，TaskLED任务会检测到sem01信号量可用，从而退出等待状态。</span><br><span class=\"line\">    如果TaskLED任务的阻塞期间发生了其他中断或事件，导致任务切换，则当TaskLED任务再次运行时，会重新检查sem01信号量的可用性，并根据情况决定是否退出等待状态。</span><br></pre></td></tr></table></figure>\n<h3 id=\"题二\">题二</h3>\n<p>基于uC/OS-II操作系统的程序中，主函数及任务函数主要代码如下。分析程序并回答下列问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main（<span class=\"type\">void</span>）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">OSInit();</span><br><span class=\"line\">OSTaskCreate(task1, (<span class=\"type\">void</span> *)<span class=\"number\">0</span>, &amp;task1Stk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">12</span> );</span><br><span class=\"line\">OSTaskCreate(task2, (<span class=\"type\">void</span> *)<span class=\"number\">0</span>, &amp;task2Stk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">9</span> );</span><br><span class=\"line\">OSTaskCreate(task3, (<span class=\"type\">void</span> *)<span class=\"number\">0</span>, &amp;task3Stk[TASK_STK_SIZE - <span class=\"number\">1</span>],  <span class=\"number\">6</span>);</span><br><span class=\"line\">OSStart();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> task1（）</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">ClearScreen();                    <span class=\"comment\">//LCD清屏</span></span><br><span class=\"line\">LCD_Printf(“ task1 \\n”);            <span class=\"comment\">//LCD显示字符串 </span></span><br><span class=\"line\">OSTimeDly(<span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> task2（）</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">ClearScreen();</span><br><span class=\"line\">LCD_Printf(“ task2 \\n”);            <span class=\"comment\">//LCD显示字符串</span></span><br><span class=\"line\">OSTimeDly(<span class=\"number\">300</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> task3（）</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">ClearScreen();</span><br><span class=\"line\">LCD_Printf(“ task3 \\n”);            <span class=\"comment\">//LCD显示字符串</span></span><br><span class=\"line\">OSTimeDly(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回答下面问题：<br>\n（1）程序中三个任务task1、task2、task3的优先级分别为什么，其中优先级最高的是哪个任务？         。<br>\n（2）uC/OS-II操作系统中，按照任务的执行方式可分为哪几种类型？本程序中任务task1、task2、task3属于其中哪一种？<br>\n（3）uC/OS-II操作系统中，任务有哪几种状态？本程序中任务调用OSTimeDly( )函数后，将进入哪种状态？<br>\n（4）在LCD上的显示结果为：<br>\n第一次：                  \t      第二次：                  \t<br>\n第三次：                  \t      第四次：                  \t<br>\n第五次：                  \t      第六次：</p>\n<p>(1) 程序中三个任务task1、task2、task3的优先级分别为：12、9、6。优先级数值越小，优先级越高。因此，优先级最高的任务是task3。</p>\n<p>(2) uC/OS-II操作系统中，按照任务的执行方式可分为两种类型：抢占式任务和非抢占式任务。本程序中的任务task1、task2、task3属于非抢占式任务，因为它们在任务执行期间不会被其他优先级更高的任务打断。</p>\n<p>(3) uC/OS-II操作系统中，任务有四种状态：就绪状态（READY）、运行状态（RUNNING）、阻塞状态（BLOCKED）和挂起状态（SUSPENDED）。本程序中，任务调用OSTimeDly()函数后，任务将进入阻塞状态。OSTimeDly()函数会使任务延迟一段指定的时间，任务在此期间将处于阻塞状态，不会被调度执行。</p>\n<p>(4) 在LCD上的显示结果为：<br>\n第一次： task1                   \t  第二次： task2<br>\n第三次： task3                   \t  第四次： task1<br>\n第五次： task2                   \t  第六次： task3</p>\n<p>分析</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据程序的执行逻辑，任务task1、task2、task3依次执行，每个任务都会先清屏，然后在LCD上显示对应的任务名，并通过OSTimeDly()函数延迟一定时间。因此，首次执行时LCD上会显示&quot;task1&quot;，然后延迟200个时钟节拍，接着显示&quot;task2&quot;，再延迟300个时钟节拍，最后显示&quot;task3&quot;，再延迟500个时钟节拍。之后，任务会不断循环执行，按照相同的顺序在LCD上显示任务名，并延迟指定的时间。</span><br></pre></td></tr></table></figure>\n"},{"title":"修改Poershell默认启动路径","date":"2023-05-29T12:48:28.000Z","_content":"\n## 打开 Powershell 文件位置\n\n如图所示\n\n![截图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292049231.png)\n\n## 右键打开 Powershell 属性\n\n如图所示\n\n![截图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292051740.png)\n\n修改起始位置的路径即可\n","source":"_posts/修改Poershell默认启动路径.md","raw":"---\ntitle: 修改Poershell默认启动路径\ndate: 2023-05-29 20:48:28\ntags: Windows\n---\n\n## 打开 Powershell 文件位置\n\n如图所示\n\n![截图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292049231.png)\n\n## 右键打开 Powershell 属性\n\n如图所示\n\n![截图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292051740.png)\n\n修改起始位置的路径即可\n","slug":"修改Poershell默认启动路径","published":1,"updated":"2023-05-29T12:52:37.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli8unx910000r497b6ku1naw","content":"<h2 id=\"打开-powershell 文件位置\">打开 Powershell 文件位置</h2>\n<p>如图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292049231.png\" alt=\"截图\"></p>\n<h2 id=\"右键打开-powershell 属性\">右键打开 Powershell 属性</h2>\n<p>如图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292051740.png\" alt=\"截图\"></p>\n<p>修改起始位置的路径即可</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"打开-powershell 文件位置\">打开 Powershell 文件位置</h2>\n<p>如图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292049231.png\" alt=\"截图\"></p>\n<h2 id=\"右键打开-powershell 属性\">右键打开 Powershell 属性</h2>\n<p>如图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292051740.png\" alt=\"截图\"></p>\n<p>修改起始位置的路径即可</p>\n"},{"title":"修改WindowsTerminal默认启动路径","date":"2023-05-29T12:44:37.000Z","_content":"\n打开 Terminal 设置面板\n\n![截图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292045285.png)\n\n点击左下方 Windows PowerShell\n\n点击右方启动目录选项进行修改\n","source":"_posts/修改WindowsTerminal默认启动路径.md","raw":"---\ntitle: 修改WindowsTerminal默认启动路径\ndate: 2023-05-29 20:44:37\ntags: Windows\n---\n\n打开 Terminal 设置面板\n\n![截图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292045285.png)\n\n点击左下方 Windows PowerShell\n\n点击右方启动目录选项进行修改\n","slug":"修改WindowsTerminal默认启动路径","published":1,"updated":"2023-05-29T12:53:37.842Z","_id":"cli8unx950001r4970x0uh6az","comments":1,"layout":"post","photos":[],"link":"","content":"<p>打开 Terminal 设置面板</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292045285.png\" alt=\"截图\"></p>\n<p>点击左下方 Windows PowerShell</p>\n<p>点击右方启动目录选项进行修改</p>\n","site":{"data":{}},"excerpt":"","more":"<p>打开 Terminal 设置面板</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202305292045285.png\" alt=\"截图\"></p>\n<p>点击左下方 Windows PowerShell</p>\n<p>点击右方启动目录选项进行修改</p>\n"},{"title":"Hexo添加标签","date":"2023-05-29T13:27:15.000Z","_content":"\n## 创建标签目录文件\n\n```bash\nhexo new page tags\n```\n\n打开 /source/tags/index.md\n\n修改 type 的值为 \"tags\"\n\n实例代码\n\n```markdown\n---\ntitle: tags\ndate: 2023-05-29 12:18:26\ntype: \"tags\"\n---\n```\n\n## 修改主题配置\n\n笔者使用的是 next 主题\n\n打开主题的配置文件找到 tags 选项, 打开即可\n\n如下\n\n```yml\nmenu:\n  home: / || fa fa-home\n  # about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  # categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  # schedule: /schedule/ || fa fa-calendar\n  # sitemap: /sitemap.xml || fa fa-sitemap\n  # commonweal: /404/ || fa fa-heartbeat\n```\n\n将 tags 前的注释去掉即可\n","source":"_posts/Hexo添加标签.md","raw":"---\ntitle: Hexo添加标签\ndate: 2023-05-29 21:27:15\ntags: 博客\n---\n\n## 创建标签目录文件\n\n```bash\nhexo new page tags\n```\n\n打开 /source/tags/index.md\n\n修改 type 的值为 \"tags\"\n\n实例代码\n\n```markdown\n---\ntitle: tags\ndate: 2023-05-29 12:18:26\ntype: \"tags\"\n---\n```\n\n## 修改主题配置\n\n笔者使用的是 next 主题\n\n打开主题的配置文件找到 tags 选项, 打开即可\n\n如下\n\n```yml\nmenu:\n  home: / || fa fa-home\n  # about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  # categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  # schedule: /schedule/ || fa fa-calendar\n  # sitemap: /sitemap.xml || fa fa-sitemap\n  # commonweal: /404/ || fa fa-heartbeat\n```\n\n将 tags 前的注释去掉即可\n","slug":"Hexo添加标签","published":1,"updated":"2023-05-29T13:33:02.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli8w3wnr00000g978six79iw","content":"<h2 id=\"创建标签目录文件\">创建标签目录文件</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n<p>打开 /source/tags/index.md</p>\n<p>修改 type 的值为 “tags”</p>\n<p>实例代码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2023-05-29 12:18:26</span><br><span class=\"line\"><span class=\"section\">type: &quot;tags&quot;</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改主题配置\">修改主题配置</h2>\n<p>笔者使用的是 next 主题</p>\n<p>打开主题的配置文件找到 tags 选项, 打开即可</p>\n<p>如下</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"comment\"># about: /about/ || fa fa-user</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-tags</span></span><br><span class=\"line\">  <span class=\"comment\"># categories: /categories/ || fa fa-th</span></span><br><span class=\"line\">  <span class=\"attr\">archives:</span> <span class=\"string\">/archives/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"comment\"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>\n<p>将 tags 前的注释去掉即可</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建标签目录文件\">创建标签目录文件</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n<p>打开 /source/tags/index.md</p>\n<p>修改 type 的值为 “tags”</p>\n<p>实例代码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2023-05-29 12:18:26</span><br><span class=\"line\"><span class=\"section\">type: &quot;tags&quot;</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改主题配置\">修改主题配置</h2>\n<p>笔者使用的是 next 主题</p>\n<p>打开主题的配置文件找到 tags 选项, 打开即可</p>\n<p>如下</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\">  <span class=\"comment\"># about: /about/ || fa fa-user</span></span><br><span class=\"line\">  <span class=\"attr\">tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-tags</span></span><br><span class=\"line\">  <span class=\"comment\"># categories: /categories/ || fa fa-th</span></span><br><span class=\"line\">  <span class=\"attr\">archives:</span> <span class=\"string\">/archives/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class=\"line\">  <span class=\"comment\"># sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class=\"line\">  <span class=\"comment\"># commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>\n<p>将 tags 前的注释去掉即可</p>\n"},{"title":"配置虚拟机通过主机代理","date":"2024-01-06T11:46:15.000Z","_content":"\n## 说明\n\n- **主机环境**: Win11\n- **虚拟机环境**: VMware Ubantu16.04\n\n## Windows 主机查询IP地址\n\n在cmd下输入**ipconfig**, 复制IPv4地址\n\n## 代理软件配置\n\n在代理软件的参数设置下**打开允许来自局域网的连接**\n\n## 虚拟机下配置\n\n在VMware下配置网络适配器为NAT\n\n在网络配置中添加代理, **地址为本机的IPv4地址, 端口查看代理软件**\n\n","source":"_posts/配置虚拟机通过主机代理.md","raw":"---\ntitle: 配置虚拟机通过主机代理\ndate: 2024-01-06 19:46:15\ntags: 虚拟机\n---\n\n## 说明\n\n- **主机环境**: Win11\n- **虚拟机环境**: VMware Ubantu16.04\n\n## Windows 主机查询IP地址\n\n在cmd下输入**ipconfig**, 复制IPv4地址\n\n## 代理软件配置\n\n在代理软件的参数设置下**打开允许来自局域网的连接**\n\n## 虚拟机下配置\n\n在VMware下配置网络适配器为NAT\n\n在网络配置中添加代理, **地址为本机的IPv4地址, 端口查看代理软件**\n\n","slug":"配置虚拟机通过主机代理","published":1,"updated":"2024-01-16T17:40:40.674Z","_id":"clr20lqim0000b89714p11vpp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\">说明</h2>\n<ul>\n<li><strong>主机环境</strong>: Win11</li>\n<li><strong>虚拟机环境</strong>: VMware Ubantu16.04</li>\n</ul>\n<h2 id=\"windows-主机查询ip地址\">Windows 主机查询IP地址</h2>\n<p>在cmd下输入<strong>ipconfig</strong>, 复制IPv4地址</p>\n<h2 id=\"代理软件配置\">代理软件配置</h2>\n<p>在代理软件的参数设置下<strong>打开允许来自局域网的连接</strong></p>\n<h2 id=\"虚拟机下配置\">虚拟机下配置</h2>\n<p>在VMware下配置网络适配器为NAT</p>\n<p>在网络配置中添加代理, <strong>地址为本机的IPv4地址, 端口查看代理软件</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\">说明</h2>\n<ul>\n<li><strong>主机环境</strong>: Win11</li>\n<li><strong>虚拟机环境</strong>: VMware Ubantu16.04</li>\n</ul>\n<h2 id=\"windows-主机查询ip地址\">Windows 主机查询IP地址</h2>\n<p>在cmd下输入<strong>ipconfig</strong>, 复制IPv4地址</p>\n<h2 id=\"代理软件配置\">代理软件配置</h2>\n<p>在代理软件的参数设置下<strong>打开允许来自局域网的连接</strong></p>\n<h2 id=\"虚拟机下配置\">虚拟机下配置</h2>\n<p>在VMware下配置网络适配器为NAT</p>\n<p>在网络配置中添加代理, <strong>地址为本机的IPv4地址, 端口查看代理软件</strong></p>\n"},{"title":"Git代理命令","date":"2024-01-13T18:42:12.000Z","_content":"\n## Git设置代理命令\n\n```shell\ngit config --global http.proxy \"http://127.0.0.1:10807\"\ngit config --global https.proxy \"http://127.0.0.1:10807\"\n```\n\n注意: **代理的端口号需要根据实际情况进行调整**\n\n## Git清除代理命令\n\n```shell\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n","source":"_posts/Git代理命令.md","raw":"---\ntitle: Git代理命令\ndate: 2024-01-14 02:42:12\ntags: Git\n---\n\n## Git设置代理命令\n\n```shell\ngit config --global http.proxy \"http://127.0.0.1:10807\"\ngit config --global https.proxy \"http://127.0.0.1:10807\"\n```\n\n注意: **代理的端口号需要根据实际情况进行调整**\n\n## Git清除代理命令\n\n```shell\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n","slug":"Git代理命令","published":1,"updated":"2024-01-13T18:45:44.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrcf4r5v00005s972uhxhlt1","content":"<h2 id=\"git设置代理命令\">Git设置代理命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy &quot;http://127.0.0.1:10807&quot;</span><br><span class=\"line\">git config --global https.proxy &quot;http://127.0.0.1:10807&quot;</span><br></pre></td></tr></table></figure>\n<p>注意: <strong>代理的端口号需要根据实际情况进行调整</strong></p>\n<h2 id=\"git清除代理命令\">Git清除代理命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset http.proxy</span><br><span class=\"line\">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"git设置代理命令\">Git设置代理命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy &quot;http://127.0.0.1:10807&quot;</span><br><span class=\"line\">git config --global https.proxy &quot;http://127.0.0.1:10807&quot;</span><br></pre></td></tr></table></figure>\n<p>注意: <strong>代理的端口号需要根据实际情况进行调整</strong></p>\n<h2 id=\"git清除代理命令\">Git清除代理命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset http.proxy</span><br><span class=\"line\">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>\n"},{"title":"Git常用命令","date":"2024-01-16T17:53:17.000Z","_content":"\n## 初始化流程\n\n```shell\ngit init\ngit add <file-name>\ngit commit -m \"commit message\"\ngit branch -M main\ngit remote add origin <repository URL>\ngit push -u origin main\n```\n\n1. git add README.md:\n - 这个命令将 README.md 文件添加到暂存区（staging area）。Git 的暂存区是一个准备好的下一次提交的文件列表。这意味着 README.md 文件的更改将被包含在下一次提交中。\n2. git commit -m \"first commit\":\n - 这个命令将暂存区中的更改提交到本地仓库。-m 后面跟随的 \"first commit\" 是提交信息，用于描述这次提交的内容或目的。\n3. git branch -M main:\n - 这个命令用于将当前分支重命名为 main。Git 默认的主分支名是 master，但近年来，main 开始被广泛采用作为默认主分支的名称。-M 参数表示强制重命名，即使目标分支名已存在。\n4. git remote add origin <repository URL>:\n - 这个命令用于添加一个新的远程仓库，并将其命名为 origin。在 Git 中，origin 是远程仓库的默认名称。\n5. git push -u origin main:\n - 这个命令将本地的 main 分支推送到名为 origin 的远程仓库。-u 参数意味着将本地的 main 分支和远程的 main 分支关联起来，以后可以简化推送或拉取命令。\n\n## 提交部分命令\n\n### 添加文件到暂存区\n\n**添加指定文件到暂存区**\n\n```shell\ngit add <file>\n```\n\n**添加当前目录下所有更改到暂存区**\n\n```shell\ngit add .\n```\n\n### 提交更改\n\n将暂存区的更改提交到本地仓库.每个提交都需要一个提交信息，描述所做的更改.\n\n```shell\ngit commit -m \"commit message\"\n```\n\n### 连接远程仓库\n\n将本地仓库与远程仓库关联。通常，远程仓库的默认名称是 origin\n\n```shell\ngit remote add origin <repository URL>\n```\n\n### 推送更改到远程仓库\n\n将本地分支的更改推送到远程仓库。例如，推送到主分支通常是 git push origin main\n\n```shell\ngit push origin <branch>\n```\n\n## 拉取部分命令\n\n### 拉取远程仓库的更改\n\n从远程仓库拉取最新的更改并合并到本地分支\n\n```shell\ngit pull origin <branch>\n```\n\n## 克隆部分命令\n\n### 克隆远程仓库\n\n克隆一个远程仓库到本地\n\n```shell\ngit clone <repository URL>\n```\n","source":"_posts/Git常用命令.md","raw":"---\ntitle: Git常用命令\ndate: 2024-01-17 01:53:17\ntags: Git\n---\n\n## 初始化流程\n\n```shell\ngit init\ngit add <file-name>\ngit commit -m \"commit message\"\ngit branch -M main\ngit remote add origin <repository URL>\ngit push -u origin main\n```\n\n1. git add README.md:\n - 这个命令将 README.md 文件添加到暂存区（staging area）。Git 的暂存区是一个准备好的下一次提交的文件列表。这意味着 README.md 文件的更改将被包含在下一次提交中。\n2. git commit -m \"first commit\":\n - 这个命令将暂存区中的更改提交到本地仓库。-m 后面跟随的 \"first commit\" 是提交信息，用于描述这次提交的内容或目的。\n3. git branch -M main:\n - 这个命令用于将当前分支重命名为 main。Git 默认的主分支名是 master，但近年来，main 开始被广泛采用作为默认主分支的名称。-M 参数表示强制重命名，即使目标分支名已存在。\n4. git remote add origin <repository URL>:\n - 这个命令用于添加一个新的远程仓库，并将其命名为 origin。在 Git 中，origin 是远程仓库的默认名称。\n5. git push -u origin main:\n - 这个命令将本地的 main 分支推送到名为 origin 的远程仓库。-u 参数意味着将本地的 main 分支和远程的 main 分支关联起来，以后可以简化推送或拉取命令。\n\n## 提交部分命令\n\n### 添加文件到暂存区\n\n**添加指定文件到暂存区**\n\n```shell\ngit add <file>\n```\n\n**添加当前目录下所有更改到暂存区**\n\n```shell\ngit add .\n```\n\n### 提交更改\n\n将暂存区的更改提交到本地仓库.每个提交都需要一个提交信息，描述所做的更改.\n\n```shell\ngit commit -m \"commit message\"\n```\n\n### 连接远程仓库\n\n将本地仓库与远程仓库关联。通常，远程仓库的默认名称是 origin\n\n```shell\ngit remote add origin <repository URL>\n```\n\n### 推送更改到远程仓库\n\n将本地分支的更改推送到远程仓库。例如，推送到主分支通常是 git push origin main\n\n```shell\ngit push origin <branch>\n```\n\n## 拉取部分命令\n\n### 拉取远程仓库的更改\n\n从远程仓库拉取最新的更改并合并到本地分支\n\n```shell\ngit pull origin <branch>\n```\n\n## 克隆部分命令\n\n### 克隆远程仓库\n\n克隆一个远程仓库到本地\n\n```shell\ngit clone <repository URL>\n```\n","slug":"Git常用命令","published":1,"updated":"2024-01-16T18:12:44.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrgo9dgz0000hw9755wv2e89","content":"<h2 id=\"初始化流程\">初始化流程</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add &lt;file-name&gt;</span><br><span class=\"line\">git commit -m &quot;commit message&quot;</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin &lt;repository URL&gt;</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n<ol>\n<li>git add <a href=\"http://README.md\">README.md</a>:</li>\n</ol>\n<ul>\n<li>这个命令将 <a href=\"http://README.md\">README.md</a> 文件添加到暂存区（staging area）。Git 的暂存区是一个准备好的下一次提交的文件列表。这意味着 <a href=\"http://README.md\">README.md</a> 文件的更改将被包含在下一次提交中。</li>\n</ul>\n<ol start=\"2\">\n<li>git commit -m “first commit”:</li>\n</ol>\n<ul>\n<li>这个命令将暂存区中的更改提交到本地仓库。-m 后面跟随的 “first commit” 是提交信息，用于描述这次提交的内容或目的。</li>\n</ul>\n<ol start=\"3\">\n<li>git branch -M main:</li>\n</ol>\n<ul>\n<li>这个命令用于将当前分支重命名为 main。Git 默认的主分支名是 master，但近年来，main 开始被广泛采用作为默认主分支的名称。-M 参数表示强制重命名，即使目标分支名已存在。</li>\n</ul>\n<ol start=\"4\">\n<li>git remote add origin <repository URL>:</li>\n</ol>\n<ul>\n<li>这个命令用于添加一个新的远程仓库，并将其命名为 origin。在 Git 中，origin 是远程仓库的默认名称。</li>\n</ul>\n<ol start=\"5\">\n<li>git push -u origin main:</li>\n</ol>\n<ul>\n<li>这个命令将本地的 main 分支推送到名为 origin 的远程仓库。-u 参数意味着将本地的 main 分支和远程的 main 分支关联起来，以后可以简化推送或拉取命令。</li>\n</ul>\n<h2 id=\"提交部分命令\">提交部分命令</h2>\n<h3 id=\"添加文件到暂存区\">添加文件到暂存区</h3>\n<p><strong>添加指定文件到暂存区</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add &lt;file&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>添加当前目录下所有更改到暂存区</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<h3 id=\"提交更改\">提交更改</h3>\n<p>将暂存区的更改提交到本地仓库.每个提交都需要一个提交信息，描述所做的更改.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;commit message&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接远程仓库\">连接远程仓库</h3>\n<p>将本地仓库与远程仓库关联。通常，远程仓库的默认名称是 origin</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;repository URL&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"推送更改到远程仓库\">推送更改到远程仓库</h3>\n<p>将本地分支的更改推送到远程仓库。例如，推送到主分支通常是 git push origin main</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"拉取部分命令\">拉取部分命令</h2>\n<h3 id=\"拉取远程仓库的更改\">拉取远程仓库的更改</h3>\n<p>从远程仓库拉取最新的更改并合并到本地分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"克隆部分命令\">克隆部分命令</h2>\n<h3 id=\"克隆远程仓库\">克隆远程仓库</h3>\n<p>克隆一个远程仓库到本地</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;repository URL&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"初始化流程\">初始化流程</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add &lt;file-name&gt;</span><br><span class=\"line\">git commit -m &quot;commit message&quot;</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin &lt;repository URL&gt;</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n<ol>\n<li>git add <a href=\"http://README.md\">README.md</a>:</li>\n</ol>\n<ul>\n<li>这个命令将 <a href=\"http://README.md\">README.md</a> 文件添加到暂存区（staging area）。Git 的暂存区是一个准备好的下一次提交的文件列表。这意味着 <a href=\"http://README.md\">README.md</a> 文件的更改将被包含在下一次提交中。</li>\n</ul>\n<ol start=\"2\">\n<li>git commit -m “first commit”:</li>\n</ol>\n<ul>\n<li>这个命令将暂存区中的更改提交到本地仓库。-m 后面跟随的 “first commit” 是提交信息，用于描述这次提交的内容或目的。</li>\n</ul>\n<ol start=\"3\">\n<li>git branch -M main:</li>\n</ol>\n<ul>\n<li>这个命令用于将当前分支重命名为 main。Git 默认的主分支名是 master，但近年来，main 开始被广泛采用作为默认主分支的名称。-M 参数表示强制重命名，即使目标分支名已存在。</li>\n</ul>\n<ol start=\"4\">\n<li>git remote add origin <repository URL>:</li>\n</ol>\n<ul>\n<li>这个命令用于添加一个新的远程仓库，并将其命名为 origin。在 Git 中，origin 是远程仓库的默认名称。</li>\n</ul>\n<ol start=\"5\">\n<li>git push -u origin main:</li>\n</ol>\n<ul>\n<li>这个命令将本地的 main 分支推送到名为 origin 的远程仓库。-u 参数意味着将本地的 main 分支和远程的 main 分支关联起来，以后可以简化推送或拉取命令。</li>\n</ul>\n<h2 id=\"提交部分命令\">提交部分命令</h2>\n<h3 id=\"添加文件到暂存区\">添加文件到暂存区</h3>\n<p><strong>添加指定文件到暂存区</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add &lt;file&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>添加当前目录下所有更改到暂存区</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<h3 id=\"提交更改\">提交更改</h3>\n<p>将暂存区的更改提交到本地仓库.每个提交都需要一个提交信息，描述所做的更改.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;commit message&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接远程仓库\">连接远程仓库</h3>\n<p>将本地仓库与远程仓库关联。通常，远程仓库的默认名称是 origin</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;repository URL&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"推送更改到远程仓库\">推送更改到远程仓库</h3>\n<p>将本地分支的更改推送到远程仓库。例如，推送到主分支通常是 git push origin main</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"拉取部分命令\">拉取部分命令</h2>\n<h3 id=\"拉取远程仓库的更改\">拉取远程仓库的更改</h3>\n<p>从远程仓库拉取最新的更改并合并到本地分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"克隆部分命令\">克隆部分命令</h2>\n<h3 id=\"克隆远程仓库\">克隆远程仓库</h3>\n<p>克隆一个远程仓库到本地</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;repository URL&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"STM32F103学习笔记","date":"2024-01-16T18:19:55.000Z","_content":"\n# STM32F103学习笔记\n\n## 说明\n\n本库仅供学习交流使用\n\n- 开发板: 野火霸道V2开发板\n- 编译器： ARM v5.06\n- C编译版本: C99\n- 固件库版本: V3.5.0\n- MDK version: 538A\n- 芯片包: Keil.STM32F1xx_DFP.2.4.1\n- 芯片型号: STM32F103ZET6\n- 参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道/指南者/MINI)【全】(刘火良老师出品) (无字幕)】 <https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4>\n- 仓库地址: <https://github.com/See-YouL/Fire-Projects.git>\n\n## 基础配置\n\n### 配置KeilMDK\n\n看视频配置KeilMDK,P2\n\n[看视频配置Keil MDK](https://www.bilibili.com/video/BV1yW411Y7Gw)\n\n### 配置串口下载程序\n\n看视频配置串口下载程序,P4\n\n[看视频配置串口下载程序](https://www.bilibili.com/video/BV1yW411Y7Gw)\n\n### 美化Keil界面\n\n**非必须步骤**, 用来美化界面\n\n[使用该方案的插件](https://www.bilibili.com/video/BV1uT411S7mB/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n[使用该方案的主题配色](https://www.bilibili.com/video/BV1Df4y1k75Z/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n### 配置VScode\n\n**非必须步骤**, 用来使用VScode开发, *也可使用Keil MDK则不需要该步骤*\n\n方案一: 使用VScode + Keil5 MDK进行开发(主要插件**Keil Assistant**)\n\n- 优点: 不需要使用Keil进行编辑\n- 缺点: 不具备Debug功能,只有编译和烧录\n\n[方案一参考视频](https://www.bilibili.com/video/BV19V411g7gD/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n方案二: 使用Vscode + EIDE进行开发(主要插件**EIDE**)\n\n- 优点: 可在VScode中进行调试\n- 缺点: 依赖Keil的编译环境\n\n[方案二参考视频](https://www.bilibili.com/video/BV1nr4y1R7Jb/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n## 理论知识\n\n### STM32命名方式\n\n- STM32: 32bit的MCU\n- F或L: F表示基础型(Foundation)或高性能型(High-Performance), L表示低功耗型(Ultra-low-power)\n- xxx: 芯片特性, 如性能级别、内存大小、特殊功能等\n- 系列:\n  - F0, F1, F2, F3, F4, F7：这些数字代表不同的性能级别，数字越大，性能通常越高。\n  - L0, L1, L4, L5：这些是低功耗系列，数字越大，性能和功能通常越丰富。\n- 性能级别: 通常由一到两位数字表示，如STM32F103或STM32L152。这些数字表示不同的性能级别、内存大小和外设\n- 包装类型: 通常由一个字母表示，如STM32F103C8T6中的C表示LQFP48封装\n- 额外特性: 如STM32F103C8T6中的8表示该芯片有64KB闪存，T表示温度范围（-40°C 到 85°C），6表示批次号或版本\n\n#### 例子\n\n以 STM32F103C8T6 为例：\n\n- STM32：STMicroelectronics的32位微控制器。\n- F：Foundation系列。\n- 103：该系列中的特定型号，具有特定的性能、内存和外设配置。\n- C：封装类型，这里是LQFP48。\n- 8：闪存大小，这里是64KB。\n- T：温度范围，这里是-40°C 到 85°C。\n- 6：批次号或版本。\n\n## 置位与清零\n\n- &= ~(1 << n); **将bit n清零,其他位保持不变**\n- |= (1 << n); **将bit n置1,其他位保持不变**\n\n## GPIO\n\n### GPIO简介\n\nGPIO(General purpose input output)通用输入输出端口的简称,**软件可以控制的引脚,可输入可输出**\n\n#### GPIO和引脚的区别\n\n引脚（Pin）\n\n- 定义：引脚是指微控制器、微处理器或其他电子组件上的物理接点。它们是硬件设备的一部分，用于连接电路板、传递信号或供电。\n- 通用性：引脚可以有多种功能，包括但不限于传输数据、供电、接地或作为特殊功能的接口（如模拟输入、PWM输出等）。\n- 物理特性：引脚是实体的、物理存在的，可以是金属的脚或焊盘。\n\nGPIO（General-Purpose Input/Output）\n\n- 定义：GPIO是指在微控制器或其他数字电路设备上的一种特定类型的引脚，可以通过编程设置为输入或输出模式。\n- 功能：GPIO引脚的功能非常灵活，可以用于读取数字信号（如按钮的按压）或输出数字信号（如控制LED灯的开关）。\n- 编程控制：GPIO引脚的主要特点是它们可以通过软件编程来控制其行为，这使得它们非常适合于各种通用的数字输入输出任务。\n\n区别\n\n- 功能范围：所有GPIO都是引脚，但并非所有引脚都是GPIO。引脚是一个更广泛的概念，包括GPIO以及其他专用功能的引脚。\n- 灵活性和用途：GPIO引脚特别设计用于通用的数字输入输出任务，并且它们的行为可以通过软件编程来改变。而其他类型的引脚可能有固定的功能，如电源、接地或特定的通信功能。\n- 编程控制：GPIO的关键特性是它们可以被编程来执行不同的任务（输入或输出），而其他类型的引脚可能不具备这种灵活性。\n\n总的来说，**GPIO是引脚的一个子集，专门用于可编程的通用数字输入输出任务。而引脚是一个更广泛的概念，涵盖了电子设备上的所有物理接点。**\n\n#### 引脚的分类\n\n![引脚的分类](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png)\n\n### GPIO 框图讲解\n\n#### 保护二极管\n\n![保护二极管](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.41.14.png)\n\n- **如果引脚电压大于VDD则上面的保护二极管导通**,防止高电压进入芯片内部,如果电压过高则会烧坏二极管进而烧坏芯片\n- **如果引脚电压低于VSS则下面的保护二极管导通**,保护芯片\n\n#### 推挽输出\n\n![ODR=1时推挽输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.09.27.png)\n\n推挽输出部分的INT来自ODR寄存器\n\n若ODR为1, 经过反相器后为0, 此时PMOS和NMOS的Ug=0V\n\n对于PMOS, Us=3.3V > Ug=0V, PMOS管导通, OUT=VDD\n\n对于NMOS, Us=0V = Ug=0V, 简单认为, NMOS管截止\n\n![ODR=0时推挽输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.20.46.png)\n\n若ODR为0,经过反相器后为1, 此时PMOS和NMOS的Ug=3.3V\n\n对于PMOS, Us=3.3V = Ug=3.3V, 简单认为, PMOS管截止\n\n对于NMOS, Us=0V < Ug=3.3V, NMOS管导通, OUT=GND=0V\n\n##### 推挽输出的含义\n\n![推挽输出含义图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.23.18.png)\n\n- PMOS导通时, OUT处电流向外称为**推**, 此时电流称为**灌电流**\n- NMOS导通时, OUT处电流向里称为**挽**, 此时电流称为**拉电流**\n\n推挽输出（Push-Pull Output）是一种常见的电子电路输出类型，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的**主要特点是它使用两个晶体管（一个N型和一个P型）来控制输出引脚的电压状态。**\n\n##### 推挽输出的原理\n\n在推挽配置中，通常有两个晶体管：\n\n- N型晶体管：当被激活（或导通）时，它将输出引脚连接到地（GND），从而产生低电平（0）输出。\n- P型晶体管：当被激活时，它将输出引脚连接到正电源（VCC），从而产生高电平（1）输出。\n\n这两个晶体管不会同时导通，以避免短路。在任何给定的时刻，要么N型晶体管导通将输出拉低，要么P型晶体管导通将输出拉高。\n\n##### 推挽输出的特点\n\n- 强驱动能力：**推挽输出可以提供较强的电流驱动能力**，无论是向输出引脚提供电流（高电平）还是从引脚吸收电流（低电平）。\n- 确定的逻辑状态：输出要么明确地是高电平，要么是低电平，**不会处于悬空（高阻态）状态**。\n- 无需外部上拉或下拉电阻：由于**推挽输出自身就可以明确地驱动高电平或低电平**，因此不需要外部的上拉或下拉电阻来确保稳定的输出状态。\n\n##### 推挽输出的应用\n\n推挽输出广泛应用于各种数字电路，特别是**在需要驱动LED、继电器或其他需要较高电流的负载时**。由于其**强大的驱动能力和清晰的逻辑电平**，推挽输出是实现**数字信号传输**的理想选择。\n\n##### 推挽输出对比开漏/开集输出\n\n与推挽输出相对的是开漏（在MOSFET技术中）或开集（在双极晶体管技术中）输出，**这种类型的输出只有一个晶体管，要么将输出拉低，要么让它悬空（高阻态）**。开漏/开集输出**需要外部上拉电阻来确保高电平状态**，常用于需要多个设备共享同一输出线的应用，如I2C通信协议。\n\n#### 开漏输出\n\n内部只能输出低电平,不能输出高电平\n\n![当ODR为1时开漏输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png)\n\n 该图片标注有误, 实际用的是ODR=0时的图, 但是结构相同, 不影响分析\n\nODR=1, 经反相器为0, Vg=0V=Vs=0V, NMOS管截止, 此时OUT为高阻态悬空, 加入外部上拉电阻后, OUT=1\n\n如果外部需要高电平驱动可以通过更换外部上拉电路来进行更换\n\n![当ODR为0时开漏输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png)\n\nODR=0, 经反相器为1, Vg=1 > Vs=0, NMOS管导通, 此时OUT=0V\n\n开漏输出（Open-Drain Output，在使用MOSFET技术的情况下称为开漏，而在使用双极性晶体管的情况下称为开集（Open-Collector）输出）是一种常见的电子电路设计，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的**主要特点是它使用单个晶体管来控制输出引脚的电压状态，而不是像推挽输出那样使用两个晶体管。**\n\n##### 开漏输出的原理\n\n在开漏配置中，只有一个N型晶体管：\n\n- N型晶体管：当晶体管导通（激活）时，它将输出引脚连接到地（GND），产生低电平（0）输出。当晶体管关闭（非激活）时，输出引脚不连接到任何东西，处于悬空状态。\n- 由于输出在晶体管关闭时处于悬空状态，因此通常需要一个外部的上拉电阻连接到正电源（VCC），以确保当晶体管关闭时输出能够达到高电平（1）。\n\n##### 开漏输出的特点\n\n- 单向驱动能力：开漏输出**只能将输出拉低，不能主动驱动高电平**。\n- 需要外部上拉电阻：**为了确保输出能够达到高电平，需要外部上拉电阻**。\n- 适合于总线和共享线路：开漏输出非常**适合于多个设备共享同一输出线的应用**，因为任何一个设备都可以将线路拉低，而不会对其他设备造成干扰。\n\n##### 开漏输出的应用\n\n开漏输出**常用于需要多个设备共享同一通信线路的场合**，如I2C和1-Wire通信协议。在这些应用中，**多个设备可以连接到同一条线路上，每个设备都可以通过将线路拉低来发送信号，而不会影响其他设备。**\n\n##### 开漏输出对比推挽输出\n\n与开漏输出相对的是推挽输出，后者使用两个晶体管（一个N型和一个P型）来分别驱动高电平和低电平。推挽输出可以主动驱动高电平和低电平，而**开漏输出只能驱动低电平，需要外部上拉电阻来实现高电平状态。**\n\n#### 补充: 高阻态与悬空\n\n**高阻态（High-Impedance State），通常简称为Hi-Z**，是电子电路中的一个术语，用来描述一个电路节点在特定条件下呈现出非常高电阻的状态。在这种状态下，**电路节点既不明显地连接到电源（高电平），也不明显地连接到地（低电平）**。换句话说，这个节点处于一种“断开”或“浮空”的状态，对电路中的其他部分几乎没有任何电气影响。\n\n##### 高阻态的应用\n\n- **三态逻辑（Tri-state Logic）**：在数字电路中，高阻态常用于三态逻辑，**允许多个输出连接到同一个线路或总线上，而不会相互干扰**只有被选中的设备会将其输出置于低电阻状态（高电平或低电平），其他设备的输出则处于高阻态。\n- **总线系统**：在微处理器、微控制器和其他数字系统的总线（如数据总线、地址总线）上，高阻态用于控制哪个设备可以在特定时刻向总线发送数据。\n- **输入/输出端口**：在可编程的微控制器的GPIO（通用输入/输出）端口中，**高阻态可以用来防止未使用的或被配置为输入的端口对电路造成影响**。\n\n##### 高阻态的重要性\n\n- **避免冲突**：在多个设备共享同一通信线路时，高阻态可以防止输出冲突。\n- **节能**：当端口处于高阻态时，它几乎不消耗电流，有助于降低功耗。\n- **灵活性**：高阻态提供了电路设计的灵活性，特别是在需要多个设备共享同一资源的情况下。\n\n##### 高阻态的注意事项\n\n- **浮动电压**：当一个端口或线路处于高阻态时，它可能会因为电磁干扰或静电感应而捕获不确定的电压，**有时可能需要通过上拉或下拉电阻来确保稳定的逻辑状态**。\n- **设计考虑**：在设计电路和编写程序时，需要考虑到高阻态的影响，确保在适当的时候启用或禁用高阻态。\n\n在电子电路中，**“悬空”（Floating）是指一个电路节点没有被明确连接到电源（高电平）或地（低电平），也没有通过任何电阻或其他电子元件连接到其他电路节点的状态**这种状态下的节点电压是不确定的，因为它既不是被固定在逻辑高也不是逻辑低，而是可以随外部电磁场或附近电路的状态变化而变化。\n\n##### 悬空状态的特点\n\n- 不确定的电压：悬空的节点可能会随机地捕获周围环境的电磁干扰，导致其电压处于不确定的状态。\n- 易受干扰：由于没有明确的电气连接，悬空的节点容易受到外部电磁干扰的影响。\n- 可能导致问题：在数字电路中，悬空的输入引脚可能导致不稳定的逻辑状态，从而引发电路的不可预测行为。\n\n##### 高阻态与悬空的关系\n\n高阻态是一种特定的电路配置，**其中一个节点（如微控制器的GPIO引脚）被设置为非常高的电阻状态。这意味着该节点对电路的其他部分几乎没有电气影响，类似于断开连接**因此，**当一个引脚被设置为高阻态时，它实际上是在悬空状态**，因为它既不是明确地连接到高电平也不是低电平。\n\n##### 高阻态与悬空区别和联系\n\n- 联系：**高阻态通常会导致节点悬空**当一个节点处于高阻态时，由于其极高的电阻值，它实际上与电路的其他部分隔离，从而处于悬空状态。\n- 区别：**高阻态是一种有意设置的电路状态**，用于特定的目的（如防止总线冲突）。而**悬空可能是无意的**，可能是由于设计不当或电路未完成造成的。\n\n##### 悬空的注意事项\n\n- 设计考虑：在设计电子电路和系统时，**应避免输入引脚悬空，因为这可能导致不稳定的行为**。通常**使用上拉或下拉电阻来确保这些引脚有一个确定的逻辑状态。**\n- 高阻态应用：在某些情况下，如**多个设备共享一个通信总线，高阻态是必要的，以确保只有一个设备在任何时刻控制总线。**\n\n#### 复用功能输出\n\n![复用功能输出原理框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.18.55.png)\n\n通过片上外设如EXTI到引脚输出\n\n#### 输入模式\n\nISR读出\n\n![普通模式的输入](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.24.03.png)\n\nI/O引脚至上拉/下拉输入(通过BSRR寄存器软件配置), 经TTL肖特基触发器(>2V <1.2V), 至IDR寄存器读出\n\n复用功能输入\n\n![复用功能输入](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.29.40.png)\n\n以EXTI为例,RX数据经由TTL肖特基触发器到DR寄存器\n\n模拟输入\n\n![模拟输入框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.33.21.png)\n\n不经过TTL肖特基触发器直接被读出\n\n#### GPIO框图对应寄存器\n\n![GPIO框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.35.42.png)\n\n- 2部分: 推挽,开漏输出对应CRL,CRH寄存器\n- 3部分: 输出数据寄存器对应ODR; 位设置/清除寄存器对应BSRR\n- 上拉/下拉输入: 对应CRL,CRH,具体选择上拉还是下拉需要软件配置BSRR\n- 5部分: 输入数据寄存器对应IDR\n\n### GPIO输出初始化顺序\n\n1. 时钟使能\n2. 选择具体的GPIO\n3. 配置GPIO的工作模式(CRL CRH)\n4. 控制GPIO输出高低电平(ODR,BRR和BSRR)\n\n## 手写库\n\n### 通过地址使用寄存器\n\n项目地址: **REG-LED**\n\n#### main.c中的主要代码\n\n```c\n*(unsigned int *)(0x40021018) |= ((1) << 3); // RCC_APB2ENR的bit3置1\n/*----------------------------------------------------------------\n开启GPIOB的时钟\nGPIOB挂载在APB2总线\nRCC_APB2ENR的偏移量为0x18\nRCC的基地址为0x40021000\nRCC_APB2ENR的bit3为IOPBEN(IO端口B时钟使能) 1开启\n****************************************************************************/\n*(unsigned int *)(0x40010C00) |= ((1) << (4*0)); // GPIOB_CRL的bit4-0置0001\n/*----------------------------------------------------------------\n将GPIOB设置为推挽输出\nGPIOB 基地址 0x40010C00\nGPIOx_CRL 偏移量 00h \nbit1-0: 01 输出模式，最大速度10MHz\nbit4-3: 00 通用推挽输出模式\n((1) << (4*0)) // 若修改PB1则为(4*1)\n****************************************************************************/\n*(unsigned int *)(0x40010C0C) &= ~(1<<0); // GPIOB_ODR的bit0置0\n/*----------------------------------------------------------------\n修改PB0为1\nGPIOB 基地址 0x40010C00\nGPIOx_ODR 偏移量 0Ch \n****************************************************************************/\n```\n\n### 通过头文件定义使用寄存器\n\n项目地址: **REG-LED-Register**\n\n确定总线基地址, 其中AHB的基地址是从DMA1开始的,即从0x40020000开始\n\n#### 在stm32f10x.h中增加宏定义\n\n ```c\n// 存放stm32寄存器映射的代码\n\n// 外设 Peripheral\n#define PERIPH_BASE ((unsigned int)0x40000000)\n#define APB1PERIPH_BASE (PERIPH_BASE) // 从TIM2开始\n#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000) // 从AFIO开始\n#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000) // 从DMA1开始\n\n// RCC\n#define RCC_BASE (AHBPERIPH_BASE + 0x1000) // RCC基地址 \n\n// GPIOB\n#define GPIOB_BASE (APB2PERIPH_BASE + 0x0C00) // GPIOB基地址\n\n// 定义寄存器\n\n#define RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x18)) // APB2外设时钟使能寄存器\n#define GPIOB_CRL (*(volatile unsigned int *)(GPIOB_BASE + 0x00))// GPIOB_CRL\n#define GPIOB_CRH (*(volatile unsigned int *)(GPIOB_BASE + 0x04)) // GPIOB_CRH\n#define GPIOB_ODR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C)) // GPIOB_CRH\n ```\n\n#### 在main.c中的主函数代码改为\n\n```c\nRCC_APB2ENR |= ((1) << 3); // 开启GPIOB的时钟\nGPIOB_CRL &= ~((0x0F) << (4*0)); // 将GPIOB状态清零\nGPIOB_CRL |= ((1) << (4*0)); // 将GPIOB设置为推挽输出\nGPIOB_ODR &= ~(1<<0); // PB0置0\n```\n\n#### 补充: 关键字volatile的作用\n\n在C语言中，尤其是在嵌入式领域，volatile 关键字用于告诉编译器，**定义为 volatile 的变量可能会以编译器不可预知的方式被改变**。这意味着编译器在处理这些变量时，**应避免进行某些优化，确保每次访问都直接从内存中读取变量的值**。\n\n#### 关键字volatile含义\n\n当一个变量被声明为 volatile 时，编译器会对该变量的处理方式做出以下调整：\n\n- **防止优化**：编译器不会对这些变量进行优化，这可能包括消除看似多余的读取或写入操作。\n- **直接访问**：每次访问 volatile 变量时，都会直接从其内存地址读取数据，而不是使用可能存储在寄存器中的副本。\n\n#### 关键字volatile的应用场景\n\n在嵌入式编程中，volatile 关键字的使用场景主要包括：\n\n- **硬件寄存器访问**：当编程与硬件寄存器交互时，如读取一个传感器的数据寄存器或写入一个控制寄存器。这些寄存器的值可能会在任何时候改变，因此需要使用 volatile 来确保每次读取或写入都是最新的值。\n- **中断服务例程**：在中断服务例程（ISR）中使用的变量，这些变量可能在ISR中被改变，并在程序的其他部分被访问。使用 volatile 可以确保主程序中的代码能够看到在ISR中对这些变量所做的更改。\n- **多线程和并发**：在多线程或并发环境中，一个线程可能修改另一个线程正在访问的变量。volatile 确保每个线程都能访问到最新的值。\n\n#### 关键字volative的注意事项\n\n- **不是并发解决方案**：volatile 关键字不能替代互斥锁或其他并发控制机制。它不保证操作的原子性或内存可见性。\n- **性能影响**：由于 volatile 防止了某些优化，过度使用它可能会降低程序的性能。\n- **正确使用**：只有在上述特定场景中才应使用 volatile。错误地使用 volatile 可能会导致难以发现的错误。\n\n### 通过结构体操作寄存器\n\n项目地址: **FWlib-LED**\n\n#### 在stm32f10x.h中添加结构体定义\n\n```c\n// 定义结构体\ntypedef unsigned int uint32_t;\ntypedef unsigned short uint16_t;\n\ntypedef struct \n{\n    uint32_t CRL;\n    uint32_t CRH;\n    uint32_t IDR;\n    uint32_t ODR;\n    uint32_t BSRR;\n    uint32_t BRR;\n    uint32_t LCKR;\n}GPIO_TypeDef;\n\n#define GPIOB ((GPIO_TypeDef *)GPIOB_BASE) // 使用GPIOB->访问成员变量\n/*----------------------------------------------------------------\n若定义为 #define GPIOB (*(GPIO_TypeDef *)(GPIOB_BASE))\n则使用GPIOB.XXX来访问成员变量\n----------------------------------------------------------------*/\n```\n\n在main.c中使用GPIOB->XXX的方式来访问结构体成员(即寄存器), 主要代码如下\n\n```c\nGPIOB->CRL &= ~((0x0F) << (4*1)); // 将GPIOB状态复位\nGPIOB->CRL |= ((1) << (4*1)); // 将GPIOB设置为推挽输出\nGPIOB->ODR &= ~(1<<0); // PB0置0\n```\n\n#### 在stm32f10x.h中增加RCC的结构体定义,如下\n\n```c\ntypedef struct \n{\n    uint32_t CR;\n    uint32_t CFGR;\n    uint32_t CIR;\n    uint32_t APB2RSTR;\n    uint32_t APB1RSTR;\n    uint32_t AHBENR;\n    uint32_t APB2ENR;\n    uint32_t APB1ENR;\n    uint32_t BDCR;\n    uint32_t CSR;\n    uint32_t AHBRSTR;\n    uint32_t CFGR2;\n}RCC_Typedef;\n\n#define RCC ((RCC_Typedef*)RCC_BASE) // 使用RCC->访问成员变量\n/*----------------------------------------------------------------\n若定义为 #define RCC (*(RCC_Typedef*)RCC_Base)\n则使用RCC.XXX来访问成员变量\n----------------------------------------------------------------*/\n```\n\n#### 在main.c中通过结构体访问RCC寄存器,代码如下\n\n```c\nRCC->APB2ENR |= ((1) << 3); // 开启GPIOB的时钟\n```\n\n#### 更换LED说明\n\n由于我的开发板，PB0总是点亮蓝灯(本应该是绿灯), 以后的测试换为测试蓝灯，**PB0换为PB1进行测试**\n\n### 增加端口置位/复位函数\n\n项目地址: **FWlib-LED**\n\n增加stm32f10x_gpio.c和stm32f10x_gpio.h文件\n\n#### 在stm32f10x_gpio.c中增加置位/复位函数\n\n```c\n#include \"stm32f10x_gpio.h\"\n\n// 端口置位函数\nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t Pin)\n{\n    GPIOx->BSRR |= Pin;\n    /*----------------------------------------------------------------\n    BSRR寄存器:\n    低16位写1置1，写0不改变\n    高16位写1置0，写0不改变\n    *----------------------------------------------------------------*/\n}\n\n// 端口复位函数\nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t Pin)\n{\n    GPIOx->BRR |= Pin;\n    /*----------------------------------------------------------------\n    BRR寄存器:\n    低16位写1置0，写0不改变\n    高16位保留\n    ----------------------------------------------------------------*/\n}\n```\n\n#### 在stm32f10x_gpio.h中添加16位PIN置1的宏定义与函数声明\n\n```c\n#ifndef __STM32F10X_GPIO_H\n#define __STM32F10X_GPIO_H\n\n#include \"stm32f10x.h\"\n\n// 宏定义端口\n#define GPIO_Pin_0    ((uint16_t)0x0001)  /*!< 选择Pin0 */    //(00000000 00000001)b\n#define GPIO_Pin_1    ((uint16_t)0x0002)  /*!< 选择Pin1 */    //(00000000 00000010)b\n#define GPIO_Pin_2    ((uint16_t)0x0004)  /*!< 选择Pin2 */    //(00000000 00000100)b\n#define GPIO_Pin_3    ((uint16_t)0x0008)  /*!< 选择Pin3 */    //(00000000 00001000)b\n#define GPIO_Pin_4    ((uint16_t)0x0010)  /*!< 选择Pin4 */    //(00000000 00010000)b\n#define GPIO_Pin_5    ((uint16_t)0x0020)  /*!< 选择Pin5 */    //(00000000 00100000)b\n#define GPIO_Pin_6    ((uint16_t)0x0040)  /*!< 选择Pin6 */    //(00000000 01000000)b\n#define GPIO_Pin_7    ((uint16_t)0x0080)  /*!< 选择Pin7 */    //(00000000 10000000)b\n#define GPIO_Pin_8    ((uint16_t)0x0100)  /*!< 选择Pin8 */    //(00000001 00000000)b\n#define GPIO_Pin_9    ((uint16_t)0x0200)  /*!< 选择Pin9 */    //(00000010 00000000)b\n#define GPIO_Pin_10   ((uint16_t)0x0400)  /*!< 选择Pin10 */   //(00000100 00000000)b\n#define GPIO_Pin_11   ((uint16_t)0x0800)  /*!< 选择Pin11 */   //(00001000 00000000)b\n#define GPIO_Pin_12   ((uint16_t)0x1000)  /*!< 选择Pin12 */   //(00010000 00000000)b\n#define GPIO_Pin_13   ((uint16_t)0x2000)  /*!< 选择Pin13 */   //(00100000 00000000)b\n#define GPIO_Pin_14   ((uint16_t)0x4000)  /*!< 选择Pin14 */   //(01000000 00000000)b\n#define GPIO_Pin_15   ((uint16_t)0x8000)  /*!< 选择Pin15 */   //(10000000 00000000)b\n#define GPIO_Pin_All  ((uint16_t)0xFFFF)  /*!< 选择全部引脚*/ //(11111111 11111111)b\n/*----------------------------------------------------------------\n对于类似于GPIOx_BSRR, GPIOx_BRR寄存器通过写1来进行置位/复位操作的寄存器来说\n宏定义16位端口的1值很有必要\n----------------------------------------------------------------*/\n\n// 函数声明\nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t Pin);\nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t Pin);\n\n#endif // !__STM32F10X_GPIO\n```\n\n#### 在main.c函数中使用置位/复位函数\n\n```c\n // 增加复位/置位函数\nRCC->APB2ENR  |=  ( (1) << 3 );\nGPIOB->CRL &=  ~( (0x0f) << (4*0) );\nGPIOB->CRL |=  ( (1) << (4*0) );\nGPIO_SetBits(GPIOB,GPIO_Pin_1);\nGPIO_ResetBits( GPIOB,GPIO_Pin_1 );\n```\n\n#### 在stm32f10x.h中增加#ifndef\n\n```c\n#ifndef __STM32F10X_H\n#define __STM32F10X_H\n\n// 中间代码省略\n\n#endif // !__STM32F10X_H\n```\n\n#### 补充: 在C语言中#ifndef的作用\n\n在C语言中，#ifndef 是一种预处理指令，用于条件编译。它的全称是 \"if not defined\"，意思是“如果没有定义”。#ifndef 通常与 #define 和 #endif 一起使用，**用于防止头文件的内容被多次包含（重复包含）**。\n\n##### ifndef的作用\n\n\"#ifndef\"的主要作用是**确保一个头文件中的内容只被包含一次，防止因重复包含同一头文件而导致的编译错误**这种技术被称为“包含卫士”（Include Guards）或“头文件卫士”（Header Guards）。\n\n##### ifndef的使用方式\n\n一个典型的使用 #ifndef 的例子如下：\n\n```c\n// 假设这是一个头文件 example.h\n\n#ifndef EXAMPLE_H    // 如果没有定义 EXAMPLE_H\n#define EXAMPLE_H    // 定义 EXAMPLE_H\n\n// 头文件的内容\nvoid someFunction();\n// 更多的声明...\n\n#endif // 结束 #ifndef\n```\n\n在这个例子中：\n\n1. 当编译器首次遇到 example.h 时，EXAMPLE_H 还没有被定义，所以编译器会处理 #define EXAMPLE_H 和随后的头文件内容。\n2. 如果同一源文件或其他包含了 example.h 的文件再次尝试包含 example.h，EXAMPLE_H 已经被定义了，因此 #ifndef EXAMPLE_H 条件失败，编译器将跳过文件的其余部分，防止重复包含。\n\n##### ifndef的重要性\n\n在C语言项目中，特别是在大型项目中，头文件经常被多个源文件包含，或者一个头文件包含其他头文件。如果没有包含卫士，头文件中的定义（如函数声明、宏定义、类型定义等）可能会被重复包含，导致编译错误（如重复定义错误）。使用 #ifndef 可以有效地避免这种情况。\n\n#### 补充: 使用#ifndef命名使用双下划线说明\n\n在C语言中，当使用 #ifndef（和 #define、#endif）作为头文件的包含卫士时，通常会在文件名前加上双下划线 __ 或其他类似的前缀/后缀，**这是一种非正式的约定，用于减少命名冲突的风险**然而，需要注意的是，**使用双下划线作为前缀或后缀在某些情况下可能并不是最佳实践**。\n\n##### 使用双下划线的原因\n\n- **唯一性**：在大型项目中，可能会有许多不同的头文件。使用文件名作为宏的一部分可以帮助确保每个包含卫士的宏是唯一的。\n- **减少冲突**：添加额外的字符（如双下划线）可以进一步减少不同头文件之间宏名称冲突的可能性。\n\n##### 使用双下划线的注意事项\n\n**保留标识符**：根据C和C++标准，**以双下划线开头或以单下划线后跟大写字母开头的标识符是保留给实现（编译器和标准库）使用的**。因此，使用这样的标识符作为宏名称**可能会导致与标准库或编译器的内部标识符冲突**。\n\n建议的做法：更安全的做法是**使用文件名的大写形式加上一个后缀（如 _H），而不是使用双下划线**。例如，对于 example.h 头文件，可以使用 EXAMPLE_H 作为包含卫士的宏。\n\n##### 示例\n\n```c\n#ifndef EXAMPLE_H    // 更安全的做法\n#define EXAMPLE_H\n\n// 头文件内容\n\n#endif // EXAMPLE_H\n```\n\n总之，**虽然在文件名前加上双下划线是一种常见做法，但为了避免与编译器或标准库的内部标识符冲突，建议使用其他方法来确保宏名称的唯一性和安全性**。\n\n### 增加GPIO初始化结构体\n\n项目地址: **FWlib-LED**\n\n配置GPIO工作模式的宏定义(GPIOMode_TypeDef)参考下图\n\n![GPIO工作模式图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202312301523539.png)\n\n实际写入寄存器的是bit3-0,bit7-4并不写入寄存器\n\n勘误：上拉输入和下拉输入两行的bit3-2应该为10\n\n- bit1-0: 置0, 配置输出速度，通过GPIOSpeed_TypeDef进行覆盖配置\n- bit3-2: 配置输入/输出模式\n- bi4: **不写入寄存器**, 用来标志是输入还是输出\n- bit6-5: **不写入寄存器**， 用来判断是上拉输入还是下拉输入\n- bit7: **不写入寄存器**\n\n#### 在stm32f10x_gpio.h中增加宏定义\n\n```c\n// 通过枚举 限定GPIO_Speed的选择\ntypedef enum\n{\n    GPIO_Speed_10MHZ = 1, // 01 输出模式，最大速度10MHz\n    GPIO_Speed_2MHZ, // 10 输出模式，最大速度2MHz\n    GPIO_Speed_50MHZ // 11 输出模式，最大速度50MHz\n}GPIOSpeed_TypeDef;\n\n// 通过枚举限定GPIO_Mode的选择\ntypedef enum\n{ GPIO_Mode_AIN = 0x0,           // 模拟输入     (0000 0000)b\n  GPIO_Mode_IN_FLOATING = 0x04,  // 浮空输入     (0000 0100)b\n  GPIO_Mode_IPD = 0x28,          // 下拉输入     (0010 1000)b\n  GPIO_Mode_IPU = 0x48,          // 上拉输入     (0100 1000)b\n  \n  GPIO_Mode_Out_OD = 0x14,       // 开漏输出     (0001 0100)b\n  GPIO_Mode_Out_PP = 0x10,       // 推挽输出     (0001 0000)b\n  GPIO_Mode_AF_OD = 0x1C,        // 复用开漏输出 (0001 1100)b\n  GPIO_Mode_AF_PP = 0x18         // 复用推挽输出 (0001 1000)b\n}GPIOMode_TypeDef;\n\n// 定义GPIO初始化结构体\ntypedef struct\n{\n    uint16_t GPIO_Pin;\n    uint16_t GPIO_Speed;\n    uint16_t GPIO_Mode;\n}GPIO_InitTypeDef;\n\nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);\n```\n\n#### 在stm32f10x_gpio.c中写入GPIO初始化函数\n\n该函数是从库函数中复制得到\n\n```c\n// GPIO初始化函数\nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)\n{\n  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;\n  uint32_t tmpreg = 0x00, pinmask = 0x00;\n  \n/*---------------------- GPIO 模式配置 --------------------------*/\n  // 把输入参数GPIO_Mode的低四位暂存在currentmode\n  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);\n \n  // bit4是1表示输出，bit4是0则是输入 \n  // 判断bit4是1还是0，即首选判断是输入还是输出模式\n  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)\n  { \n    // 输出模式则要设置输出速度\n    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;\n  }\n/*-------------GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- -------*/\n  // 配置端口低8位，即Pin0~Pin7\n  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)\n  {\n    // 先备份CRL寄存器的值\n    tmpreg = GPIOx->CRL;\n  \n    // 循环，从Pin0开始配对，找出具体的Pin\n    for (pinpos = 0x00; pinpos < 0x08; pinpos++)\n    {\n      // pos的值为1左移pinpos位\n      pos = ((uint32_t)0x01) << pinpos;\n      \n      // 令pos与输入参数GPIO_PIN作位与运算，为下面的判断作准备\n      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;\n   \n      //若currentpin=pos,则找到使用的引脚\n      if (currentpin == pos)\n      {\n        // pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚\n        pos = pinpos << 2;\n       //把控制这个引脚的4个寄存器位清零，其它寄存器位不变\n        pinmask = ((uint32_t)0x0F) << pos;\n        tmpreg &= ~pinmask;\n    \n        // 向寄存器写入将要配置的引脚的模式\n        tmpreg |= (currentmode << pos);  \n    \n        // 判断是否为下拉输入模式\n        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)\n        {\n          // 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0\n          GPIOx->BRR = (((uint32_t)0x01) << pinpos);\n        }    \n        else\n        {\n          // 判断是否为上拉输入模式\n          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)\n          {\n            // 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1\n            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);\n          }\n        }\n      }\n    }\n  // 把前面处理后的暂存值写入到CRL寄存器之中\n    GPIOx->CRL = tmpreg;\n  }\n/*-------------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----------*/\n  // 配置端口高8位，即Pin8~Pin15\n  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)\n  {\n    // 先备份CRH寄存器的值\n    tmpreg = GPIOx->CRH;\n  \n    // 循环，从Pin8开始配对，找出具体的Pin\n    for (pinpos = 0x00; pinpos < 0x08; pinpos++)\n    {\n      pos = (((uint32_t)0x01) << (pinpos + 0x08));\n   \n      // pos与输入参数GPIO_PIN作位与运算\n      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);\n   \n      //若currentpin=pos,则找到使用的引脚\n      if (currentpin == pos)\n      {\n        //pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚\n        pos = pinpos << 2;\n        \n        //把控制这个引脚的4个寄存器位清零，其它寄存器位不变\n        pinmask = ((uint32_t)0x0F) << pos;\n        tmpreg &= ~pinmask;\n    \n        // 向寄存器写入将要配置的引脚的模式\n        tmpreg |= (currentmode << pos);\n        \n        // 判断是否为下拉输入模式\n        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)\n        {\n          // 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0\n          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));\n        }\n         // 判断是否为上拉输入模式\n        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)\n        {\n          // 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1\n          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));\n        }\n      }\n    }\n    // 把前面处理后的暂存值写入到CRH寄存器之中\n    GPIOx->CRH = tmpreg;\n  }\n}\n```\n\n#### 在main.c中使用GPIO初始化函数\n\n```c\nGPIO_InitTypeDef GPIO_InitStructure;\nGPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\nGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;\nGPIO_Init(GPIOB, &GPIO_InitStructure);\n```\n\n### 增加宏定义来增强代码可移植性\n\n项目地址： **FWlib-LED**\n\n#### 在main.c中增加宏定义\n\n```c\n#define LED_B_GPIO_PORT GPIOB\n#define LED_B_GPIO_CLK_ENABLE (RCC->APB2ENR |= ((1) << 3)) \n#define LED_B_GPIO_PIN GPIO_Pin_0\n```\n\n在main.c中增加延时函数，实现LED闪烁\n\n```c\nvoid Delay(uint32_t count)\n{\n  for( ; count != 0; count-- )\n  {\n    ;\n  }\n}\n```\n\n#### 在main.c中使用宏定义后的代码实现LED闪烁\n\n```c\n// 增加宏定义以增强代码可移植性\nLED_B_GPIO_CLK_ENABLE;\nGPIO_InitTypeDef GPIO_InitStructure;\nGPIO_InitStructure.GPIO_Pin = LED_B_GPIO_PIN;\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\nGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;\nGPIO_Init(GPIOB, &GPIO_InitStructure);\n\nwhile(1)\n{\n  GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); // PB1置1 蓝灯灭\n  Delay(0xFFFF);\n  GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); // PB1置0 蓝灯亮\n  Delay(0xFFFF);\n}\n```\n\n## 固件库编程\n\n### STM32固件库文件分析\n\n1. 汇编编写的启动文件 startup_stm32f10x_h.s: 设置堆栈指针,设置PC指针，初始化中断向量表，配置系统时钟，调用C库函数_main最终去C的世界\n2. 时钟配置文件 system_stm32f10x.c: 把外部时钟HSE=8M，经过PLL倍频成72M\n3. 外设相关\n   - stm32f10x.h: 实现了内核之外的外设的寄存器映射\n   - xx: GPIO, USART, I2C\n   - stm32f10x_xx.c: 外设的驱动函数库文件\n   - stm32f10x_xx.h: 存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库的头文件声明\n4. 内核相关\n   - CMSIS: Cortex微控制器软件接口标准\n   - core_cm3.h: 实现了内核里面外设的寄存器映射\n   - core_cm3.c: 内核外设的驱动固件库\n   - NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器), misc.h, misc.c\n5. 头文件的配置文件 stm32f10x_conf.h里面包含\n   - stm32f10x_usar.c\n   - stm32f10x_i2c.h\n   - stm32f10x_spi.h\n   - stm32f10x_adc.h\n   - stm32f10x_fsmc.h\n6. 专门存放终端服务函数的C文件(可以放在其他地方，不一定要放在stm32f10x_it.c中)\n   - stm32f10x_it.c\n   - stm32f10x_it.h\n\n### 新建固件库版本工程\n\n项目地址: **Fwlib-Template**\n\n- Doc: 用来存放程序说明的文件，由写程序的人添加\n- Libraries: 存放库文件\n- Project: 存放工程\n- User: 用户编写的驱动文件\n\n其余按照视频配置，P18, 视频链接: [按照P18进行库移植](https://www.bilibili.com/video/BV1yW411Y7Gw/?p=18&share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n### GPIO输出-使用固件库点亮LED\n\n项目地址: **12-GPIO输出-使用固件库点亮LED**\n\n在User目录下新建led文件夹，添加bsp_led.c和bsp_led.h\n\n#### 在bsp_led.h中添加所使用的宏定义和函数声明\n\n```c\n#ifndef __BSP_LED_H\n#define __BSP_LED_H\n\n#include \"stm32f10x.h\"\n\n// 宏定义\n#define LED_B_GPIO_PIN GPIO_Pin_1 // stm32f10x_gpio.h中定义\n#define LED_B_GPIO_PORT GPIOB // stm32f10x.h中定义 \n#define LED_B_GPIO_CLK RCC_APB2Periph_GPIOB\n\n// 函数声明\nvoid LED_GPIO_Config(void);\n\n#endif // !__BSP_LED_H\n```\n\n#### 在bsp_led.c中添加初始化函数\n\n```c\n// bsp: board support package 板级支持包\n#include \"bsp_led.h\"\n\nvoid LED_GPIO_Config(void)\n{\n    RCC_APB2PeriphClockCmd(LED_B_GPIO_CLK, ENABLE);\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.GPIO_Pin = LED_B_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(LED_B_GPIO_PORT, &GPIO_InitStruct);\n}\n```\n\n#### 在main.c中调用初始化函数，并进行软件延时，实现LED闪烁\n\n```c\n#include \"stm32f10x.h\"\n#include \"bsp_led.h\"\n\nvoid Delay(uint32_t count)\n{\n    for( ; count != 0; count--)\n    {\n        uint32_t current;\n        for(current = count; current != 0; current--)\n        {\n            ;\n        }\n    }\n    \n}\n\nint main(void)\n{\n    LED_GPIO_Config();\n\n    while(1)\n    {\n        GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);\n        Delay(0xFFF); // 延时\n        GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);\n        Delay(0xFFF); // 延时\n    }\n}\n```\n\n#### 在bsp_led.h中增加函数宏定义\n\n```c\n#define ON 1 \n#define OFF 0\n#define LED_B(a) if (a)\\\n                     GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); \\\n                     else\\\n                     GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);\n// 使用\\可以进行换行，其后不能跟空格，\\后应该直接回车\n```\n\n#### 在main.c中使用宏定义的函数\n\n```c\nLED_B(OFF);\nDelay(0xFFF); // 延时\nLED_B(ON);\nDelay(0xFFF); // 延时\n```\n\n#### 补充: C语言反斜杠\\换行\n\n在C语言中使用反斜杠 \\ 进行换行时，确实有一些需要注意的事项。这种用法通常出现在宏定义或是将长代码行分割为多行以提高代码的可读性。正确使用时，\\ 应该放在行尾，紧接着是换行符。\n\n##### C语言反斜杠\\换行的注意事项\n\n- **无空格**：在行尾使用 \\ 时，它之后直到行末不能有任何字符，包括空格或制表符。任何在 \\ 之后的空格都会使得换行转义失效，导致编译错误。\n- **紧跟换行符**：\\ 应该直接紧跟换行符。这告诉编译器忽略换行符，将下一行视为当前行的延续。\n- **可读性**：虽然使用 \\ 可以将长代码行分割为多行，但过度使用可能会降低代码的可读性。适当使用，以保持代码整洁和可维护。\n- **宏定义中的使用**：在宏定义中使用 \\ 进行换行是常见的做法，**因为宏定义必须是单行的**。在这种情况下，确保每一行（除了最后一行）都以 \\ 结尾。\n\n##### C语言反斜杠\\换行的示例\n\n正确的使用：\n\n```c\n#define MY_MACRO(a, b) \\\n    do { \\\n        a = 2; \\\n        b = 3; \\\n    } while(0)\n\nint main() {\n    int x, y;\n    MY_MACRO(x, y);\n    return 0;\n}\n```\n\n在这个例子中，宏 MY_MACRO 被分成了多行，每行的末尾都使用了 \\ 来实现。\n\n错误的使用（如果 \\ 后有空格）：\n\n```c\n#define MY_MACRO(a, b) \\ \n    do { \\\n        a = 2; \\\n        b = 3; \\\n    } while(0)\n```\n\n在这个错误的例子中，**第一行的 \\ 后面如果有空格，将导致编译错误**。\n\n总之，当在C语言中使用 \\ 进行换行时，**确保 \\ 是每行的最后一个字符，并且紧接着换行符**，以避免编译错误并保持代码的清晰\n\n### GPIO输入\n\n项目地址: **13-GPIO输入-按键检测**\n\n通过原理图可知**KEY1接PA0口, 按键按下后为高电平**, 原理图如下\n\n![KEY1原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401011723631.png)\n\n实现**按下KEY1后蓝灯状态翻转**\n\n#### 在bsp_led.h中宏定义电平翻转函数\n\n```c\n#define LED_B_TOGGLE {LED_B_GPIO_PORT->ODR ^= LED_B_GPIO_PIN;}\n/*----------------------------------------------------------------\n^= 异或运算 (a ^ b) 则ab不同为1，相同则为0\nODR低16位和GPIO_Pin_1作异或并重新赋值给ODR可实现ODR的Bit0翻转\n若Bit0=1则Bit0 = 1 ^ 1 = 0, 下一次运算时, Bit0=0则Bit0 = 0^1 = 1\n实际上是ODR的Bit0在和1进行异或操作\n----------------------------------------------------------------*/\n```\n\n#### 在bsp_key.h中进行宏定义和函数声明\n\n```c\n#ifndef __BSP_KEY_H\n#define __BSP_KEY_H\n\n#include \"stm32f10x.h\"\n\n#define KEY_ON 1\n#define KEY_OFF 0\n\n// 宏定义\n#define KEY1_GPIO_PIN GPIO_Pin_0 // stm32f10x_gpio.h中定义\n#define KEY1_GPIO_PORT GPIOA // stm32f10x.h中定义 \n#define KEY1_GPIO_CLK RCC_APB2Periph_GPIOA\n\n// 函数声明\nvoid KEY_GPIO_Config(void);\nuint8_t Key_Scan(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);\n\n#endif // !__BSP_KEY_H\n```\n\n#### 在bsp_key.c中写初始化函数和端口扫描函数\n\n```c\n#include \"bsp_key.h\"\n\nvoid KEY_GPIO_Config(void)\n{\n    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(KEY1_GPIO_PORT, &GPIO_InitStruct);\n}\n\n// 端口扫面函数 检测按下返回1，否则返回0\nuint8_t Key_Scan(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\n{\n    if(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)\n    {\n        while(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)\n        {\n            ;\n        }\n\n        return KEY_ON;\n    }\n    else\n    {\n        return KEY_OFF;\n    }\n    \n}\n\n```\n\n#### 在main.c中进行调用\n\n```c\nint main(void)\n{\n    LED_GPIO_Config();\n    KEY_GPIO_Config();\n\n    while(1)\n    {\n        if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)\n        {\n            LED_B_TOGGLE;\n        }\n    }\n}\n```\n\n#### 补充: C语言中的异或操作\n\n在C语言中，异或运算是一种基本的位运算，使用符号 ^ 表示。**异或运算符对两个操作数的对应位进行比较，如果两个相应的位不同，则结果为1，如果相同，则结果为0**换句话说，它在以下情况下返回1：\n\n- 第一个操作数的位是0，第二个操作数的位是1。\n- 第一个操作数的位是1，第二个操作数的位是0。\n\n##### C语言异或运算的特性\n\n- 交换律：a ^ b 等于 b ^ a。\n- 结合律：(a ^ b) ^ c 等于 a ^ (b ^ c)。\n- 自反性：任何数与自身异或的结果都是0，即 a ^ a 等于 0。\n- 与0的异或：任何数与0异或都等于它本身，即 a ^ 0 等于 a。\n\n##### C语言异或操作的应用\n\n异或运算在C语言编程中有多种应用：\n\n**值交换**：不使用临时变量交换两个变量的值。\n\n```c\na = a ^ b;\nb = a ^ b;\na = a ^ b;\n```\n\n这种方法虽然巧妙，但**在实际编程中不常用**，因为如果 a 和 b 指向同一内存位置，这会导致结果为0。\n\n**反转特定位**：可以使用异或运算来反转数值中的特定位。\n\n```c\nx = x ^ (1 << n);  // 反转x的第n位\n```\n\n**检查奇偶性**：通过检查数的最低位是否为1，可以使用异或运算来快速检查一个数是奇数还是偶数。\n\n**加密和解密**：由于异或运算的自反性，它可以用于简单的加密和解密操作。\n\n##### C语言异或操作的示例\n\n```c\n#include <stdio.h>\n\nint main() {\n    unsigned int a = 5;  // 二进制: 0101\n    unsigned int b = 3;  // 二进制: 0011\n\n    // 执行异或运算\n    unsigned int result = a ^ b;  // 结果是 6，二进制: 0110\n\n    printf(\"Result = %d\\n\", result);\n    return 0;\n}\n\n```\n\n在这个例子中，5（二进制0101）和3（二进制0011）进行异或运算的结果是6（二进制0110），因为每一位都被相应地比较并计算出结果。\n\n## 位带操作\n\n### 位带简介\n\nCortex-M3微控制器，作为ARM的Cortex-M系列的一部分，提供了位带（Bit-banding）功能，**这是一种允许对单个位进行原子读写操作的机制**。这种功能在需要精确控制或原子性操作单个位的场合非常有用，例如在多任务环境中操作共享资源。\n\n在 CM3 中，有两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，**它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个 32 位的字**。\n\n![位带地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021935413.png)\n\n在CM3权威指南CnR2中**支持位带操作的两个内存区的范围**如下\n\n![内存区范围](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021941642.png)\n\n### 位带操作的原理\n\n位带操作在Cortex-M3中是**通过将一个较大的地址空间（位带区域）映射到一个较小的地址空间（位带别名区域）来实现的**。在Cortex-M3中，有两个主要的位带区域：\n\n1. SRAM位带区域：通常用于内存中的变量。\n2. 外设位带区域：用于外设寄存器。\n\n每个位带区域的一个字（32位）对应主存储区的一个位。这意味着，通过写入位带区域的地址，你可以设置或清除主存储区相应位的值。\n\n### 位带操作的地址映射\n\n位带操作的地址映射通常遵循以下规则：\n\n位带别名地址 = 位带基地址 + (字节偏移量 x 32) + (位编号 x 4)\n\n其中，**字节偏移量是目标地址相对于位带区域基地址的偏移量**，**位编号是要操作的位**。\n\n### 位带操作的示例\n\n假设有一个外设寄存器的地址为 0x40000000，我们要设置这个寄存器的第2位。首先，我们需要计算这个位在位带别名区域中的地址。\n\n假设外设位带区域的基地址是 0x42000000，那么：\n\n- 字节偏移量 = 0x40000000 - 0x40000000 = 0x00000000\n- 位编号 = 2\n- 位带别名地址 = 0x42000000 + (0x00000000 x 32) + (2 x 4) = 0x42000008\n\n然后，你可以直接写入这个位带别名地址来设置或清除该位：\n\n```c\n#define BITBAND_PERIPH(address, bit) ((void*)(0x42000000 + ((address) - 0x40000000) * 32 + (bit) * 4))\n\nunsigned int *alias_address = (unsigned int *)BITBAND_PERIPH(0x40000000, 2);\n*alias_address = 1;  // 设置第2位, 将第二位值设置为1\n```\n\n### 位带操作的注意事项\n\n- 硬件支持：确保你的Cortex-M3微控制器支持位带操作。\n- 地址计算：正确的地址计算对于位带操作至关重要。\n- 原子操作：位带操作是原子的，这意味着在多任务或中断驱动的环境中，它们是安全的。\n\n### 使用位带操作实现GPIO的输出和输入\n\n项目地址: **14-位带操作-GPIO的输出和输入**\n\n使用位带操作实现GPIO输出: LED_B的闪烁\n\n#### 在main.c中添加位带操作的宏定义\n\n```c\n#define GPIOB_ODR_Addr (GPIOB_BASE+0x0C)\n#define PBout(n) *(unsigned int*)((GPIOB_ODR_Addr&0xF0000000) + 0x02000000 + ((GPIOB_ODR_Addr&0x00FFFFFF)<<5)+(n<<2))\n```\n\n#### 在main.c中使用位带操作点灯\n\n```c\nwhile(1)\n{\n    PBout(1) = 1;\n    Delay(0xFFF); // 延时\n    PBout(1) = 0;\n    Delay(0xFFF); // 延时\n}\n```\n\n使用位带操作实现GPIO输入: KEY1和KEY2控制LED_B状态翻转\n\n#### 在bsp_key.h中添加KEY2的宏定义\n\n```c\n#define KEY2_GPIO_PIN GPIO_Pin_13 // stm32f10x_gpio.h中定义\n#define KEY2_GPIO_PORT GPIOC // stm32f10x.h中定义 \n#define KEY2_GPIO_CLK RCC_APB2Periph_GPIOC\n```\n\n#### 在bsp.c中增加KEY2的GPIO初始化\n\n```c\nvoid KEY_GPIO_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStruct;\n\n    // KEY1 初始化\n    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);\n    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(KEY1_GPIO_PORT, &GPIO_InitStruct);\n\n    // KEY2 初始化\n    RCC_APB2PeriphClockCmd(KEY2_GPIO_CLK, ENABLE);\n    GPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(KEY2_GPIO_PORT, &GPIO_InitStruct);\n}\n```\n\n#### 在main.c中添加GPIO输入位带操作的宏定义\n\n```c\n#define GPIOA_IDR_Addr (GPIOA_BASE+0x08)\n#define GPIOC_IDR_Addr (GPIOC_BASE+0x08)\n#define PAin(n) *(unsigned int*)((GPIOA_IDR_Addr&0xF0000000) + 0x02000000 + ((GPIOA_IDR_Addr&0x00FFFFFF)<<5)+(n<<2))\n#define PCin(n) *(unsigned int*)((GPIOC_IDR_Addr&0xF0000000) + 0x02000000 + ((GPIOC_IDR_Addr&0x00FFFFFF)<<5)+(n<<2))\n```\n\n#### 在main.c中测试LED闪烁\n\n```c\nwhile(1)\n{\n    if(PAin(0) == KEY_ON)\n    {\n        Delay(0xFFF); // 加入软件消抖后可正常运行\n        while(PAin(0) == KEY_ON) // 等待按键释放\n        {\n            ;\n        }\n        LED_B_TOGGLE;\n    }\n\n    if(PCin(13) == KEY_ON)\n    {\n        Delay(0xFFF); // 加入软件消抖后可正常运行\n        while(PCin(13) == KEY_ON) // 等待按键释放\n        {\n            ;\n        }\n        LED_B_TOGGLE;\n    }\n}\n```\n\n## 启动文件详解\n\n```assembly\n;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************\n;* File Name          : startup_stm32f10x_hd.s\n;* Author             : MCD Application Team\n;* Version            : V3.5.0\n;* Date               : 11-March-2011\n;* Description        : STM32F10x High Density Devices vector table for MDK-ARM \n;*                      toolchain. \n;*                      This module performs:\n;*                      - Set the initial SP \n;                       初始化堆栈指针\n;*                      - Set the initial PC == Reset_Handler \n;                       初始化PC指针 == Reset_Handler程序\n;*                      - Set the vector table entries with the exceptions ISR address \n;                       初始化中断向量表\n;*                      - Configure the clock system and also configure the external \n;*                        SRAM mounted on STM3210E-EVAL board to be used as data \n;*                        memory (optional, to be enabled by user) \n;                       配置系统时钟\n;*                      - Branches to __main in the C library (which eventually\n;*                        calls main()). \n;                       调用C库函数, 最终去到C的世界\n;*                      After Reset the CortexM3 processor is in Thread mode,\n;*                      priority is Privileged, and the Stack is set to Main.\n;* <<< Use Configuration Wizard in Context Menu >>>   \n;*******************************************************************************\n; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n;*******************************************************************************\n\n;****************************************************************************\n;* 1- 栈的配置\n;****************************************************************************\n\n; Amount of memory (in bytes) allocated for Stack\n; Tailor this value to your application needs\n; <h> Stack Configuration \n;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>\n; </h>\n; 配置栈: 用于变量存储(局部/全局), 函数调用\n\nStack_Size      EQU     0x00000400 \n; 宏定义的伪指令，相当于等于，类似与 C 中的 define。\n; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小\n\n                AREA    STACK, NOINIT, READWRITE, ALIGN=3\n                ; 告诉汇编器汇编一个新的代码段或者数据段。\n                ; STACK 表示段名，这个可以任意命名\n                ; NOINIT 表示不初始化\n                ; READWRITE 表示可读可写\n                ; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐\nStack_Mem       SPACE   Stack_Size\n__initial_sp\n; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。\n; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长\n的。 \n                                                  \n;****************************************************************\n;* 2-堆的配置\n;****************************************************************\n\n; <h> Heap Configuration\n;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>\n; </h>\n; 配置堆: 主要用于动态内存的分配, 如malloc()函数\n\nHeap_Size       EQU     0x00000200\n; 将0x00000200命名为Heap_Size, 0x00000200为512Type\n\n                AREA    HEAP, NOINIT, READWRITE, ALIGN=3\n                ; 汇编数据段\n                ; 名字叫HEAP\n                ; 不初始化\n                ; 可读可写\n                ; 2^3即8字节对齐\n__heap_base\nHeap_Mem        SPACE   Heap_Size\n__heap_limit\n; __heap_base 表示对的起始地址\n; SPACE 分配大小为Heap_Size即512字节的内存空间\n; __heap_limit 表示堆的结束地址\n; 堆是由低向高生长的，跟栈的生长方向相反。\n\n                PRESERVE8\n                ; 指定当前文件的堆栈按照 8 字节对齐\n                THUMB\n                ; 表示后面指令兼容 THUMB 指令\n\n;****************************************************************\n;* 3-初始化中断向量表\n;****************************************************************\n\n; Vector Table Mapped to Address 0 at Reset\n                AREA    RESET, DATA, READONLY\n                ; 区域名称为RESET\n                ; 区域类型为DATA, 与CODE相对,后者用于包含可执行指令\n                ; 区域属性为只读\n                EXPORT  __Vectors\n                EXPORT  __Vectors_End\n                EXPORT  __Vectors_Size\n                ; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用\n\n__Vectors       DCD     __initial_sp               ; Top of Stack ; 栈顶地址\n                DCD     Reset_Handler              ; Reset Handler ; 复位程序地址\n                DCD     NMI_Handler                ; NMI Handler\n                DCD     HardFault_Handler          ; Hard Fault Handler\n                DCD     MemManage_Handler          ; MPU Fault Handler\n                DCD     BusFault_Handler           ; Bus Fault Handler\n                DCD     UsageFault_Handler         ; Usage Fault Handler\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     SVC_Handler                ; SVCall Handler\n                DCD     DebugMon_Handler           ; Debug Monitor Handler\n                DCD     0                          ; Reserved\n                DCD     PendSV_Handler             ; PendSV Handler\n                DCD     SysTick_Handler            ; SysTick Handler\n\n                ; External Interrupts\n                DCD     WWDG_IRQHandler            ; Window Watchdog\n                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect\n                DCD     TAMPER_IRQHandler          ; Tamper\n                DCD     RTC_IRQHandler             ; RTC\n                DCD     FLASH_IRQHandler           ; Flash\n                DCD     RCC_IRQHandler             ; RCC\n                DCD     EXTI0_IRQHandler           ; EXTI Line 0\n                DCD     EXTI1_IRQHandler           ; EXTI Line 1\n                DCD     EXTI2_IRQHandler           ; EXTI Line 2\n                DCD     EXTI3_IRQHandler           ; EXTI Line 3\n                DCD     EXTI4_IRQHandler           ; EXTI Line 4\n                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1\n                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2\n                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3\n                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4\n                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5\n                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6\n                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7\n                DCD     ADC1_2_IRQHandler          ; ADC1 & ADC2\n                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX\n                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0\n                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1\n                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE\n                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5\n                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break\n                DCD     TIM1_UP_IRQHandler         ; TIM1 Update\n                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation\n                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare\n                DCD     TIM2_IRQHandler            ; TIM2\n                DCD     TIM3_IRQHandler            ; TIM3\n                DCD     TIM4_IRQHandler            ; TIM4\n                DCD     I2C1_EV_IRQHandler         ; I2C1 Event\n                DCD     I2C1_ER_IRQHandler         ; I2C1 Error\n                DCD     I2C2_EV_IRQHandler         ; I2C2 Event\n                DCD     I2C2_ER_IRQHandler         ; I2C2 Error\n                DCD     SPI1_IRQHandler            ; SPI1\n                DCD     SPI2_IRQHandler            ; SPI2\n                DCD     USART1_IRQHandler          ; USART1\n                DCD     USART2_IRQHandler          ; USART2\n                DCD     USART3_IRQHandler          ; USART3\n                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10\n                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line\n                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend\n                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break\n                DCD     TIM8_UP_IRQHandler         ; TIM8 Update\n                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation\n                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare\n                DCD     ADC3_IRQHandler            ; ADC3\n                DCD     FSMC_IRQHandler            ; FSMC\n                DCD     SDIO_IRQHandler            ; SDIO\n                DCD     TIM5_IRQHandler            ; TIM5\n                DCD     SPI3_IRQHandler            ; SPI3\n                DCD     UART4_IRQHandler           ; UART4\n                DCD     UART5_IRQHandler           ; UART5\n                DCD     TIM6_IRQHandler            ; TIM6\n                DCD     TIM7_IRQHandler            ; TIM7\n                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1\n                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2\n                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3\n                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 & Channel5\n__Vectors_End\n; _Vectors 为向量表起始地址，__Vectors_End 为向量表结束地址\n; 向量表中，DCD 分配了一堆内存，并且以 ESR 的入口地址初始化它们 \n\n__Vectors_Size  EQU  __Vectors_End - __Vectors\n; 向量表的大小为结束地址减去起始地址\n\n                AREA    |.text|, CODE, READONLY\n                ; 定义一个名称为.text 的代码段，只读\n                \n;****************************************************************\n;* 4-复位程序\n;****************************************************************\n\n; Reset handler\nReset_Handler   PROC\n                EXPORT  Reset_Handler             [WEAK]\n                ; WEAK 表示弱定义, 如果在其他地方定义了Reset_Handler就使用其他地方的定义\n                ; 可以理解为C++中的\"可以重载\"\n                IMPORT  __main\n                IMPORT  SystemInit\n                ;表示 SystemInit和 __main 这两个函数均来自外部的文件\n\n                LDR     R0, =SystemInit\n                ; 把SystemInit的地址加载到R0中\n                BLX     R0               \n                ; 跳转到R0执行, 执行完毕后返回\n                LDR     R0, =__main\n                ; 把__main的地址加载到R0中\n                BX      R0\n                ; 跳转到R0执行, 执行完毕后不返回\n                ENDP\n                \n;****************************************************************\n;* 5-中断服务函数\n;****************************************************************\n\n; Dummy Exception Handlers (infinite loops which can be modified)\n; 中断服务函数均跳转到无限循环\n; 目的是用户在未定义中断服务函数的情况下调用可进入无限循环状态中(兜底作用)\n\nNMI_Handler     PROC\n                EXPORT  NMI_Handler                [WEAK]\n                B       .\n                ; B 表示跳转指令\n                ; . 表示无限循环\n                ENDP\nHardFault_Handler\\\n                PROC\n                EXPORT  HardFault_Handler          [WEAK]\n                B       .\n                ENDP\nMemManage_Handler\\\n                PROC\n                EXPORT  MemManage_Handler          [WEAK]\n                B       .\n                ENDP\nBusFault_Handler\\\n                PROC\n                EXPORT  BusFault_Handler           [WEAK]\n                B       .\n                ENDP\nUsageFault_Handler\\\n                PROC\n                EXPORT  UsageFault_Handler         [WEAK]\n                B       .\n                ENDP\nSVC_Handler     PROC\n                EXPORT  SVC_Handler                [WEAK]\n                B       .\n                ENDP\nDebugMon_Handler\\\n                PROC\n                EXPORT  DebugMon_Handler           [WEAK]\n                B       .\n                ENDP\nPendSV_Handler  PROC\n                EXPORT  PendSV_Handler             [WEAK]\n                B       .\n                ENDP\nSysTick_Handler PROC\n                EXPORT  SysTick_Handler            [WEAK]\n                B       .\n                ENDP\n\nDefault_Handler PROC\n\n                EXPORT  WWDG_IRQHandler            [WEAK]\n                EXPORT  PVD_IRQHandler             [WEAK]\n                EXPORT  TAMPER_IRQHandler          [WEAK]\n                EXPORT  RTC_IRQHandler             [WEAK]\n                EXPORT  FLASH_IRQHandler           [WEAK]\n                EXPORT  RCC_IRQHandler             [WEAK]\n                EXPORT  EXTI0_IRQHandler           [WEAK]\n                EXPORT  EXTI1_IRQHandler           [WEAK]\n                EXPORT  EXTI2_IRQHandler           [WEAK]\n                EXPORT  EXTI3_IRQHandler           [WEAK]\n                EXPORT  EXTI4_IRQHandler           [WEAK]\n                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]\n                EXPORT  ADC1_2_IRQHandler          [WEAK]\n                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]\n                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]\n                EXPORT  CAN1_RX1_IRQHandler        [WEAK]\n                EXPORT  CAN1_SCE_IRQHandler        [WEAK]\n                EXPORT  EXTI9_5_IRQHandler         [WEAK]\n                EXPORT  TIM1_BRK_IRQHandler        [WEAK]\n                EXPORT  TIM1_UP_IRQHandler         [WEAK]\n                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]\n                EXPORT  TIM1_CC_IRQHandler         [WEAK]\n                EXPORT  TIM2_IRQHandler            [WEAK]\n                EXPORT  TIM3_IRQHandler            [WEAK]\n                EXPORT  TIM4_IRQHandler            [WEAK]\n                EXPORT  I2C1_EV_IRQHandler         [WEAK]\n                EXPORT  I2C1_ER_IRQHandler         [WEAK]\n                EXPORT  I2C2_EV_IRQHandler         [WEAK]\n                EXPORT  I2C2_ER_IRQHandler         [WEAK]\n                EXPORT  SPI1_IRQHandler            [WEAK]\n                EXPORT  SPI2_IRQHandler            [WEAK]\n                EXPORT  USART1_IRQHandler          [WEAK]\n                EXPORT  USART2_IRQHandler          [WEAK]\n                EXPORT  USART3_IRQHandler          [WEAK]\n                EXPORT  EXTI15_10_IRQHandler       [WEAK]\n                EXPORT  RTCAlarm_IRQHandler        [WEAK]\n                EXPORT  USBWakeUp_IRQHandler       [WEAK]\n                EXPORT  TIM8_BRK_IRQHandler        [WEAK]\n                EXPORT  TIM8_UP_IRQHandler         [WEAK]\n                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]\n                EXPORT  TIM8_CC_IRQHandler         [WEAK]\n                EXPORT  ADC3_IRQHandler            [WEAK]\n                EXPORT  FSMC_IRQHandler            [WEAK]\n                EXPORT  SDIO_IRQHandler            [WEAK]\n                EXPORT  TIM5_IRQHandler            [WEAK]\n                EXPORT  SPI3_IRQHandler            [WEAK]\n                EXPORT  UART4_IRQHandler           [WEAK]\n                EXPORT  UART5_IRQHandler           [WEAK]\n                EXPORT  TIM6_IRQHandler            [WEAK]\n                EXPORT  TIM7_IRQHandler            [WEAK]\n                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]\n                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]\n                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]\n                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]\n\nWWDG_IRQHandler\nPVD_IRQHandler\nTAMPER_IRQHandler\nRTC_IRQHandler\nFLASH_IRQHandler\nRCC_IRQHandler\nEXTI0_IRQHandler\nEXTI1_IRQHandler\nEXTI2_IRQHandler\nEXTI3_IRQHandler\nEXTI4_IRQHandler\nDMA1_Channel1_IRQHandler\nDMA1_Channel2_IRQHandler\nDMA1_Channel3_IRQHandler\nDMA1_Channel4_IRQHandler\nDMA1_Channel5_IRQHandler\nDMA1_Channel6_IRQHandler\nDMA1_Channel7_IRQHandler\nADC1_2_IRQHandler\nUSB_HP_CAN1_TX_IRQHandler\nUSB_LP_CAN1_RX0_IRQHandler\nCAN1_RX1_IRQHandler\nCAN1_SCE_IRQHandler\nEXTI9_5_IRQHandler\nTIM1_BRK_IRQHandler\nTIM1_UP_IRQHandler\nTIM1_TRG_COM_IRQHandler\nTIM1_CC_IRQHandler\nTIM2_IRQHandler\nTIM3_IRQHandler\nTIM4_IRQHandler\nI2C1_EV_IRQHandler\nI2C1_ER_IRQHandler\nI2C2_EV_IRQHandler\nI2C2_ER_IRQHandler\nSPI1_IRQHandler\nSPI2_IRQHandler\nUSART1_IRQHandler\nUSART2_IRQHandler\nUSART3_IRQHandler\nEXTI15_10_IRQHandler\nRTCAlarm_IRQHandler\nUSBWakeUp_IRQHandler\nTIM8_BRK_IRQHandler\nTIM8_UP_IRQHandler\nTIM8_TRG_COM_IRQHandler\nTIM8_CC_IRQHandler\nADC3_IRQHandler\nFSMC_IRQHandler\nSDIO_IRQHandler\nTIM5_IRQHandler\nSPI3_IRQHandler\nUART4_IRQHandler\nUART5_IRQHandler\nTIM6_IRQHandler\nTIM7_IRQHandler\nDMA2_Channel1_IRQHandler\nDMA2_Channel2_IRQHandler\nDMA2_Channel3_IRQHandler\nDMA2_Channel4_5_IRQHandler\n                B       .\n\n                ENDP\n\n                ALIGN\n                ; ALIGN 表示4字节对齐(参数缺省时)\n\n;****************************************************************\n;* 6-堆栈的初始化, 由C库函数__main实现\n;****************************************************************\n\n;*******************************************************************************\n; User Stack and Heap initialization\n;*******************************************************************************\n                 IF      :DEF:__MICROLIB ; __MICROLIB在ide里定义, 在Keil5 MDK中勾选Use MicroLIB选项\n                \n                 EXPORT  __initial_sp\n                 EXPORT  __heap_base\n                 EXPORT  __heap_limit\n                \n                 ELSE\n                \n                 IMPORT  __use_two_region_memory ; 如果__MICROLIB未定义, 则由用户自己实现\n                 EXPORT  __user_initial_stackheap\n                 \n__user_initial_stackheap\n\n                 LDR     R0, =  Heap_Mem\n                 LDR     R1, =(Stack_Mem + Stack_Size)\n                 LDR     R2, = (Heap_Mem +  Heap_Size)\n                 LDR     R3, = Stack_Mem\n                 BX      LR\n\n                 ALIGN\n\n                 ENDIF\n\n                 END\n\n;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****\n\n```\n\n### EQU指令\n\n作用: The EQU directive is a register-relative address, a PC-relative address, an absolute address, or a 32-bit integer constant. // 为数值常量、寄存器相对值或 PC 相对值提供符号名称。(*可以理解为重命名*)\n\n```assembly\nStack_Size      EQU     0x00000400 \n; 宏定义的伪指令，相当于等于，类似与 C 中的 define。\n; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小\n```\n\n#### EQU手册说明\n\n![EQU指令](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031428875.png)\n\n### AREA指令\n\nAREA: 汇编一个新的代码段或数据段\n\n```assembly\nAREA    STACK, NOINIT, READWRITE, ALIGN=3\n; 告诉汇编器汇编一个新的代码段或者数据段。\n; STACK 表示段名，这个可以任意命名\n; NOINIT 表示不初始化\n; READWRITE 表示可读可写\n; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐\n```\n\n#### AREA手册说明\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031529274.png)\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530123.png)\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530696.png)\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031531689.png)\n\n### SPACE指令\n\nSPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size, 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长\n\n```assembly\nStack_Mem       SPACE   Stack_Size\n; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。\n__initial_sp\n; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长\n```\n\n#### SPACE手册说明\n\n![SPACE](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031539781.png)\n\n### PRESERVE8指令\n\nPRESERVE8：指定当前文件的堆栈按照 8 字节对齐\n\n#### PRESERVE8手册说明\n\n![PRESERVE8](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031556307.png)\n\n![PRESERVE8](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031557775.png)\n\n### THUMB指令\n\n野火的解释: **THUMB：表示后面指令兼容 THUMB 指令。THUBM 是 ARM 以前的指令集，16bit，现在 Cortex-M系列的都使用 THUMB-2 指令集，THUMB-2 是 32 位的，兼容 16 位和 32 位的指令，是 THUMB的超集**\n\n#### THUMB手册说明\n\n![THUMB](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031600256.png)\n\n### EXPORT指令\n\nEXPORT：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 IAR 编译器，则使用的是 GLOBAL 这个指令\n\n```assembly\nEXPORT  __Vectors\nEXPORT  __Vectors_End\nEXPORT  __Vectors_Size\n; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用\n```\n\n#### EXPORT手册说明\n\n![EXPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031623174.png)\n\n![EXPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624509.png)\n\n![EXPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624882.png)\n\n### DCD指令\n\nDCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存\n\n#### DCD手册说明\n\n![DCD](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032016385.png)\n\n### PROC指令\n\nPROC: 定义子程序, 与ENDP成对使用, 表示子程序结束\n\n#### PROC手册说明\n\n![PROC](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032025440.png)\n\n![PROC](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032026200.png)\n\n### IMPORT指令\n\nIMPORT：表示该标号来自外部文件，跟 C 语言中的 EXTERN 关键字类似\n\n```assembly\nIMPORT  __main\nIMPORT  SystemInit\n;表示 SystemInit和 __main 这两个函数均来自外部的文件\n```\n\n#### IMPORT手册说明\n\n![IMPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034894.png)\n\n![IMPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034604.png)\n\n![IMPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032035341.png)\n\n### LDR指令\n\nLDR: 从存储器中加载字到一个寄存器中\n\n```assembly\nLDR     R0, =SystemInit\n; 把SystemInit的地址加载到R0中\nBLX     R0               \n; 跳转到R0执行, 执行完毕后返回\nLDR     R0, =__main\n; 把__main的地址加载到R0中\nBX      R0\n; 跳转到R0执行, 执行完毕后不返回\n```\n\n#### LDR手册说明\n\n![LDR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046548.png)\n\n![LDR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046349.png)\n\n![LDR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032047305.png)\n\n### BLX指令\n\nBLX: 跳转到由寄存器给出的地址, 并根据寄存器的LSE确定处理器的状态, 还要把跳转前的下条指令地址保存到LR\n\n```assembly\nBLX     R0               \n; 跳转到R0执行, 执行完毕后返回\n```\n\n### BX指令\n\nBX: 跳转到由寄存器/标号给出的地址, 不用返回\n\n```assembly\nBX      R0\n; 跳转到R0执行, 执行完毕后不返回\n```\n\n### ALIGN指令\n\nALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐\n\n#### ALIGN手册说明\n\n![ALIGN](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103293.png)\n\n![ALIGN](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103739.png)\n\n![ALIGN](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103256.png)\n\n## 时钟\n\n### 时钟系统框图\n\n![时钟系统框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2009.47.02.png)\n\n#### SYSCLK系统时钟源选择\n\n- HSI_RC: 高速内部时钟, RC 震荡产生(频率约为 8MHz)\n- HSE: 高速外部时钟,通过外接晶振产生(频率范围: 4-16MHz)\n- PLL: 锁相环,倍频到72MHz\n\n##### SYSCLK 系统时钟的选择\n\n1. HSI_RC 约 8MHz\n2. PLLCLK 倍频至72MHz\n3. HSE_Osc直接使用\n\n##### PLL锁相环的选择\n\n1. HSI_RC 两分频后\n2. HSE_Osc or HSE_Osc二分频后\n\nCSS: 时钟监视系统, 监视 HSE_Osc 是否正常工作,若 外部时钟源异常则将 SYSCLK 切换为 HSI_RC\n\n![时钟系统框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.03.07.png)\n\n#### RTCCLK时钟源选择\n\n- LSE_Osc: 低速外部时钟源, 频率为36.768KHz\n- LSI_RC: 低速内部时钟源, 频率约为40KHz, 由 RC 震荡产生\n\n##### RTC_CLK(RTC 时钟)的选择\n\n1. HSE_Osc 128 分频后\n2. LSE_Osc\n3. LSI_RC\n\n#### IWDGCLK独立看门狗时钟源\n\nIWDGCLK独立看门狗时钟源由LSI_RC 提供\n\n![IWDGCLK独立看门狗时钟源](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401291156077.png)\n\n#### MCO 的选择\n\nMCO是一个引脚来输出内部时钟\n\n![系统时钟框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.13.53.png)\n\n1. SYSCLK\n2. HSI\n3. HSE\n4. PLLCLK 二分频\n\n#### 各类总线时钟\n\n![时钟系统框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.26.21.png)\n\n1. USBCLK_48MHz (USB 时钟): 由 PLLCLK经USB_Prescaler预分频至 48MHz\n2. HCLK: SYSCLK->AHB_Prescaler 最高 72MHz\n3. PCLK1: SYSCLK->AHB_Prescaler->APB1_Prescaler 最高36MHz\n4. TIMxCLK(通用定时器时钟): SYSCLK->AHB_Prescaler->APB1_Prescaler->TIM2,3,4_Multiplier\n5. PCKL2: SYSCLK->AHB_Prescaler->APB2_Prescaler 最高72MHz\n6. TIM1CLK(TIM1 时钟): SYSCLK->AHB_Prescal->APB2_Prescaler->TIM1_Multiplier\n7. ADCCLK(ADC 时钟): SYSCLK->AHB_Prescaler->APB2_Prescaler->ADC_Prescaler\n\n#### 总结\n\n![知识总结](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2011.09.39.png)\n\n### 系统时钟配置函数 SetSysClockTo72()分析\n\n在启动文件startup_stm32f10x_hd.s中执行SystemInit函数, 如下\n\n```assembly\n; Reset handler\nReset_Handler   PROC\n                EXPORT  Reset_Handler             [WEAK]\n                IMPORT  __main\n                IMPORT  SystemInit\n                LDR     R0, =SystemInit\n                BLX     R0               \n                LDR     R0, =__main\n                BX      R0\n                ENDP\n```\n\n在system_stm32f10x.c文件中调用SystemInit函数, SystemInit函数在末尾调用SetSysClock()函数\n\n```c\nvoid SystemInit (void)\n{\n  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */\n  /* Set HSION bit */\n  RCC->CR |= (uint32_t)0x00000001;\n\n  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */\n#ifndef STM32F10X_CL\n  RCC->CFGR &= (uint32_t)0xF8FF0000;\n#else\n  RCC->CFGR &= (uint32_t)0xF0FF0000;\n#endif /* STM32F10X_CL */   \n  \n  /* Reset HSEON, CSSON and PLLON bits */\n  RCC->CR &= (uint32_t)0xFEF6FFFF;\n\n  /* Reset HSEBYP bit */\n  RCC->CR &= (uint32_t)0xFFFBFFFF;\n\n  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */\n  RCC->CFGR &= (uint32_t)0xFF80FFFF;\n\n#ifdef STM32F10X_CL\n  /* Reset PLL2ON and PLL3ON bits */\n  RCC->CR &= (uint32_t)0xEBFFFFFF;\n\n  /* Disable all interrupts and clear pending bits  */\n  RCC->CIR = 0x00FF0000;\n\n  /* Reset CFGR2 register */\n  RCC->CFGR2 = 0x00000000;\n#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)\n  /* Disable all interrupts and clear pending bits  */\n  RCC->CIR = 0x009F0000;\n\n  /* Reset CFGR2 register */\n  RCC->CFGR2 = 0x00000000;      \n#else\n  /* Disable all interrupts and clear pending bits  */\n  RCC->CIR = 0x009F0000;\n#endif /* STM32F10X_CL */\n    \n#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)\n  #ifdef DATA_IN_ExtSRAM\n    SystemInit_ExtMemCtl(); \n  #endif /* DATA_IN_ExtSRAM */\n#endif \n\n  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */\n  /* Configure the Flash Latency cycles and enable prefetch buffer */\n  SetSysClock(); // 末尾调用SetSysClock()函数 \n```\n\n调用system_stm32f10x.c中SetSysClock()\n\n默认情况下定义SYSCLK_FREQ_72MHz宏, 调用SetSysClockTo72()函数\n\n```c\n/**\n  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.\n  * @param  None\n  * @retval None\n  */\nstatic void SetSysClock(void)\n{\n#ifdef SYSCLK_FREQ_HSE\n  SetSysClockToHSE();\n#elif defined SYSCLK_FREQ_24MHz\n  SetSysClockTo24();\n#elif defined SYSCLK_FREQ_36MHz\n  SetSysClockTo36();\n#elif defined SYSCLK_FREQ_48MHz\n  SetSysClockTo48();\n#elif defined SYSCLK_FREQ_56MHz\n  SetSysClockTo56();  \n#elif defined SYSCLK_FREQ_72MHz\n  SetSysClockTo72();\n#endif\n \n /* If none of the define above is enabled, the HSI is used as System clock\n    source (default after reset) */ \n}\n```\n\n在system_stm32f10x.c中宏定义, 默认宏定义SYSTEMCLK_FREQ_72MHz\n\n```c\n#if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)\n/* #define SYSCLK_FREQ_HSE    HSE_VALUE */\n #define SYSCLK_FREQ_24MHz  24000000\n#else\n/* #define SYSCLK_FREQ_HSE    HSE_VALUE */\n/* #define SYSCLK_FREQ_24MHz  24000000 */ \n/* #define SYSCLK_FREQ_36MHz  36000000 */\n/* #define SYSCLK_FREQ_48MHz  48000000 */\n/* #define SYSCLK_FREQ_56MHz  56000000 */\n#define SYSCLK_FREQ_72MHz  72000000\n#endif\n```\n\n在system_stem32f10x.c中定义SetSysClockTo72()函数\n\n```c\n#elif defined SYSCLK_FREQ_72MHz\n/**\n  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers. \n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\nstatic void SetSysClockTo72(void)\n{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  // 使能HSE\n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n  \n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  // 等待 HSE 就绪并作超时处理\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  // 如果 HSE启动成功, 程序则继续往下执行\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer */\n    // 启用 Flsh  预取缓冲区\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 2 wait state */\n    // flash 时延两个等待状态\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    \n\n \n    /* HCLK = SYSCLK */\n    // 72MHz\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    // 72MHz\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    // 36MHz\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n\n/*----------------------------------------------------------------\n * 互联型芯片 F105, F107 以下代码不进行分析\n *---------------------------------------------------------------*/\n\n/**********************************************************************/\n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */\n        \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }\n    \n   \n    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ \n    // 锁相环配置\n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL9); \n#else    \n\n    /* Enable PLL */\n    // 使能 PLL\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    //  等待 PLL 稳定\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n    \n    /* Select PLL as system clock source */\n    // 选择 PLLCLK 作为系统时钟\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    // 等待 PLLCLK 切换为系统时钟\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n    // 如果 HSE 启动失败,用户可以在这里添加处理错误的代码\n  }\n}\n#endif\n```\n\n### HSE配置系统时钟\n\n项目地址: **16-使用HSE配置系统时钟并使用MCO输出监控系统时钟**\n\n#### 在bsp_rccclkconfig.c中写入HSE的配置函数\n\n```c\n/**\n * @brief 设置系统时钟为外部高速晶振（HSE）时钟，并配置PLL倍频系数。\n * \n * @param RCC_PLLMul_x PLL倍频系数，范围为2-16。\n * @note 该函数会将RCC模块复位，并使能HSE。如果HSE启动成功，则设置FLASH预取指令使能、FLASH等待周期、AHB总线时钟、APB1总线时钟、APB2总线时钟、PLL倍频系数，并等待PLL稳定后将系统时钟设置为PLL时钟。\n *       如果HSE启动失败，则用户可以在函数中添加处理错误的代码。\n */\nvoid HSE_SetSysClk(uint32_t RCC_PLLMul_x)\n{\n    RCC_DeInit(); // RCC复位\n    ErrorStatus HSEStatus;\n    RCC_HSEConfig(RCC_HSE_ON); // 使能HSE\n    HSEStatus = RCC_WaitForHSEStartUp(); // 获取HSE启动状态\n\n    if(HSEStatus == SUCCESS)\n    {\n        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); // 使能预取指\n        FLASH_SetLatency(FLASH_ACR_LATENCY_2); // 设置等待\n        RCC_HCLKConfig(RCC_SYSCLK_Div1); //HCLK = SYSCLK = 72MHz\n        RCC_PCLK1Config(RCC_SYSCLK_Div2); //PCLK1 = HCLK / 2 = 36MHz\n        RCC_PCLK2Config(RCC_SYSCLK_Div1); //PCLK2 = HCLK / 1 = 72MHz\n        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_x); // RCC_RLLMul_x 用来超频 频率:(8*x)MHz\n        RCC_PLLCmd(ENABLE); // 使能PLL\n        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n        {\n            // 等待PLL稳定\n            ;\n        }\n        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); // 设置系统时钟为PLL时钟\n        while(RCC_GetSYSCLKSource() != 0x08)\n        {\n            // 等待设置系统时钟\n            ;\n        }\n    }\n    else\n    {\n        // 如果HSE启动失败, 用户在此添加处理错误代码\n    }\n}\n```\n\n#### 在bsp_rccclkconfig.c中编写MCO的GPIO初始化函数\n\n```c\n/**\n * @brief Configures the GPIO for MCO (Microcontroller Clock Output).\n * \n * This function initializes the GPIO pin for MCO and configures it as an alternate function push-pull output.\n * The GPIO pin used for MCO is GPIOA Pin 8.\n * \n * @param None\n * @return None\n */\nvoid MCO_GPIO_Config()\n{\n    // MCO的GPIO初始化\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOA, &GPIO_InitStruct);\n}\n```\n\n#### 在bsp_rccclkconfig.h中添加函数声明\n\n```c\n#ifndef __BSP_RCCCLKCONFIG_H\n#define __BSP_RCCCLKCONFIG_H\n\n#include \"stm32f10x.h\"\n\nvoid HSE_SetSysClk(uint32_t RCC_PLLMul_x);\nvoid MCO_GPIO_Config();\n\n#endif // !__BSP_RCCCLKCONFIG_H\n```\n\n#### 在main.c中调用HSE配置系统时钟函数和MCO的GPIO初始化函数\n\n```c\n#include \"stm32f10x.h\"\n#include \"bsp_led.h\"\n#include \"bsp_rccclkconfig.h\"\n\n// 延时函数Delay()\nvoid Delay(uint32_t count)\n{\n    uint32_t i = 0;\n    for(; count != 0; count--)\n    {\n        for(i = 0; i < 0x2AFF; i++)\n        {\n            ;\n        }\n    }\n}\n\nint main(void)\n{\n    HSE_SetSysClk(RCC_PLLMul_9); // 72MHz\n    // HSE_SetSysClk(RCC_PLLMul_16); // 128MHz\n    MCO_GPIO_Config();\n    RCC_MCOConfig(RCC_MCO_SYSCLK); // 配置MCO选择系统时钟\n    LED_GPIO_Config();\n\n    while(1)\n    {\n        LED_B(OFF);\n        Delay(50); // 延时\n        LED_B(ON);\n        Delay(50); // 延时\n    }\n}\n\n```\n\n### 使用HSI配置系统时钟并用MCO监控系统时钟\n\n项目地址: **16-使用HSI配置系统时钟并用MCO监控系统时钟**\n\n#### 在bsp_rccclkconfig.c中编写HSI配置系统时钟函数\n\n```c\n/**\n * @brief 设置系统时钟为HSI，并配置PLL倍频系数\n * \n * @param RCC_PLLMul_x PLL倍频系数，范围为2-16\n * \n * @note 该函数将系统时钟设置为HSI，并根据传入的PLL倍频系数配置PLL，以实现超频功能。\n *       如果HSI启动失败，用户可以在函数的else分支中添加处理错误的代码。\n */\nvoid HSI_SetSysClk(uint32_t RCC_PLLMul_x)\n{\n    // Function implementation\n    __IO uint32_t HSIStatus = 0; // 参考固件库源码\n    RCC_DeInit(); // RCC复位\n    RCC_HSICmd(ENABLE); // 使能HSI\n    HSIStatus = RCC->CR & RCC_CR_HSIRDY; // 获取HSI启动状态, 参考固件库源码\n\n    if(HSIStatus == RCC_CR_HSIRDY)\n    {\n        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); // 使能预取指\n        FLASH_SetLatency(FLASH_ACR_LATENCY_2); // 设置等待\n        RCC_HCLKConfig(RCC_SYSCLK_Div1); //HCLK = SYSCLK = 72MHz\n        RCC_PCLK1Config(RCC_SYSCLK_Div2); //PCLK1 = HCLK / 2 = 36MHz\n        RCC_PCLK2Config(RCC_SYSCLK_Div1); //PCLK2 = HCLK / 1 = 72MHz\n        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_x); // RCC_RLLMul_x 用来超频 频率:(8*x)MHz\n        RCC_PLLCmd(ENABLE); // 使能PLL\n        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n        {\n            // 等待PLL稳定\n            ;\n        }\n        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); // 设置系统时钟为PLL时钟\n        while(RCC_GetSYSCLKSource() != 0x08)\n        {\n            // 等待设置系统时钟\n            ;\n        }\n    }\n    else\n    {\n        // 如果HSI启动失败, 用户在此添加处理错误代码\n    }\n}\n```\n\n#### 在bsp_rccclkconfig.h中加入函数声明\n\n```c\nvoid HSI_SetSysClk(uint32_t RCC_PLLMul_x);\n```\n\n#### 在main.c中调用HSI配置系统时钟函数\n\n```c\nHSI_SetSysClk(RCC_PLLMul_12); // 4*12=48MHz\nMCO_GPIO_Config();\nRCC_MCOConfig(RCC_MCO_SYSCLK); // 配置MCO选择系统时钟\nLED_GPIO_Config();\n```\n\n## 中断\n\n### STM32中断应用概览\n\n#### 中断类型\n\n- 系统异常: 体现在内核水平\n- 外部中断: 体现在外设水平\n\n#### NVIC\n\nNVIC负责管理中断\n\n在core_cm3.h中的定义  \n\n```c\n/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC\n  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)\n  @{\n */\ntypedef struct\n{\n  // 中断使能寄存器\n  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */\n       uint32_t RESERVED0[24];                                   \n\n  // 中断清除寄存器\n  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */\n       uint32_t RSERVED1[24];                                    \n\n  // 中断使能悬起寄存器\n  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */\n       uint32_t RESERVED2[24];                                   \n  \n  // 中断清除悬起寄存器 \n  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */\n       uint32_t RESERVED3[24];                                   \n\n  // 中断有效位寄存器\n  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */\n       uint32_t RESERVED4[56];                                   \n\n  // 中断优先级寄存器\n  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */\n       uint32_t RESERVED5[644];                                  \n\n  // 软件触发中断寄存器\n  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */\n}  NVIC_Type;                                               \n/*@}*/ /* end of group CMSIS_CM3_NVIC */\n```\n\n##### NVIC的优先级分组\n\n通过**SCB->AIRCR寄存器的PRIGROUP部分(即bit[10:8])进行分组**\n\n![NVIC优先级](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401140238595.png)\n\n### 中断编程的顺序\n\n1. 使能中断请求(**使能外设中断, 使能 NVIC 中断**)\n2. 配置中断优先级分组(NVIC_PriorityGroupConfig)\n3. 配置 NVIC 寄存器, 初始化NVIC_InitTypeDef\n4. 编写中断服务函数\n\n## EXTI\n\n### EXTI 输入线\n\n![EXTI 输入线](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.13.32.png)\n\n通过寄存器 AFIO_EXTICR1, 2, 3, 4配置\n\n### EXTI 框图讲解\n\n![EXTI 框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.18.42.png)\n\n#### 外部中断流程\n\n1. 通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1\n2. 通过 EXTI_SWIER 来配置软件中断, 配置后为 1\n3. 经过逻辑与门后, 进入请求挂起寄存器\n4. 通过 EXTI_PR 配置挂起\n5. 通过 EXTI_IMR 配置中断屏蔽\n6. 请求挂起寄存器的逻辑值与中断屏蔽寄存器的逻辑值做逻辑与至 NVIC 中断控制器\n\n#### 外部事件流程\n\n1. 通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1\n2. 通过 EXTI_SWIER 来配置软件中断, 配置后为 1\n3. 经过逻辑与门后, 向下跟事件屏蔽寄存器相与\n4. 通过 EXTI_EMR 配置事件屏蔽\n5. 若为 1 产生脉冲\n\n### EXTI 结构体\n\nEXTI_InitTypeDef\n\n- EXTI_Line : 用于产生中断/事件线\n- EXTI_Mode : EXTI 模式(中断/事件)\n- EXTI_Trigger : 触发(上/下/上下)\n- EXTI_LineCmd :  使能或者失能(IMR/EMR)\n\n#### EXTI 的结构体定义\n\n```c\n/** \n  * @brief  EXTI Init Structure definition  \n  */\n\ntypedef struct\n{\n  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.\n                                         This parameter can be any combination of @ref EXTI_Lines */\n   \n  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.\n                                         This parameter can be a value of @ref EXTIMode_TypeDef */\n\n  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.\n                                         This parameter can be a value of @ref EXTIMode_TypeDef */\n\n  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.\n                                         This parameter can be set either to ENABLE or DISABLE */ \n}EXTI_InitTypeDef;\n\n/**\n  * @}\n  */\n```\n\n##### EXTI_Line 的定义\n\n```c\n/** @defgroup EXTI_Lines \n  * @{\n  */\n\n#define EXTI_Line0       ((uint32_t)0x00001)  /*!< External interrupt line 0 */\n#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */\n#define EXTI_Line2       ((uint32_t)0x00004)  /*!< External interrupt line 2 */\n#define EXTI_Line3       ((uint32_t)0x00008)  /*!< External interrupt line 3 */\n#define EXTI_Line4       ((uint32_t)0x00010)  /*!< External interrupt line 4 */\n#define EXTI_Line5       ((uint32_t)0x00020)  /*!< External interrupt line 5 */\n#define EXTI_Line6       ((uint32_t)0x00040)  /*!< External interrupt line 6 */\n#define EXTI_Line7       ((uint32_t)0x00080)  /*!< External interrupt line 7 */\n#define EXTI_Line8       ((uint32_t)0x00100)  /*!< External interrupt line 8 */\n#define EXTI_Line9       ((uint32_t)0x00200)  /*!< External interrupt line 9 */\n#define EXTI_Line10      ((uint32_t)0x00400)  /*!< External interrupt line 10 */\n#define EXTI_Line11      ((uint32_t)0x00800)  /*!< External interrupt line 11 */\n#define EXTI_Line12      ((uint32_t)0x01000)  /*!< External interrupt line 12 */\n#define EXTI_Line13      ((uint32_t)0x02000)  /*!< External interrupt line 13 */\n#define EXTI_Line14      ((uint32_t)0x04000)  /*!< External interrupt line 14 */\n#define EXTI_Line15      ((uint32_t)0x08000)  /*!< External interrupt line 15 */\n#define EXTI_Line16      ((uint32_t)0x10000)  /*!< External interrupt line 16 Connected to the PVD Output */\n#define EXTI_Line17      ((uint32_t)0x20000)  /*!< External interrupt line 17 Connected to the RTC Alarm event */\n#define EXTI_Line18      ((uint32_t)0x40000)  /*!< External interrupt line 18 Connected to the USB Device/USB OTG FS\n                                                   Wakeup from suspend event */                                    \n#define EXTI_Line19      ((uint32_t)0x80000)  /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */\n```\n\n##### EXTI_Mode 的定义\n\n```c\n/** \n  * @brief  EXTI mode enumeration  \n  */\n\ntypedef enum\n{\n  EXTI_Mode_Interrupt = 0x00,\n  EXTI_Mode_Event = 0x04\n}EXTIMode_TypeDef;\n\n#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))\n```\n\n##### EXTI_Trigger 的定义\n\n```c\n/** \n  * @brief  EXTI Trigger enumeration  \n  */\n\ntypedef enum\n{\n  EXTI_Trigger_Rising = 0x08,\n  EXTI_Trigger_Falling = 0x0C,  \n  EXTI_Trigger_Rising_Falling = 0x10\n}EXTITrigger_TypeDef;\n\n#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \\\n                                  ((TRIGGER) == EXTI_Trigger_Falling) || \\\n                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))\n```\n\n### GPIO 作为 EXTI 输入线的配置\n\n在 stm32f10x_gpio.c 中, 使用 GPIO_EXTILineConfig 函数进行配置\n\n```c\n/**\n  * @brief  Selects the GPIO pin used as EXTI Line.\n  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.\n  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).\n  * @param  GPIO_PinSource: specifies the EXTI line to be configured.\n  *   This parameter can be GPIO_PinSourcex where x can be (0..15).\n  * @retval None\n  */\nvoid GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)\n{\n  uint32_t tmp = 0x00;\n  /* Check the parameters */\n  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));\n  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));\n  \n  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));\n  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;\n  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));\n}\n```\n\n### EXTI中断实验\n\n项目地址: **18-EXTI**\n\n**项目需求:**\n\n1. PA0 连接到 EXTI 用于产生中断, PA0 的电平变化通过按键来控制\n2. 产生一次中断, LED 反转一次\n\n#### 在bsp_exti.c中初始化要连接到EXTI的GPIO\n\n```c\n// 初始化 Key1(PA0)\nRCC_APB2PeriphClockCmd(KEY1_INT_GPIO_CLK, ENABLE);\nGPIO_InitStruct.GPIO_Pin = KEY1_INT_GPIO_PIN;\nGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\nGPIO_Init(KEY1_INT_GPIO_PORT, &GPIO_InitStruct);\n```\n\n#### 在bsp_exti.c中初始化EXTI用于产生中断/事件\n\n```c\nRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\nGPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); // 选择输入线\nEXTI_InitStruct.EXTI_Line = EXTI_Line0;                     // 选择EXTI线路\nEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            // 选择中断模式\nEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;         // 选择触发模式\nEXTI_InitStruct.EXTI_LineCmd = ENABLE;                          // 使能EXTI线路\nEXTI_Init(&EXTI_InitStruct);\n```\n\n#### 在bsp_exti.c中初始化NVIC, 用于处理中断\n\n```c\nNVIC_InitTypeDef NVIC_InitStruct;\n\nNVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); // 配置中断优先级分组\n\nNVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn; // 选择中断源\nNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; // 抢占优先级\nNVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; // 子优先级\nNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; // 使能中断\nNVIC_Init(&NVIC_InitStruct);\n```\n\n#### 在stm32f10x_it.c中编写中断服务函数\n\n```c\n/**\n * @brief EXTI0_IRQHandler: Interrupt handler for EXTI Line 0\n *\n * This function is the interrupt handler for EXTI Line 0. It toggles the state of the blue LED.\n * It checks the interrupt status of EXTI Line 0 and clears the interrupt pending bit.\n */\nvoid EXTI0_IRQHandler(void)\n{\n  if(EXTI_GetITStatus(EXTI_Line0) != RESET) // 判断中断位\n  {\n    LED_B_TOGGLE;\n  }\n  EXTI_ClearITPendingBit(EXTI_Line0); // 清除中断标志位\n}\n```\n\n#### 在bsp_led.h中编写电平反转函数\n\n```c\n#define LED_B_TOGGLE {LED_B_GPIO_PORT->ODR ^= LED_B_GPIO_PIN;}\n```\n\n### 补充: 使能AFIO时钟\n\n在STM32微控制器系列中，使用外部中断（EXTI）时需要开启AFIO（Alternate Function IO）时钟的原因与STM32的硬件设计和引脚复用功能有关。\n\n#### AFIO的作用\n\n1. **引脚复用**：STM32的GPIO（通用输入输出）引脚具有多功能性。一个物理引脚可以用作普通的I/O，也可以被配置为特殊功能，如USART、SPI、I2C通信或外部中断（EXTI）等。AFIO（Alternate Function IO）模块负责管理这些引脚的复用功能。\n2. **EXTI配置**：在STM32中，外部中断线（EXTI）可以映射到不同的GPIO引脚上。AFIO模块提供了这种映射功能。例如，如果你想将EXTI0配置为由PA0、PB0、PC0等其中一个引脚触发，就需要通过AFIO模块来设置这种映射。\n\n#### 开启AFIO时钟的原因\n\n**由于AFIO模块负责处理引脚的复用功能，包括EXTI的引脚映射，因此在使用EXTI功能之前，必须确保AFIO模块的时钟是使能的**如果没有使能AFIO时钟，对AFIO寄存器的任何配置操作都不会生效，这意味着EXTI线路无法正确地映射到相应的GPIO引脚上，从而导致外部中断功能无法正常工作。\n\n#### AFIO的实际操作\n\n在STM32的标准固件库或HAL（硬件抽象层）库中，通常会看到类似以下的代码片段，用于使能AFIO时钟：\n\n```c\nRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n```\n\n或在使用HAL库时：\n\n```c\n__HAL_RCC_AFIO_CLK_ENABLE();\n```\n\n这些函数调用确保了AFIO模块的时钟被使能，从而使得外部中断的相关配置（如引脚映射）能够正确执行。\n\n#### AFIO的总结\n\n开启AFIO时钟是使用STM32的EXTI功能的必要步骤，因为AFIO模块控制着GPIO引脚的复用功能，包括将外部中断线路映射到特定的GPIO引脚。未使能AFIO时钟可能导致外部中断配置无效，进而影响整个中断处理机制的正常工作。\n\n## SysTick\n\n### SysTick简介\n\nSysTick: 系统定时器, **24位, 只能递减, 存在于内核中**, 嵌套在NVIC中, 所有的Cotex-M内核的单片机都具有这个定时器.\n\n### SysTick 功能框图\n\n![框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170017620.png)\n\n重装载寄存器把值写入递减计数器, 可通过STK_VAL实时查询其中的值, 递减计数器从reload值开始递减, 减为0后可产生中断并且置位COUNTFLAG标志位, 置位后从reload获取值重复以上操作\n\n### SysTick 寄存器描述\n\n![SysTick 寄存器描述](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170023320.png)\n\n### SysTick 定时时间计算\n\n需要计算的参数\n\n![计算参数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025237.png)\n\n计算过程\n\n![计算过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025314.png)\n\n- Clk = 72M时\n- reload = 72, t = 1us\n- reload = 72000, t = 1ms\n\n### 补充: SysTick 介绍\n\nSysTick（System Tick Timer）是ARM Cortex-M微控制器内核的一个内置组件，用于提供一个简单但高效的系统定时器。这个定时器通常用于实现操作系统的节拍（tick），也可以用于简单的延时功能。\n\n#### SysTick的主要特点\n\n1. 24位递减计数器：SysTick包含一个24位的递减计数器，当计数器值递减到零时，定时器溢出并触发一个中断。\n2. 可编程重载值：可以设置计数器的重载值，这决定了定时器的溢出时间间隔。\n3. 可配置的时钟源：SysTick定时器可以配置为使用内核时钟或外部时钟（通常是内核时钟的一半）。\n4. 自动重载：在计数到零时，计数器会自动重新加载预设的重载值，从而实现周期性定时。\n5. 中断功能：当计数器达到零时，SysTick定时器可以产生一个中断。这个中断可以用于各种定时任务，如操作系统的任务调度。\n\n#### SysTick的应用场景\n\n1. 操作系统节拍：在实时操作系统（RTOS）中，SysTick常用于生成操作系统的节拍，这对于任务调度和时间管理非常重要。\n2. 延时功能：在不需要RTOS的简单应用中，SysTick可用于生成精确的延时，例如在两个事件之间等待固定的时间。\n3. 时间基准：SysTick还可以作为程序中的时间基准，用于测量时间间隔或产生定时事件。\n\n#### SysTick的配置和使用\n\n在使用SysTick时，一般需要进行以下配置：\n\n1. 设置重载值：根据所需的定时周期和时钟源频率设置重载值。\n2. 选择时钟源：选择使用内核时钟还是外部时钟作为SysTick的时钟源。\n3. 启用中断（可选）：如果需要在定时器溢出时执行特定操作，可以启\n   用SysTick中断。\n4. 启动定时器：启用SysTick定时器开始计数\n\n#### SysTick的编程示例\n\n在STM32等ARM Cortex-M微控制器上，SysTick的配置和使用通常涉及直接操作其控制和状态寄存器。以下是一个简单的示例：\n\n```c\nSysTick_Config(SystemCoreClock / 1000);  // 配置SysTick产生\n```\n\n### SysTick 源码分析\n\nSysTick_Type定义在core_cm3.h中\n\n```c\n/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick\n  memory mapped structure for SysTick\n  @{\n */\ntypedef struct\n{\n  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */\n  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */\n  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */\n  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */\n} SysTick_Type;\n```\n\nSysTick_Config函数在core_cm3.h中定义\n\n```c\n/**\n * @brief  Initialize and start the SysTick counter and its interrupt.\n *\n * @param   ticks   number of ticks between two interrupts\n * @return  1 = failed, 0 = successful\n *\n * Initialise the system tick timer and its interrupt and start the\n * system tick timer / counter in free running mode to generate \n * periodical interrupts.\n */\nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)\n{ \n  // 判断ticks的值是否大于2^24, 若大于则违法\n  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */\n                                                               \n  // 初始化reaload寄存器的值\n  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */\n\n  // 配置中断优先级, 配置为15, 默认为最低的优先级\n  /*-------------------------------------------------------------\n   * 注: \n   * 内核优先级的判断方式:\n   * 将内核外设的中断优先级的四个位按照外设的中断优先级进行分组\n   * 分组后可判断内核的抢占优先级和响应优先级\n   * 即人为分出抢占和响应优先级\n   * \n   * 例:\n   * 这里SysTick的中断优先级为15, 二进制为1111\n   * 若分组为2位抢占, 2位响应\n   * 则SysTick的抢占优先级为11即3, 响应优先级为11即3\n   * 若分组为1位抢占, 3位响应\n   * 则SysTick的抢占优先级为1即1, 响应优先级为111即7\n   * 通过该方法可以比较内核优先级与外设的优先级谁更高\n   * ----------------------------------------------------------*/\n  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */\n\n  // 初始化counter的值为0\n  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */\n\n  // 配置 SysTick的时钟为 72M\n  // 使能中断\n  // 使能 SysTick \n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | \n                   SysTick_CTRL_TICKINT_Msk   | \n                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */\n  return (0);                                                  /* Function successful */\n}\n```\n\n### SysTick 实验\n\n项目地址: **19-SysTick**\n\n实验要求:\n\n1. 编写一个微妙延时函数\n2. 编写一个毫秒延时函数\n\n#### 在bsp_systick.c中编写微妙延时函数\n\n```c\n/**\n * @brief 延时指定的微秒数\n * @param us 延时的微秒数\n * @retval None\n */\nvoid SysTick_Delay_us(uint32_t us)\n{\n    SysTick_Config(SystemCoreClock / 1000000); // reload 设置为 72, t = 1us\n    \n    for(int i = 0; i < us; i++)\n    {\n        while(!(SysTick->CTRL & (1 << 16)))\n        {\n            ; // 等待CTRL的Bit16置1\n        }\n    }\n\n    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk; // 状态位清除\n}\n```\n\n#### 在bsp_systick.c中编写毫秒延时函数\n\n```c\n/**\n * @brief 延时指定的毫秒数\n * @param ms 延时的毫秒数\n * @return 无\n */\nvoid SysTick_Delay_ms(uint32_t ms)\n{\n    SysTick_Config(SystemCoreClock / 1000); // reload 设置为 72000, t = 1ms\n    \n    for(int i = 0; i < ms; i++)\n    {\n        while(!(SysTick->CTRL & (1 << 16)))\n        {\n            ; // 等待CTRL的Bit16置1\n        }\n    }\n\n    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk; // 状态位清除\n}\n```\n\n#### 在bsp_systick.h中引用库文件和进行函数声明\n\n```c\n#ifndef __BSP_SYSTICK_H\n#define __BSP_SYSTICK_H\n\n#include \"stm32f10x.h\"\n#include \"core_cm3.h\"\n\nvoid SysTick_Delay_ms(uint32_t ms);\nvoid SysTick_Delay_us(uint32_t us);\n\n#endif // !__BSP_SYSTICK_H\n\n```\n\n#### 在main.c中调用延时函数,实现LED闪烁\n\n```c\n/**\n * @brief Main function of the program.\n * \n * This function initializes the LED GPIO and enters an infinite loop. \n * In each iteration of the loop, it turns off the blue LED, delays for 0.5 seconds,\n * turns on the blue LED, and delays for 0.5 seconds again.\n * \n * @return int The exit status of the program.\n */\nint main(void)\n{\n    LED_GPIO_Config(); // Initialize the LED GPIO\n\n    while(1)\n    {\n        LED_B(OFF); // Turn off the blue LED\n        SysTick_Delay_ms(500); // Delay for 0.5 seconds\n        LED_B(ON); // Turn on the blue LED\n        SysTick_Delay_us(500000); // Delay for 0.5 seconds\n    }\n}\n\n```\n\n## 通信的基本概念\n\n### 串行和并行通信\n\n![串行和并行通信](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171542012.png)\n\n- 串行协议: USART, I2C, SPI, W500, CAN, LIN\n- 并行协议: FSMC, SDIO\n\n![对比](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171546066.png)\n\n### 全双工, 半双工和单工\n\n![全双工,半双工和单工](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171548657.png)\n\n### 同步与异步\n\n同步传输通过时钟信号进行同步, 保证数据传输的准确性\n\n![同步](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171550768.png)\n\n异步传输通过加入辅助的标识符, 保证数据传输的准确性\n\n![异步](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171552733.png)\n\n#### 同步与异步的区别\n\n![区别](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171554763.png)\n\n### 通信的速率\n\n![通信的速率](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171555519.png)\n\n当用一个二进制位表示一个码元时, 比特率和波特率相等\n\n## USART-串口通信\n\n### 串口通信协议简介\n\n![USART](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610065.png)\n\n#### 物理层的常用标准\n\n![USART](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610887.png)\n\n##### 232和TTL电平区别\n\n![USART](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171611637.png)\n\n- TTL: 从芯片出来的基本是TTL电平\n- 232: 负逻辑, 压差大\n\n###### 232通信通讯结构图\n\n![232](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171631235.png)\n\nDB9接口图\n\n![DB9接口](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171634288.png)\n\n###### USB转串口通讯结构图\n\n![USB转串口](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171644660.png)\n\n##### 串口到串口通讯结构图\n\n![串口到串口](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171655718.png)\n\n#### 串口数据包的组成\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171658813.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171659831.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171702232.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703446.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703050.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171704956.png)\n\n### STM32串口功能框图讲解\n\n#### 引脚部分讲解\n\n![STM32串口功能框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708669.png)\n\n![STM32串口功能框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708578.png)\n\n##### 引脚对应\n\n![引脚对应](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171710068.png)\n\n#### 数据寄存器部分\n\n![数据寄存器部分](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171723621.png)\n\n##### 数据格式\n\n![数据格式](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171725627.png)\n\n###### USART_CR1的bit12 M控制字长\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727509.png)\n\n###### USART_CR2的bit[13:12] STOP控制停止位的位数\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727238.png)\n\n###### USART_CR1的bit10(PSE), bit9(PS)来使能校验和选择校验模式\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171730822.png)\n\n###### USART_CR1的bit8(PEIE)来使能中断\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171731175.png)\n\n###### USART_SR的bit0(PE)来检测校验错误\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171732400.png)\n\n#### 发送数据部分\n\n![发送数据](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171739676.png)\n\n1. 先将USART_CR1的UE位置1(*使能USART模块*), 再将USART_CR1的TE位置1(*使能发送*)\n2. 数据从CPU或DMA中写入发送数据寄存器(TDR), TDR发送完毕后, USART_SR的TXE位置1(*数据已经被转移到移位寄存器中*)\n3. 发送移位寄存器发送完毕后, USART_SR的TC位置1(*表示发送完成*)\n\n#### 接收数据部分\n\n![接收数据部分](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171900970.png)\n\n1. 先将USART_CR1的UE位置1(*使能USART模块*), 再将USART_CR1的RE位置1(*使能接收*)\n2. 数据从RX到接收移位寄存器到接收数据寄存器(RDR), 接收完毕后, USART_SR的RXNE位置1(*收到数据, 可以读出*)\n\n#### 波特率设置\n\n##### 使用USART_BRR进行配置\n\n![USART_BRR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171906798.png)\n\n##### 波特率的计算公式\n\n![波特率的计算公式](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171909589.png)\n\n- APB2时钟: 72MHz, 挂载USART1\n- APB1时钟: 36MHz, 挂载USART2, 3, 4, 5\n\n![波特率](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171910703.png)\n\n### 串口初始化结构体和固件库讲解\n\n#### 串口初始化结构体\n\n在stm32f10x_usart.h中定义串口初始化结构体(异步)\n\n```c\n/** \n  * @brief  USART Init Structure definition  \n  */ \n  \ntypedef struct\n{\n  // 设置波特率\n  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.\n                                           The baud rate is computed using the following formula:\n                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))\n                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */\n\n  // 设置字长\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_WordLength_8b                  ((uint16_t)0x0000)\n   * #define USART_WordLength_9b                  ((uint16_t)0x1000)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.\n                                           This parameter can be a value of @ref USART_Word_Length */\n\n  // 设置停止位\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_StopBits_1                     ((uint16_t)0x0000)\n   * #define USART_StopBits_0_5                   ((uint16_t)0x1000)\n   * #define USART_StopBits_2                     ((uint16_t)0x2000)\n   * #define USART_StopBits_1_5                   ((uint16_t)0x3000)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.\n                                           This parameter can be a value of @ref USART_Stop_Bits */\n\n  // 设置校验\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_Parity_No                      ((uint16_t)0x0000)\n   * #define USART_Parity_Even                    ((uint16_t)0x0400)\n   * #define USART_Parity_Odd                     ((uint16_t)0x0600)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_Parity;              /*!< Specifies the parity mode.\n                                           This parameter can be a value of @ref USART_Parity\n                                           @note When parity is enabled, the computed parity is inserted\n                                                 at the MSB position of the transmitted data (9th bit when\n                                                 the word length is set to 9 data bits; 8th bit when the\n                                                 word length is set to 8 data bits). */\n \n  // 设置模式\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_Mode_Rx                        ((uint16_t)0x0004)\n   * #define USART_Mode_Tx                        ((uint16_t)0x0008)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.\n                                           This parameter can be a value of @ref USART_Mode */\n\n  // 设置硬件控制流\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)\n   * #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)\n   * #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)\n   * #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled\n                                           or disabled.\n                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */\n} USART_InitTypeDef;\n```\n\n在stm32f10x_usart.h中定义串口初始化结构体(同步)\n\n```c\n/** \n  * @brief  USART Clock Init Structure definition  \n  */ \n  \ntypedef struct\n{\n\n  // 设置使能时钟\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_Clock_Disable                  ((uint16_t)0x0000)\n   * #define USART_Clock_Enable                   ((uint16_t)0x0800)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.\n                               This parameter can be a value of @ref USART_Clock */\n\n  // 设置时钟的极性, 即总线空闲时CK引脚保持低电平还是高电平\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_CPOL_Low                       ((uint16_t)0x0000)\n   * #define USART_CPOL_High                      ((uint16_t)0x0400)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.\n                               This parameter can be a value of @ref USART_Clock_Polarity */\n\n  // 设置时钟的相位, 即数据采样的时机为第一个边沿还是第二个边沿\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_CPHA_1Edge                     ((uint16_t)0x0000)\n   * #define USART_CPHA_2Edge                     ((uint16_t)0x0200)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.\n                               This parameter can be a value of @ref USART_Clock_Phase */\n\n  // 设置时钟的最后一个数据位的时钟脉冲是否输出到SCLK引脚\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_LastBit_Disable                ((uint16_t)0x0000)\n   * #define USART_LastBit_Enable                 ((uint16_t)0x0100)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted\n                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.\n                               This parameter can be a value of @ref USART_Last_Bit */\n} USART_ClockInitTypeDef;\n```\n\n#### 串口库函数\n\n- **串口初始化函数**: void USART_Init(USART_TypeDef*USARTx, USART_InitTypeDef* USART_InitStruct);\n- **中断配置函数**: void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);\n- **串口使能函数**: void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);\n- **数据发送函数**: void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);\n- **数据接收函数**: void USART_ReceiveData(USART_TypeDef* USARTx);\n- **中断状态位获取函数**: ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);\n\n### USB转串口的硬件原理图\n\n![硬件原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401172002602.png)\n\n### 串口GPIO汇总\n\n![串口GPIO](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220859886.png)\n\n### 补充: 外设的GPIO配置\n\n在STM32F10x参考手册中的8.1.11节可找到外设的GPIO配置, 其中关于USART部分的GPIO配置如下图\n\n![USART的GPIO配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220904826.png)\n\n### 配置串口助手\n\n本项目使用的串口助手: 野火多功能调试助手V1.0.2.9\n\n串口配置如下图(*串口配置参数与串口的初始化配置有关, 该配置符合下文代码的初始化*)\n\n![串口助手配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401250242370.png)\n\n### USART接收和发送实验\n\n项目地址: **21-USART-接收和发送**\n\n**实验需求**: 单片机给电脑发送数据, 电脑上位机把数据打印出来; 电脑上位机给单片机发数据, 单片机接收到数据之后立马发回给电脑, 并打印出来.\n\n#### 在bsp_usart.h中进行串口的宏定义, 并使用条件编译来选择串口\n\n```c\n/** \n  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏\n  * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线\n  * 2-修改GPIO的宏\n  */\n\n // 通过条件编译选择串口, 使用的串口置1，其余置0\n #define DEBUG_USART1 1\n #define DEBUG_USART2 0\n #define DEBUG_USART3 0\n #define DEBUG_USART4 0\n #define DEBUG_USART5 0\n \n#if DEBUG_USART1\n// 串口1-USART1\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n    \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define  DEBUG_USART_IRQ                USART1_IRQn\n#define  DEBUG_USART_IRQHandler         USART1_IRQHandler\n\n#elif DEBUG_USART2\n// 串口2-USART2\n#define  DEBUG_USARTx                   USART2\n#define  DEBUG_USART_CLK                RCC_APB1Periph_USART2\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3\n\n#define  DEBUG_USART_IRQ                USART2_IRQn\n#define  DEBUG_USART_IRQHandler         USART2_IRQHandler\n\n#elif DEBUG_USART3\n// 串口3-USART3\n#define  DEBUG_USARTx                   USART3\n#define  DEBUG_USART_CLK                RCC_APB1Periph_USART3\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOB   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOB\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n#define  DEBUG_USART_IRQ                USART3_IRQn\n#define  DEBUG_USART_IRQHandler         USART3_IRQHandler\n\n#elif DEBUG_USART4\n//串口4-UART4\n#define  DEBUG_USARTx                   UART4\n#define  DEBUG_USART_CLK                RCC_APB1Periph_UART4\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOC\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n#define  DEBUG_USART_IRQ                UART4_IRQn\n#define  DEBUG_USART_IRQHandler         UART4_IRQHandler\n\n#elif DEBUG_UART5\n// 串口5-UART5\n#define  DEBUG_USARTx                   UART5\n#define  DEBUG_USART_CLK                RCC_APB1Periph_UART5\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOD\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2\n\n#define  DEBUG_USART_IRQ                UART5_IRQn\n#define  DEBUG_USART_IRQHandler         UART5_IRQHandler\n\n#endif\n```\n\n#### 在bsp_usart.c中编写usart的初始化函数\n\n```c\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n    \n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n    \n     // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = \n    USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 串口中断优先级配置\n    NVIC_Configuration();\n    \n    // 使能串口接收中断\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE); \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);     \n}\n```\n\n#### 在bsp_usart.c中编写串口中断优先级配置函数\n\n```c\n /**\n  * @brief  配置嵌套向量中断控制器NVIC\n  * @param  无\n  * @retval 无\n  */\nstatic void NVIC_Configuration(void)\n{\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  /* 嵌套向量中断控制器组选择 */\n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  /* 配置USART为中断源 */\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  /* 抢断优先级*/\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\n  /* 子优先级 */\n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  /* 使能中断 */\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  /* 初始化配置NVIC */\n  NVIC_Init(&NVIC_InitStructure);\n}\n```\n\n#### 在bsp_usart.c中编写发送一个字节到串口的函数\n\n```c\n/**\n * @brief 发送一个字节到指定的USART外设\n * \n * @param pUSARTx USART外设指针\n * @param ch 要发送的字节\n */\nvoid Usart_SendByte(USART_TypeDef* pUSARTx, uint8_t ch)\n{\n    // 发送一个字节\n    USART_SendData(pUSARTx, ch);\n    \n    // 等待发送数据寄存器为空\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)\n    {\n     ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写发送两个字节到串口的函数\n\n```c\n/**\n * @brief 发送两个字节的数据\n * \n * @param pUSARTx USART外设指针\n * @param ch 要发送的16位数据\n */\nvoid Usart_SendHalfWord(USART_TypeDef* pUSARTx, uint16_t ch)\n{\n    uint8_t tmp_h, tmp_l;\n\n    tmp_h = (ch & 0xFF00) >> 8; // 取出高八位\n    tmp_l = (ch & 0xFF) >> 0; // 取出低八位\n\n    USART_SendData(pUSARTx, tmp_h); // 发送高八位\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)\n    {\n        ;\n    }\n\n    USART_SendData(pUSARTx, tmp_l); // 发送低八位\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)\n    {\n        ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写发送数组的函数\n\n```c\n/**\n * @brief Sends an array of bytes over USART.\n * \n * This function sends an array of bytes over the specified USART peripheral.\n * \n * @param pUSARTx The USART peripheral to use.\n * @param array Pointer to the array of bytes to send.\n * @param num The number of bytes to send.\n */\nvoid Usart_SendArray(USART_TypeDef* pUSARTx, uint8_t* array, uint16_t num)\n{\n    for(uint16_t i = 0; i < num; i++)\n    {\n     Usart_SendByte(pUSARTx, array[i]);\n    }\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)\n    {\n     ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写发送字符串的函数\n\n```c\n/**\n * @brief 发送字符串到USART外设\n * \n * @param pUSARTx USART外设指针\n * @param str 要发送的字符串\n */\nvoid Usart_SendString(USART_TypeDef* pUSARTx, uint8_t* str)\n{\n    // 发送数据\n    uint8_t i = 0;\n    do\n    {\n     Usart_SendByte(pUSARTx, *(str + i));\n     i++;\n    } while (*(str + i) != '\\0');\n\n    // 等待发送完成\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)\n    {\n     ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写重定向标准输出输入函数, 使得串口可使用scanf printf等函数\n\n```c\n// 重定向c库函数printf, putchar到串口，重定向后可使用printf, putchar函数\n/**\n * @brief 重定向标准输出函数\n * @param ch 要发送的字符\n * @param f 文件指针\n * @retval 发送的字符\n */\nint fputc(int ch, FILE* f)\n{\n    USART_SendData(DEBUG_USARTx, (uint8_t)ch);\n\n    while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET)\n    {\n     ;\n    }\n\n    return (ch);\n}\n\n/**\n * @brief 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\n * \n * @param f 文件指针\n * @return int 从串口接收到的数据\n */\nint fgetc(FILE *f)\n{\n    /* 等待串口输入数据 */\n    while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);\n\n    return (int)USART_ReceiveData(DEBUG_USARTx);\n}\n\n```\n\n#### 在main.c函数中进行测试\n\n```c\n#include \"stm32f10x.h\"\n#include \"bsp_led.h\"\n#include \"bsp_usart.h\"\n\nint main(void)\n{\n    USART_Config(); // 初始化USART\n\n    // 发送1字节数据\n    Usart_SendByte(DEBUG_USARTx, 'a');\n    Usart_SendByte(DEBUG_USARTx, '\\n');\n\n    // 发送2字节数据\n    Usart_SendHalfWord(DEBUG_USARTx, 0xFF56);\n\n    // 发送数组\n    Usart_SendArray(DEBUG_USARTx, (uint8_t*)\"Hello World!\", 11);\n    uint8_t array[11] = {\"Hello World!\"};\n    Usart_SendArray(DEBUG_USARTx, array, 11);\n\n    // 发送字符串\n    Usart_SendString(DEBUG_USARTx, \"\\nString: Hello World\\n\");\n\n    // 重定向printf函数\n    printf(\"printf: Hello World\\n\");\n\n    // 重定向putchar函数\n    putchar('p');\n    putchar('u');\n    putchar('t');\n    putchar('c');\n    putchar('h');\n    putchar('a');\n    putchar('r');\n    putchar('\\n');\n    \n    while(1)\n    {\n        ;\n    }\n}\n\n```\n\n#### 在stm32f10x_it.c中编写中断服务函数实现串口数据的接收并发送\n\n```c\n/**\n * @brief Interrupt handler for the DEBUG_USART.\n *\n * This function is called when there is a receive interrupt from the DEBUG_USART.\n * It receives data from the DEBUG_USART and sends it back.\n */\nvoid DEBUG_USART_IRQHandler(void)\n{\n  uint8_t ucTemp;\n\n  if(USART_GetITStatus(DEBUG_USARTx, USART_IT_RXNE) != RESET)\n  {\n    ucTemp = USART_ReceiveData(DEBUG_USARTx); // Receive data into ucTemp\n    USART_SendData(DEBUG_USARTx, ucTemp); // Send data\n  }\n}\n```\n\n### 补充: 通过重写fputc函数重定向C库函数printf到串口\n\n通过重写 fputc 函数可以实现重定向 printf 到串口的效果。这是因为 printf 函数实际上是通过 C 标准库中的输出函数 fputc 来将字符一个个地发送到输出设备的。当你重写了 fputc 函数，实际上就改变了字符的输出方式，使得字符被发送到你所定义的输出设备，比如串口。\n\n下面是一个简单的示例，演示了如何通过重写 fputc 函数来重定向 printf 到串口。这里假设你已经在系统中初始化了串口的硬件。\n\n```c\n#include <stdio.h>\n\n// 串口初始化函数，假设已经在系统中实现\nvoid initSerialPort() {\n    // 串口初始化的相关代码\n}\n\n// 重定向标准输出函数\nint fputc(int ch, FILE *f) {\n    // 将字符发送到串口\n    // 你需要在这里添加实际的串口发送代码\n    // 例如：sendCharacterToSerialPort(ch);\n    \n    return ch;\n}\n\nint main() {\n    // 初始化串口\n    initSerialPort();\n\n    // 在这之后，调用printf将输出信息发送到串口\n    printf(\"Hello, Serial Port!\\n\");\n\n    // 其他代码...\n\n    return 0;\n}\n\n```\n\n在这个示例中，我们重写了 fputc 函数，使其将字符发送到串口。当 printf 调用 fputc 函数时，字符就会被发送到串口。这样就实现了将 printf 输出重定向到串口的效果。\n\n需要注意的是，具体的串口发送函数实现（比如 sendCharacterToSerialPort）需要根据你的具体硬件和系统来编写。这个示例只是演示了重定向的基本原理。\n\n### USART控制RGB灯实验\n\n项目地址: **21-USART-控制RGB灯**\n\n**实验需求**: 电脑给单片机发命令, 用于控制开发板上的RGB灯.\n\n#### 在bsp_led.h中定义RGB灯的宏\n\n```c\n#ifndef __LED_H\n#define __LED_H\n\n\n#include \"stm32f10x.h\"\n\n\n/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */\n// R-红色\n#define LED1_GPIO_PORT     GPIOB                 /* GPIO端口 */\n#define LED1_GPIO_CLK      RCC_APB2Periph_GPIOB  /* GPIO端口时钟 */\n#define LED1_GPIO_PIN  GPIO_Pin_5           /* 连接到SCL时钟线的GPIO */\n\n// G-绿色\n#define LED2_GPIO_PORT     GPIOB                 /* GPIO端口 */\n#define LED2_GPIO_CLK      RCC_APB2Periph_GPIOB  /* GPIO端口时钟 */\n#define LED2_GPIO_PIN  GPIO_Pin_0           /* 连接到SCL时钟线的GPIO */\n\n// B-蓝色\n#define LED3_GPIO_PORT     GPIOB                 /* GPIO端口 */\n#define LED3_GPIO_CLK      RCC_APB2Periph_GPIOB  /* GPIO端口时钟 */\n#define LED3_GPIO_PIN  GPIO_Pin_1           /* 连接到SCL时钟线的GPIO */\n\n\n/** the macro definition to trigger the led on or off \n  * 1 - off\n  *0 - on\n  */\n#define ON  0\n#define OFF 1\n\n/* 使用标准的固件库控制IO*/\n#define LED1(a) if (a) \\\n     GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\\\n     else  \\\n     GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)\n\n#define LED2(a) if (a) \\\n     GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\\\n     else  \\\n     GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)\n\n#define LED3(a) if (a) \\\n     GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);\\\n     else  \\\n     GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)\n\n\n/* 直接操作寄存器的方法控制IO */\n#define digitalHi(p,i)   {p->BSRR=i;}  //输出为高电平  \n#define digitalLo(p,i)   {p->BRR=i;}  //输出低电平\n#define digitalToggle(p,i) {p->ODR ^=i;} //输出反转状态\n\n\n/* 定义控制IO的宏 */\n#define LED1_TOGGLE   digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)\n#define LED1_OFF     digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)\n#define LED1_ON      digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)\n\n#define LED2_TOGGLE   digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)\n#define LED2_OFF     digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)\n#define LED2_ON      digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)\n\n#define LED3_TOGGLE   digitalToggle(LED3_GPIO_PORT,LED3_GPIO_PIN)\n#define LED3_OFF     digitalHi(LED3_GPIO_PORT,LED3_GPIO_PIN)\n#define LED3_ON      digitalLo(LED3_GPIO_PORT,LED3_GPIO_PIN)\n\n/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */\n\n//红\n#define LED_RED  \\\n     LED1_ON;\\\n     LED2_OFF\\\n     LED3_OFF\n\n//绿\n#define LED_GREEN  \\\n     LED1_OFF;\\\n     LED2_ON\\\n     LED3_OFF\n\n//蓝\n#define LED_BLUE \\\n     LED1_OFF;\\\n     LED2_OFF\\\n     LED3_ON\n\n     \n//黄(红+绿)     \n#define LED_YELLOW \\\n     LED1_ON;\\\n     LED2_ON\\\n     LED3_OFF\n//紫(红+蓝)\n#define LED_PURPLE \\\n     LED1_ON;\\\n     LED2_OFF\\\n     LED3_ON\n\n//青(绿+蓝)\n#define LED_CYAN \\\n     LED1_OFF;\\\n     LED2_ON\\\n     LED3_ON\n     \n//白(红+绿+蓝)\n#define LED_WHITE \\\n     LED1_ON;\\\n     LED2_ON\\\n     LED3_ON\n     \n//黑(全部关闭)\n#define LED_RGBOFF \\\n     LED1_OFF;\\\n     LED2_OFF\\\n     LED3_OFF\n\nvoid LED_GPIO_Config(void);\n\n#endif /* __LED_H */\n```\n\n#### 在bsp_led.c中编写led初始化函数\n\n```c\n/**\n  ******************************************************************************\n  * @file    bsp_led.c\n  * @author  fire\n  * @version V1.0\n  * @date    2013-xx-xx\n  * @brief   led应用函数接口\n  ******************************************************************************\n  * @attention\n  *\n  * 实验平台:野火 F103-霸道 STM32 开发板 \n  * 论坛    :http://www.firebbs.cn\n  * 淘宝    :https://fire-stm32.taobao.com\n  *\n  ******************************************************************************\n  */\n  \n#include \"./led/bsp_led.h\"   \n\n /**\n  * @brief  初始化控制LED的IO\n  * @param  无\n  * @retval 无\n  */\nvoid LED_GPIO_Config(void)\n{  \n    /*定义一个GPIO_InitTypeDef类型的结构体*/\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    /*开启LED相关的GPIO外设时钟*/\n    RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK | LED3_GPIO_CLK, ENABLE);\n    /*选择要控制的GPIO引脚*/\n    GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN; \n\n    /*设置引脚模式为通用推挽输出*/\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   \n\n    /*设置引脚速率为50MHz */   \n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; \n\n    /*调用库函数，初始化GPIO*/\n    GPIO_Init(LED1_GPIO_PORT, &GPIO_InitStructure); \n\n    /*选择要控制的GPIO引脚*/\n    GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;\n\n    /*调用库函数，初始化GPIO*/\n    GPIO_Init(LED2_GPIO_PORT, &GPIO_InitStructure);\n\n    /*选择要控制的GPIO引脚*/\n    GPIO_InitStructure.GPIO_Pin = LED3_GPIO_PIN;\n\n    /*调用库函数，初始化GPIOF*/\n    GPIO_Init(LED3_GPIO_PORT, &GPIO_InitStructure);\n\n    /* 关闭所有led灯 */\n    GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);\n\n    /* 关闭所有led灯 */\n    GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);  \n    \n      /* 关闭所有led灯 */\n    GPIO_SetBits(LED3_GPIO_PORT, LED3_GPIO_PIN);\n}\n\nvoid assert_failed(uint8_t* file, uint32_t line)\n{\n    // 断言错误时执行的代码\n    LED1_ON;\n}\n/*********************************************END OF FILE**********************/\n```\n\n#### 在bsp_usart.c中关闭串口中断\n\n```c\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n       // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = \n    USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 将中断失能\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, DISABLE); \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);     \n}\n```\n\n#### 在main.c中编写测试程序\n\n```c\nint main(void)\n{\n    uint8_t ch = 0;\n\n    USART_Config(); // 初始化USART\n    LED_GPIO_Config(); // 初始化LED\n\n    printf(\"USART-RGB\\n\");\n    printf(\"1:RED, 2:GREEN, 3:BLUE, 4:YELLOW, 5:PURPLE, 6:CYAN, 7:WHITE\\n\");\n    printf(\"Others: BLACK\\n\");\n    \n\n    while(1)\n    {\n        ch = getchar();\n        printf(\"ch = %c\\n\", ch);\n\n        switch(ch)\n        {\n        case '1': LED_RED;\n            break;\n        case '2': LED_GREEN;\n            break;\n        case '3': LED_BLUE;\n            break;\n        case '4': LED_YELLOW;\n            break;\n        case '5': LED_PURPLE;\n            break;\n        case '6': LED_CYAN;\n            break;\n        case '7': LED_WHITE;\n            break;\n        \n        default: LED_RGBOFF;\n            break;\n        }\n    }\n}\n\n```\n\n## DMA\n\nDMA: Direct Memory Access, 直接寄存器访问. 主要功能是可以把数据从一个地方搬到另一个地方, 而且不占用CPU\n\n- DMA1: 有7个通道, 可实现P->M, M->P, M->M\n- DMA2: 有5个通道, 可实现P->M, M->P, M->M(*只存在于大容量和互联型产品中*)\n\n### 补充: DMA介绍\n\nDMA（Direct Memory Access，直接内存访问）是计算机系统中的一种技术，**它允许外设或内存模块通过绕过中央处理器（CPU）直接与系统内存进行数据传输**。DMA的目标是提高数据传输效率，减轻CPU的负担，使CPU能够专注于执行其他任务。\n\n以下是关于DMA的一些重要概念和特性：\n\n#### DMA的工作原理\n\nDMA通过在系统总线上控制数据传输而不涉及CPU来工作。它可以在CPU不介入的情况下，直接将数据从一个位置传输到另一个位置。\n\n1. 配置： CPU负责配置DMA，确定源地址、目标地址、传输方向、传输大小等参数。\n2. 启动： 一旦DMA被配置，CPU就可以启动DMA控制器，它将负责管理数据传输。\n3. 传输： DMA控制器在总线上控制数据传输，无需CPU的干预。数据在源和目标之间直接传输。\n4. 中断通知： DMA传输完成后，通常会发出一个中断信号，以通知CPU或其他系统组件。\n\n#### DMA的优点\n\n1. 提高性能： 通过绕过CPU，减轻了CPU的负担，使其能够执行其他任务，提高了整体系统性能。\n2. 实时数据传输： 特别适用于实时数据传输，如音频、视频流等。\n3. 高效处理大量数据： 对于大量数据的块传输，DMA比CPU执行这样的传输更为高效。\n\n#### DMA的应用领域\n\nDMA在多种应用场景中都得到了广泛应用，包括但不限于：\n\n1. 嵌入式系统： 用于处理外设和内存之间的数据传输，例如，处理音频、图像等。\n2. 网络通信： 在网络接口控制器和系统内存之间快速传输数据。\n3. 存储系统： 用于在磁盘、固态硬盘等存储设备和系统内存之间进行数据传输。\n4. 图形处理： 在图形卡和系统内存之间进行大规模图形数据的传输。\n\n#### DMA控制器\n\nDMA通常由专门的硬件单元，称为DMA控制器，来管理。DMA控制器的设计和功能因芯片架构而异，但通常包括寄存器用于配置、启动和监视传输。\n\n总的来说，DMA是一项重要的技术，对于需要高效数据传输的系统是至关重要的。通过减轻CPU的负担，DMA提高了系统的整体性能和响应速度。\n\n### DMA功能框图讲解\n\n![DMA功能框图讲解](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261122722.png)\n\n#### DMA请求映射\n\nDMA1请求映射\n\n![DMA1请求映射](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261126729.png)\n\nDMA2请求映射\n\n![DMA2请求映射](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261127579.png)\n\n#### DMA仲裁器\n\n![DMA仲裁器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261128690.png)\n\n软件配置在寄存器DMA_CCRx:PL[1:0]进行通道优先级配置\n\n### DMA固件库-初始化结构体\n\n初始化结构体在stm32f10x_dma.h文件中\n\n```c\n/** \n  * @brief  DMA Init structure definition\n  */\n\ntypedef struct\n{\n  /*--------------------------------------------------------------------------------\n   * 外设地址\n   * 由寄存器 DMA_CPARx 进行配置\n   *---------------------------------------------------------------------------- */\n  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器地址\n   * 由寄存器 DMA_CMARx 进行配置\n   *---------------------------------------------------------------------------- */\n  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */\n\n  /*--------------------------------------------------------------------------------\n   * 传输方向\n   * P->M 和 M->P 由寄存器 DMA_CCRx:DIR[4] 进行配置\n   * M->M 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.\n                                        This parameter can be a value of @ref DMA_data_transfer_direction */\n\n  /*--------------------------------------------------------------------------------\n   * 缓冲区大小, 传输数目\n   * 由寄存器 DMA_CNDTRx 进行配置\n   *-------------------------------------------------------------------------------*/\n  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. \n                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize\n                                        or DMA_MemoryDataSize members depending in the transfer direction. */\n\n  /*--------------------------------------------------------------------------------\n   * 外设增量模式\n   * 由寄存器 DMA_CCRx:PINC[6] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器增量模式\n   * 由寄存器 DMA_CCRx:MINC[7] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_memory_incremented_mode */\n\n  /*--------------------------------------------------------------------------------\n   * 外设数据宽度\n   * 由寄存器 DMA_CCRx:PSIZE[9:8] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.\n                                        This parameter can be a value of @ref DMA_peripheral_data_size */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器数据宽度\n   * 由寄存器 DMA_CCRx:MSIZE[11:10] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.\n                                        This parameter can be a value of @ref DMA_memory_data_size */\n\n  /*--------------------------------------------------------------------------------\n   * 传输模式\n   * 由寄存器 DMA_CCRx:CIRC[5] 进行配置\n   * 通过 DMA_ISR 判断传输状态来判断传输完成, 传输一半, 传输错误\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_circular_normal_mode.\n                                        @note: The circular buffer mode cannot be used if the memory-to-memory\n                                              data transfer is configured on the selected Channel */\n\n  /*--------------------------------------------------------------------------------\n   * 优先级\n   * 由寄存器 DMA_CCRx:PL[1:0] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_priority_level */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器到存储器模式\n   * 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.\n                                        This parameter can be a value of @ref DMA_memory_to_memory */\n}DMA_InitTypeDef;\n```\n\n### DMA固件库-固件库函数\n\n在stm32f10x_dma.h文件中可以找到DMA固件库函数的声明, 以下是常用的函数\n\n```c\nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct); // 初始化函数\nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState); // 使能DMA\nFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG); // 判断标志位\n```\n\n### DMA实验1: M to M\n\n项目地址: **22-DMA-MtoM**\n\n**实验需求**: FLASH to SRAM, 把内部FLASH的数据传输到内部的SRAM\n\n#### 在bsp_dma_m2m.h增加宏定义\n\n```c\n// 当使用存储器到存储器模式时候，通道可以随便选，没有硬性的规定\n#define M2M_DMA_CHANNEL     DMA1_Channel6\n#define M2M_DMA_CLOCK       RCC_AHBPeriph_DMA1\n// 传输完成标志\n#define M2M_DMA_FLAG_TC     DMA1_FLAG_TC6\n// 要发送的数据大小\n#define BUFFER_SIZE     32\n```\n\n#### 在bsp_dma_m2m.c中定义源和目标变量\n\n```c\n/* 定义aSRC_Const_Buffer数组作为DMA传输数据源\n * const关键字将aSRC_Const_Buffer数组变量定义为常量类型\n * 表示数据存储在内部的FLASH中\n */\nconst uint32_t aSRC_Const_Buffer[BUFFER_SIZE]= {\n                                    0x01020304,0x05060708,0x090A0B0C,0x0D0E0F10,\n                                    0x11121314,0x15161718,0x191A1B1C,0x1D1E1F20,\n                                    0x21222324,0x25262728,0x292A2B2C,0x2D2E2F30,\n                                    0x31323334,0x35363738,0x393A3B3C,0x3D3E3F40,\n                                    0x41424344,0x45464748,0x494A4B4C,0x4D4E4F50,\n                                    0x51525354,0x55565758,0x595A5B5C,0x5D5E5F60,\n                                    0x61626364,0x65666768,0x696A6B6C,0x6D6E6F70,\n                                    0x71727374,0x75767778,0x797A7B7C,0x7D7E7F80};\n\n/**\n * 定义DMA传输目标存储器\n * 存储在内部的SRAM中                  \n */\nuint32_t aDST_Buffer[BUFFER_SIZE];\n\n```\n\n#### 在bsp_dma_m2m.c中增加DMA初始化函数\n\n```c\n/**\n * @brief 配置存储器到存储器的DMA传输\n * \n * @param None\n * @return None\n */\nvoid M2M_DMA_Config(void)\n{\n    DMA_InitTypeDef DMA_InitStructure; // 定义DMA初始化结构体变量\n    \n    RCC_AHBPeriphClockCmd(M2M_DMA_CLOCK, ENABLE); // 打开DMA时钟\n\n    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)aSRC_Const_Buffer; // 配置外设地址, 实际将FLASH的数据配置成了外设\n    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)aDST_Buffer; // 配置存储器地址\n    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; // 配置传输方向，从外设读取数据发送到存储器\n    DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE; // 配置传输数据大小\n    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable; // 配置外设地址自增\n    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; // 配置存储器地址自增\n    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; // 配置外设数据大小\n    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; // 配置存储器数据大小\n    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; // 配置传输模式，非循环模式\n    DMA_InitStructure.DMA_Priority = DMA_Priority_High; // 配置传输通道优先级\n    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; // 配置存储器到存储器模式\n\n    DMA_Init(M2M_DMA_CHANNEL, &DMA_InitStructure); // 初始化DMA通道\n    DMA_ClearFlag(M2M_DMA_FLAG_TC); // 清除DMA通道传输完成标志位\n    DMA_Cmd(M2M_DMA_CHANNEL, ENABLE); // 使能DMA通道\n}\n```\n\n#### 在bsp_dma_m2m.c中增加判断数据相等的函数\n\n```c\n/**\n * @brief 比较两个缓冲区的数据是否相等\n * \n * @param pBuffer 指向第一个缓冲区的指针\n * @param pBuffer1 指向第二个缓冲区的指针\n * @param BufferLength 缓冲区的长度\n * @return uint8_t 如果两个缓冲区的数据相等，则返回1；否则返回0\n */\nuint8_t Buffercmp(const uint32_t* pBuffer, uint32_t* pBuffer1, uint16_t BufferLength)\n{\n    /* 数据长度递减 */\n    while(BufferLength--)\n    {\n        /* 判断两个数据源是否对应相等 */\n        if(*pBuffer != *pBuffer1)\n        {\n            /* 对应数据源不相等马上退出函数，并返回0 */\n            return 0;\n        }\n        /* 递增两个数据源的地址指针 */\n        pBuffer++;\n        pBuffer1++;\n    }\n    /* 完成判断并且对应数据相对 */\n    return 1;  \n}\n```\n\n#### 在main.c函数中进行DMA测试\n\n```c\n// 声明以下变量来自外部文件\nextern const uint32_t aSRC_Const_Buffer[BUFFER_SIZE];\nextern uint32_t aDST_Buffer[BUFFER_SIZE];\n\n/**\n * @brief Delays the execution for a specified number of milliseconds.(Not Sure)\n * @param ms The number of milliseconds to delay.\n * @return None.\n */\nvoid Delay_ms(uint32_t ms)\n{\n    uint32_t i = 0;\n    for(i = 0; i < ms; i++)\n    {\n        uint16_t j = 0;\n        for(j = 0; j < 1000; j++)\n        {\n            ;\n        }\n    }\n}\n\nint main(void)\n{\n    uint8_t status = 0; // 接收比较的结构\n\n    LED_GPIO_Config(); // 初始化LED\n    M2M_DMA_Config(); // 初始化DMA\n     \n    // 等待DMA1传送完毕\n    while(DMA_GetFlagStatus(M2M_DMA_FLAG_TC) == RESET)\n    {\n        ;\n    }\n\n    LED_YELLOW;\n    Delay_ms(10000); // DMA初始化完成后亮黄灯\n\n    status = Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE); // 比较两个数组的数据是否相等\n    if(status == 0)\n    {\n        LED_RED; // 数据不相等亮红灯\n    }\n    else\n    {\n        LED_GREEN; // 数据相等亮绿灯\n    }\n\n    while(1)\n    {\n        ;\n    }\n}\n```\n\n### DMA实验2: M to P\n\n项目地址: **22-DMA-MtoP**\n\n**实验需求**: SRAM to 串口, 同时LED灯闪烁, 演示DMA数据不需占用CPU\n\n### 在bsp_dma_m2p.h中加入宏定义\n\n```c\n// 串口工作参数宏定义\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define USART_TX_DMA_CLK RCC_AHBPeriph_DMA1 // 串口DMA时钟\n#define  USART_TX_DMA_CHANNEL     DMA1_Channel4 // 串口对应的DMA请求通道\n#define  USART_DR_ADDRESS        (USART1_BASE+0x04) // 外设寄存器地址\n#define  SENDBUFF_SIZE            5000 // 一次发送的数据量\n#define  USART_TX_DMA_FLAG_TC DMA1_FLAG_TC4 // 标志位\n```\n\n#### 在bsp_dma_m2p.c中加入USART的初始化函数\n\n```c\n/**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n\n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n       // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n\n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure); \n\n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);     \n}\n```\n\n#### 在bsp_dma_m2p.c中加入USARTx_TX DMA配置\n\n实现内存到外设(USART1->DR)\n\n```c\n/**\n  * @brief  USARTx TX DMA 配置，内存到外设(USART1->DR)\n  * @param  无\n  * @retval 无\n  */\nvoid USARTx_DMA_Config(void)\n{\n    DMA_InitTypeDef DMA_InitStructure;\n    \n    // 开启DMA时钟\n    RCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);\n    // 设置DMA源地址：串口数据寄存器地址*/\n       DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;\n    // 内存地址(要传输的变量的指针)\n    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff;\n    // 方向：从内存到外设 \n    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\n    // 传输大小 \n    DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;\n    // 外设地址不增     \n    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n    // 内存地址自增\n    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n    // 外设数据单位 \n    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\n    // 内存数据单位\n    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  \n    // DMA模式，一次或者循环模式\n    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;\n    // DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; \n    // 优先级：中 \n    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; \n    // 禁止内存到内存的传输\n    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n    // 配置DMA通道     \n    DMA_Init(USART_TX_DMA_CHANNEL, &DMA_InitStructure);  \n    // 清除TC标志位\n    DMA_ClearFlag(USART_TX_DMA_FLAG_TC);\n    // 使能DMA\n    DMA_Cmd (USART_TX_DMA_CHANNEL, ENABLE);\n    \n```\n\n#### 在bsp_dma_m2p.c中声明在内存的变量\n\n```c\nuint8_t SendBuff[SENDBUFF_SIZE];\n```\n\n#### 在main.c中声明外部变量\n\n```c\nextern uint8_t SendBuff[SENDBUFF_SIZE];\n```\n\n#### 在main.c中测试DMA\n\n实现DMA将储存器中的数据发送到USART->DR, 并实现LED1闪烁\n\n```c\n/**\n * @brief 实现DMA将储存器中的数据发送到USART->DR, 并实现LED1闪烁\n * \n * @return int \n */\nint main(void)\n{\n\n    LED_GPIO_Config(); // 初始化LED\n    USART_Config(); // 串口初始化\n\n    for(uint16_t i = 0; i < SENDBUFF_SIZE; i++)\n    {\n        SendBuff[i] = 'P';\n    }\n\n    USARTx_DMA_Config(); // 初始化DMA\n    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); // 使能DMA发送\n\n    while(1)\n    {\n        LED1_TOGGLE;\n        Delay_ms(10000);\n    }\n}\n```\n\n## 常用存储器\n\n### 存储器的种类\n\n易失性和非易失性区别在于**掉电数据是否会丢失**, 易失性存储器**读写速度相对较快**\n\n- 易失性存储器(RAM)\n  - DRAM(动态RAM, 常用于PC机)\n    - SDRAM(STM32F429)\n    - DDR SDRAM\n    - DDRII SDRAM\n    - DDRIII SDRAM(常用于PC机)\n  - SRAM(静态RAM, STM32F103)\n- 非易失性存储器\n  - ROM(半导体类)\n    - MASK ROM(对于STM32可读不可写)\n    - PROM(可编程ROM)\n      - OTPROM(可写一次的ROM)\n      - EPROM(可用高电压擦除的ROM)\n      - EEPROM(STM32F103, 可用较低电压3.3V擦除的ROM)\n    - FLASH(半导体类)\n    - NOR FLASH(一般用来存储程序)\n    - NAND FLASH(一般用来存储数据)\n    - 光盘\n    - 软盘\n    - 机械硬盘\n\n### RAM存储器(易失性存储器)\n\n#### RAM介绍\n\n![RAM介绍](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262322421.png)\n\n#### DRAM的存储单元结构\n\n![DRAM的存储单元结构](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262327533.png)\n\n**DRAM通过电容充放电与MOS管配合产生高低电平**, 需要配合电平检测阈值来减少电容漏电带来的影响\n\n#### SRAM的存储单元结构\n\n![SRAM的存储单元结构](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262328328.png)\n\n**SRAM以锁存器结构来存储数据**, 锁存器结构在没有输入的情况下会一直保持原来的状态\n\n#### SRAM和DRAM的比较\n\n![SRAM和DRAM的比较](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262336065.png)\n\nSDRAM使用同步通信方式\n\n![SDRAM同步通信](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262341860.png)\n\nSRAM使用异步方式通信\n\n![SRAM异步通信](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270000903.png)\n\n### 非易失性存储器\n\n#### ROM简介\n\n![ROM简介](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270001764.png)\n\n#### FLASH简介\n\n![FLASH简介](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270007166.png)\n\n在嵌入式开发中选择 NOR FLASH 主要因为坏区较少, 基于字节读写可以支持XIP\n\nXIP(Execute In Place，就地执行)功能，它是一种特性，允许直接从 Flash 存储器中执行代码，而无需将代码首先复制到RAM中。XIP功能在嵌入式系统中很常见，它带来了一些优势，包括更少的RAM使用和更快的启动速度\n\n与ROM不同, FLASH必须先按块擦除数据后才能写入数据\n\n## I2C-读写EEPROM\n\n### 补充: I2C简介\n\nI2C（Inter-Integrated Circuit）是一种串行通信协议，**用于在集成电路之间进行短距离通信** I2C 由飞利浦公司（Philips）于1982年开发，并且现在由多家公司支持和采用。该协议通常用于连接芯片、传感器、存储器、外设等设备。\n\n以下是 I2C 协议的一些关键特点和基本概念：\n\n1. 总线结构\n   - 主从结构： I2C 使用主从结构，其中一个设备充当主设备（通常是微控制器或处理器），而其他设备则充当从设备。主设备负责发起通信和生成时钟信号。\n   - 双线制： I2C 使用两根线，一根是数据线（SDA），另一根是时钟线（SCL）。这两根线上都有上拉电阻，以便在设备不主动拉低时保持高电平。\n2. 数据传输：\n   - 起始和停止条件： 数据传输始于主设备发送起始条件（Start Condition），并以主设备发送停止条件（Stop Condition）结束。这两个条件都是由主设备在总线上生成的。\n   - 地址帧： 每个数据传输都以地址帧开始，其中包含目标设备的地址和读写位。地址帧由主设备发送。\n   - 数据帧： 在地址帧之后是一个或多个数据帧，其中包含实际的数据。数据帧的传输由主设备和从设备之间交替进行。\n   - 应答（Acknowledge）： 在每个数据帧之后，接收方发送一个应答信号，通常是一个低电平，以确认数据的接收。\n3. 速率和模式：\n   - 速率： I2C 支持不同的传输速率，常见的有 100 kHz、400 kHz 和 1 MHz 等。\n   - 模式： I2C 支持标准模式（100 kHz），快速模式（400 kHz），高速模式（1 MHz）等不同的工作模式。\n4. 多主设备和重复启动：\n   - 多主设备： I2C 支持多主设备共享同一总线。主设备之间通过仲裁（Arbitration）来确定哪个主设备能够继续发送。\n   - 重复启动： 主设备可以在一个传输结束后发送重复启动条件，而无需先发送停止条件，从而在同一次通信中与另一个从设备建立连接。\n5. I2C设备地址：\n   - 7位或10位地址： I2C 设备使用 7 位或 10 位地址来识别自己。大多数设备使用 7 位地址。\n\nI2C 协议的简洁性和灵活性使得它在连接各种设备和传感器时非常有用，尤其是在嵌入式系统中。\n\n### 补充: 高阻态\n\n在嵌入式领域中，高阻态的概念同样非常重要，并涉及到数字电路设计和信号完整性的方面。以下是在嵌入式系统中高阻态的一些关键应用和概念：\n\n1. 输入端口的高阻态： 很多嵌入式系统包括微控制器或微处理器，**其输入端口通常具有高阻抗特性。这意味着当输入端口未连接到任何外部设备时，输入端口会处于高阻态状态。这有助于避免在未连接设备时引入不必要的电流，同时防止信号线上的悬空状态(floating)**。\n2. 悬空输入的高阻态： 在数字电路中，当一个输入端未连接时，它被称为悬空输入。在悬空输入的情况下，该输入端常常设计为高阻态，以减少对电路的干扰和功耗。\n3. 总线冲突的高阻态： **在多主设备共享总线的系统中，当多个主设备尝试在同一时刻传输数据时可能会发生总线冲突。为了避免冲突设备之间的干扰，某些设备在冲突时会将总线设置为高阻态，以允许其他设备继续操作**。\n4. 三态逻辑门： 一些数字逻辑门（如三态门）具有高阻态输出。这允许将多个门连接到同一总线上，当其中一个门处于高阻态时，其他门仍能够正常工作。\n5. 输入缓冲器的高阻态： 在输入缓冲器中，当输入未被有效驱动时，输入缓冲器通常进入高阻态，以避免对电路产生负面影响。\n\n在这些情况下，高阻态的概念有助于确保电路在非活动状态时不引入不必要的电流，提高系统的稳定性和可靠性。这对于嵌入式系统中对功耗、信号完整性和总线冲突等方面的考虑非常重要。\n\n### I2C物理层\n\n![I2C物理层](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270111246.png)\n\n![I2C物理层](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270140896.png)\n\n#### I2C物理层主要特点\n\n- I2C是支持多设备的总线, 可支持多个通讯主机和从机\n- I2C使用两条线路, 一条SDA(双向串行数据线)来表示数据, 一条SCL(串行时钟线)来同步数据, 属于同步通信\n- 连接到总线的设备分配独立地址(7位或10位)\n- 总线接上拉电阻到电源(一般4.7KΩ, 具体看手册)\n  1. 当设备空闲时输出高阻态*防止短路总线上的其他接地设备*\n  2. 当所有设备都空闲时全部输出高阻态, 可通过上拉电阻把总线拉到高电平\n  3. 输出高阻态的特性需要GPIO的开漏输出\n- 多设备占用总线会仲裁\n- 具有三种传输速度模式, **实际开发中可使用低于最高速的速度, 协调总线设备速度一致即可**\n- I2C可接入的设备数量受到最大电容负载的限制, 一般为400pF, *也就是说总线上的设备数量越多, 传输速度越慢*\n\n### I2C协议层\n\nI2C协议定义了**通讯的起始和停止信号, 数据有效性, 响应, 仲裁, 时钟同步和地址广播等环节**\n\n#### I2C基本读写过程\n\n##### 主机写数据到从机\n\n![I2C基本读写过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270157626.png)\n\n1. S: 主机传输开始信号\n2. SLAVE ADDRESS: 主机传输需要通信的从机地址\n3. R/!W: 主机传输读或写信号, *若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据*\n4. A: 从机传输响应\n5. DATA: 主机传输数据段\n6. A: 从机响应\n7. DATA: 主机继续发送数据段\n8. A/!A: 从机响应是否继续接收\n9. P: 若从机响应不继续接收, 则主机传输停止位\n\n##### 主机由从机读数据\n\n![I2C基本读写过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270207508.png)\n\n1. S: 主机传输开始信号\n2. SLAVE ADDRESS: 主机传输需要通信的从机地址\n3. R/!W: 主机传输读或写信号, *若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据*\n4. A: 从机传输响应\n5. DATA: 从机传输数据段\n6. A: 主机响应\n7. DATA: 从机继续发送数据段\n8. A/!A: 主机响应是否继续接收\n9. P: 若主机响应不继续接收, 则主机传输停止位\n\n注意:\n\n- S: 开始信号只能由主机产生\n- SLAVE ADDRESS: 进行通信的从机地址只能由主机产生\n- R/!W: 读/写信号只能由主机产生\n- P: 停止信号只能由主机产生\n- DATA 和 A: 数据段和响应段由主机和从机交替产生, 具体由主机和从机的读写决定\n\n##### 通信复合格式\n\n![通信复合格式](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270209992.png)\n\n常用的复合通信的方法, **即先写入外设地址后将外设的寄存器地址返回进行读取**\n\n- S: 主机传输开始信号\n- SLAVE ADDRESS: 进行通信的从机地址(一般为外设)\n- R/W!: 一般为写操作\n- DATA: 写入的外设地址\n- A/A!: 从机响应\n- Sr: 主机传输开始信号\n- SLAVE ADDRESS: 进行通信的从机地址(一般为同一个外设)\n- R/W!: 一般为读操作\n- DATA: 读取外设的寄存器的具体地址\n- A/A!: 逐个字节进行读取外设每个寄存器的地址并做出响应\n- P: 全部读取完毕后主机传输停止信号\n\n#### 通讯的起始和停止信号\n\n![通讯的起始和停止信号](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270225648.png)\n\n- 起始信号: **SCL高电平, SDA由高电平向低电平转换**\n- 停止信号: **SCL高电平, SDA由低电平向高电平转换**\n\n#### 数据的有效性\n\n![数据有效性](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270237788.png)\n\n- SDA: 负责传输数据\n- SCL: 高电平时采集SDA上1bit数据, 低电平时SDA进行电平转换\n\n#### 地址及数据方向\n\n![地址及数据方向](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270243764.png)\n\nI2C采用高位先行, 由高位到低位进行传输\n\n一般使用7位表示I2C上的设备地址, 设备地址加上其后的读写位可以凑成8位即1字节方便传输\n\n例如, 某设备在I2C上的设备地址为7位的0x78(0b01111000), 可加入读写位凑到八位\n\n- 8位设备的读地址位为0xF1(0b11110001)\n- 8位设备的写地址位为0xF0(0b11110000)\n\n#### 响应\n\n![响应](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270254565.png)\n\n1. 1-8个时钟信号中: 数据发送端控制SDA传输7位设备地址和1位读写信号\n2. 在第9个时钟信号时: 数据接收端获得SDA控制权, 发送应答信号(低电平表示应答)\n\n### STM32的I2C特性及架构\n\n![STM32的I2C特性及架构](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270305500.png)\n\n- 软件模拟协议: 较为繁琐\n- 硬件模拟协议: 较为方便, 减轻CPU负担\n\n注: *STM32硬件的I2C逻辑可能会有问题*\n\n#### STM32的I2C架构分析\n\n![STM32的I2C架构分析](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270315440.png)\n\n##### I2C的通讯引脚\n\n![I2C的通讯引脚](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270346561.png)\n\n![I2C的通讯引脚](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270316720.png)\n\n勘误: *I2C1_SCL默认映射到PB5, I2C1_SDA默认映射到PB7, 图片中有误*\n\nSTM32兼容smbus协议\n\n##### 时钟控制逻辑\n\n![时钟控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347794.png)\n![时钟控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270325594.png)\n\n注: *Tpck1: 指的是APB1时钟周期(1/36MHz)*\n\n###### 计算时钟频率的方法\n\n![计算时钟频率的方法](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270333989.png)\n\n实际就是解未知数CCR的一元一次方程\n\n##### 数据控制逻辑\n\n![数据控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347332.png)\n\n![数据控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270337311.png)\n\n1. 将8位数据写入数据寄存器(DR)\n2. 数据寄存器里面的数据会被发送到数据移位寄存器\n\n##### 整体控制逻辑\n\n![整体控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270348369.png)\n\n![整体控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270355991.png)\n\n### STM32硬件I2C的通讯过程\n\n#### STM32作为主发送器的通讯过程\n\n![STM32作为主发送器的通讯过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270357886.png)\n\n勘误: *EV8_2: TxE=1, BTF=1, 请求设置停止位. TxE和BTF位由硬件在产生停止条件时清除*\n\n- EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)\n- EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)\n- EV8: 在正常数据发送完毕后会产生EV8事件(I2C_SRx:TxE[7]置1表示数据寄存器空)\n- EV8_2: 在从机发送结束应答后会产生EV8_2事件(I2C_SRx:TxE[7]置1表示数据寄存器空, I2C_SRx:BTF[2]置1表示字节发送结束, I2C_CRx:STOP[9]置1表示在当前字节传输或在当前起始条件发出后产生停止条件, 产生停止条件后由硬件清除TxE和BTF位)\n\n#### STM32作为主接收器的通讯过程\n\n![STM32作为主接收器的通讯过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270423471.png)\n\n勘误: *EV7_1: RxNE=1, 读DR寄存器清除该事件. 设置ACK=0和STOP请求*\n\n- EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)\n- EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)\n- EV7: 在正常数据发送完毕后会产生EV7事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空)\n- EV7_1: 在主机发送结束应答后会产生EV7_1事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空, I2C_CRx:ACK[10]置0表示设置为无应答返回, I2C_CRx:STOP[9]置1表示在当前字节传输或释放SCL和SDA线)\n\n每个状态标志位的清除方法各不相同, 使用库函数的方法可以较方便的清除寄存器的标志位\n\n### I2C初始化结构体\n\n在stm32f10x_i2c.h中定义I2C初始化结构体\n\n```c\n/** \n  * @brief  I2C Init structure definition  \n  */\n\ntypedef struct\n{\n  /*---------------------------------------------------------------------------------\n   * 设置时钟频率\n   * 设置I2C的传输速率, 函数根据该值经过运算后写入I2C_CCR寄存器\n   * 不得高于400kHz, 即400 000\n   * 由于I2C_CCR寄存器不能写入浮点数, 可能会导致实际速率小于设定的传输速率参数\n   * 使得通讯稍慢, 但是并不会对I2C的通讯造成其他影响\n   *-------------------------------------------------------------------------------*/\n  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.\n                                         This parameter must be set to a value lower than 400kHz */\n\n  /*---------------------------------------------------------------------------------\n   * 设置I2C的模式\n   * I2C_Mode_I2C: 标准I2C模式\n   * I2C_Mode_SMBusDevice: SMBus设备模式\n   * I2C_Mode_SMBusHost: SMBus主机模式\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.\n                                         This parameter can be a value of @ref I2C_mode */\n\n  /*---------------------------------------------------------------------------------\n   * 设置I2C的SCL时钟的占空比\n   * I2C_DutyCycle_16_9: Tlow/Thigh = 16:9\n   * I2C_DutyCycle_2: Tlow/Thigh = 2:1\n   * 这两个选项差别不大, 开发中一般不会进行严格区分\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.\n                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */\n\n  /*---------------------------------------------------------------------------------\n   * 配置STM32的I2C设备自己的地址\n   * 此参数可以是 7 位或 10 位地址\n   * 第二个地址可以通过函数I2C_OwnAddress2Config进行配置, 只能是7位地址\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.\n                                         This parameter can be a 7-bit or 10-bit address. */\n\n  /*---------------------------------------------------------------------------------\n   * 配置I2C应答是否使能\n   * I2C_Ack_Enable: 允许应答使能\n   * I2C_Ack_Disable: 禁止应答使能\n   * 一般配置为允许应答使能, 改为禁止应答使能往往会导致通讯错误\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.\n                                         This parameter can be a value of @ref I2C_acknowledgement */\n\n  /*---------------------------------------------------------------------------------\n   * 配置I2C的寻址长度\n   * I2C_AcknowledgedAddress_7bit: 7位地址\n   * I2C_AcknowledgedAddress_10bit: 10位地址\n   * 需要根据连接到I2C总线上的设备进行选择, 确保地址长度一致, 才能进行通信\n   * 只有I2C_OwnAddress1才能配置10位地址, I2C_OwnAddress2只支持7位地址 *-------------------------------------------------------------------------------*/\n  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.\n                                         This parameter can be a value of @ref I2C_acknowledged_address */\n}I2C_InitTypeDef;\n```\n\n### I2C库函数\n\n#### I2C_GenerateSTART函数, 用于产生起始条件\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271607885.png)\n\n#### I2C_GetFlagStatus函数, 用于获取状态位\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271610721.png)\n\nI2C_FLAG参数列表对应I2C_SRx状态寄存器的各个位, 可通过查询手册查看其含义\n\n返回值说明\n\n![返回值说明](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271612900.png)\n\n```c\ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;\n```\n\n- RESET: 0, 返回RESET表示该状态位为0\n- SET: 1, 返回SET表示该状态位为1\n\n#### I2C_Send7bitAddress函数, 用于发送7位地址\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271616560.png)\n\n参数Address为八位读/写地址, 通过I2C_Direction实际配置读写方向, 最终方向以I2C_Direction配置为准, 参数Address的读写位失效\n\n#### I2C_SendDate函数, 通过I2Cx外设发送数据字节\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271618557.png)\n\n#### I2C_ReceiveData函数, 返回 I2Cx 外设最近接收的数据\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271622473.png)\n\n#### AcknowledgeConfig函数, 使能或禁用I2C的应答\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271623317.png)\n\n#### I2C_Cmd函数, 使能或禁用I2Cx外设\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271625131.png)\n\n#### I2C_CheckEvent函数, I2C状态监测函数\n\n监测的事件发生则返回SUCCESS\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280036252.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037103.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037758.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038783.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038105.png)\n\n### EEPROM硬件结构\n\n![EEPROM](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271630443.png)\n\n#### 引脚说明\n\n- VCC: 电源引脚, 接3V3\n- GND: 地引脚, 接地\n- SCL: 时钟线, 经2.2K上拉电阻接3V3, 接PB6引脚(默认映射I2C1_SCL)\n- SDA: 数据线, 经2,2K上拉电阻接3V3, 接PB7引脚(默认映射I2C1_SDA)\n- HOLD: WP引脚, 接地, 不启用写保护(即可向AT24C02写数据)\n- A0-A2: 地址引脚, 接地, A0:A2为000, 如需拓展EEPROM则可通过配置A0-A2的地址引脚来进行区分(如: 配置A0:A2为001, 则可对两EEPROM进行区分)\n\n### AT24C02介绍\n\n![AT24C02](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271642465.png)\n\nAT24C02可存储256字节数据\n\n#### AT24C02引脚说明\n\n![AT24C02](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271648925.png)\n\n- A0-A2: AT24C02用来区分不同AT24C0x芯片的设备地址\n- SDA: 数据线\n- SCL: 时钟线\n- WP: 写保护, 置1启用写保护\n- NC: 不连接\n\n#### AT24C02设备地址\n\n![设备地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702961.png)\n\n![设备地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702718.png)\n\nAT24C02有256字节, 即属于2K(256*8)\n\n![设备地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271701248.png)\n\n根据原理图, 将A2-A0均接地, 则A2 = A1 = A0 = 0\n\nAT24C02的地址为0b1010000R/W, Bit0为R/!W位\n\n- AT24C02在A2:A1[000]情况下读地址: 0b10100001(0xA1)\n- AT24C02在A2:A1[000]情况下写地址: 0b10100000(0xA0)\n\n#### AT24C02的Byte Write(以字节方式写数据)操作\n\n![Byte Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271719435.png)\n\n第一个传输的数据段(DATA)为WORD ADDRESS(需要写入的字节所在的地址), 第二次传输数据段(DATA)才为真正需要写入的内容\n\n![Byte Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271723653.png)\n\n```tex\n翻译: Byte Write的工作流程\n\n1. 在发送完SLAVE ADDRESS和W/!R后, 需要发送一个字节的数据地址(WORD ADDRESS)(即需要写入的字节所在的地址)\n2. 收到地址(WORD ADDRESS)后, EEPROM会响应ACK, 然后接收一个字节的数据(DATA)(真正要写入的内容)\n3. 接收到数据(DATA)后, EEPROM响应ACK, 单片机必须发送STOP信号, 不能继续传输第二段数据(给EEPROM预留写入时间)\n4. 接收到停止信号后, EEPROM在tWR的周期时间内进行向内部写入数据\n5. 在此写入周期中, 所有输入被禁用, EEPROM不进行响应\n```\n\n#### AT24C02的Page Write(以页方式写数据)操作\n\n又称突发写入(即仅发送一个地址可写入多个数据)\n\nPage Write解决了Byte Write不能连续写入的缺陷\n\n![Page Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271734727.png)\n\n- WORD ADDRESS(n): 数据的起始地址\n- DATA(n): 写入到WORD ADDRESS(n)中\n- DATA(n+1): 写入到WORD ADDRESS(n+1)中\n- DATA(n+x): 写入到WORD ADDRESS(n+x)中\n\n![Page Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271741445.png)\n\n```tex\n翻译: Page Write工作流程\n\n1. AT24C02能以8字节进行Page Write\n2. 与Byte Write类似, 第一个字节是数据地址(WORD ADDRESS)(即需要写入的字节所在的地址), 在接受到第二个字节(DATA)后不会要求单片机发送STOP信号\n3. 相反, EEPROM在接收到第一个DATA(真正要写入的数据)后, 对于AT24C02来说, 能再最多传输7个DATA\n4. EEPROM每接收到一个数据位都会响应ACK, 单片机必须发送停止信号来结束Page Writting\n5. 收到每个DATA后, 对于AT24C02来说, 数据地址(WORD ADDRESS)的低三位会递增(低三位的取值情况为2^3 = 8, 即8字节)\n6. 高位地址不会递增, 从而保证原来的初始数据地址不发生改变(确保低三位正确递增)\n7. 当递增的地址到达Page的界限后, 剩下的8位数据会覆盖Page的开头\n8. 如果向EEPROM传输的DATA超过8个字节(对于AT24C02), 则数据会从头覆盖\n```\n\n#### AT24C02的ACKNOWLEDGE POLLING(确认轮询)\n\n![ACKNOWLEDGE POLLING](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280423663.png)\n\n```tex\n一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。\n这涉及发送一个启动条件，后跟设备地址。读/写位是代表所需的操作。\n仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列\n```\n\n需要在向AT24C02写入数据操作后, 进行确认询问, 主机需要发送启动条件, 设备地址, 读写位, 如果AT24C02准备完毕会响应0才能继续进行操作\n\n以I2C1为例, 软件编程实现如下\n\n```c\n/**\n * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认询问 \n *   STM32向EEPROM写入数据后, EEPROM需要时间向内部存储期间进行写入\n *   此时EEPROM不应答, 所以在发送下一次I2C请求之前,应等待EEPROM写入完成\n *   以上步骤称为ACKNOWLEDGE POLLING\n * @param None\n * @retval None\n */\nvoid EEPROM_ACK_Polling(void)\n{\n    do\n    {\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */\n    while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    } while (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); \n    /* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */\n    /* 结束询问 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n}\n\n```\n\n#### AT24C02的Current Address Read(从当前地址读数据)操作\n\n![Current Address Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271810617.png)\n\n一般不用, 因为在开发中不好确定当前地址的位置\n\n#### AT24C02的Random Read(随机读数据)操作\n\n![Random Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271813901.png)\n\n1. 产生起始信号, 向EEPROM发送要读取数据的数据地址(写方向)\n2. 再次产生起始信号, 从EEPROM中读取数据(读方向)\n3. EEPROM在被写入要读取数据的数据地址后会进行确认并输出该数据内容\n\n![Random Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271821179.png)\n\n```tex\n翻译: Random Read流程\n\n1. Random Read需要\"dummy\"来写入要读取数据(DATA)的数据地址(WORD ADDRESS)\n2. 一旦DEVICE ADDRESS和WORD ADDRESS被EEPROM响应, 单片机必须生成另一个START信号\n3. 单片机发送读信号来读取当前地址(DEVICE ADDRESS)\n4. EEPROM响应DEVICE ADDRESS并串行输出数据(DATA)\n5. 单片机响应NO ACK并紧跟生成STOP信号\n```\n\n#### AT24C02的Sequential Read(顺序读数据)操作\n\n![Sequential Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271838678.png)\n\n与Page Write类似\n\n![Sequential Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271841941.png)\n\n```tex\n翻译: Sequential Read流程\n\n1. Sequntial Read从当前地址读取或随机地址开始读取\n2. 单片机收到DATA后，会响应ACK\n3. 只要EEPROM收到ACK响应，它就会继续递增数据地址，并顺序串行输出DATA\n4. 当达到内存地址限制时，数据地址将\"roll over\"，顺序读取将继续从头开始重新读取数据\n5. 当单片机NO ACK响应并生成STOP，则终止Sequential Read\n```\n\n### I2C-读写EEPROM实验\n\n项目地址: **24-I2C-EEPROM**\n\n#### 操作流程\n\n1. 初始化I2C相关的GPIO\n2. 配置I2C外设的工作模式\n3. 编写I2C写入EEPROM的Byte Write函数\n4. 编写I2C读取EEPROM的Random Read函数\n5. 使用read函数和write函数进行读写校验\n6. 编写Page Write和Sequential Read函数进行校验\n\n#### 在bsp_i2c.h中定义相关宏\n\n```c\n/**\n * @defgroup I2C_EEPROM_Define \n * @{\n */\n\n/**\n * @brief I2C的宏定义\n */\n\n#define EEPROM_I2C I2C1 /*!< EEPROM所使用的I2Cx */\n#define EEPROM_I2C_CLK RCC_APB1Periph_I2C1 /*!< I2C的时钟 */\n#define EEPROM_I2C_APBxClkCmd RCC_APB1PeriphClockCmd /*!< I2C时钟的使能函数 */\n#define EEPROM_I2C_BAUDRATE 400000 /*!< I2C的通信速率 */\n#define STM32_I2C_OWN_ADDR 0x5F /*!< STM32在I2C总线上的自身地址, 可任意配置(只要在I2C总线上唯一即可) */\n#define EEPROM_I2C_WRITE_ADDRESS 0xA0 /*!< EEPROM在I2C总线上的8位写地址 */\n#define EEPROM_I2C_READ_ADDRESS 0xA1 /*!< EEPROM在I2C总线上的8位读地址 */\n\n/**\n * @brief I2C的GPIO引脚宏定义\n */\n\n#define EEPROM_I2C_SCL_GPIO_CLK (RCC_APB2Periph_GPIOB) /*!< I2C的SCL引脚的GPIO时钟 */\n#define EEPROM_I2C_SDA_GPIO_CLK (RCC_APB2Periph_GPIOB) /*!< I2C的SDA引脚的GPIO时钟 */\n#define EEPROM_I2C_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd /*!< I2C的GPIO时钟的使能函数 */\n#define EEPROM_I2C_SCL_GPIO_PORT GPIOB /*!< I2C的SCL引脚的GPIO端口 */\n#define EEPROM_I2C_SCL_GPIO_Pin GPIO_Pin_6 /*!< I2C的SCL引脚的GPIO引脚 */\n#define EEPROM_I2C_SDA_GPIO_PORT GPIOB /*!< I2C的SDA引脚的GPIO端口 */\n#define EEPROM_I2C_SDA_GPIO_Pin GPIO_Pin_7 /*!< I2C的SDA引脚的GPIO引脚 */\n\n/**\n * @} \n */\n```\n\n#### 在bsp_i2c.h中进行函数声明\n\n```c\n/**\n * @defgroup EEPROM_I2C_Functions \n * @{\n */\n\nvoid I2C_EEPROM_Config(void);\nvoid EEPROM_Byte_Writting(uint8_t WordAddress, uint8_t Data);\nvoid EEPROM_Page_Writting(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToWrite);\nvoid EEPROM_Random_Read(uint8_t WordAddress, uint8_t* Data);\nvoid EEPROM_Sequential_Read(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToRead);\nvoid EEPROM_ACK_Polling(void);\n\n/**\n * @} \n * \n */\n```\n\n#### 在bsp_i2c.c中编写I2C_EEPROM配置函数\n\n```c\n/**\n * @brief I2C EEPROM配置函数 \n * @param None\n * @retval None \n */\nvoid I2C_EEPROM_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    I2C_InitTypeDef I2C_InitStructure;\n\n    /*-------------------------- 时钟配置 ------------------------------*/\n    /* 使能I2C GPIO的时钟 */\n    EEPROM_I2C_GPIO_APBxClkCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);\n    /* 使能I2C的时钟 */\n    EEPROM_I2C_APBxClkCmd(EEPROM_I2C_CLK, ENABLE);\n\n    /*-------------------------- I2C_SCL的GPIO配置 ------------------------------*/\n    /* 配置引脚为I2C的SCL */\n    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_GPIO_Pin;\n    /* 配置输出速率为50MHz */\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    /* 配置模式开漏复用输出 */\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n    /* 初始化I2C_SCL的GPIO配置 */ \n    GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);\n\n    /*-------------------------- I2C_SDA的GPIO配置 ------------------------------*/\n    /* 配置引脚为I2C的SDA */\n    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_GPIO_Pin;\n    /* 配置输出速率为50MHz */\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    /* 配置模式开漏复用输出 */\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n    /* 初始化I2C_SDA的GPIO配置 */ \n    GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);\n\n    /*-------------------------- I2C的工作模式配置 ------------------------------*/\n    /* 使能响应 */\n    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;\n    /* 使用7位地址 */\n    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;\n    /* 时钟频率 400kHz*/\n    I2C_InitStructure.I2C_ClockSpeed = EEPROM_I2C_BAUDRATE;\n    /* 占空比 Tlow/Thigh = 2 */\n    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;\n    /* 模式 I2C */\n    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;\n    /* STM32主机地址 */\n    I2C_InitStructure.I2C_OwnAddress1 = STM32_I2C_OWN_ADDR;\n    /* 初始化I2C */\n    I2C_Init(EEPROM_I2C, &I2C_InitStructure); \n    /* 使能I2C */\n    I2C_Cmd(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Byte Writting方式的函数\n\n```c\n/**\n * @brief 函数实现了STM32作为主发送器向EEPROM以Byte Writting的方式写数据 \n * @param WordAddress: 需要写入的字节所在的地址\n * @param Data: 真正要写入的内容\n * @retval None\n */\nvoid EEPROM_Byte_Writting(uint8_t WordAddress, uint8_t Data)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n        ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n        ;\n    }\n/*---------------- STM32发送Data ----------------*/\n    /* STM32向EEPROM发送Data */\n    I2C_SendData(EEPROM_I2C, Data);\n    /* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)\n    {\n       ;\n    }\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n    /* STM32使能ACK信号, 恢复到默认状态 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Page Writting方式的函数\n\n```c\n/**\n * @brief 函数实现了STM32作为主发送器向EEPROM以Page Writting的方式写数据(每次不超过8字节) \n * @param WordAddress: 需要写入的字节所在的地址\n * @param Data: 真正要写入的数据的指针\n * @param NumByteToWrite: 要写入数据的个数小于8\n * @retval None\n */\nvoid EEPROM_Page_Writting(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToWrite)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n        ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n        ;\n    }\n/*---------------- STM32发送Data ----------------*/\n    /* 循环写入数据 */\n    while(NumByteToWrite)\n    {\n        /* STM32向EEPROM发送Data */\n        I2C_SendData(EEPROM_I2C, *Data);\n        /* 数据指针自增 */\n        Data++;\n        /* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */\n        while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)\n        {\n        ;\n        }\n        NumByteToWrite--;\n    }\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n    /* STM32使能ACK信号, 恢复到默认状态 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Random Read方式的函数\n\n```c\n/**\n * @brief 函数实现STM32从EEPROM以Random Read方式读取数据\n * @param WordAddress: 要读取数据的地址\n * @param Data: 读取数据要写入到的变量\n * @retval None\n */\nvoid EEPROM_Random_Read(uint8_t WordAddress, uint8_t* Data)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n       ;\n    }\n/*---------------- STM32接收Data ----------------*/\n    /* STM32另外产生一个START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的读地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);\n    /* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n\n    /*------------------------------------------------------------------------\n    * 注意: \n    * 该部分为STM32接收来自EEPROM的数据\n    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作\n    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据\n    * 而不是进行数据接收\n    *------------------------------------------------------------------------*/\n\n    /* 监测到EV7事件发生, 说明接收到了新数据 */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)\n    {\n       ;\n    }\n    /* 将接收到的数据赋值给Data变量 */\n    *Data = I2C_ReceiveData(EEPROM_I2C);\n    /* STM32产生NO ACK响应 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Sequential Read方式的函数\n\n```c\n/**\n * @brief 函数实现STM32从EEPROM以Sequential Read方式读取数据\n * @param WordAddress: 要读取数据的地址\n * @param Data: 读取数据要写入到的变量\n * @param NumByteToRead: 要读取数据的个数\n * @retval None\n */\nvoid EEPROM_Sequential_Read(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToRead)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n      ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n        ;\n    }\n  /*---------------- STM32接收Data ----------------*/\n    /* STM32另外产生一个START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的读地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);\n    /* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /*------------------------------------------------------------------------\n    * 注意: \n    * 该部分为STM32接收来自EEPROM的数据\n    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作\n    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据\n    * 而不是进行数据接收\n    *------------------------------------------------------------------------*/\n    while(NumByteToRead)\n    {\n        if (NumByteToRead == 1) /* 如果为最后一个字节, 产生NO ACK响应 */\n        {\n            /* STM32产生NO ACK响应 */\n            I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);\n        }\n        /* 监测到EV7事件发生, 说明接收到了新数据 */\n        while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)\n        {\n            \n        }\n        /* 将接收到的数据赋值给Data变量 */\n        *Data = I2C_ReceiveData(EEPROM_I2C);\n        /* Data 指针自增 */\n        Data++;\n        /* NumByteToRead递减 */\n        NumByteToRead--;\n    }\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n    /* STM32使能ACK信号, 恢复到默认状态 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写确认询问函数\n\n```c\n/**\n * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认轮询\n *   一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。\n *   这涉及发送一个启动条件，后跟设备地址。\n *   读/写位是代表所需的操作。\n *   仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列\n *   以上步骤称为ACKNOWLEDGE POLLING\n * @param None\n * @retval None\n */\nvoid EEPROM_ACK_Polling(void)\n{\n    do\n    {\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */\n    while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    } while (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); \n    /* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */\n    /* 结束轮询 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在main.c中进行读写测试\n\n```c\n/**\n  ******************************************************************************\n  * @file    main.c\n  * @author  eric\n  * @version V0.0.1\n  * @date    27-January-2024\n  * @brief   STM32与EEPROM通过I2C协议进行读写测试\n  ******************************************************************************\n  * @attention\n  *\n  * THE PRESENT FUNTIONS WHICH IS FOR GUIDANCE ONLY\n  ******************************************************************************\n  */\n\n/* Includes ------------------------------------------------------------------*/\n#include \"stm32f10x.h\"\n#include \"stm32f10x_conf.h\"\n#include \"bsp_led.h\"\n#include \"bsp_usart.h\"\n#include \"bsp_i2c.h\"\n\n/*----------------------------------------------------------------------------\n * 操作流程:\n * \n * 1. 初始化I2C相关的GPIO\n * 2. 配置I2C外设的工作模式\n * 3. 编写I2C写入EEPROM的Byte Write函数 \n * 4. 编写I2C读取EEPROM的Random Read函数\n * 5. 使用read函数和write函数进行读写校验\n * 6. 编写Page Write和Sequential Read函数进行校验\n *----------------------------------------------------------------------------*/\n\n/**\n * @defgroup: Global_Values\n * @{  \n */\n\nuint8_t ReadData[20] = {0};\nuint8_t WriteData[3] = {3, 4, 5};\n\n/**\n * @} \n * \n */\n\n/**\n * @brief STM32与EEPROM通过I2C协议进行读写测试 \n * @param None\n * @retval None \n */\nint main(void)\n{\n    /* 初始化USART */\n    USART_Config(); \n    /* 串口打印 */\n    printf(\"I2C-EEPROM\\n\");\n    /* 初始化I2C */\n    I2C_EEPROM_Config();\n    /* STM32向EEPROM 地址1写入数据0x01 */\n    EEPROM_Byte_Writting(1, 0x01);\n    /* ACKNOWLEDGE POLLING 确认询问 */\n    EEPROM_ACK_Polling();\n    /* STM32向EEPROM 地址2写入数据0x02 */\n    EEPROM_Byte_Writting(2, 0x02);\n    /* ACKNOWLEDGE POLLING 确认询问 */\n    EEPROM_ACK_Polling();\n    /*----------------------------------------\n     * Page Writting的地址对齐\n     * 为保证数据无误需addr%8 == 0\n     *----------------------------------------*/ \n    /* STM32向EEPROM 地址3-5写入数据0x03-0x05 */\n    EEPROM_Page_Writting(0x03, WriteData, 3);\n    /* ACKNOWLEDGE POLLING 确认询问 */\n    EEPROM_ACK_Polling();\n    /* STM32从EEPROM以SequentialRead方式读取地址1-4的数据 */ \n    EEPROM_Sequential_Read((uint8_t)1, ReadData, 4);\n    /* STM32从EEPROM以RandomRead方式读取地址5的数据 */ \n    EEPROM_Random_Read((uint8_t)5, &ReadData[4]);\n    /* 将读出的数据循环打印 */\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        printf(\"ReadData[%d] = 0x%x\\n\", i, ReadData[i]);\n    }\n    \n    /* 空循环 */\n    while(1)\n    {\n        ;\n    }\n}\n\n```\n\n#### 串口实验现象\n\n![实验现象](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280831099.png)\n\n#### 完善功能\n\n以下函数是对实验中出现函数的进一步完善, 源文件不在工程中\n\n##### 增加的宏定义\n\n```c\n/* STM32 I2C 快速模式 */\n#define I2C_Speed              400000  //*\n\n/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */\n#define I2Cx_OWN_ADDRESS7      0X0A   \n\n/* AT24C01/02每页有8个字节 */\n#define I2C_PageSize           8\n\n/* AT24C04/08A/16A每页有16个字节 */\n//#define I2C_PageSize           16\n\n/*等待超时时间*/\n#define I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)\n#define I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT)\n```\n\n##### 调试功能\n\n```c\n#define EEPROM_DEBUG_ON         0\n\n#define EEPROM_INFO(fmt,arg...)           printf(\"<<-EEPROM-INFO->> \"fmt\"\\n\",##arg)\n#define EEPROM_ERROR(fmt,arg...)          printf(\"<<-EEPROM-ERROR->> \"fmt\"\\n\",##arg)\n#define EEPROM_DEBUG(fmt,arg...)          do{\\\n                                          if(EEPROM_DEBUG_ON)\\\n                                          printf(\"<<-EEPROM-DEBUG->> [%s][%d]\"fmt\"\\n\", __FILE__, __LINE__, ##arg);\\\n                                          }while(0)\n```\n\n##### 超时处理函数\n\n完善了对于超时的处理\n\n###### 超时处理相关宏定义\n\n```c\n/*等待超时时间*/\n#define I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)\n#define I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))\n```\n\n###### 超时处理相关变量声明\n\n```c\nstatic __IO uint32_t  I2CTimeout = I2CT_LONG_TIMEOUT;\n\nstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode);\n```\n\n###### 超时状态函数\n\n```c\n/**\n  * @brief  Basic management of the timeout situation.\n  * @param  errorCode：错误代码，可以用来定位是哪个环节出错.\n  * @retval 返回0，表示IIC读取失败.\n  */\nstatic  uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n{\n  /* Block communication and all processes */\n  EEPROM_ERROR(\"I2C 等待超时!errorCode = %d\",errorCode);\n  \n  return 0;\n}\n```\n\n##### 多字节写入函数\n\n完善了在Page Write中字节对齐的情况\n\n```c\n/**\n  * @brief   将缓冲区中的数据写到I2C EEPROM中\n  * @param   \n  *  @arg pBuffer:缓冲区指针\n  *  @arg WriteAddr:写地址\n  *     @arg NumByteToWrite:写的字节数\n  * @retval  无\n  */\nvoid I2C_EE_BufferWrite(u8* pBuffer, u8 WriteAddr, u16 NumByteToWrite)\n{\n  u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;\n\n  Addr = WriteAddr % I2C_PageSize;\n  count = I2C_PageSize - Addr;\n  NumOfPage =  NumByteToWrite / I2C_PageSize;\n  NumOfSingle = NumByteToWrite % I2C_PageSize;\n \n  /* If WriteAddr is I2C_PageSize aligned  */\n  if(Addr == 0) \n  {\n    /* If NumByteToWrite < I2C_PageSize */\n    if(NumOfPage == 0) \n    {\n      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);\n      I2C_EE_WaitEepromStandbyState();\n    }\n    /* If NumByteToWrite > I2C_PageSize */\n    else  \n    {\n      while(NumOfPage--)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); \n     I2C_EE_WaitEepromStandbyState();\n        WriteAddr +=  I2C_PageSize;\n        pBuffer += I2C_PageSize;\n      }\n\n      if(NumOfSingle!=0)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);\n        I2C_EE_WaitEepromStandbyState();\n      }\n    }\n  }\n  /* If WriteAddr is not I2C_PageSize aligned  */\n  else \n  {\n    /* If NumByteToWrite < I2C_PageSize */\n    if(NumOfPage== 0) \n    {\n      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);\n      I2C_EE_WaitEepromStandbyState();\n    }\n    /* If NumByteToWrite > I2C_PageSize */\n    else\n    {\n      NumByteToWrite -= count;\n      NumOfPage =  NumByteToWrite / I2C_PageSize;\n      NumOfSingle = NumByteToWrite % I2C_PageSize; \n      \n      if(count != 0)\n      {  \n        I2C_EE_PageWrite(pBuffer, WriteAddr, count);\n        I2C_EE_WaitEepromStandbyState();\n        WriteAddr += count;\n        pBuffer += count;\n      } \n      \n      while(NumOfPage--)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);\n        I2C_EE_WaitEepromStandbyState();\n        WriteAddr +=  I2C_PageSize;\n        pBuffer += I2C_PageSize;  \n      }\n      if(NumOfSingle != 0)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); \n        I2C_EE_WaitEepromStandbyState();\n      }\n    }\n  }  \n}\n```\n\n##### 单字节写入函数\n\n增加超时处理\n\n```c\n/**\n  * @brief   写一个字节到I2C EEPROM中\n  * @param   \n  * @arg pBuffer:缓冲区指针\n  * @arg WriteAddr:写地址 \n  * @retval  无\n  */\nuint32_t I2C_EE_ByteWrite(u8* pBuffer, u8 WriteAddr) \n{\n  /* Send START condition */\n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n\n  I2CTimeout = I2CT_FLAG_TIMEOUT;  \n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);\n  } \n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Send EEPROM address for write */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n  \n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }  \n  /* Send the EEPROM's internal address to write to */\n  I2C_SendData(EEPROM_I2Cx, WriteAddr);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV8 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(2);\n  } \n  \n  /* Send the byte to be written */\n  I2C_SendData(EEPROM_I2Cx, *pBuffer); \n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;  \n  /* Test on EV8 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);\n  } \n  \n  /* Send STOP condition */\n  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);\n  \n  return 1;\n}\n```\n\n##### 单页写入函数\n\n```c\n/**\n  * @brief   在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数\n  *          不能超过EEPROM页的大小，AT24C02每页有8个字节\n  * @param   \n  *     @arg pBuffer:缓冲区指针\n  *     @arg WriteAddr:写地址\n  *     @arg NumByteToWrite:写的字节数\n  * @retval  无\n  */\nuint32_t I2C_EE_PageWrite(u8* pBuffer, u8 WriteAddr, u8 NumByteToWrite)\n{\n  I2CTimeout = I2CT_LONG_TIMEOUT;\n\n  while(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))   \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);\n  } \n  \n  /* Send START condition */\n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(5);\n  } \n  \n  /* Send EEPROM address for write */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(6);\n  } \n  \n  /* Send the EEPROM's internal address to write to */    \n  I2C_SendData(EEPROM_I2Cx, WriteAddr);  \n\n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV8 and clear it */\n  while(! I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(7);\n  } \n\n  /* While there is data to be written */\n  while(NumByteToWrite--)  \n  {\n    /* Send the current byte */\n    I2C_SendData(EEPROM_I2Cx, *pBuffer); \n\n    /* Point to the next byte to be written */\n    pBuffer++; \n  \n    I2CTimeout = I2CT_FLAG_TIMEOUT;\n\n    /* Test on EV8 and clear it */\n    while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n    {\n      if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);\n    } \n  }\n\n  /* Send STOP condition */\n  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);\n  \n  return 1;\n}\n```\n\n##### 读取数据函数\n\n```c\n/**\n  * @brief   从EEPROM里面读取一块数据 \n  * @param   \n  *     @arg pBuffer:存放从EEPROM读取的数据的缓冲区指针\n  *     @arg WriteAddr:接收数据的EEPROM的地址\n  *     @arg NumByteToWrite:要从EEPROM读取的字节数\n  * @retval  无\n  */\nuint32_t I2C_EE_BufferRead(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)\n{  \n  \n  I2CTimeout = I2CT_LONG_TIMEOUT;\n  \n  //*((u8 *)0x4001080c) |=0x80; \n  while(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n   }\n  \n  /* Send START condition */\n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n  //*((u8 *)0x4001080c) &=~0x80;\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);\n   }\n  \n  /* Send EEPROM address for write */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n\n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(11);\n   }\n    \n  /* Clear EV6 by setting again the PE bit */\n  I2C_Cmd(EEPROM_I2Cx, ENABLE);\n\n  /* Send the EEPROM's internal address to write to */\n  I2C_SendData(EEPROM_I2Cx, ReadAddr);  \n\n   \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV8 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(12);\n   }\n    \n  /* Send START condition a second time */  \n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(13);\n   }\n    \n  /* Send EEPROM address for read */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);\n   }\n  \n  /* While there is data to be read */\n  while(NumByteToRead)  \n  {\n    if(NumByteToRead == 1)\n    {\n      /* Disable Acknowledgement */\n      I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);\n      \n      /* Send STOP Condition */\n      I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);\n    }\n\n    /* Test on EV7 and clear it */    \n    I2CTimeout = I2CT_LONG_TIMEOUT;\n    \n    while(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==0)  \n    {\n        if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);\n    } \n    {      \n      /* Read a byte from the EEPROM */\n      *pBuffer = I2C_ReceiveData(EEPROM_I2Cx);\n\n      /* Point to the next location where the byte read will be saved */\n      pBuffer++; \n      \n      /* Decrement the read bytes counter */\n      NumByteToRead--;        \n    }   \n  }\n\n  /* Enable Acknowledgement to be ready for another reception */\n  I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);\n  \n    return 1;\n}\n```\n\n##### 等待EEPROM函数\n\n```c\n/**\n  * @brief  Wait for EEPROM Standby state \n  * @param  无\n  * @retval 无\n  */\nvoid I2C_EE_WaitEepromStandbyState(void)      \n{\n  vu16 SR1_Tmp = 0;\n\n  do\n  {\n    /* Send START condition */\n    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n    /* Read I2C1 SR1 register */\n    SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1);\n    /* Send EEPROM address for write */\n    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n  }while(!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) & 0x0002));\n  \n  /* Clear AF flag */\n  I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF);\n    /* STOP condition */    \n    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); \n}\n```\n\n","source":"_posts/STM32F103学习笔记.md","raw":"---\ntitle: STM32F103学习笔记\ndate: 2024-01-17 02:19:55\ntags: 嵌入式\n---\n\n# STM32F103学习笔记\n\n## 说明\n\n本库仅供学习交流使用\n\n- 开发板: 野火霸道V2开发板\n- 编译器： ARM v5.06\n- C编译版本: C99\n- 固件库版本: V3.5.0\n- MDK version: 538A\n- 芯片包: Keil.STM32F1xx_DFP.2.4.1\n- 芯片型号: STM32F103ZET6\n- 参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道/指南者/MINI)【全】(刘火良老师出品) (无字幕)】 <https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4>\n- 仓库地址: <https://github.com/See-YouL/Fire-Projects.git>\n\n## 基础配置\n\n### 配置KeilMDK\n\n看视频配置KeilMDK,P2\n\n[看视频配置Keil MDK](https://www.bilibili.com/video/BV1yW411Y7Gw)\n\n### 配置串口下载程序\n\n看视频配置串口下载程序,P4\n\n[看视频配置串口下载程序](https://www.bilibili.com/video/BV1yW411Y7Gw)\n\n### 美化Keil界面\n\n**非必须步骤**, 用来美化界面\n\n[使用该方案的插件](https://www.bilibili.com/video/BV1uT411S7mB/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n[使用该方案的主题配色](https://www.bilibili.com/video/BV1Df4y1k75Z/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n### 配置VScode\n\n**非必须步骤**, 用来使用VScode开发, *也可使用Keil MDK则不需要该步骤*\n\n方案一: 使用VScode + Keil5 MDK进行开发(主要插件**Keil Assistant**)\n\n- 优点: 不需要使用Keil进行编辑\n- 缺点: 不具备Debug功能,只有编译和烧录\n\n[方案一参考视频](https://www.bilibili.com/video/BV19V411g7gD/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n方案二: 使用Vscode + EIDE进行开发(主要插件**EIDE**)\n\n- 优点: 可在VScode中进行调试\n- 缺点: 依赖Keil的编译环境\n\n[方案二参考视频](https://www.bilibili.com/video/BV1nr4y1R7Jb/?share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n## 理论知识\n\n### STM32命名方式\n\n- STM32: 32bit的MCU\n- F或L: F表示基础型(Foundation)或高性能型(High-Performance), L表示低功耗型(Ultra-low-power)\n- xxx: 芯片特性, 如性能级别、内存大小、特殊功能等\n- 系列:\n  - F0, F1, F2, F3, F4, F7：这些数字代表不同的性能级别，数字越大，性能通常越高。\n  - L0, L1, L4, L5：这些是低功耗系列，数字越大，性能和功能通常越丰富。\n- 性能级别: 通常由一到两位数字表示，如STM32F103或STM32L152。这些数字表示不同的性能级别、内存大小和外设\n- 包装类型: 通常由一个字母表示，如STM32F103C8T6中的C表示LQFP48封装\n- 额外特性: 如STM32F103C8T6中的8表示该芯片有64KB闪存，T表示温度范围（-40°C 到 85°C），6表示批次号或版本\n\n#### 例子\n\n以 STM32F103C8T6 为例：\n\n- STM32：STMicroelectronics的32位微控制器。\n- F：Foundation系列。\n- 103：该系列中的特定型号，具有特定的性能、内存和外设配置。\n- C：封装类型，这里是LQFP48。\n- 8：闪存大小，这里是64KB。\n- T：温度范围，这里是-40°C 到 85°C。\n- 6：批次号或版本。\n\n## 置位与清零\n\n- &= ~(1 << n); **将bit n清零,其他位保持不变**\n- |= (1 << n); **将bit n置1,其他位保持不变**\n\n## GPIO\n\n### GPIO简介\n\nGPIO(General purpose input output)通用输入输出端口的简称,**软件可以控制的引脚,可输入可输出**\n\n#### GPIO和引脚的区别\n\n引脚（Pin）\n\n- 定义：引脚是指微控制器、微处理器或其他电子组件上的物理接点。它们是硬件设备的一部分，用于连接电路板、传递信号或供电。\n- 通用性：引脚可以有多种功能，包括但不限于传输数据、供电、接地或作为特殊功能的接口（如模拟输入、PWM输出等）。\n- 物理特性：引脚是实体的、物理存在的，可以是金属的脚或焊盘。\n\nGPIO（General-Purpose Input/Output）\n\n- 定义：GPIO是指在微控制器或其他数字电路设备上的一种特定类型的引脚，可以通过编程设置为输入或输出模式。\n- 功能：GPIO引脚的功能非常灵活，可以用于读取数字信号（如按钮的按压）或输出数字信号（如控制LED灯的开关）。\n- 编程控制：GPIO引脚的主要特点是它们可以通过软件编程来控制其行为，这使得它们非常适合于各种通用的数字输入输出任务。\n\n区别\n\n- 功能范围：所有GPIO都是引脚，但并非所有引脚都是GPIO。引脚是一个更广泛的概念，包括GPIO以及其他专用功能的引脚。\n- 灵活性和用途：GPIO引脚特别设计用于通用的数字输入输出任务，并且它们的行为可以通过软件编程来改变。而其他类型的引脚可能有固定的功能，如电源、接地或特定的通信功能。\n- 编程控制：GPIO的关键特性是它们可以被编程来执行不同的任务（输入或输出），而其他类型的引脚可能不具备这种灵活性。\n\n总的来说，**GPIO是引脚的一个子集，专门用于可编程的通用数字输入输出任务。而引脚是一个更广泛的概念，涵盖了电子设备上的所有物理接点。**\n\n#### 引脚的分类\n\n![引脚的分类](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png)\n\n### GPIO 框图讲解\n\n#### 保护二极管\n\n![保护二极管](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.41.14.png)\n\n- **如果引脚电压大于VDD则上面的保护二极管导通**,防止高电压进入芯片内部,如果电压过高则会烧坏二极管进而烧坏芯片\n- **如果引脚电压低于VSS则下面的保护二极管导通**,保护芯片\n\n#### 推挽输出\n\n![ODR=1时推挽输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.09.27.png)\n\n推挽输出部分的INT来自ODR寄存器\n\n若ODR为1, 经过反相器后为0, 此时PMOS和NMOS的Ug=0V\n\n对于PMOS, Us=3.3V > Ug=0V, PMOS管导通, OUT=VDD\n\n对于NMOS, Us=0V = Ug=0V, 简单认为, NMOS管截止\n\n![ODR=0时推挽输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.20.46.png)\n\n若ODR为0,经过反相器后为1, 此时PMOS和NMOS的Ug=3.3V\n\n对于PMOS, Us=3.3V = Ug=3.3V, 简单认为, PMOS管截止\n\n对于NMOS, Us=0V < Ug=3.3V, NMOS管导通, OUT=GND=0V\n\n##### 推挽输出的含义\n\n![推挽输出含义图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.23.18.png)\n\n- PMOS导通时, OUT处电流向外称为**推**, 此时电流称为**灌电流**\n- NMOS导通时, OUT处电流向里称为**挽**, 此时电流称为**拉电流**\n\n推挽输出（Push-Pull Output）是一种常见的电子电路输出类型，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的**主要特点是它使用两个晶体管（一个N型和一个P型）来控制输出引脚的电压状态。**\n\n##### 推挽输出的原理\n\n在推挽配置中，通常有两个晶体管：\n\n- N型晶体管：当被激活（或导通）时，它将输出引脚连接到地（GND），从而产生低电平（0）输出。\n- P型晶体管：当被激活时，它将输出引脚连接到正电源（VCC），从而产生高电平（1）输出。\n\n这两个晶体管不会同时导通，以避免短路。在任何给定的时刻，要么N型晶体管导通将输出拉低，要么P型晶体管导通将输出拉高。\n\n##### 推挽输出的特点\n\n- 强驱动能力：**推挽输出可以提供较强的电流驱动能力**，无论是向输出引脚提供电流（高电平）还是从引脚吸收电流（低电平）。\n- 确定的逻辑状态：输出要么明确地是高电平，要么是低电平，**不会处于悬空（高阻态）状态**。\n- 无需外部上拉或下拉电阻：由于**推挽输出自身就可以明确地驱动高电平或低电平**，因此不需要外部的上拉或下拉电阻来确保稳定的输出状态。\n\n##### 推挽输出的应用\n\n推挽输出广泛应用于各种数字电路，特别是**在需要驱动LED、继电器或其他需要较高电流的负载时**。由于其**强大的驱动能力和清晰的逻辑电平**，推挽输出是实现**数字信号传输**的理想选择。\n\n##### 推挽输出对比开漏/开集输出\n\n与推挽输出相对的是开漏（在MOSFET技术中）或开集（在双极晶体管技术中）输出，**这种类型的输出只有一个晶体管，要么将输出拉低，要么让它悬空（高阻态）**。开漏/开集输出**需要外部上拉电阻来确保高电平状态**，常用于需要多个设备共享同一输出线的应用，如I2C通信协议。\n\n#### 开漏输出\n\n内部只能输出低电平,不能输出高电平\n\n![当ODR为1时开漏输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png)\n\n 该图片标注有误, 实际用的是ODR=0时的图, 但是结构相同, 不影响分析\n\nODR=1, 经反相器为0, Vg=0V=Vs=0V, NMOS管截止, 此时OUT为高阻态悬空, 加入外部上拉电阻后, OUT=1\n\n如果外部需要高电平驱动可以通过更换外部上拉电路来进行更换\n\n![当ODR为0时开漏输出原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png)\n\nODR=0, 经反相器为1, Vg=1 > Vs=0, NMOS管导通, 此时OUT=0V\n\n开漏输出（Open-Drain Output，在使用MOSFET技术的情况下称为开漏，而在使用双极性晶体管的情况下称为开集（Open-Collector）输出）是一种常见的电子电路设计，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的**主要特点是它使用单个晶体管来控制输出引脚的电压状态，而不是像推挽输出那样使用两个晶体管。**\n\n##### 开漏输出的原理\n\n在开漏配置中，只有一个N型晶体管：\n\n- N型晶体管：当晶体管导通（激活）时，它将输出引脚连接到地（GND），产生低电平（0）输出。当晶体管关闭（非激活）时，输出引脚不连接到任何东西，处于悬空状态。\n- 由于输出在晶体管关闭时处于悬空状态，因此通常需要一个外部的上拉电阻连接到正电源（VCC），以确保当晶体管关闭时输出能够达到高电平（1）。\n\n##### 开漏输出的特点\n\n- 单向驱动能力：开漏输出**只能将输出拉低，不能主动驱动高电平**。\n- 需要外部上拉电阻：**为了确保输出能够达到高电平，需要外部上拉电阻**。\n- 适合于总线和共享线路：开漏输出非常**适合于多个设备共享同一输出线的应用**，因为任何一个设备都可以将线路拉低，而不会对其他设备造成干扰。\n\n##### 开漏输出的应用\n\n开漏输出**常用于需要多个设备共享同一通信线路的场合**，如I2C和1-Wire通信协议。在这些应用中，**多个设备可以连接到同一条线路上，每个设备都可以通过将线路拉低来发送信号，而不会影响其他设备。**\n\n##### 开漏输出对比推挽输出\n\n与开漏输出相对的是推挽输出，后者使用两个晶体管（一个N型和一个P型）来分别驱动高电平和低电平。推挽输出可以主动驱动高电平和低电平，而**开漏输出只能驱动低电平，需要外部上拉电阻来实现高电平状态。**\n\n#### 补充: 高阻态与悬空\n\n**高阻态（High-Impedance State），通常简称为Hi-Z**，是电子电路中的一个术语，用来描述一个电路节点在特定条件下呈现出非常高电阻的状态。在这种状态下，**电路节点既不明显地连接到电源（高电平），也不明显地连接到地（低电平）**。换句话说，这个节点处于一种“断开”或“浮空”的状态，对电路中的其他部分几乎没有任何电气影响。\n\n##### 高阻态的应用\n\n- **三态逻辑（Tri-state Logic）**：在数字电路中，高阻态常用于三态逻辑，**允许多个输出连接到同一个线路或总线上，而不会相互干扰**只有被选中的设备会将其输出置于低电阻状态（高电平或低电平），其他设备的输出则处于高阻态。\n- **总线系统**：在微处理器、微控制器和其他数字系统的总线（如数据总线、地址总线）上，高阻态用于控制哪个设备可以在特定时刻向总线发送数据。\n- **输入/输出端口**：在可编程的微控制器的GPIO（通用输入/输出）端口中，**高阻态可以用来防止未使用的或被配置为输入的端口对电路造成影响**。\n\n##### 高阻态的重要性\n\n- **避免冲突**：在多个设备共享同一通信线路时，高阻态可以防止输出冲突。\n- **节能**：当端口处于高阻态时，它几乎不消耗电流，有助于降低功耗。\n- **灵活性**：高阻态提供了电路设计的灵活性，特别是在需要多个设备共享同一资源的情况下。\n\n##### 高阻态的注意事项\n\n- **浮动电压**：当一个端口或线路处于高阻态时，它可能会因为电磁干扰或静电感应而捕获不确定的电压，**有时可能需要通过上拉或下拉电阻来确保稳定的逻辑状态**。\n- **设计考虑**：在设计电路和编写程序时，需要考虑到高阻态的影响，确保在适当的时候启用或禁用高阻态。\n\n在电子电路中，**“悬空”（Floating）是指一个电路节点没有被明确连接到电源（高电平）或地（低电平），也没有通过任何电阻或其他电子元件连接到其他电路节点的状态**这种状态下的节点电压是不确定的，因为它既不是被固定在逻辑高也不是逻辑低，而是可以随外部电磁场或附近电路的状态变化而变化。\n\n##### 悬空状态的特点\n\n- 不确定的电压：悬空的节点可能会随机地捕获周围环境的电磁干扰，导致其电压处于不确定的状态。\n- 易受干扰：由于没有明确的电气连接，悬空的节点容易受到外部电磁干扰的影响。\n- 可能导致问题：在数字电路中，悬空的输入引脚可能导致不稳定的逻辑状态，从而引发电路的不可预测行为。\n\n##### 高阻态与悬空的关系\n\n高阻态是一种特定的电路配置，**其中一个节点（如微控制器的GPIO引脚）被设置为非常高的电阻状态。这意味着该节点对电路的其他部分几乎没有电气影响，类似于断开连接**因此，**当一个引脚被设置为高阻态时，它实际上是在悬空状态**，因为它既不是明确地连接到高电平也不是低电平。\n\n##### 高阻态与悬空区别和联系\n\n- 联系：**高阻态通常会导致节点悬空**当一个节点处于高阻态时，由于其极高的电阻值，它实际上与电路的其他部分隔离，从而处于悬空状态。\n- 区别：**高阻态是一种有意设置的电路状态**，用于特定的目的（如防止总线冲突）。而**悬空可能是无意的**，可能是由于设计不当或电路未完成造成的。\n\n##### 悬空的注意事项\n\n- 设计考虑：在设计电子电路和系统时，**应避免输入引脚悬空，因为这可能导致不稳定的行为**。通常**使用上拉或下拉电阻来确保这些引脚有一个确定的逻辑状态。**\n- 高阻态应用：在某些情况下，如**多个设备共享一个通信总线，高阻态是必要的，以确保只有一个设备在任何时刻控制总线。**\n\n#### 复用功能输出\n\n![复用功能输出原理框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.18.55.png)\n\n通过片上外设如EXTI到引脚输出\n\n#### 输入模式\n\nISR读出\n\n![普通模式的输入](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.24.03.png)\n\nI/O引脚至上拉/下拉输入(通过BSRR寄存器软件配置), 经TTL肖特基触发器(>2V <1.2V), 至IDR寄存器读出\n\n复用功能输入\n\n![复用功能输入](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.29.40.png)\n\n以EXTI为例,RX数据经由TTL肖特基触发器到DR寄存器\n\n模拟输入\n\n![模拟输入框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.33.21.png)\n\n不经过TTL肖特基触发器直接被读出\n\n#### GPIO框图对应寄存器\n\n![GPIO框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.35.42.png)\n\n- 2部分: 推挽,开漏输出对应CRL,CRH寄存器\n- 3部分: 输出数据寄存器对应ODR; 位设置/清除寄存器对应BSRR\n- 上拉/下拉输入: 对应CRL,CRH,具体选择上拉还是下拉需要软件配置BSRR\n- 5部分: 输入数据寄存器对应IDR\n\n### GPIO输出初始化顺序\n\n1. 时钟使能\n2. 选择具体的GPIO\n3. 配置GPIO的工作模式(CRL CRH)\n4. 控制GPIO输出高低电平(ODR,BRR和BSRR)\n\n## 手写库\n\n### 通过地址使用寄存器\n\n项目地址: **REG-LED**\n\n#### main.c中的主要代码\n\n```c\n*(unsigned int *)(0x40021018) |= ((1) << 3); // RCC_APB2ENR的bit3置1\n/*----------------------------------------------------------------\n开启GPIOB的时钟\nGPIOB挂载在APB2总线\nRCC_APB2ENR的偏移量为0x18\nRCC的基地址为0x40021000\nRCC_APB2ENR的bit3为IOPBEN(IO端口B时钟使能) 1开启\n****************************************************************************/\n*(unsigned int *)(0x40010C00) |= ((1) << (4*0)); // GPIOB_CRL的bit4-0置0001\n/*----------------------------------------------------------------\n将GPIOB设置为推挽输出\nGPIOB 基地址 0x40010C00\nGPIOx_CRL 偏移量 00h \nbit1-0: 01 输出模式，最大速度10MHz\nbit4-3: 00 通用推挽输出模式\n((1) << (4*0)) // 若修改PB1则为(4*1)\n****************************************************************************/\n*(unsigned int *)(0x40010C0C) &= ~(1<<0); // GPIOB_ODR的bit0置0\n/*----------------------------------------------------------------\n修改PB0为1\nGPIOB 基地址 0x40010C00\nGPIOx_ODR 偏移量 0Ch \n****************************************************************************/\n```\n\n### 通过头文件定义使用寄存器\n\n项目地址: **REG-LED-Register**\n\n确定总线基地址, 其中AHB的基地址是从DMA1开始的,即从0x40020000开始\n\n#### 在stm32f10x.h中增加宏定义\n\n ```c\n// 存放stm32寄存器映射的代码\n\n// 外设 Peripheral\n#define PERIPH_BASE ((unsigned int)0x40000000)\n#define APB1PERIPH_BASE (PERIPH_BASE) // 从TIM2开始\n#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000) // 从AFIO开始\n#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000) // 从DMA1开始\n\n// RCC\n#define RCC_BASE (AHBPERIPH_BASE + 0x1000) // RCC基地址 \n\n// GPIOB\n#define GPIOB_BASE (APB2PERIPH_BASE + 0x0C00) // GPIOB基地址\n\n// 定义寄存器\n\n#define RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x18)) // APB2外设时钟使能寄存器\n#define GPIOB_CRL (*(volatile unsigned int *)(GPIOB_BASE + 0x00))// GPIOB_CRL\n#define GPIOB_CRH (*(volatile unsigned int *)(GPIOB_BASE + 0x04)) // GPIOB_CRH\n#define GPIOB_ODR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C)) // GPIOB_CRH\n ```\n\n#### 在main.c中的主函数代码改为\n\n```c\nRCC_APB2ENR |= ((1) << 3); // 开启GPIOB的时钟\nGPIOB_CRL &= ~((0x0F) << (4*0)); // 将GPIOB状态清零\nGPIOB_CRL |= ((1) << (4*0)); // 将GPIOB设置为推挽输出\nGPIOB_ODR &= ~(1<<0); // PB0置0\n```\n\n#### 补充: 关键字volatile的作用\n\n在C语言中，尤其是在嵌入式领域，volatile 关键字用于告诉编译器，**定义为 volatile 的变量可能会以编译器不可预知的方式被改变**。这意味着编译器在处理这些变量时，**应避免进行某些优化，确保每次访问都直接从内存中读取变量的值**。\n\n#### 关键字volatile含义\n\n当一个变量被声明为 volatile 时，编译器会对该变量的处理方式做出以下调整：\n\n- **防止优化**：编译器不会对这些变量进行优化，这可能包括消除看似多余的读取或写入操作。\n- **直接访问**：每次访问 volatile 变量时，都会直接从其内存地址读取数据，而不是使用可能存储在寄存器中的副本。\n\n#### 关键字volatile的应用场景\n\n在嵌入式编程中，volatile 关键字的使用场景主要包括：\n\n- **硬件寄存器访问**：当编程与硬件寄存器交互时，如读取一个传感器的数据寄存器或写入一个控制寄存器。这些寄存器的值可能会在任何时候改变，因此需要使用 volatile 来确保每次读取或写入都是最新的值。\n- **中断服务例程**：在中断服务例程（ISR）中使用的变量，这些变量可能在ISR中被改变，并在程序的其他部分被访问。使用 volatile 可以确保主程序中的代码能够看到在ISR中对这些变量所做的更改。\n- **多线程和并发**：在多线程或并发环境中，一个线程可能修改另一个线程正在访问的变量。volatile 确保每个线程都能访问到最新的值。\n\n#### 关键字volative的注意事项\n\n- **不是并发解决方案**：volatile 关键字不能替代互斥锁或其他并发控制机制。它不保证操作的原子性或内存可见性。\n- **性能影响**：由于 volatile 防止了某些优化，过度使用它可能会降低程序的性能。\n- **正确使用**：只有在上述特定场景中才应使用 volatile。错误地使用 volatile 可能会导致难以发现的错误。\n\n### 通过结构体操作寄存器\n\n项目地址: **FWlib-LED**\n\n#### 在stm32f10x.h中添加结构体定义\n\n```c\n// 定义结构体\ntypedef unsigned int uint32_t;\ntypedef unsigned short uint16_t;\n\ntypedef struct \n{\n    uint32_t CRL;\n    uint32_t CRH;\n    uint32_t IDR;\n    uint32_t ODR;\n    uint32_t BSRR;\n    uint32_t BRR;\n    uint32_t LCKR;\n}GPIO_TypeDef;\n\n#define GPIOB ((GPIO_TypeDef *)GPIOB_BASE) // 使用GPIOB->访问成员变量\n/*----------------------------------------------------------------\n若定义为 #define GPIOB (*(GPIO_TypeDef *)(GPIOB_BASE))\n则使用GPIOB.XXX来访问成员变量\n----------------------------------------------------------------*/\n```\n\n在main.c中使用GPIOB->XXX的方式来访问结构体成员(即寄存器), 主要代码如下\n\n```c\nGPIOB->CRL &= ~((0x0F) << (4*1)); // 将GPIOB状态复位\nGPIOB->CRL |= ((1) << (4*1)); // 将GPIOB设置为推挽输出\nGPIOB->ODR &= ~(1<<0); // PB0置0\n```\n\n#### 在stm32f10x.h中增加RCC的结构体定义,如下\n\n```c\ntypedef struct \n{\n    uint32_t CR;\n    uint32_t CFGR;\n    uint32_t CIR;\n    uint32_t APB2RSTR;\n    uint32_t APB1RSTR;\n    uint32_t AHBENR;\n    uint32_t APB2ENR;\n    uint32_t APB1ENR;\n    uint32_t BDCR;\n    uint32_t CSR;\n    uint32_t AHBRSTR;\n    uint32_t CFGR2;\n}RCC_Typedef;\n\n#define RCC ((RCC_Typedef*)RCC_BASE) // 使用RCC->访问成员变量\n/*----------------------------------------------------------------\n若定义为 #define RCC (*(RCC_Typedef*)RCC_Base)\n则使用RCC.XXX来访问成员变量\n----------------------------------------------------------------*/\n```\n\n#### 在main.c中通过结构体访问RCC寄存器,代码如下\n\n```c\nRCC->APB2ENR |= ((1) << 3); // 开启GPIOB的时钟\n```\n\n#### 更换LED说明\n\n由于我的开发板，PB0总是点亮蓝灯(本应该是绿灯), 以后的测试换为测试蓝灯，**PB0换为PB1进行测试**\n\n### 增加端口置位/复位函数\n\n项目地址: **FWlib-LED**\n\n增加stm32f10x_gpio.c和stm32f10x_gpio.h文件\n\n#### 在stm32f10x_gpio.c中增加置位/复位函数\n\n```c\n#include \"stm32f10x_gpio.h\"\n\n// 端口置位函数\nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t Pin)\n{\n    GPIOx->BSRR |= Pin;\n    /*----------------------------------------------------------------\n    BSRR寄存器:\n    低16位写1置1，写0不改变\n    高16位写1置0，写0不改变\n    *----------------------------------------------------------------*/\n}\n\n// 端口复位函数\nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t Pin)\n{\n    GPIOx->BRR |= Pin;\n    /*----------------------------------------------------------------\n    BRR寄存器:\n    低16位写1置0，写0不改变\n    高16位保留\n    ----------------------------------------------------------------*/\n}\n```\n\n#### 在stm32f10x_gpio.h中添加16位PIN置1的宏定义与函数声明\n\n```c\n#ifndef __STM32F10X_GPIO_H\n#define __STM32F10X_GPIO_H\n\n#include \"stm32f10x.h\"\n\n// 宏定义端口\n#define GPIO_Pin_0    ((uint16_t)0x0001)  /*!< 选择Pin0 */    //(00000000 00000001)b\n#define GPIO_Pin_1    ((uint16_t)0x0002)  /*!< 选择Pin1 */    //(00000000 00000010)b\n#define GPIO_Pin_2    ((uint16_t)0x0004)  /*!< 选择Pin2 */    //(00000000 00000100)b\n#define GPIO_Pin_3    ((uint16_t)0x0008)  /*!< 选择Pin3 */    //(00000000 00001000)b\n#define GPIO_Pin_4    ((uint16_t)0x0010)  /*!< 选择Pin4 */    //(00000000 00010000)b\n#define GPIO_Pin_5    ((uint16_t)0x0020)  /*!< 选择Pin5 */    //(00000000 00100000)b\n#define GPIO_Pin_6    ((uint16_t)0x0040)  /*!< 选择Pin6 */    //(00000000 01000000)b\n#define GPIO_Pin_7    ((uint16_t)0x0080)  /*!< 选择Pin7 */    //(00000000 10000000)b\n#define GPIO_Pin_8    ((uint16_t)0x0100)  /*!< 选择Pin8 */    //(00000001 00000000)b\n#define GPIO_Pin_9    ((uint16_t)0x0200)  /*!< 选择Pin9 */    //(00000010 00000000)b\n#define GPIO_Pin_10   ((uint16_t)0x0400)  /*!< 选择Pin10 */   //(00000100 00000000)b\n#define GPIO_Pin_11   ((uint16_t)0x0800)  /*!< 选择Pin11 */   //(00001000 00000000)b\n#define GPIO_Pin_12   ((uint16_t)0x1000)  /*!< 选择Pin12 */   //(00010000 00000000)b\n#define GPIO_Pin_13   ((uint16_t)0x2000)  /*!< 选择Pin13 */   //(00100000 00000000)b\n#define GPIO_Pin_14   ((uint16_t)0x4000)  /*!< 选择Pin14 */   //(01000000 00000000)b\n#define GPIO_Pin_15   ((uint16_t)0x8000)  /*!< 选择Pin15 */   //(10000000 00000000)b\n#define GPIO_Pin_All  ((uint16_t)0xFFFF)  /*!< 选择全部引脚*/ //(11111111 11111111)b\n/*----------------------------------------------------------------\n对于类似于GPIOx_BSRR, GPIOx_BRR寄存器通过写1来进行置位/复位操作的寄存器来说\n宏定义16位端口的1值很有必要\n----------------------------------------------------------------*/\n\n// 函数声明\nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t Pin);\nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t Pin);\n\n#endif // !__STM32F10X_GPIO\n```\n\n#### 在main.c函数中使用置位/复位函数\n\n```c\n // 增加复位/置位函数\nRCC->APB2ENR  |=  ( (1) << 3 );\nGPIOB->CRL &=  ~( (0x0f) << (4*0) );\nGPIOB->CRL |=  ( (1) << (4*0) );\nGPIO_SetBits(GPIOB,GPIO_Pin_1);\nGPIO_ResetBits( GPIOB,GPIO_Pin_1 );\n```\n\n#### 在stm32f10x.h中增加#ifndef\n\n```c\n#ifndef __STM32F10X_H\n#define __STM32F10X_H\n\n// 中间代码省略\n\n#endif // !__STM32F10X_H\n```\n\n#### 补充: 在C语言中#ifndef的作用\n\n在C语言中，#ifndef 是一种预处理指令，用于条件编译。它的全称是 \"if not defined\"，意思是“如果没有定义”。#ifndef 通常与 #define 和 #endif 一起使用，**用于防止头文件的内容被多次包含（重复包含）**。\n\n##### ifndef的作用\n\n\"#ifndef\"的主要作用是**确保一个头文件中的内容只被包含一次，防止因重复包含同一头文件而导致的编译错误**这种技术被称为“包含卫士”（Include Guards）或“头文件卫士”（Header Guards）。\n\n##### ifndef的使用方式\n\n一个典型的使用 #ifndef 的例子如下：\n\n```c\n// 假设这是一个头文件 example.h\n\n#ifndef EXAMPLE_H    // 如果没有定义 EXAMPLE_H\n#define EXAMPLE_H    // 定义 EXAMPLE_H\n\n// 头文件的内容\nvoid someFunction();\n// 更多的声明...\n\n#endif // 结束 #ifndef\n```\n\n在这个例子中：\n\n1. 当编译器首次遇到 example.h 时，EXAMPLE_H 还没有被定义，所以编译器会处理 #define EXAMPLE_H 和随后的头文件内容。\n2. 如果同一源文件或其他包含了 example.h 的文件再次尝试包含 example.h，EXAMPLE_H 已经被定义了，因此 #ifndef EXAMPLE_H 条件失败，编译器将跳过文件的其余部分，防止重复包含。\n\n##### ifndef的重要性\n\n在C语言项目中，特别是在大型项目中，头文件经常被多个源文件包含，或者一个头文件包含其他头文件。如果没有包含卫士，头文件中的定义（如函数声明、宏定义、类型定义等）可能会被重复包含，导致编译错误（如重复定义错误）。使用 #ifndef 可以有效地避免这种情况。\n\n#### 补充: 使用#ifndef命名使用双下划线说明\n\n在C语言中，当使用 #ifndef（和 #define、#endif）作为头文件的包含卫士时，通常会在文件名前加上双下划线 __ 或其他类似的前缀/后缀，**这是一种非正式的约定，用于减少命名冲突的风险**然而，需要注意的是，**使用双下划线作为前缀或后缀在某些情况下可能并不是最佳实践**。\n\n##### 使用双下划线的原因\n\n- **唯一性**：在大型项目中，可能会有许多不同的头文件。使用文件名作为宏的一部分可以帮助确保每个包含卫士的宏是唯一的。\n- **减少冲突**：添加额外的字符（如双下划线）可以进一步减少不同头文件之间宏名称冲突的可能性。\n\n##### 使用双下划线的注意事项\n\n**保留标识符**：根据C和C++标准，**以双下划线开头或以单下划线后跟大写字母开头的标识符是保留给实现（编译器和标准库）使用的**。因此，使用这样的标识符作为宏名称**可能会导致与标准库或编译器的内部标识符冲突**。\n\n建议的做法：更安全的做法是**使用文件名的大写形式加上一个后缀（如 _H），而不是使用双下划线**。例如，对于 example.h 头文件，可以使用 EXAMPLE_H 作为包含卫士的宏。\n\n##### 示例\n\n```c\n#ifndef EXAMPLE_H    // 更安全的做法\n#define EXAMPLE_H\n\n// 头文件内容\n\n#endif // EXAMPLE_H\n```\n\n总之，**虽然在文件名前加上双下划线是一种常见做法，但为了避免与编译器或标准库的内部标识符冲突，建议使用其他方法来确保宏名称的唯一性和安全性**。\n\n### 增加GPIO初始化结构体\n\n项目地址: **FWlib-LED**\n\n配置GPIO工作模式的宏定义(GPIOMode_TypeDef)参考下图\n\n![GPIO工作模式图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202312301523539.png)\n\n实际写入寄存器的是bit3-0,bit7-4并不写入寄存器\n\n勘误：上拉输入和下拉输入两行的bit3-2应该为10\n\n- bit1-0: 置0, 配置输出速度，通过GPIOSpeed_TypeDef进行覆盖配置\n- bit3-2: 配置输入/输出模式\n- bi4: **不写入寄存器**, 用来标志是输入还是输出\n- bit6-5: **不写入寄存器**， 用来判断是上拉输入还是下拉输入\n- bit7: **不写入寄存器**\n\n#### 在stm32f10x_gpio.h中增加宏定义\n\n```c\n// 通过枚举 限定GPIO_Speed的选择\ntypedef enum\n{\n    GPIO_Speed_10MHZ = 1, // 01 输出模式，最大速度10MHz\n    GPIO_Speed_2MHZ, // 10 输出模式，最大速度2MHz\n    GPIO_Speed_50MHZ // 11 输出模式，最大速度50MHz\n}GPIOSpeed_TypeDef;\n\n// 通过枚举限定GPIO_Mode的选择\ntypedef enum\n{ GPIO_Mode_AIN = 0x0,           // 模拟输入     (0000 0000)b\n  GPIO_Mode_IN_FLOATING = 0x04,  // 浮空输入     (0000 0100)b\n  GPIO_Mode_IPD = 0x28,          // 下拉输入     (0010 1000)b\n  GPIO_Mode_IPU = 0x48,          // 上拉输入     (0100 1000)b\n  \n  GPIO_Mode_Out_OD = 0x14,       // 开漏输出     (0001 0100)b\n  GPIO_Mode_Out_PP = 0x10,       // 推挽输出     (0001 0000)b\n  GPIO_Mode_AF_OD = 0x1C,        // 复用开漏输出 (0001 1100)b\n  GPIO_Mode_AF_PP = 0x18         // 复用推挽输出 (0001 1000)b\n}GPIOMode_TypeDef;\n\n// 定义GPIO初始化结构体\ntypedef struct\n{\n    uint16_t GPIO_Pin;\n    uint16_t GPIO_Speed;\n    uint16_t GPIO_Mode;\n}GPIO_InitTypeDef;\n\nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);\n```\n\n#### 在stm32f10x_gpio.c中写入GPIO初始化函数\n\n该函数是从库函数中复制得到\n\n```c\n// GPIO初始化函数\nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)\n{\n  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;\n  uint32_t tmpreg = 0x00, pinmask = 0x00;\n  \n/*---------------------- GPIO 模式配置 --------------------------*/\n  // 把输入参数GPIO_Mode的低四位暂存在currentmode\n  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);\n \n  // bit4是1表示输出，bit4是0则是输入 \n  // 判断bit4是1还是0，即首选判断是输入还是输出模式\n  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)\n  { \n    // 输出模式则要设置输出速度\n    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;\n  }\n/*-------------GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- -------*/\n  // 配置端口低8位，即Pin0~Pin7\n  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)\n  {\n    // 先备份CRL寄存器的值\n    tmpreg = GPIOx->CRL;\n  \n    // 循环，从Pin0开始配对，找出具体的Pin\n    for (pinpos = 0x00; pinpos < 0x08; pinpos++)\n    {\n      // pos的值为1左移pinpos位\n      pos = ((uint32_t)0x01) << pinpos;\n      \n      // 令pos与输入参数GPIO_PIN作位与运算，为下面的判断作准备\n      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;\n   \n      //若currentpin=pos,则找到使用的引脚\n      if (currentpin == pos)\n      {\n        // pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚\n        pos = pinpos << 2;\n       //把控制这个引脚的4个寄存器位清零，其它寄存器位不变\n        pinmask = ((uint32_t)0x0F) << pos;\n        tmpreg &= ~pinmask;\n    \n        // 向寄存器写入将要配置的引脚的模式\n        tmpreg |= (currentmode << pos);  \n    \n        // 判断是否为下拉输入模式\n        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)\n        {\n          // 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0\n          GPIOx->BRR = (((uint32_t)0x01) << pinpos);\n        }    \n        else\n        {\n          // 判断是否为上拉输入模式\n          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)\n          {\n            // 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1\n            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);\n          }\n        }\n      }\n    }\n  // 把前面处理后的暂存值写入到CRL寄存器之中\n    GPIOx->CRL = tmpreg;\n  }\n/*-------------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----------*/\n  // 配置端口高8位，即Pin8~Pin15\n  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)\n  {\n    // 先备份CRH寄存器的值\n    tmpreg = GPIOx->CRH;\n  \n    // 循环，从Pin8开始配对，找出具体的Pin\n    for (pinpos = 0x00; pinpos < 0x08; pinpos++)\n    {\n      pos = (((uint32_t)0x01) << (pinpos + 0x08));\n   \n      // pos与输入参数GPIO_PIN作位与运算\n      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);\n   \n      //若currentpin=pos,则找到使用的引脚\n      if (currentpin == pos)\n      {\n        //pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚\n        pos = pinpos << 2;\n        \n        //把控制这个引脚的4个寄存器位清零，其它寄存器位不变\n        pinmask = ((uint32_t)0x0F) << pos;\n        tmpreg &= ~pinmask;\n    \n        // 向寄存器写入将要配置的引脚的模式\n        tmpreg |= (currentmode << pos);\n        \n        // 判断是否为下拉输入模式\n        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)\n        {\n          // 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0\n          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));\n        }\n         // 判断是否为上拉输入模式\n        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)\n        {\n          // 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1\n          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));\n        }\n      }\n    }\n    // 把前面处理后的暂存值写入到CRH寄存器之中\n    GPIOx->CRH = tmpreg;\n  }\n}\n```\n\n#### 在main.c中使用GPIO初始化函数\n\n```c\nGPIO_InitTypeDef GPIO_InitStructure;\nGPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\nGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;\nGPIO_Init(GPIOB, &GPIO_InitStructure);\n```\n\n### 增加宏定义来增强代码可移植性\n\n项目地址： **FWlib-LED**\n\n#### 在main.c中增加宏定义\n\n```c\n#define LED_B_GPIO_PORT GPIOB\n#define LED_B_GPIO_CLK_ENABLE (RCC->APB2ENR |= ((1) << 3)) \n#define LED_B_GPIO_PIN GPIO_Pin_0\n```\n\n在main.c中增加延时函数，实现LED闪烁\n\n```c\nvoid Delay(uint32_t count)\n{\n  for( ; count != 0; count-- )\n  {\n    ;\n  }\n}\n```\n\n#### 在main.c中使用宏定义后的代码实现LED闪烁\n\n```c\n// 增加宏定义以增强代码可移植性\nLED_B_GPIO_CLK_ENABLE;\nGPIO_InitTypeDef GPIO_InitStructure;\nGPIO_InitStructure.GPIO_Pin = LED_B_GPIO_PIN;\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\nGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;\nGPIO_Init(GPIOB, &GPIO_InitStructure);\n\nwhile(1)\n{\n  GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); // PB1置1 蓝灯灭\n  Delay(0xFFFF);\n  GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); // PB1置0 蓝灯亮\n  Delay(0xFFFF);\n}\n```\n\n## 固件库编程\n\n### STM32固件库文件分析\n\n1. 汇编编写的启动文件 startup_stm32f10x_h.s: 设置堆栈指针,设置PC指针，初始化中断向量表，配置系统时钟，调用C库函数_main最终去C的世界\n2. 时钟配置文件 system_stm32f10x.c: 把外部时钟HSE=8M，经过PLL倍频成72M\n3. 外设相关\n   - stm32f10x.h: 实现了内核之外的外设的寄存器映射\n   - xx: GPIO, USART, I2C\n   - stm32f10x_xx.c: 外设的驱动函数库文件\n   - stm32f10x_xx.h: 存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库的头文件声明\n4. 内核相关\n   - CMSIS: Cortex微控制器软件接口标准\n   - core_cm3.h: 实现了内核里面外设的寄存器映射\n   - core_cm3.c: 内核外设的驱动固件库\n   - NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器), misc.h, misc.c\n5. 头文件的配置文件 stm32f10x_conf.h里面包含\n   - stm32f10x_usar.c\n   - stm32f10x_i2c.h\n   - stm32f10x_spi.h\n   - stm32f10x_adc.h\n   - stm32f10x_fsmc.h\n6. 专门存放终端服务函数的C文件(可以放在其他地方，不一定要放在stm32f10x_it.c中)\n   - stm32f10x_it.c\n   - stm32f10x_it.h\n\n### 新建固件库版本工程\n\n项目地址: **Fwlib-Template**\n\n- Doc: 用来存放程序说明的文件，由写程序的人添加\n- Libraries: 存放库文件\n- Project: 存放工程\n- User: 用户编写的驱动文件\n\n其余按照视频配置，P18, 视频链接: [按照P18进行库移植](https://www.bilibili.com/video/BV1yW411Y7Gw/?p=18&share_source=copy_web&vd_source=0db47c15b9f51dbaa4548ec2dc55dea4)\n\n### GPIO输出-使用固件库点亮LED\n\n项目地址: **12-GPIO输出-使用固件库点亮LED**\n\n在User目录下新建led文件夹，添加bsp_led.c和bsp_led.h\n\n#### 在bsp_led.h中添加所使用的宏定义和函数声明\n\n```c\n#ifndef __BSP_LED_H\n#define __BSP_LED_H\n\n#include \"stm32f10x.h\"\n\n// 宏定义\n#define LED_B_GPIO_PIN GPIO_Pin_1 // stm32f10x_gpio.h中定义\n#define LED_B_GPIO_PORT GPIOB // stm32f10x.h中定义 \n#define LED_B_GPIO_CLK RCC_APB2Periph_GPIOB\n\n// 函数声明\nvoid LED_GPIO_Config(void);\n\n#endif // !__BSP_LED_H\n```\n\n#### 在bsp_led.c中添加初始化函数\n\n```c\n// bsp: board support package 板级支持包\n#include \"bsp_led.h\"\n\nvoid LED_GPIO_Config(void)\n{\n    RCC_APB2PeriphClockCmd(LED_B_GPIO_CLK, ENABLE);\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.GPIO_Pin = LED_B_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(LED_B_GPIO_PORT, &GPIO_InitStruct);\n}\n```\n\n#### 在main.c中调用初始化函数，并进行软件延时，实现LED闪烁\n\n```c\n#include \"stm32f10x.h\"\n#include \"bsp_led.h\"\n\nvoid Delay(uint32_t count)\n{\n    for( ; count != 0; count--)\n    {\n        uint32_t current;\n        for(current = count; current != 0; current--)\n        {\n            ;\n        }\n    }\n    \n}\n\nint main(void)\n{\n    LED_GPIO_Config();\n\n    while(1)\n    {\n        GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);\n        Delay(0xFFF); // 延时\n        GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);\n        Delay(0xFFF); // 延时\n    }\n}\n```\n\n#### 在bsp_led.h中增加函数宏定义\n\n```c\n#define ON 1 \n#define OFF 0\n#define LED_B(a) if (a)\\\n                     GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); \\\n                     else\\\n                     GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);\n// 使用\\可以进行换行，其后不能跟空格，\\后应该直接回车\n```\n\n#### 在main.c中使用宏定义的函数\n\n```c\nLED_B(OFF);\nDelay(0xFFF); // 延时\nLED_B(ON);\nDelay(0xFFF); // 延时\n```\n\n#### 补充: C语言反斜杠\\换行\n\n在C语言中使用反斜杠 \\ 进行换行时，确实有一些需要注意的事项。这种用法通常出现在宏定义或是将长代码行分割为多行以提高代码的可读性。正确使用时，\\ 应该放在行尾，紧接着是换行符。\n\n##### C语言反斜杠\\换行的注意事项\n\n- **无空格**：在行尾使用 \\ 时，它之后直到行末不能有任何字符，包括空格或制表符。任何在 \\ 之后的空格都会使得换行转义失效，导致编译错误。\n- **紧跟换行符**：\\ 应该直接紧跟换行符。这告诉编译器忽略换行符，将下一行视为当前行的延续。\n- **可读性**：虽然使用 \\ 可以将长代码行分割为多行，但过度使用可能会降低代码的可读性。适当使用，以保持代码整洁和可维护。\n- **宏定义中的使用**：在宏定义中使用 \\ 进行换行是常见的做法，**因为宏定义必须是单行的**。在这种情况下，确保每一行（除了最后一行）都以 \\ 结尾。\n\n##### C语言反斜杠\\换行的示例\n\n正确的使用：\n\n```c\n#define MY_MACRO(a, b) \\\n    do { \\\n        a = 2; \\\n        b = 3; \\\n    } while(0)\n\nint main() {\n    int x, y;\n    MY_MACRO(x, y);\n    return 0;\n}\n```\n\n在这个例子中，宏 MY_MACRO 被分成了多行，每行的末尾都使用了 \\ 来实现。\n\n错误的使用（如果 \\ 后有空格）：\n\n```c\n#define MY_MACRO(a, b) \\ \n    do { \\\n        a = 2; \\\n        b = 3; \\\n    } while(0)\n```\n\n在这个错误的例子中，**第一行的 \\ 后面如果有空格，将导致编译错误**。\n\n总之，当在C语言中使用 \\ 进行换行时，**确保 \\ 是每行的最后一个字符，并且紧接着换行符**，以避免编译错误并保持代码的清晰\n\n### GPIO输入\n\n项目地址: **13-GPIO输入-按键检测**\n\n通过原理图可知**KEY1接PA0口, 按键按下后为高电平**, 原理图如下\n\n![KEY1原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401011723631.png)\n\n实现**按下KEY1后蓝灯状态翻转**\n\n#### 在bsp_led.h中宏定义电平翻转函数\n\n```c\n#define LED_B_TOGGLE {LED_B_GPIO_PORT->ODR ^= LED_B_GPIO_PIN;}\n/*----------------------------------------------------------------\n^= 异或运算 (a ^ b) 则ab不同为1，相同则为0\nODR低16位和GPIO_Pin_1作异或并重新赋值给ODR可实现ODR的Bit0翻转\n若Bit0=1则Bit0 = 1 ^ 1 = 0, 下一次运算时, Bit0=0则Bit0 = 0^1 = 1\n实际上是ODR的Bit0在和1进行异或操作\n----------------------------------------------------------------*/\n```\n\n#### 在bsp_key.h中进行宏定义和函数声明\n\n```c\n#ifndef __BSP_KEY_H\n#define __BSP_KEY_H\n\n#include \"stm32f10x.h\"\n\n#define KEY_ON 1\n#define KEY_OFF 0\n\n// 宏定义\n#define KEY1_GPIO_PIN GPIO_Pin_0 // stm32f10x_gpio.h中定义\n#define KEY1_GPIO_PORT GPIOA // stm32f10x.h中定义 \n#define KEY1_GPIO_CLK RCC_APB2Periph_GPIOA\n\n// 函数声明\nvoid KEY_GPIO_Config(void);\nuint8_t Key_Scan(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);\n\n#endif // !__BSP_KEY_H\n```\n\n#### 在bsp_key.c中写初始化函数和端口扫描函数\n\n```c\n#include \"bsp_key.h\"\n\nvoid KEY_GPIO_Config(void)\n{\n    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(KEY1_GPIO_PORT, &GPIO_InitStruct);\n}\n\n// 端口扫面函数 检测按下返回1，否则返回0\nuint8_t Key_Scan(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\n{\n    if(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)\n    {\n        while(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)\n        {\n            ;\n        }\n\n        return KEY_ON;\n    }\n    else\n    {\n        return KEY_OFF;\n    }\n    \n}\n\n```\n\n#### 在main.c中进行调用\n\n```c\nint main(void)\n{\n    LED_GPIO_Config();\n    KEY_GPIO_Config();\n\n    while(1)\n    {\n        if(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)\n        {\n            LED_B_TOGGLE;\n        }\n    }\n}\n```\n\n#### 补充: C语言中的异或操作\n\n在C语言中，异或运算是一种基本的位运算，使用符号 ^ 表示。**异或运算符对两个操作数的对应位进行比较，如果两个相应的位不同，则结果为1，如果相同，则结果为0**换句话说，它在以下情况下返回1：\n\n- 第一个操作数的位是0，第二个操作数的位是1。\n- 第一个操作数的位是1，第二个操作数的位是0。\n\n##### C语言异或运算的特性\n\n- 交换律：a ^ b 等于 b ^ a。\n- 结合律：(a ^ b) ^ c 等于 a ^ (b ^ c)。\n- 自反性：任何数与自身异或的结果都是0，即 a ^ a 等于 0。\n- 与0的异或：任何数与0异或都等于它本身，即 a ^ 0 等于 a。\n\n##### C语言异或操作的应用\n\n异或运算在C语言编程中有多种应用：\n\n**值交换**：不使用临时变量交换两个变量的值。\n\n```c\na = a ^ b;\nb = a ^ b;\na = a ^ b;\n```\n\n这种方法虽然巧妙，但**在实际编程中不常用**，因为如果 a 和 b 指向同一内存位置，这会导致结果为0。\n\n**反转特定位**：可以使用异或运算来反转数值中的特定位。\n\n```c\nx = x ^ (1 << n);  // 反转x的第n位\n```\n\n**检查奇偶性**：通过检查数的最低位是否为1，可以使用异或运算来快速检查一个数是奇数还是偶数。\n\n**加密和解密**：由于异或运算的自反性，它可以用于简单的加密和解密操作。\n\n##### C语言异或操作的示例\n\n```c\n#include <stdio.h>\n\nint main() {\n    unsigned int a = 5;  // 二进制: 0101\n    unsigned int b = 3;  // 二进制: 0011\n\n    // 执行异或运算\n    unsigned int result = a ^ b;  // 结果是 6，二进制: 0110\n\n    printf(\"Result = %d\\n\", result);\n    return 0;\n}\n\n```\n\n在这个例子中，5（二进制0101）和3（二进制0011）进行异或运算的结果是6（二进制0110），因为每一位都被相应地比较并计算出结果。\n\n## 位带操作\n\n### 位带简介\n\nCortex-M3微控制器，作为ARM的Cortex-M系列的一部分，提供了位带（Bit-banding）功能，**这是一种允许对单个位进行原子读写操作的机制**。这种功能在需要精确控制或原子性操作单个位的场合非常有用，例如在多任务环境中操作共享资源。\n\n在 CM3 中，有两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，**它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个 32 位的字**。\n\n![位带地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021935413.png)\n\n在CM3权威指南CnR2中**支持位带操作的两个内存区的范围**如下\n\n![内存区范围](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021941642.png)\n\n### 位带操作的原理\n\n位带操作在Cortex-M3中是**通过将一个较大的地址空间（位带区域）映射到一个较小的地址空间（位带别名区域）来实现的**。在Cortex-M3中，有两个主要的位带区域：\n\n1. SRAM位带区域：通常用于内存中的变量。\n2. 外设位带区域：用于外设寄存器。\n\n每个位带区域的一个字（32位）对应主存储区的一个位。这意味着，通过写入位带区域的地址，你可以设置或清除主存储区相应位的值。\n\n### 位带操作的地址映射\n\n位带操作的地址映射通常遵循以下规则：\n\n位带别名地址 = 位带基地址 + (字节偏移量 x 32) + (位编号 x 4)\n\n其中，**字节偏移量是目标地址相对于位带区域基地址的偏移量**，**位编号是要操作的位**。\n\n### 位带操作的示例\n\n假设有一个外设寄存器的地址为 0x40000000，我们要设置这个寄存器的第2位。首先，我们需要计算这个位在位带别名区域中的地址。\n\n假设外设位带区域的基地址是 0x42000000，那么：\n\n- 字节偏移量 = 0x40000000 - 0x40000000 = 0x00000000\n- 位编号 = 2\n- 位带别名地址 = 0x42000000 + (0x00000000 x 32) + (2 x 4) = 0x42000008\n\n然后，你可以直接写入这个位带别名地址来设置或清除该位：\n\n```c\n#define BITBAND_PERIPH(address, bit) ((void*)(0x42000000 + ((address) - 0x40000000) * 32 + (bit) * 4))\n\nunsigned int *alias_address = (unsigned int *)BITBAND_PERIPH(0x40000000, 2);\n*alias_address = 1;  // 设置第2位, 将第二位值设置为1\n```\n\n### 位带操作的注意事项\n\n- 硬件支持：确保你的Cortex-M3微控制器支持位带操作。\n- 地址计算：正确的地址计算对于位带操作至关重要。\n- 原子操作：位带操作是原子的，这意味着在多任务或中断驱动的环境中，它们是安全的。\n\n### 使用位带操作实现GPIO的输出和输入\n\n项目地址: **14-位带操作-GPIO的输出和输入**\n\n使用位带操作实现GPIO输出: LED_B的闪烁\n\n#### 在main.c中添加位带操作的宏定义\n\n```c\n#define GPIOB_ODR_Addr (GPIOB_BASE+0x0C)\n#define PBout(n) *(unsigned int*)((GPIOB_ODR_Addr&0xF0000000) + 0x02000000 + ((GPIOB_ODR_Addr&0x00FFFFFF)<<5)+(n<<2))\n```\n\n#### 在main.c中使用位带操作点灯\n\n```c\nwhile(1)\n{\n    PBout(1) = 1;\n    Delay(0xFFF); // 延时\n    PBout(1) = 0;\n    Delay(0xFFF); // 延时\n}\n```\n\n使用位带操作实现GPIO输入: KEY1和KEY2控制LED_B状态翻转\n\n#### 在bsp_key.h中添加KEY2的宏定义\n\n```c\n#define KEY2_GPIO_PIN GPIO_Pin_13 // stm32f10x_gpio.h中定义\n#define KEY2_GPIO_PORT GPIOC // stm32f10x.h中定义 \n#define KEY2_GPIO_CLK RCC_APB2Periph_GPIOC\n```\n\n#### 在bsp.c中增加KEY2的GPIO初始化\n\n```c\nvoid KEY_GPIO_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStruct;\n\n    // KEY1 初始化\n    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);\n    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(KEY1_GPIO_PORT, &GPIO_InitStruct);\n\n    // KEY2 初始化\n    RCC_APB2PeriphClockCmd(KEY2_GPIO_CLK, ENABLE);\n    GPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(KEY2_GPIO_PORT, &GPIO_InitStruct);\n}\n```\n\n#### 在main.c中添加GPIO输入位带操作的宏定义\n\n```c\n#define GPIOA_IDR_Addr (GPIOA_BASE+0x08)\n#define GPIOC_IDR_Addr (GPIOC_BASE+0x08)\n#define PAin(n) *(unsigned int*)((GPIOA_IDR_Addr&0xF0000000) + 0x02000000 + ((GPIOA_IDR_Addr&0x00FFFFFF)<<5)+(n<<2))\n#define PCin(n) *(unsigned int*)((GPIOC_IDR_Addr&0xF0000000) + 0x02000000 + ((GPIOC_IDR_Addr&0x00FFFFFF)<<5)+(n<<2))\n```\n\n#### 在main.c中测试LED闪烁\n\n```c\nwhile(1)\n{\n    if(PAin(0) == KEY_ON)\n    {\n        Delay(0xFFF); // 加入软件消抖后可正常运行\n        while(PAin(0) == KEY_ON) // 等待按键释放\n        {\n            ;\n        }\n        LED_B_TOGGLE;\n    }\n\n    if(PCin(13) == KEY_ON)\n    {\n        Delay(0xFFF); // 加入软件消抖后可正常运行\n        while(PCin(13) == KEY_ON) // 等待按键释放\n        {\n            ;\n        }\n        LED_B_TOGGLE;\n    }\n}\n```\n\n## 启动文件详解\n\n```assembly\n;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************\n;* File Name          : startup_stm32f10x_hd.s\n;* Author             : MCD Application Team\n;* Version            : V3.5.0\n;* Date               : 11-March-2011\n;* Description        : STM32F10x High Density Devices vector table for MDK-ARM \n;*                      toolchain. \n;*                      This module performs:\n;*                      - Set the initial SP \n;                       初始化堆栈指针\n;*                      - Set the initial PC == Reset_Handler \n;                       初始化PC指针 == Reset_Handler程序\n;*                      - Set the vector table entries with the exceptions ISR address \n;                       初始化中断向量表\n;*                      - Configure the clock system and also configure the external \n;*                        SRAM mounted on STM3210E-EVAL board to be used as data \n;*                        memory (optional, to be enabled by user) \n;                       配置系统时钟\n;*                      - Branches to __main in the C library (which eventually\n;*                        calls main()). \n;                       调用C库函数, 最终去到C的世界\n;*                      After Reset the CortexM3 processor is in Thread mode,\n;*                      priority is Privileged, and the Stack is set to Main.\n;* <<< Use Configuration Wizard in Context Menu >>>   \n;*******************************************************************************\n; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.\n; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,\n; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE\n; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING\n; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n;*******************************************************************************\n\n;****************************************************************************\n;* 1- 栈的配置\n;****************************************************************************\n\n; Amount of memory (in bytes) allocated for Stack\n; Tailor this value to your application needs\n; <h> Stack Configuration \n;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>\n; </h>\n; 配置栈: 用于变量存储(局部/全局), 函数调用\n\nStack_Size      EQU     0x00000400 \n; 宏定义的伪指令，相当于等于，类似与 C 中的 define。\n; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小\n\n                AREA    STACK, NOINIT, READWRITE, ALIGN=3\n                ; 告诉汇编器汇编一个新的代码段或者数据段。\n                ; STACK 表示段名，这个可以任意命名\n                ; NOINIT 表示不初始化\n                ; READWRITE 表示可读可写\n                ; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐\nStack_Mem       SPACE   Stack_Size\n__initial_sp\n; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。\n; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长\n的。 \n                                                  \n;****************************************************************\n;* 2-堆的配置\n;****************************************************************\n\n; <h> Heap Configuration\n;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>\n; </h>\n; 配置堆: 主要用于动态内存的分配, 如malloc()函数\n\nHeap_Size       EQU     0x00000200\n; 将0x00000200命名为Heap_Size, 0x00000200为512Type\n\n                AREA    HEAP, NOINIT, READWRITE, ALIGN=3\n                ; 汇编数据段\n                ; 名字叫HEAP\n                ; 不初始化\n                ; 可读可写\n                ; 2^3即8字节对齐\n__heap_base\nHeap_Mem        SPACE   Heap_Size\n__heap_limit\n; __heap_base 表示对的起始地址\n; SPACE 分配大小为Heap_Size即512字节的内存空间\n; __heap_limit 表示堆的结束地址\n; 堆是由低向高生长的，跟栈的生长方向相反。\n\n                PRESERVE8\n                ; 指定当前文件的堆栈按照 8 字节对齐\n                THUMB\n                ; 表示后面指令兼容 THUMB 指令\n\n;****************************************************************\n;* 3-初始化中断向量表\n;****************************************************************\n\n; Vector Table Mapped to Address 0 at Reset\n                AREA    RESET, DATA, READONLY\n                ; 区域名称为RESET\n                ; 区域类型为DATA, 与CODE相对,后者用于包含可执行指令\n                ; 区域属性为只读\n                EXPORT  __Vectors\n                EXPORT  __Vectors_End\n                EXPORT  __Vectors_Size\n                ; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用\n\n__Vectors       DCD     __initial_sp               ; Top of Stack ; 栈顶地址\n                DCD     Reset_Handler              ; Reset Handler ; 复位程序地址\n                DCD     NMI_Handler                ; NMI Handler\n                DCD     HardFault_Handler          ; Hard Fault Handler\n                DCD     MemManage_Handler          ; MPU Fault Handler\n                DCD     BusFault_Handler           ; Bus Fault Handler\n                DCD     UsageFault_Handler         ; Usage Fault Handler\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     0                          ; Reserved\n                DCD     SVC_Handler                ; SVCall Handler\n                DCD     DebugMon_Handler           ; Debug Monitor Handler\n                DCD     0                          ; Reserved\n                DCD     PendSV_Handler             ; PendSV Handler\n                DCD     SysTick_Handler            ; SysTick Handler\n\n                ; External Interrupts\n                DCD     WWDG_IRQHandler            ; Window Watchdog\n                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect\n                DCD     TAMPER_IRQHandler          ; Tamper\n                DCD     RTC_IRQHandler             ; RTC\n                DCD     FLASH_IRQHandler           ; Flash\n                DCD     RCC_IRQHandler             ; RCC\n                DCD     EXTI0_IRQHandler           ; EXTI Line 0\n                DCD     EXTI1_IRQHandler           ; EXTI Line 1\n                DCD     EXTI2_IRQHandler           ; EXTI Line 2\n                DCD     EXTI3_IRQHandler           ; EXTI Line 3\n                DCD     EXTI4_IRQHandler           ; EXTI Line 4\n                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1\n                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2\n                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3\n                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4\n                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5\n                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6\n                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7\n                DCD     ADC1_2_IRQHandler          ; ADC1 & ADC2\n                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX\n                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0\n                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1\n                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE\n                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5\n                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break\n                DCD     TIM1_UP_IRQHandler         ; TIM1 Update\n                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation\n                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare\n                DCD     TIM2_IRQHandler            ; TIM2\n                DCD     TIM3_IRQHandler            ; TIM3\n                DCD     TIM4_IRQHandler            ; TIM4\n                DCD     I2C1_EV_IRQHandler         ; I2C1 Event\n                DCD     I2C1_ER_IRQHandler         ; I2C1 Error\n                DCD     I2C2_EV_IRQHandler         ; I2C2 Event\n                DCD     I2C2_ER_IRQHandler         ; I2C2 Error\n                DCD     SPI1_IRQHandler            ; SPI1\n                DCD     SPI2_IRQHandler            ; SPI2\n                DCD     USART1_IRQHandler          ; USART1\n                DCD     USART2_IRQHandler          ; USART2\n                DCD     USART3_IRQHandler          ; USART3\n                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10\n                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line\n                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend\n                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break\n                DCD     TIM8_UP_IRQHandler         ; TIM8 Update\n                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation\n                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare\n                DCD     ADC3_IRQHandler            ; ADC3\n                DCD     FSMC_IRQHandler            ; FSMC\n                DCD     SDIO_IRQHandler            ; SDIO\n                DCD     TIM5_IRQHandler            ; TIM5\n                DCD     SPI3_IRQHandler            ; SPI3\n                DCD     UART4_IRQHandler           ; UART4\n                DCD     UART5_IRQHandler           ; UART5\n                DCD     TIM6_IRQHandler            ; TIM6\n                DCD     TIM7_IRQHandler            ; TIM7\n                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1\n                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2\n                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3\n                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 & Channel5\n__Vectors_End\n; _Vectors 为向量表起始地址，__Vectors_End 为向量表结束地址\n; 向量表中，DCD 分配了一堆内存，并且以 ESR 的入口地址初始化它们 \n\n__Vectors_Size  EQU  __Vectors_End - __Vectors\n; 向量表的大小为结束地址减去起始地址\n\n                AREA    |.text|, CODE, READONLY\n                ; 定义一个名称为.text 的代码段，只读\n                \n;****************************************************************\n;* 4-复位程序\n;****************************************************************\n\n; Reset handler\nReset_Handler   PROC\n                EXPORT  Reset_Handler             [WEAK]\n                ; WEAK 表示弱定义, 如果在其他地方定义了Reset_Handler就使用其他地方的定义\n                ; 可以理解为C++中的\"可以重载\"\n                IMPORT  __main\n                IMPORT  SystemInit\n                ;表示 SystemInit和 __main 这两个函数均来自外部的文件\n\n                LDR     R0, =SystemInit\n                ; 把SystemInit的地址加载到R0中\n                BLX     R0               \n                ; 跳转到R0执行, 执行完毕后返回\n                LDR     R0, =__main\n                ; 把__main的地址加载到R0中\n                BX      R0\n                ; 跳转到R0执行, 执行完毕后不返回\n                ENDP\n                \n;****************************************************************\n;* 5-中断服务函数\n;****************************************************************\n\n; Dummy Exception Handlers (infinite loops which can be modified)\n; 中断服务函数均跳转到无限循环\n; 目的是用户在未定义中断服务函数的情况下调用可进入无限循环状态中(兜底作用)\n\nNMI_Handler     PROC\n                EXPORT  NMI_Handler                [WEAK]\n                B       .\n                ; B 表示跳转指令\n                ; . 表示无限循环\n                ENDP\nHardFault_Handler\\\n                PROC\n                EXPORT  HardFault_Handler          [WEAK]\n                B       .\n                ENDP\nMemManage_Handler\\\n                PROC\n                EXPORT  MemManage_Handler          [WEAK]\n                B       .\n                ENDP\nBusFault_Handler\\\n                PROC\n                EXPORT  BusFault_Handler           [WEAK]\n                B       .\n                ENDP\nUsageFault_Handler\\\n                PROC\n                EXPORT  UsageFault_Handler         [WEAK]\n                B       .\n                ENDP\nSVC_Handler     PROC\n                EXPORT  SVC_Handler                [WEAK]\n                B       .\n                ENDP\nDebugMon_Handler\\\n                PROC\n                EXPORT  DebugMon_Handler           [WEAK]\n                B       .\n                ENDP\nPendSV_Handler  PROC\n                EXPORT  PendSV_Handler             [WEAK]\n                B       .\n                ENDP\nSysTick_Handler PROC\n                EXPORT  SysTick_Handler            [WEAK]\n                B       .\n                ENDP\n\nDefault_Handler PROC\n\n                EXPORT  WWDG_IRQHandler            [WEAK]\n                EXPORT  PVD_IRQHandler             [WEAK]\n                EXPORT  TAMPER_IRQHandler          [WEAK]\n                EXPORT  RTC_IRQHandler             [WEAK]\n                EXPORT  FLASH_IRQHandler           [WEAK]\n                EXPORT  RCC_IRQHandler             [WEAK]\n                EXPORT  EXTI0_IRQHandler           [WEAK]\n                EXPORT  EXTI1_IRQHandler           [WEAK]\n                EXPORT  EXTI2_IRQHandler           [WEAK]\n                EXPORT  EXTI3_IRQHandler           [WEAK]\n                EXPORT  EXTI4_IRQHandler           [WEAK]\n                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]\n                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]\n                EXPORT  ADC1_2_IRQHandler          [WEAK]\n                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]\n                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]\n                EXPORT  CAN1_RX1_IRQHandler        [WEAK]\n                EXPORT  CAN1_SCE_IRQHandler        [WEAK]\n                EXPORT  EXTI9_5_IRQHandler         [WEAK]\n                EXPORT  TIM1_BRK_IRQHandler        [WEAK]\n                EXPORT  TIM1_UP_IRQHandler         [WEAK]\n                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]\n                EXPORT  TIM1_CC_IRQHandler         [WEAK]\n                EXPORT  TIM2_IRQHandler            [WEAK]\n                EXPORT  TIM3_IRQHandler            [WEAK]\n                EXPORT  TIM4_IRQHandler            [WEAK]\n                EXPORT  I2C1_EV_IRQHandler         [WEAK]\n                EXPORT  I2C1_ER_IRQHandler         [WEAK]\n                EXPORT  I2C2_EV_IRQHandler         [WEAK]\n                EXPORT  I2C2_ER_IRQHandler         [WEAK]\n                EXPORT  SPI1_IRQHandler            [WEAK]\n                EXPORT  SPI2_IRQHandler            [WEAK]\n                EXPORT  USART1_IRQHandler          [WEAK]\n                EXPORT  USART2_IRQHandler          [WEAK]\n                EXPORT  USART3_IRQHandler          [WEAK]\n                EXPORT  EXTI15_10_IRQHandler       [WEAK]\n                EXPORT  RTCAlarm_IRQHandler        [WEAK]\n                EXPORT  USBWakeUp_IRQHandler       [WEAK]\n                EXPORT  TIM8_BRK_IRQHandler        [WEAK]\n                EXPORT  TIM8_UP_IRQHandler         [WEAK]\n                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]\n                EXPORT  TIM8_CC_IRQHandler         [WEAK]\n                EXPORT  ADC3_IRQHandler            [WEAK]\n                EXPORT  FSMC_IRQHandler            [WEAK]\n                EXPORT  SDIO_IRQHandler            [WEAK]\n                EXPORT  TIM5_IRQHandler            [WEAK]\n                EXPORT  SPI3_IRQHandler            [WEAK]\n                EXPORT  UART4_IRQHandler           [WEAK]\n                EXPORT  UART5_IRQHandler           [WEAK]\n                EXPORT  TIM6_IRQHandler            [WEAK]\n                EXPORT  TIM7_IRQHandler            [WEAK]\n                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]\n                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]\n                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]\n                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]\n\nWWDG_IRQHandler\nPVD_IRQHandler\nTAMPER_IRQHandler\nRTC_IRQHandler\nFLASH_IRQHandler\nRCC_IRQHandler\nEXTI0_IRQHandler\nEXTI1_IRQHandler\nEXTI2_IRQHandler\nEXTI3_IRQHandler\nEXTI4_IRQHandler\nDMA1_Channel1_IRQHandler\nDMA1_Channel2_IRQHandler\nDMA1_Channel3_IRQHandler\nDMA1_Channel4_IRQHandler\nDMA1_Channel5_IRQHandler\nDMA1_Channel6_IRQHandler\nDMA1_Channel7_IRQHandler\nADC1_2_IRQHandler\nUSB_HP_CAN1_TX_IRQHandler\nUSB_LP_CAN1_RX0_IRQHandler\nCAN1_RX1_IRQHandler\nCAN1_SCE_IRQHandler\nEXTI9_5_IRQHandler\nTIM1_BRK_IRQHandler\nTIM1_UP_IRQHandler\nTIM1_TRG_COM_IRQHandler\nTIM1_CC_IRQHandler\nTIM2_IRQHandler\nTIM3_IRQHandler\nTIM4_IRQHandler\nI2C1_EV_IRQHandler\nI2C1_ER_IRQHandler\nI2C2_EV_IRQHandler\nI2C2_ER_IRQHandler\nSPI1_IRQHandler\nSPI2_IRQHandler\nUSART1_IRQHandler\nUSART2_IRQHandler\nUSART3_IRQHandler\nEXTI15_10_IRQHandler\nRTCAlarm_IRQHandler\nUSBWakeUp_IRQHandler\nTIM8_BRK_IRQHandler\nTIM8_UP_IRQHandler\nTIM8_TRG_COM_IRQHandler\nTIM8_CC_IRQHandler\nADC3_IRQHandler\nFSMC_IRQHandler\nSDIO_IRQHandler\nTIM5_IRQHandler\nSPI3_IRQHandler\nUART4_IRQHandler\nUART5_IRQHandler\nTIM6_IRQHandler\nTIM7_IRQHandler\nDMA2_Channel1_IRQHandler\nDMA2_Channel2_IRQHandler\nDMA2_Channel3_IRQHandler\nDMA2_Channel4_5_IRQHandler\n                B       .\n\n                ENDP\n\n                ALIGN\n                ; ALIGN 表示4字节对齐(参数缺省时)\n\n;****************************************************************\n;* 6-堆栈的初始化, 由C库函数__main实现\n;****************************************************************\n\n;*******************************************************************************\n; User Stack and Heap initialization\n;*******************************************************************************\n                 IF      :DEF:__MICROLIB ; __MICROLIB在ide里定义, 在Keil5 MDK中勾选Use MicroLIB选项\n                \n                 EXPORT  __initial_sp\n                 EXPORT  __heap_base\n                 EXPORT  __heap_limit\n                \n                 ELSE\n                \n                 IMPORT  __use_two_region_memory ; 如果__MICROLIB未定义, 则由用户自己实现\n                 EXPORT  __user_initial_stackheap\n                 \n__user_initial_stackheap\n\n                 LDR     R0, =  Heap_Mem\n                 LDR     R1, =(Stack_Mem + Stack_Size)\n                 LDR     R2, = (Heap_Mem +  Heap_Size)\n                 LDR     R3, = Stack_Mem\n                 BX      LR\n\n                 ALIGN\n\n                 ENDIF\n\n                 END\n\n;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****\n\n```\n\n### EQU指令\n\n作用: The EQU directive is a register-relative address, a PC-relative address, an absolute address, or a 32-bit integer constant. // 为数值常量、寄存器相对值或 PC 相对值提供符号名称。(*可以理解为重命名*)\n\n```assembly\nStack_Size      EQU     0x00000400 \n; 宏定义的伪指令，相当于等于，类似与 C 中的 define。\n; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小\n```\n\n#### EQU手册说明\n\n![EQU指令](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031428875.png)\n\n### AREA指令\n\nAREA: 汇编一个新的代码段或数据段\n\n```assembly\nAREA    STACK, NOINIT, READWRITE, ALIGN=3\n; 告诉汇编器汇编一个新的代码段或者数据段。\n; STACK 表示段名，这个可以任意命名\n; NOINIT 表示不初始化\n; READWRITE 表示可读可写\n; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐\n```\n\n#### AREA手册说明\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031529274.png)\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530123.png)\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530696.png)\n\n![AREA](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031531689.png)\n\n### SPACE指令\n\nSPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size, 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长\n\n```assembly\nStack_Mem       SPACE   Stack_Size\n; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。\n__initial_sp\n; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长\n```\n\n#### SPACE手册说明\n\n![SPACE](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031539781.png)\n\n### PRESERVE8指令\n\nPRESERVE8：指定当前文件的堆栈按照 8 字节对齐\n\n#### PRESERVE8手册说明\n\n![PRESERVE8](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031556307.png)\n\n![PRESERVE8](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031557775.png)\n\n### THUMB指令\n\n野火的解释: **THUMB：表示后面指令兼容 THUMB 指令。THUBM 是 ARM 以前的指令集，16bit，现在 Cortex-M系列的都使用 THUMB-2 指令集，THUMB-2 是 32 位的，兼容 16 位和 32 位的指令，是 THUMB的超集**\n\n#### THUMB手册说明\n\n![THUMB](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031600256.png)\n\n### EXPORT指令\n\nEXPORT：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 IAR 编译器，则使用的是 GLOBAL 这个指令\n\n```assembly\nEXPORT  __Vectors\nEXPORT  __Vectors_End\nEXPORT  __Vectors_Size\n; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用\n```\n\n#### EXPORT手册说明\n\n![EXPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031623174.png)\n\n![EXPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624509.png)\n\n![EXPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624882.png)\n\n### DCD指令\n\nDCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存\n\n#### DCD手册说明\n\n![DCD](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032016385.png)\n\n### PROC指令\n\nPROC: 定义子程序, 与ENDP成对使用, 表示子程序结束\n\n#### PROC手册说明\n\n![PROC](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032025440.png)\n\n![PROC](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032026200.png)\n\n### IMPORT指令\n\nIMPORT：表示该标号来自外部文件，跟 C 语言中的 EXTERN 关键字类似\n\n```assembly\nIMPORT  __main\nIMPORT  SystemInit\n;表示 SystemInit和 __main 这两个函数均来自外部的文件\n```\n\n#### IMPORT手册说明\n\n![IMPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034894.png)\n\n![IMPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034604.png)\n\n![IMPORT](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032035341.png)\n\n### LDR指令\n\nLDR: 从存储器中加载字到一个寄存器中\n\n```assembly\nLDR     R0, =SystemInit\n; 把SystemInit的地址加载到R0中\nBLX     R0               \n; 跳转到R0执行, 执行完毕后返回\nLDR     R0, =__main\n; 把__main的地址加载到R0中\nBX      R0\n; 跳转到R0执行, 执行完毕后不返回\n```\n\n#### LDR手册说明\n\n![LDR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046548.png)\n\n![LDR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046349.png)\n\n![LDR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032047305.png)\n\n### BLX指令\n\nBLX: 跳转到由寄存器给出的地址, 并根据寄存器的LSE确定处理器的状态, 还要把跳转前的下条指令地址保存到LR\n\n```assembly\nBLX     R0               \n; 跳转到R0执行, 执行完毕后返回\n```\n\n### BX指令\n\nBX: 跳转到由寄存器/标号给出的地址, 不用返回\n\n```assembly\nBX      R0\n; 跳转到R0执行, 执行完毕后不返回\n```\n\n### ALIGN指令\n\nALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐\n\n#### ALIGN手册说明\n\n![ALIGN](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103293.png)\n\n![ALIGN](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103739.png)\n\n![ALIGN](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103256.png)\n\n## 时钟\n\n### 时钟系统框图\n\n![时钟系统框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2009.47.02.png)\n\n#### SYSCLK系统时钟源选择\n\n- HSI_RC: 高速内部时钟, RC 震荡产生(频率约为 8MHz)\n- HSE: 高速外部时钟,通过外接晶振产生(频率范围: 4-16MHz)\n- PLL: 锁相环,倍频到72MHz\n\n##### SYSCLK 系统时钟的选择\n\n1. HSI_RC 约 8MHz\n2. PLLCLK 倍频至72MHz\n3. HSE_Osc直接使用\n\n##### PLL锁相环的选择\n\n1. HSI_RC 两分频后\n2. HSE_Osc or HSE_Osc二分频后\n\nCSS: 时钟监视系统, 监视 HSE_Osc 是否正常工作,若 外部时钟源异常则将 SYSCLK 切换为 HSI_RC\n\n![时钟系统框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.03.07.png)\n\n#### RTCCLK时钟源选择\n\n- LSE_Osc: 低速外部时钟源, 频率为36.768KHz\n- LSI_RC: 低速内部时钟源, 频率约为40KHz, 由 RC 震荡产生\n\n##### RTC_CLK(RTC 时钟)的选择\n\n1. HSE_Osc 128 分频后\n2. LSE_Osc\n3. LSI_RC\n\n#### IWDGCLK独立看门狗时钟源\n\nIWDGCLK独立看门狗时钟源由LSI_RC 提供\n\n![IWDGCLK独立看门狗时钟源](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401291156077.png)\n\n#### MCO 的选择\n\nMCO是一个引脚来输出内部时钟\n\n![系统时钟框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.13.53.png)\n\n1. SYSCLK\n2. HSI\n3. HSE\n4. PLLCLK 二分频\n\n#### 各类总线时钟\n\n![时钟系统框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.26.21.png)\n\n1. USBCLK_48MHz (USB 时钟): 由 PLLCLK经USB_Prescaler预分频至 48MHz\n2. HCLK: SYSCLK->AHB_Prescaler 最高 72MHz\n3. PCLK1: SYSCLK->AHB_Prescaler->APB1_Prescaler 最高36MHz\n4. TIMxCLK(通用定时器时钟): SYSCLK->AHB_Prescaler->APB1_Prescaler->TIM2,3,4_Multiplier\n5. PCKL2: SYSCLK->AHB_Prescaler->APB2_Prescaler 最高72MHz\n6. TIM1CLK(TIM1 时钟): SYSCLK->AHB_Prescal->APB2_Prescaler->TIM1_Multiplier\n7. ADCCLK(ADC 时钟): SYSCLK->AHB_Prescaler->APB2_Prescaler->ADC_Prescaler\n\n#### 总结\n\n![知识总结](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2011.09.39.png)\n\n### 系统时钟配置函数 SetSysClockTo72()分析\n\n在启动文件startup_stm32f10x_hd.s中执行SystemInit函数, 如下\n\n```assembly\n; Reset handler\nReset_Handler   PROC\n                EXPORT  Reset_Handler             [WEAK]\n                IMPORT  __main\n                IMPORT  SystemInit\n                LDR     R0, =SystemInit\n                BLX     R0               \n                LDR     R0, =__main\n                BX      R0\n                ENDP\n```\n\n在system_stm32f10x.c文件中调用SystemInit函数, SystemInit函数在末尾调用SetSysClock()函数\n\n```c\nvoid SystemInit (void)\n{\n  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */\n  /* Set HSION bit */\n  RCC->CR |= (uint32_t)0x00000001;\n\n  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */\n#ifndef STM32F10X_CL\n  RCC->CFGR &= (uint32_t)0xF8FF0000;\n#else\n  RCC->CFGR &= (uint32_t)0xF0FF0000;\n#endif /* STM32F10X_CL */   \n  \n  /* Reset HSEON, CSSON and PLLON bits */\n  RCC->CR &= (uint32_t)0xFEF6FFFF;\n\n  /* Reset HSEBYP bit */\n  RCC->CR &= (uint32_t)0xFFFBFFFF;\n\n  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */\n  RCC->CFGR &= (uint32_t)0xFF80FFFF;\n\n#ifdef STM32F10X_CL\n  /* Reset PLL2ON and PLL3ON bits */\n  RCC->CR &= (uint32_t)0xEBFFFFFF;\n\n  /* Disable all interrupts and clear pending bits  */\n  RCC->CIR = 0x00FF0000;\n\n  /* Reset CFGR2 register */\n  RCC->CFGR2 = 0x00000000;\n#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)\n  /* Disable all interrupts and clear pending bits  */\n  RCC->CIR = 0x009F0000;\n\n  /* Reset CFGR2 register */\n  RCC->CFGR2 = 0x00000000;      \n#else\n  /* Disable all interrupts and clear pending bits  */\n  RCC->CIR = 0x009F0000;\n#endif /* STM32F10X_CL */\n    \n#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)\n  #ifdef DATA_IN_ExtSRAM\n    SystemInit_ExtMemCtl(); \n  #endif /* DATA_IN_ExtSRAM */\n#endif \n\n  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */\n  /* Configure the Flash Latency cycles and enable prefetch buffer */\n  SetSysClock(); // 末尾调用SetSysClock()函数 \n```\n\n调用system_stm32f10x.c中SetSysClock()\n\n默认情况下定义SYSCLK_FREQ_72MHz宏, 调用SetSysClockTo72()函数\n\n```c\n/**\n  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.\n  * @param  None\n  * @retval None\n  */\nstatic void SetSysClock(void)\n{\n#ifdef SYSCLK_FREQ_HSE\n  SetSysClockToHSE();\n#elif defined SYSCLK_FREQ_24MHz\n  SetSysClockTo24();\n#elif defined SYSCLK_FREQ_36MHz\n  SetSysClockTo36();\n#elif defined SYSCLK_FREQ_48MHz\n  SetSysClockTo48();\n#elif defined SYSCLK_FREQ_56MHz\n  SetSysClockTo56();  \n#elif defined SYSCLK_FREQ_72MHz\n  SetSysClockTo72();\n#endif\n \n /* If none of the define above is enabled, the HSI is used as System clock\n    source (default after reset) */ \n}\n```\n\n在system_stm32f10x.c中宏定义, 默认宏定义SYSTEMCLK_FREQ_72MHz\n\n```c\n#if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)\n/* #define SYSCLK_FREQ_HSE    HSE_VALUE */\n #define SYSCLK_FREQ_24MHz  24000000\n#else\n/* #define SYSCLK_FREQ_HSE    HSE_VALUE */\n/* #define SYSCLK_FREQ_24MHz  24000000 */ \n/* #define SYSCLK_FREQ_36MHz  36000000 */\n/* #define SYSCLK_FREQ_48MHz  48000000 */\n/* #define SYSCLK_FREQ_56MHz  56000000 */\n#define SYSCLK_FREQ_72MHz  72000000\n#endif\n```\n\n在system_stem32f10x.c中定义SetSysClockTo72()函数\n\n```c\n#elif defined SYSCLK_FREQ_72MHz\n/**\n  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 \n  *         and PCLK1 prescalers. \n  * @note   This function should be used only after reset.\n  * @param  None\n  * @retval None\n  */\nstatic void SetSysClockTo72(void)\n{\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\n  \n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \n  /* Enable HSE */    \n  // 使能HSE\n  RCC->CR |= ((uint32_t)RCC_CR_HSEON);\n  \n \n  /* Wait till HSE is ready and if Time out is reached exit */\n  // 等待 HSE 就绪并作超时处理\n  do\n  {\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\n    StartUpCounter++;  \n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\n\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\n  {\n    HSEStatus = (uint32_t)0x01;\n  }\n  else\n  {\n    HSEStatus = (uint32_t)0x00;\n  }  \n\n  // 如果 HSE启动成功, 程序则继续往下执行\n  if (HSEStatus == (uint32_t)0x01)\n  {\n    /* Enable Prefetch Buffer */\n    // 启用 Flsh  预取缓冲区\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\n\n    /* Flash 2 wait state */\n    // flash 时延两个等待状态\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    \n\n \n    /* HCLK = SYSCLK */\n    // 72MHz\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\n      \n    /* PCLK2 = HCLK */\n    // 72MHz\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\n    \n    /* PCLK1 = HCLK */\n    // 36MHz\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\n\n/*----------------------------------------------------------------\n * 互联型芯片 F105, F107 以下代码不进行分析\n *---------------------------------------------------------------*/\n\n/**********************************************************************/\n#ifdef STM32F10X_CL\n    /* Configure PLLs ------------------------------------------------------*/\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */\n        \n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);\n  \n    /* Enable PLL2 */\n    RCC->CR |= RCC_CR_PLL2ON;\n    /* Wait till PLL2 is ready */\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\n    {\n    }\n    \n   \n    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ \n    // 锁相环配置\n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \n                            RCC_CFGR_PLLMULL9); \n#else    \n\n    /* Enable PLL */\n    // 使能 PLL\n    RCC->CR |= RCC_CR_PLLON;\n\n    /* Wait till PLL is ready */\n    //  等待 PLL 稳定\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\n    {\n    }\n    \n    /* Select PLL as system clock source */\n    // 选择 PLLCLK 作为系统时钟\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \n\n    /* Wait till PLL is used as system clock source */\n    // 等待 PLLCLK 切换为系统时钟\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\n    {\n    }\n  }\n  else\n  { /* If HSE fails to start-up, the application will have wrong clock \n         configuration. User can add here some code to deal with this error */\n    // 如果 HSE 启动失败,用户可以在这里添加处理错误的代码\n  }\n}\n#endif\n```\n\n### HSE配置系统时钟\n\n项目地址: **16-使用HSE配置系统时钟并使用MCO输出监控系统时钟**\n\n#### 在bsp_rccclkconfig.c中写入HSE的配置函数\n\n```c\n/**\n * @brief 设置系统时钟为外部高速晶振（HSE）时钟，并配置PLL倍频系数。\n * \n * @param RCC_PLLMul_x PLL倍频系数，范围为2-16。\n * @note 该函数会将RCC模块复位，并使能HSE。如果HSE启动成功，则设置FLASH预取指令使能、FLASH等待周期、AHB总线时钟、APB1总线时钟、APB2总线时钟、PLL倍频系数，并等待PLL稳定后将系统时钟设置为PLL时钟。\n *       如果HSE启动失败，则用户可以在函数中添加处理错误的代码。\n */\nvoid HSE_SetSysClk(uint32_t RCC_PLLMul_x)\n{\n    RCC_DeInit(); // RCC复位\n    ErrorStatus HSEStatus;\n    RCC_HSEConfig(RCC_HSE_ON); // 使能HSE\n    HSEStatus = RCC_WaitForHSEStartUp(); // 获取HSE启动状态\n\n    if(HSEStatus == SUCCESS)\n    {\n        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); // 使能预取指\n        FLASH_SetLatency(FLASH_ACR_LATENCY_2); // 设置等待\n        RCC_HCLKConfig(RCC_SYSCLK_Div1); //HCLK = SYSCLK = 72MHz\n        RCC_PCLK1Config(RCC_SYSCLK_Div2); //PCLK1 = HCLK / 2 = 36MHz\n        RCC_PCLK2Config(RCC_SYSCLK_Div1); //PCLK2 = HCLK / 1 = 72MHz\n        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_x); // RCC_RLLMul_x 用来超频 频率:(8*x)MHz\n        RCC_PLLCmd(ENABLE); // 使能PLL\n        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n        {\n            // 等待PLL稳定\n            ;\n        }\n        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); // 设置系统时钟为PLL时钟\n        while(RCC_GetSYSCLKSource() != 0x08)\n        {\n            // 等待设置系统时钟\n            ;\n        }\n    }\n    else\n    {\n        // 如果HSE启动失败, 用户在此添加处理错误代码\n    }\n}\n```\n\n#### 在bsp_rccclkconfig.c中编写MCO的GPIO初始化函数\n\n```c\n/**\n * @brief Configures the GPIO for MCO (Microcontroller Clock Output).\n * \n * This function initializes the GPIO pin for MCO and configures it as an alternate function push-pull output.\n * The GPIO pin used for MCO is GPIOA Pin 8.\n * \n * @param None\n * @return None\n */\nvoid MCO_GPIO_Config()\n{\n    // MCO的GPIO初始化\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n    GPIO_InitTypeDef GPIO_InitStruct;\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOA, &GPIO_InitStruct);\n}\n```\n\n#### 在bsp_rccclkconfig.h中添加函数声明\n\n```c\n#ifndef __BSP_RCCCLKCONFIG_H\n#define __BSP_RCCCLKCONFIG_H\n\n#include \"stm32f10x.h\"\n\nvoid HSE_SetSysClk(uint32_t RCC_PLLMul_x);\nvoid MCO_GPIO_Config();\n\n#endif // !__BSP_RCCCLKCONFIG_H\n```\n\n#### 在main.c中调用HSE配置系统时钟函数和MCO的GPIO初始化函数\n\n```c\n#include \"stm32f10x.h\"\n#include \"bsp_led.h\"\n#include \"bsp_rccclkconfig.h\"\n\n// 延时函数Delay()\nvoid Delay(uint32_t count)\n{\n    uint32_t i = 0;\n    for(; count != 0; count--)\n    {\n        for(i = 0; i < 0x2AFF; i++)\n        {\n            ;\n        }\n    }\n}\n\nint main(void)\n{\n    HSE_SetSysClk(RCC_PLLMul_9); // 72MHz\n    // HSE_SetSysClk(RCC_PLLMul_16); // 128MHz\n    MCO_GPIO_Config();\n    RCC_MCOConfig(RCC_MCO_SYSCLK); // 配置MCO选择系统时钟\n    LED_GPIO_Config();\n\n    while(1)\n    {\n        LED_B(OFF);\n        Delay(50); // 延时\n        LED_B(ON);\n        Delay(50); // 延时\n    }\n}\n\n```\n\n### 使用HSI配置系统时钟并用MCO监控系统时钟\n\n项目地址: **16-使用HSI配置系统时钟并用MCO监控系统时钟**\n\n#### 在bsp_rccclkconfig.c中编写HSI配置系统时钟函数\n\n```c\n/**\n * @brief 设置系统时钟为HSI，并配置PLL倍频系数\n * \n * @param RCC_PLLMul_x PLL倍频系数，范围为2-16\n * \n * @note 该函数将系统时钟设置为HSI，并根据传入的PLL倍频系数配置PLL，以实现超频功能。\n *       如果HSI启动失败，用户可以在函数的else分支中添加处理错误的代码。\n */\nvoid HSI_SetSysClk(uint32_t RCC_PLLMul_x)\n{\n    // Function implementation\n    __IO uint32_t HSIStatus = 0; // 参考固件库源码\n    RCC_DeInit(); // RCC复位\n    RCC_HSICmd(ENABLE); // 使能HSI\n    HSIStatus = RCC->CR & RCC_CR_HSIRDY; // 获取HSI启动状态, 参考固件库源码\n\n    if(HSIStatus == RCC_CR_HSIRDY)\n    {\n        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); // 使能预取指\n        FLASH_SetLatency(FLASH_ACR_LATENCY_2); // 设置等待\n        RCC_HCLKConfig(RCC_SYSCLK_Div1); //HCLK = SYSCLK = 72MHz\n        RCC_PCLK1Config(RCC_SYSCLK_Div2); //PCLK1 = HCLK / 2 = 36MHz\n        RCC_PCLK2Config(RCC_SYSCLK_Div1); //PCLK2 = HCLK / 1 = 72MHz\n        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_x); // RCC_RLLMul_x 用来超频 频率:(8*x)MHz\n        RCC_PLLCmd(ENABLE); // 使能PLL\n        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n        {\n            // 等待PLL稳定\n            ;\n        }\n        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); // 设置系统时钟为PLL时钟\n        while(RCC_GetSYSCLKSource() != 0x08)\n        {\n            // 等待设置系统时钟\n            ;\n        }\n    }\n    else\n    {\n        // 如果HSI启动失败, 用户在此添加处理错误代码\n    }\n}\n```\n\n#### 在bsp_rccclkconfig.h中加入函数声明\n\n```c\nvoid HSI_SetSysClk(uint32_t RCC_PLLMul_x);\n```\n\n#### 在main.c中调用HSI配置系统时钟函数\n\n```c\nHSI_SetSysClk(RCC_PLLMul_12); // 4*12=48MHz\nMCO_GPIO_Config();\nRCC_MCOConfig(RCC_MCO_SYSCLK); // 配置MCO选择系统时钟\nLED_GPIO_Config();\n```\n\n## 中断\n\n### STM32中断应用概览\n\n#### 中断类型\n\n- 系统异常: 体现在内核水平\n- 外部中断: 体现在外设水平\n\n#### NVIC\n\nNVIC负责管理中断\n\n在core_cm3.h中的定义  \n\n```c\n/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC\n  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)\n  @{\n */\ntypedef struct\n{\n  // 中断使能寄存器\n  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */\n       uint32_t RESERVED0[24];                                   \n\n  // 中断清除寄存器\n  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */\n       uint32_t RSERVED1[24];                                    \n\n  // 中断使能悬起寄存器\n  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */\n       uint32_t RESERVED2[24];                                   \n  \n  // 中断清除悬起寄存器 \n  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */\n       uint32_t RESERVED3[24];                                   \n\n  // 中断有效位寄存器\n  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */\n       uint32_t RESERVED4[56];                                   \n\n  // 中断优先级寄存器\n  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */\n       uint32_t RESERVED5[644];                                  \n\n  // 软件触发中断寄存器\n  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */\n}  NVIC_Type;                                               \n/*@}*/ /* end of group CMSIS_CM3_NVIC */\n```\n\n##### NVIC的优先级分组\n\n通过**SCB->AIRCR寄存器的PRIGROUP部分(即bit[10:8])进行分组**\n\n![NVIC优先级](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401140238595.png)\n\n### 中断编程的顺序\n\n1. 使能中断请求(**使能外设中断, 使能 NVIC 中断**)\n2. 配置中断优先级分组(NVIC_PriorityGroupConfig)\n3. 配置 NVIC 寄存器, 初始化NVIC_InitTypeDef\n4. 编写中断服务函数\n\n## EXTI\n\n### EXTI 输入线\n\n![EXTI 输入线](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.13.32.png)\n\n通过寄存器 AFIO_EXTICR1, 2, 3, 4配置\n\n### EXTI 框图讲解\n\n![EXTI 框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.18.42.png)\n\n#### 外部中断流程\n\n1. 通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1\n2. 通过 EXTI_SWIER 来配置软件中断, 配置后为 1\n3. 经过逻辑与门后, 进入请求挂起寄存器\n4. 通过 EXTI_PR 配置挂起\n5. 通过 EXTI_IMR 配置中断屏蔽\n6. 请求挂起寄存器的逻辑值与中断屏蔽寄存器的逻辑值做逻辑与至 NVIC 中断控制器\n\n#### 外部事件流程\n\n1. 通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1\n2. 通过 EXTI_SWIER 来配置软件中断, 配置后为 1\n3. 经过逻辑与门后, 向下跟事件屏蔽寄存器相与\n4. 通过 EXTI_EMR 配置事件屏蔽\n5. 若为 1 产生脉冲\n\n### EXTI 结构体\n\nEXTI_InitTypeDef\n\n- EXTI_Line : 用于产生中断/事件线\n- EXTI_Mode : EXTI 模式(中断/事件)\n- EXTI_Trigger : 触发(上/下/上下)\n- EXTI_LineCmd :  使能或者失能(IMR/EMR)\n\n#### EXTI 的结构体定义\n\n```c\n/** \n  * @brief  EXTI Init Structure definition  \n  */\n\ntypedef struct\n{\n  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.\n                                         This parameter can be any combination of @ref EXTI_Lines */\n   \n  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.\n                                         This parameter can be a value of @ref EXTIMode_TypeDef */\n\n  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.\n                                         This parameter can be a value of @ref EXTIMode_TypeDef */\n\n  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.\n                                         This parameter can be set either to ENABLE or DISABLE */ \n}EXTI_InitTypeDef;\n\n/**\n  * @}\n  */\n```\n\n##### EXTI_Line 的定义\n\n```c\n/** @defgroup EXTI_Lines \n  * @{\n  */\n\n#define EXTI_Line0       ((uint32_t)0x00001)  /*!< External interrupt line 0 */\n#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */\n#define EXTI_Line2       ((uint32_t)0x00004)  /*!< External interrupt line 2 */\n#define EXTI_Line3       ((uint32_t)0x00008)  /*!< External interrupt line 3 */\n#define EXTI_Line4       ((uint32_t)0x00010)  /*!< External interrupt line 4 */\n#define EXTI_Line5       ((uint32_t)0x00020)  /*!< External interrupt line 5 */\n#define EXTI_Line6       ((uint32_t)0x00040)  /*!< External interrupt line 6 */\n#define EXTI_Line7       ((uint32_t)0x00080)  /*!< External interrupt line 7 */\n#define EXTI_Line8       ((uint32_t)0x00100)  /*!< External interrupt line 8 */\n#define EXTI_Line9       ((uint32_t)0x00200)  /*!< External interrupt line 9 */\n#define EXTI_Line10      ((uint32_t)0x00400)  /*!< External interrupt line 10 */\n#define EXTI_Line11      ((uint32_t)0x00800)  /*!< External interrupt line 11 */\n#define EXTI_Line12      ((uint32_t)0x01000)  /*!< External interrupt line 12 */\n#define EXTI_Line13      ((uint32_t)0x02000)  /*!< External interrupt line 13 */\n#define EXTI_Line14      ((uint32_t)0x04000)  /*!< External interrupt line 14 */\n#define EXTI_Line15      ((uint32_t)0x08000)  /*!< External interrupt line 15 */\n#define EXTI_Line16      ((uint32_t)0x10000)  /*!< External interrupt line 16 Connected to the PVD Output */\n#define EXTI_Line17      ((uint32_t)0x20000)  /*!< External interrupt line 17 Connected to the RTC Alarm event */\n#define EXTI_Line18      ((uint32_t)0x40000)  /*!< External interrupt line 18 Connected to the USB Device/USB OTG FS\n                                                   Wakeup from suspend event */                                    \n#define EXTI_Line19      ((uint32_t)0x80000)  /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */\n```\n\n##### EXTI_Mode 的定义\n\n```c\n/** \n  * @brief  EXTI mode enumeration  \n  */\n\ntypedef enum\n{\n  EXTI_Mode_Interrupt = 0x00,\n  EXTI_Mode_Event = 0x04\n}EXTIMode_TypeDef;\n\n#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))\n```\n\n##### EXTI_Trigger 的定义\n\n```c\n/** \n  * @brief  EXTI Trigger enumeration  \n  */\n\ntypedef enum\n{\n  EXTI_Trigger_Rising = 0x08,\n  EXTI_Trigger_Falling = 0x0C,  \n  EXTI_Trigger_Rising_Falling = 0x10\n}EXTITrigger_TypeDef;\n\n#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \\\n                                  ((TRIGGER) == EXTI_Trigger_Falling) || \\\n                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))\n```\n\n### GPIO 作为 EXTI 输入线的配置\n\n在 stm32f10x_gpio.c 中, 使用 GPIO_EXTILineConfig 函数进行配置\n\n```c\n/**\n  * @brief  Selects the GPIO pin used as EXTI Line.\n  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.\n  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).\n  * @param  GPIO_PinSource: specifies the EXTI line to be configured.\n  *   This parameter can be GPIO_PinSourcex where x can be (0..15).\n  * @retval None\n  */\nvoid GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)\n{\n  uint32_t tmp = 0x00;\n  /* Check the parameters */\n  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));\n  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));\n  \n  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));\n  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;\n  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));\n}\n```\n\n### EXTI中断实验\n\n项目地址: **18-EXTI**\n\n**项目需求:**\n\n1. PA0 连接到 EXTI 用于产生中断, PA0 的电平变化通过按键来控制\n2. 产生一次中断, LED 反转一次\n\n#### 在bsp_exti.c中初始化要连接到EXTI的GPIO\n\n```c\n// 初始化 Key1(PA0)\nRCC_APB2PeriphClockCmd(KEY1_INT_GPIO_CLK, ENABLE);\nGPIO_InitStruct.GPIO_Pin = KEY1_INT_GPIO_PIN;\nGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\nGPIO_Init(KEY1_INT_GPIO_PORT, &GPIO_InitStruct);\n```\n\n#### 在bsp_exti.c中初始化EXTI用于产生中断/事件\n\n```c\nRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\nGPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); // 选择输入线\nEXTI_InitStruct.EXTI_Line = EXTI_Line0;                     // 选择EXTI线路\nEXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            // 选择中断模式\nEXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;         // 选择触发模式\nEXTI_InitStruct.EXTI_LineCmd = ENABLE;                          // 使能EXTI线路\nEXTI_Init(&EXTI_InitStruct);\n```\n\n#### 在bsp_exti.c中初始化NVIC, 用于处理中断\n\n```c\nNVIC_InitTypeDef NVIC_InitStruct;\n\nNVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); // 配置中断优先级分组\n\nNVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn; // 选择中断源\nNVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; // 抢占优先级\nNVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; // 子优先级\nNVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; // 使能中断\nNVIC_Init(&NVIC_InitStruct);\n```\n\n#### 在stm32f10x_it.c中编写中断服务函数\n\n```c\n/**\n * @brief EXTI0_IRQHandler: Interrupt handler for EXTI Line 0\n *\n * This function is the interrupt handler for EXTI Line 0. It toggles the state of the blue LED.\n * It checks the interrupt status of EXTI Line 0 and clears the interrupt pending bit.\n */\nvoid EXTI0_IRQHandler(void)\n{\n  if(EXTI_GetITStatus(EXTI_Line0) != RESET) // 判断中断位\n  {\n    LED_B_TOGGLE;\n  }\n  EXTI_ClearITPendingBit(EXTI_Line0); // 清除中断标志位\n}\n```\n\n#### 在bsp_led.h中编写电平反转函数\n\n```c\n#define LED_B_TOGGLE {LED_B_GPIO_PORT->ODR ^= LED_B_GPIO_PIN;}\n```\n\n### 补充: 使能AFIO时钟\n\n在STM32微控制器系列中，使用外部中断（EXTI）时需要开启AFIO（Alternate Function IO）时钟的原因与STM32的硬件设计和引脚复用功能有关。\n\n#### AFIO的作用\n\n1. **引脚复用**：STM32的GPIO（通用输入输出）引脚具有多功能性。一个物理引脚可以用作普通的I/O，也可以被配置为特殊功能，如USART、SPI、I2C通信或外部中断（EXTI）等。AFIO（Alternate Function IO）模块负责管理这些引脚的复用功能。\n2. **EXTI配置**：在STM32中，外部中断线（EXTI）可以映射到不同的GPIO引脚上。AFIO模块提供了这种映射功能。例如，如果你想将EXTI0配置为由PA0、PB0、PC0等其中一个引脚触发，就需要通过AFIO模块来设置这种映射。\n\n#### 开启AFIO时钟的原因\n\n**由于AFIO模块负责处理引脚的复用功能，包括EXTI的引脚映射，因此在使用EXTI功能之前，必须确保AFIO模块的时钟是使能的**如果没有使能AFIO时钟，对AFIO寄存器的任何配置操作都不会生效，这意味着EXTI线路无法正确地映射到相应的GPIO引脚上，从而导致外部中断功能无法正常工作。\n\n#### AFIO的实际操作\n\n在STM32的标准固件库或HAL（硬件抽象层）库中，通常会看到类似以下的代码片段，用于使能AFIO时钟：\n\n```c\nRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);\n```\n\n或在使用HAL库时：\n\n```c\n__HAL_RCC_AFIO_CLK_ENABLE();\n```\n\n这些函数调用确保了AFIO模块的时钟被使能，从而使得外部中断的相关配置（如引脚映射）能够正确执行。\n\n#### AFIO的总结\n\n开启AFIO时钟是使用STM32的EXTI功能的必要步骤，因为AFIO模块控制着GPIO引脚的复用功能，包括将外部中断线路映射到特定的GPIO引脚。未使能AFIO时钟可能导致外部中断配置无效，进而影响整个中断处理机制的正常工作。\n\n## SysTick\n\n### SysTick简介\n\nSysTick: 系统定时器, **24位, 只能递减, 存在于内核中**, 嵌套在NVIC中, 所有的Cotex-M内核的单片机都具有这个定时器.\n\n### SysTick 功能框图\n\n![框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170017620.png)\n\n重装载寄存器把值写入递减计数器, 可通过STK_VAL实时查询其中的值, 递减计数器从reload值开始递减, 减为0后可产生中断并且置位COUNTFLAG标志位, 置位后从reload获取值重复以上操作\n\n### SysTick 寄存器描述\n\n![SysTick 寄存器描述](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170023320.png)\n\n### SysTick 定时时间计算\n\n需要计算的参数\n\n![计算参数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025237.png)\n\n计算过程\n\n![计算过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025314.png)\n\n- Clk = 72M时\n- reload = 72, t = 1us\n- reload = 72000, t = 1ms\n\n### 补充: SysTick 介绍\n\nSysTick（System Tick Timer）是ARM Cortex-M微控制器内核的一个内置组件，用于提供一个简单但高效的系统定时器。这个定时器通常用于实现操作系统的节拍（tick），也可以用于简单的延时功能。\n\n#### SysTick的主要特点\n\n1. 24位递减计数器：SysTick包含一个24位的递减计数器，当计数器值递减到零时，定时器溢出并触发一个中断。\n2. 可编程重载值：可以设置计数器的重载值，这决定了定时器的溢出时间间隔。\n3. 可配置的时钟源：SysTick定时器可以配置为使用内核时钟或外部时钟（通常是内核时钟的一半）。\n4. 自动重载：在计数到零时，计数器会自动重新加载预设的重载值，从而实现周期性定时。\n5. 中断功能：当计数器达到零时，SysTick定时器可以产生一个中断。这个中断可以用于各种定时任务，如操作系统的任务调度。\n\n#### SysTick的应用场景\n\n1. 操作系统节拍：在实时操作系统（RTOS）中，SysTick常用于生成操作系统的节拍，这对于任务调度和时间管理非常重要。\n2. 延时功能：在不需要RTOS的简单应用中，SysTick可用于生成精确的延时，例如在两个事件之间等待固定的时间。\n3. 时间基准：SysTick还可以作为程序中的时间基准，用于测量时间间隔或产生定时事件。\n\n#### SysTick的配置和使用\n\n在使用SysTick时，一般需要进行以下配置：\n\n1. 设置重载值：根据所需的定时周期和时钟源频率设置重载值。\n2. 选择时钟源：选择使用内核时钟还是外部时钟作为SysTick的时钟源。\n3. 启用中断（可选）：如果需要在定时器溢出时执行特定操作，可以启\n   用SysTick中断。\n4. 启动定时器：启用SysTick定时器开始计数\n\n#### SysTick的编程示例\n\n在STM32等ARM Cortex-M微控制器上，SysTick的配置和使用通常涉及直接操作其控制和状态寄存器。以下是一个简单的示例：\n\n```c\nSysTick_Config(SystemCoreClock / 1000);  // 配置SysTick产生\n```\n\n### SysTick 源码分析\n\nSysTick_Type定义在core_cm3.h中\n\n```c\n/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick\n  memory mapped structure for SysTick\n  @{\n */\ntypedef struct\n{\n  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */\n  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */\n  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */\n  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */\n} SysTick_Type;\n```\n\nSysTick_Config函数在core_cm3.h中定义\n\n```c\n/**\n * @brief  Initialize and start the SysTick counter and its interrupt.\n *\n * @param   ticks   number of ticks between two interrupts\n * @return  1 = failed, 0 = successful\n *\n * Initialise the system tick timer and its interrupt and start the\n * system tick timer / counter in free running mode to generate \n * periodical interrupts.\n */\nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)\n{ \n  // 判断ticks的值是否大于2^24, 若大于则违法\n  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */\n                                                               \n  // 初始化reaload寄存器的值\n  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */\n\n  // 配置中断优先级, 配置为15, 默认为最低的优先级\n  /*-------------------------------------------------------------\n   * 注: \n   * 内核优先级的判断方式:\n   * 将内核外设的中断优先级的四个位按照外设的中断优先级进行分组\n   * 分组后可判断内核的抢占优先级和响应优先级\n   * 即人为分出抢占和响应优先级\n   * \n   * 例:\n   * 这里SysTick的中断优先级为15, 二进制为1111\n   * 若分组为2位抢占, 2位响应\n   * 则SysTick的抢占优先级为11即3, 响应优先级为11即3\n   * 若分组为1位抢占, 3位响应\n   * 则SysTick的抢占优先级为1即1, 响应优先级为111即7\n   * 通过该方法可以比较内核优先级与外设的优先级谁更高\n   * ----------------------------------------------------------*/\n  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */\n\n  // 初始化counter的值为0\n  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */\n\n  // 配置 SysTick的时钟为 72M\n  // 使能中断\n  // 使能 SysTick \n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | \n                   SysTick_CTRL_TICKINT_Msk   | \n                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */\n  return (0);                                                  /* Function successful */\n}\n```\n\n### SysTick 实验\n\n项目地址: **19-SysTick**\n\n实验要求:\n\n1. 编写一个微妙延时函数\n2. 编写一个毫秒延时函数\n\n#### 在bsp_systick.c中编写微妙延时函数\n\n```c\n/**\n * @brief 延时指定的微秒数\n * @param us 延时的微秒数\n * @retval None\n */\nvoid SysTick_Delay_us(uint32_t us)\n{\n    SysTick_Config(SystemCoreClock / 1000000); // reload 设置为 72, t = 1us\n    \n    for(int i = 0; i < us; i++)\n    {\n        while(!(SysTick->CTRL & (1 << 16)))\n        {\n            ; // 等待CTRL的Bit16置1\n        }\n    }\n\n    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk; // 状态位清除\n}\n```\n\n#### 在bsp_systick.c中编写毫秒延时函数\n\n```c\n/**\n * @brief 延时指定的毫秒数\n * @param ms 延时的毫秒数\n * @return 无\n */\nvoid SysTick_Delay_ms(uint32_t ms)\n{\n    SysTick_Config(SystemCoreClock / 1000); // reload 设置为 72000, t = 1ms\n    \n    for(int i = 0; i < ms; i++)\n    {\n        while(!(SysTick->CTRL & (1 << 16)))\n        {\n            ; // 等待CTRL的Bit16置1\n        }\n    }\n\n    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk; // 状态位清除\n}\n```\n\n#### 在bsp_systick.h中引用库文件和进行函数声明\n\n```c\n#ifndef __BSP_SYSTICK_H\n#define __BSP_SYSTICK_H\n\n#include \"stm32f10x.h\"\n#include \"core_cm3.h\"\n\nvoid SysTick_Delay_ms(uint32_t ms);\nvoid SysTick_Delay_us(uint32_t us);\n\n#endif // !__BSP_SYSTICK_H\n\n```\n\n#### 在main.c中调用延时函数,实现LED闪烁\n\n```c\n/**\n * @brief Main function of the program.\n * \n * This function initializes the LED GPIO and enters an infinite loop. \n * In each iteration of the loop, it turns off the blue LED, delays for 0.5 seconds,\n * turns on the blue LED, and delays for 0.5 seconds again.\n * \n * @return int The exit status of the program.\n */\nint main(void)\n{\n    LED_GPIO_Config(); // Initialize the LED GPIO\n\n    while(1)\n    {\n        LED_B(OFF); // Turn off the blue LED\n        SysTick_Delay_ms(500); // Delay for 0.5 seconds\n        LED_B(ON); // Turn on the blue LED\n        SysTick_Delay_us(500000); // Delay for 0.5 seconds\n    }\n}\n\n```\n\n## 通信的基本概念\n\n### 串行和并行通信\n\n![串行和并行通信](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171542012.png)\n\n- 串行协议: USART, I2C, SPI, W500, CAN, LIN\n- 并行协议: FSMC, SDIO\n\n![对比](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171546066.png)\n\n### 全双工, 半双工和单工\n\n![全双工,半双工和单工](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171548657.png)\n\n### 同步与异步\n\n同步传输通过时钟信号进行同步, 保证数据传输的准确性\n\n![同步](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171550768.png)\n\n异步传输通过加入辅助的标识符, 保证数据传输的准确性\n\n![异步](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171552733.png)\n\n#### 同步与异步的区别\n\n![区别](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171554763.png)\n\n### 通信的速率\n\n![通信的速率](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171555519.png)\n\n当用一个二进制位表示一个码元时, 比特率和波特率相等\n\n## USART-串口通信\n\n### 串口通信协议简介\n\n![USART](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610065.png)\n\n#### 物理层的常用标准\n\n![USART](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610887.png)\n\n##### 232和TTL电平区别\n\n![USART](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171611637.png)\n\n- TTL: 从芯片出来的基本是TTL电平\n- 232: 负逻辑, 压差大\n\n###### 232通信通讯结构图\n\n![232](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171631235.png)\n\nDB9接口图\n\n![DB9接口](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171634288.png)\n\n###### USB转串口通讯结构图\n\n![USB转串口](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171644660.png)\n\n##### 串口到串口通讯结构图\n\n![串口到串口](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171655718.png)\n\n#### 串口数据包的组成\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171658813.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171659831.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171702232.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703446.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703050.png)\n\n![串口数据包](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171704956.png)\n\n### STM32串口功能框图讲解\n\n#### 引脚部分讲解\n\n![STM32串口功能框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708669.png)\n\n![STM32串口功能框图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708578.png)\n\n##### 引脚对应\n\n![引脚对应](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171710068.png)\n\n#### 数据寄存器部分\n\n![数据寄存器部分](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171723621.png)\n\n##### 数据格式\n\n![数据格式](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171725627.png)\n\n###### USART_CR1的bit12 M控制字长\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727509.png)\n\n###### USART_CR2的bit[13:12] STOP控制停止位的位数\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727238.png)\n\n###### USART_CR1的bit10(PSE), bit9(PS)来使能校验和选择校验模式\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171730822.png)\n\n###### USART_CR1的bit8(PEIE)来使能中断\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171731175.png)\n\n###### USART_SR的bit0(PE)来检测校验错误\n\n![寄存器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171732400.png)\n\n#### 发送数据部分\n\n![发送数据](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171739676.png)\n\n1. 先将USART_CR1的UE位置1(*使能USART模块*), 再将USART_CR1的TE位置1(*使能发送*)\n2. 数据从CPU或DMA中写入发送数据寄存器(TDR), TDR发送完毕后, USART_SR的TXE位置1(*数据已经被转移到移位寄存器中*)\n3. 发送移位寄存器发送完毕后, USART_SR的TC位置1(*表示发送完成*)\n\n#### 接收数据部分\n\n![接收数据部分](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171900970.png)\n\n1. 先将USART_CR1的UE位置1(*使能USART模块*), 再将USART_CR1的RE位置1(*使能接收*)\n2. 数据从RX到接收移位寄存器到接收数据寄存器(RDR), 接收完毕后, USART_SR的RXNE位置1(*收到数据, 可以读出*)\n\n#### 波特率设置\n\n##### 使用USART_BRR进行配置\n\n![USART_BRR](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171906798.png)\n\n##### 波特率的计算公式\n\n![波特率的计算公式](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171909589.png)\n\n- APB2时钟: 72MHz, 挂载USART1\n- APB1时钟: 36MHz, 挂载USART2, 3, 4, 5\n\n![波特率](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171910703.png)\n\n### 串口初始化结构体和固件库讲解\n\n#### 串口初始化结构体\n\n在stm32f10x_usart.h中定义串口初始化结构体(异步)\n\n```c\n/** \n  * @brief  USART Init Structure definition  \n  */ \n  \ntypedef struct\n{\n  // 设置波特率\n  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.\n                                           The baud rate is computed using the following formula:\n                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))\n                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */\n\n  // 设置字长\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_WordLength_8b                  ((uint16_t)0x0000)\n   * #define USART_WordLength_9b                  ((uint16_t)0x1000)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.\n                                           This parameter can be a value of @ref USART_Word_Length */\n\n  // 设置停止位\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_StopBits_1                     ((uint16_t)0x0000)\n   * #define USART_StopBits_0_5                   ((uint16_t)0x1000)\n   * #define USART_StopBits_2                     ((uint16_t)0x2000)\n   * #define USART_StopBits_1_5                   ((uint16_t)0x3000)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.\n                                           This parameter can be a value of @ref USART_Stop_Bits */\n\n  // 设置校验\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_Parity_No                      ((uint16_t)0x0000)\n   * #define USART_Parity_Even                    ((uint16_t)0x0400)\n   * #define USART_Parity_Odd                     ((uint16_t)0x0600)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_Parity;              /*!< Specifies the parity mode.\n                                           This parameter can be a value of @ref USART_Parity\n                                           @note When parity is enabled, the computed parity is inserted\n                                                 at the MSB position of the transmitted data (9th bit when\n                                                 the word length is set to 9 data bits; 8th bit when the\n                                                 word length is set to 8 data bits). */\n \n  // 设置模式\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_Mode_Rx                        ((uint16_t)0x0004)\n   * #define USART_Mode_Tx                        ((uint16_t)0x0008)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.\n                                           This parameter can be a value of @ref USART_Mode */\n\n  // 设置硬件控制流\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)\n   * #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)\n   * #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)\n   * #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled\n                                           or disabled.\n                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */\n} USART_InitTypeDef;\n```\n\n在stm32f10x_usart.h中定义串口初始化结构体(同步)\n\n```c\n/** \n  * @brief  USART Clock Init Structure definition  \n  */ \n  \ntypedef struct\n{\n\n  // 设置使能时钟\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_Clock_Disable                  ((uint16_t)0x0000)\n   * #define USART_Clock_Enable                   ((uint16_t)0x0800)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.\n                               This parameter can be a value of @ref USART_Clock */\n\n  // 设置时钟的极性, 即总线空闲时CK引脚保持低电平还是高电平\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_CPOL_Low                       ((uint16_t)0x0000)\n   * #define USART_CPOL_High                      ((uint16_t)0x0400)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.\n                               This parameter can be a value of @ref USART_Clock_Polarity */\n\n  // 设置时钟的相位, 即数据采样的时机为第一个边沿还是第二个边沿\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_CPHA_1Edge                     ((uint16_t)0x0000)\n   * #define USART_CPHA_2Edge                     ((uint16_t)0x0200)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.\n                               This parameter can be a value of @ref USART_Clock_Phase */\n\n  // 设置时钟的最后一个数据位的时钟脉冲是否输出到SCLK引脚\n  /*-----------------------------------------------------------------------------\n   * 参数如下:\n   * #define USART_LastBit_Disable                ((uint16_t)0x0000)\n   * #define USART_LastBit_Enable                 ((uint16_t)0x0100)\n   * ---------------------------------------------------------------------------*/\n  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted\n                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.\n                               This parameter can be a value of @ref USART_Last_Bit */\n} USART_ClockInitTypeDef;\n```\n\n#### 串口库函数\n\n- **串口初始化函数**: void USART_Init(USART_TypeDef*USARTx, USART_InitTypeDef* USART_InitStruct);\n- **中断配置函数**: void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);\n- **串口使能函数**: void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);\n- **数据发送函数**: void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);\n- **数据接收函数**: void USART_ReceiveData(USART_TypeDef* USARTx);\n- **中断状态位获取函数**: ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);\n\n### USB转串口的硬件原理图\n\n![硬件原理图](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401172002602.png)\n\n### 串口GPIO汇总\n\n![串口GPIO](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220859886.png)\n\n### 补充: 外设的GPIO配置\n\n在STM32F10x参考手册中的8.1.11节可找到外设的GPIO配置, 其中关于USART部分的GPIO配置如下图\n\n![USART的GPIO配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220904826.png)\n\n### 配置串口助手\n\n本项目使用的串口助手: 野火多功能调试助手V1.0.2.9\n\n串口配置如下图(*串口配置参数与串口的初始化配置有关, 该配置符合下文代码的初始化*)\n\n![串口助手配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401250242370.png)\n\n### USART接收和发送实验\n\n项目地址: **21-USART-接收和发送**\n\n**实验需求**: 单片机给电脑发送数据, 电脑上位机把数据打印出来; 电脑上位机给单片机发数据, 单片机接收到数据之后立马发回给电脑, 并打印出来.\n\n#### 在bsp_usart.h中进行串口的宏定义, 并使用条件编译来选择串口\n\n```c\n/** \n  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏\n  * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线\n  * 2-修改GPIO的宏\n  */\n\n // 通过条件编译选择串口, 使用的串口置1，其余置0\n #define DEBUG_USART1 1\n #define DEBUG_USART2 0\n #define DEBUG_USART3 0\n #define DEBUG_USART4 0\n #define DEBUG_USART5 0\n \n#if DEBUG_USART1\n// 串口1-USART1\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n    \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define  DEBUG_USART_IRQ                USART1_IRQn\n#define  DEBUG_USART_IRQHandler         USART1_IRQHandler\n\n#elif DEBUG_USART2\n// 串口2-USART2\n#define  DEBUG_USARTx                   USART2\n#define  DEBUG_USART_CLK                RCC_APB1Periph_USART2\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3\n\n#define  DEBUG_USART_IRQ                USART2_IRQn\n#define  DEBUG_USART_IRQHandler         USART2_IRQHandler\n\n#elif DEBUG_USART3\n// 串口3-USART3\n#define  DEBUG_USARTx                   USART3\n#define  DEBUG_USART_CLK                RCC_APB1Periph_USART3\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOB   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOB\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n#define  DEBUG_USART_IRQ                USART3_IRQn\n#define  DEBUG_USART_IRQHandler         USART3_IRQHandler\n\n#elif DEBUG_USART4\n//串口4-UART4\n#define  DEBUG_USARTx                   UART4\n#define  DEBUG_USART_CLK                RCC_APB1Periph_UART4\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOC\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11\n\n#define  DEBUG_USART_IRQ                UART4_IRQn\n#define  DEBUG_USART_IRQHandler         UART4_IRQHandler\n\n#elif DEBUG_UART5\n// 串口5-UART5\n#define  DEBUG_USARTx                   UART5\n#define  DEBUG_USART_CLK                RCC_APB1Periph_UART5\n#define  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n   \n#define  DEBUG_USART_TX_GPIO_PORT       GPIOC   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOD\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2\n\n#define  DEBUG_USART_IRQ                UART5_IRQn\n#define  DEBUG_USART_IRQHandler         UART5_IRQHandler\n\n#endif\n```\n\n#### 在bsp_usart.c中编写usart的初始化函数\n\n```c\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n    \n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n    \n     // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = \n    USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 串口中断优先级配置\n    NVIC_Configuration();\n    \n    // 使能串口接收中断\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE); \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);     \n}\n```\n\n#### 在bsp_usart.c中编写串口中断优先级配置函数\n\n```c\n /**\n  * @brief  配置嵌套向量中断控制器NVIC\n  * @param  无\n  * @retval 无\n  */\nstatic void NVIC_Configuration(void)\n{\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  /* 嵌套向量中断控制器组选择 */\n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  /* 配置USART为中断源 */\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  /* 抢断优先级*/\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;\n  /* 子优先级 */\n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  /* 使能中断 */\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  /* 初始化配置NVIC */\n  NVIC_Init(&NVIC_InitStructure);\n}\n```\n\n#### 在bsp_usart.c中编写发送一个字节到串口的函数\n\n```c\n/**\n * @brief 发送一个字节到指定的USART外设\n * \n * @param pUSARTx USART外设指针\n * @param ch 要发送的字节\n */\nvoid Usart_SendByte(USART_TypeDef* pUSARTx, uint8_t ch)\n{\n    // 发送一个字节\n    USART_SendData(pUSARTx, ch);\n    \n    // 等待发送数据寄存器为空\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)\n    {\n     ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写发送两个字节到串口的函数\n\n```c\n/**\n * @brief 发送两个字节的数据\n * \n * @param pUSARTx USART外设指针\n * @param ch 要发送的16位数据\n */\nvoid Usart_SendHalfWord(USART_TypeDef* pUSARTx, uint16_t ch)\n{\n    uint8_t tmp_h, tmp_l;\n\n    tmp_h = (ch & 0xFF00) >> 8; // 取出高八位\n    tmp_l = (ch & 0xFF) >> 0; // 取出低八位\n\n    USART_SendData(pUSARTx, tmp_h); // 发送高八位\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)\n    {\n        ;\n    }\n\n    USART_SendData(pUSARTx, tmp_l); // 发送低八位\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)\n    {\n        ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写发送数组的函数\n\n```c\n/**\n * @brief Sends an array of bytes over USART.\n * \n * This function sends an array of bytes over the specified USART peripheral.\n * \n * @param pUSARTx The USART peripheral to use.\n * @param array Pointer to the array of bytes to send.\n * @param num The number of bytes to send.\n */\nvoid Usart_SendArray(USART_TypeDef* pUSARTx, uint8_t* array, uint16_t num)\n{\n    for(uint16_t i = 0; i < num; i++)\n    {\n     Usart_SendByte(pUSARTx, array[i]);\n    }\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)\n    {\n     ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写发送字符串的函数\n\n```c\n/**\n * @brief 发送字符串到USART外设\n * \n * @param pUSARTx USART外设指针\n * @param str 要发送的字符串\n */\nvoid Usart_SendString(USART_TypeDef* pUSARTx, uint8_t* str)\n{\n    // 发送数据\n    uint8_t i = 0;\n    do\n    {\n     Usart_SendByte(pUSARTx, *(str + i));\n     i++;\n    } while (*(str + i) != '\\0');\n\n    // 等待发送完成\n    while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)\n    {\n     ;\n    }\n}\n```\n\n#### 在bsp_usart.c中编写重定向标准输出输入函数, 使得串口可使用scanf printf等函数\n\n```c\n// 重定向c库函数printf, putchar到串口，重定向后可使用printf, putchar函数\n/**\n * @brief 重定向标准输出函数\n * @param ch 要发送的字符\n * @param f 文件指针\n * @retval 发送的字符\n */\nint fputc(int ch, FILE* f)\n{\n    USART_SendData(DEBUG_USARTx, (uint8_t)ch);\n\n    while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET)\n    {\n     ;\n    }\n\n    return (ch);\n}\n\n/**\n * @brief 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数\n * \n * @param f 文件指针\n * @return int 从串口接收到的数据\n */\nint fgetc(FILE *f)\n{\n    /* 等待串口输入数据 */\n    while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);\n\n    return (int)USART_ReceiveData(DEBUG_USARTx);\n}\n\n```\n\n#### 在main.c函数中进行测试\n\n```c\n#include \"stm32f10x.h\"\n#include \"bsp_led.h\"\n#include \"bsp_usart.h\"\n\nint main(void)\n{\n    USART_Config(); // 初始化USART\n\n    // 发送1字节数据\n    Usart_SendByte(DEBUG_USARTx, 'a');\n    Usart_SendByte(DEBUG_USARTx, '\\n');\n\n    // 发送2字节数据\n    Usart_SendHalfWord(DEBUG_USARTx, 0xFF56);\n\n    // 发送数组\n    Usart_SendArray(DEBUG_USARTx, (uint8_t*)\"Hello World!\", 11);\n    uint8_t array[11] = {\"Hello World!\"};\n    Usart_SendArray(DEBUG_USARTx, array, 11);\n\n    // 发送字符串\n    Usart_SendString(DEBUG_USARTx, \"\\nString: Hello World\\n\");\n\n    // 重定向printf函数\n    printf(\"printf: Hello World\\n\");\n\n    // 重定向putchar函数\n    putchar('p');\n    putchar('u');\n    putchar('t');\n    putchar('c');\n    putchar('h');\n    putchar('a');\n    putchar('r');\n    putchar('\\n');\n    \n    while(1)\n    {\n        ;\n    }\n}\n\n```\n\n#### 在stm32f10x_it.c中编写中断服务函数实现串口数据的接收并发送\n\n```c\n/**\n * @brief Interrupt handler for the DEBUG_USART.\n *\n * This function is called when there is a receive interrupt from the DEBUG_USART.\n * It receives data from the DEBUG_USART and sends it back.\n */\nvoid DEBUG_USART_IRQHandler(void)\n{\n  uint8_t ucTemp;\n\n  if(USART_GetITStatus(DEBUG_USARTx, USART_IT_RXNE) != RESET)\n  {\n    ucTemp = USART_ReceiveData(DEBUG_USARTx); // Receive data into ucTemp\n    USART_SendData(DEBUG_USARTx, ucTemp); // Send data\n  }\n}\n```\n\n### 补充: 通过重写fputc函数重定向C库函数printf到串口\n\n通过重写 fputc 函数可以实现重定向 printf 到串口的效果。这是因为 printf 函数实际上是通过 C 标准库中的输出函数 fputc 来将字符一个个地发送到输出设备的。当你重写了 fputc 函数，实际上就改变了字符的输出方式，使得字符被发送到你所定义的输出设备，比如串口。\n\n下面是一个简单的示例，演示了如何通过重写 fputc 函数来重定向 printf 到串口。这里假设你已经在系统中初始化了串口的硬件。\n\n```c\n#include <stdio.h>\n\n// 串口初始化函数，假设已经在系统中实现\nvoid initSerialPort() {\n    // 串口初始化的相关代码\n}\n\n// 重定向标准输出函数\nint fputc(int ch, FILE *f) {\n    // 将字符发送到串口\n    // 你需要在这里添加实际的串口发送代码\n    // 例如：sendCharacterToSerialPort(ch);\n    \n    return ch;\n}\n\nint main() {\n    // 初始化串口\n    initSerialPort();\n\n    // 在这之后，调用printf将输出信息发送到串口\n    printf(\"Hello, Serial Port!\\n\");\n\n    // 其他代码...\n\n    return 0;\n}\n\n```\n\n在这个示例中，我们重写了 fputc 函数，使其将字符发送到串口。当 printf 调用 fputc 函数时，字符就会被发送到串口。这样就实现了将 printf 输出重定向到串口的效果。\n\n需要注意的是，具体的串口发送函数实现（比如 sendCharacterToSerialPort）需要根据你的具体硬件和系统来编写。这个示例只是演示了重定向的基本原理。\n\n### USART控制RGB灯实验\n\n项目地址: **21-USART-控制RGB灯**\n\n**实验需求**: 电脑给单片机发命令, 用于控制开发板上的RGB灯.\n\n#### 在bsp_led.h中定义RGB灯的宏\n\n```c\n#ifndef __LED_H\n#define __LED_H\n\n\n#include \"stm32f10x.h\"\n\n\n/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */\n// R-红色\n#define LED1_GPIO_PORT     GPIOB                 /* GPIO端口 */\n#define LED1_GPIO_CLK      RCC_APB2Periph_GPIOB  /* GPIO端口时钟 */\n#define LED1_GPIO_PIN  GPIO_Pin_5           /* 连接到SCL时钟线的GPIO */\n\n// G-绿色\n#define LED2_GPIO_PORT     GPIOB                 /* GPIO端口 */\n#define LED2_GPIO_CLK      RCC_APB2Periph_GPIOB  /* GPIO端口时钟 */\n#define LED2_GPIO_PIN  GPIO_Pin_0           /* 连接到SCL时钟线的GPIO */\n\n// B-蓝色\n#define LED3_GPIO_PORT     GPIOB                 /* GPIO端口 */\n#define LED3_GPIO_CLK      RCC_APB2Periph_GPIOB  /* GPIO端口时钟 */\n#define LED3_GPIO_PIN  GPIO_Pin_1           /* 连接到SCL时钟线的GPIO */\n\n\n/** the macro definition to trigger the led on or off \n  * 1 - off\n  *0 - on\n  */\n#define ON  0\n#define OFF 1\n\n/* 使用标准的固件库控制IO*/\n#define LED1(a) if (a) \\\n     GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\\\n     else  \\\n     GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)\n\n#define LED2(a) if (a) \\\n     GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\\\n     else  \\\n     GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)\n\n#define LED3(a) if (a) \\\n     GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);\\\n     else  \\\n     GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)\n\n\n/* 直接操作寄存器的方法控制IO */\n#define digitalHi(p,i)   {p->BSRR=i;}  //输出为高电平  \n#define digitalLo(p,i)   {p->BRR=i;}  //输出低电平\n#define digitalToggle(p,i) {p->ODR ^=i;} //输出反转状态\n\n\n/* 定义控制IO的宏 */\n#define LED1_TOGGLE   digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)\n#define LED1_OFF     digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)\n#define LED1_ON      digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)\n\n#define LED2_TOGGLE   digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)\n#define LED2_OFF     digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)\n#define LED2_ON      digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)\n\n#define LED3_TOGGLE   digitalToggle(LED3_GPIO_PORT,LED3_GPIO_PIN)\n#define LED3_OFF     digitalHi(LED3_GPIO_PORT,LED3_GPIO_PIN)\n#define LED3_ON      digitalLo(LED3_GPIO_PORT,LED3_GPIO_PIN)\n\n/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */\n\n//红\n#define LED_RED  \\\n     LED1_ON;\\\n     LED2_OFF\\\n     LED3_OFF\n\n//绿\n#define LED_GREEN  \\\n     LED1_OFF;\\\n     LED2_ON\\\n     LED3_OFF\n\n//蓝\n#define LED_BLUE \\\n     LED1_OFF;\\\n     LED2_OFF\\\n     LED3_ON\n\n     \n//黄(红+绿)     \n#define LED_YELLOW \\\n     LED1_ON;\\\n     LED2_ON\\\n     LED3_OFF\n//紫(红+蓝)\n#define LED_PURPLE \\\n     LED1_ON;\\\n     LED2_OFF\\\n     LED3_ON\n\n//青(绿+蓝)\n#define LED_CYAN \\\n     LED1_OFF;\\\n     LED2_ON\\\n     LED3_ON\n     \n//白(红+绿+蓝)\n#define LED_WHITE \\\n     LED1_ON;\\\n     LED2_ON\\\n     LED3_ON\n     \n//黑(全部关闭)\n#define LED_RGBOFF \\\n     LED1_OFF;\\\n     LED2_OFF\\\n     LED3_OFF\n\nvoid LED_GPIO_Config(void);\n\n#endif /* __LED_H */\n```\n\n#### 在bsp_led.c中编写led初始化函数\n\n```c\n/**\n  ******************************************************************************\n  * @file    bsp_led.c\n  * @author  fire\n  * @version V1.0\n  * @date    2013-xx-xx\n  * @brief   led应用函数接口\n  ******************************************************************************\n  * @attention\n  *\n  * 实验平台:野火 F103-霸道 STM32 开发板 \n  * 论坛    :http://www.firebbs.cn\n  * 淘宝    :https://fire-stm32.taobao.com\n  *\n  ******************************************************************************\n  */\n  \n#include \"./led/bsp_led.h\"   \n\n /**\n  * @brief  初始化控制LED的IO\n  * @param  无\n  * @retval 无\n  */\nvoid LED_GPIO_Config(void)\n{  \n    /*定义一个GPIO_InitTypeDef类型的结构体*/\n    GPIO_InitTypeDef GPIO_InitStructure;\n\n    /*开启LED相关的GPIO外设时钟*/\n    RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK | LED3_GPIO_CLK, ENABLE);\n    /*选择要控制的GPIO引脚*/\n    GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN; \n\n    /*设置引脚模式为通用推挽输出*/\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   \n\n    /*设置引脚速率为50MHz */   \n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; \n\n    /*调用库函数，初始化GPIO*/\n    GPIO_Init(LED1_GPIO_PORT, &GPIO_InitStructure); \n\n    /*选择要控制的GPIO引脚*/\n    GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;\n\n    /*调用库函数，初始化GPIO*/\n    GPIO_Init(LED2_GPIO_PORT, &GPIO_InitStructure);\n\n    /*选择要控制的GPIO引脚*/\n    GPIO_InitStructure.GPIO_Pin = LED3_GPIO_PIN;\n\n    /*调用库函数，初始化GPIOF*/\n    GPIO_Init(LED3_GPIO_PORT, &GPIO_InitStructure);\n\n    /* 关闭所有led灯 */\n    GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);\n\n    /* 关闭所有led灯 */\n    GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);  \n    \n      /* 关闭所有led灯 */\n    GPIO_SetBits(LED3_GPIO_PORT, LED3_GPIO_PIN);\n}\n\nvoid assert_failed(uint8_t* file, uint32_t line)\n{\n    // 断言错误时执行的代码\n    LED1_ON;\n}\n/*********************************************END OF FILE**********************/\n```\n\n#### 在bsp_usart.c中关闭串口中断\n\n```c\n /**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n    \n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n       // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n    \n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = \n    USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure);\n    \n    // 将中断失能\n    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, DISABLE); \n    \n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);     \n}\n```\n\n#### 在main.c中编写测试程序\n\n```c\nint main(void)\n{\n    uint8_t ch = 0;\n\n    USART_Config(); // 初始化USART\n    LED_GPIO_Config(); // 初始化LED\n\n    printf(\"USART-RGB\\n\");\n    printf(\"1:RED, 2:GREEN, 3:BLUE, 4:YELLOW, 5:PURPLE, 6:CYAN, 7:WHITE\\n\");\n    printf(\"Others: BLACK\\n\");\n    \n\n    while(1)\n    {\n        ch = getchar();\n        printf(\"ch = %c\\n\", ch);\n\n        switch(ch)\n        {\n        case '1': LED_RED;\n            break;\n        case '2': LED_GREEN;\n            break;\n        case '3': LED_BLUE;\n            break;\n        case '4': LED_YELLOW;\n            break;\n        case '5': LED_PURPLE;\n            break;\n        case '6': LED_CYAN;\n            break;\n        case '7': LED_WHITE;\n            break;\n        \n        default: LED_RGBOFF;\n            break;\n        }\n    }\n}\n\n```\n\n## DMA\n\nDMA: Direct Memory Access, 直接寄存器访问. 主要功能是可以把数据从一个地方搬到另一个地方, 而且不占用CPU\n\n- DMA1: 有7个通道, 可实现P->M, M->P, M->M\n- DMA2: 有5个通道, 可实现P->M, M->P, M->M(*只存在于大容量和互联型产品中*)\n\n### 补充: DMA介绍\n\nDMA（Direct Memory Access，直接内存访问）是计算机系统中的一种技术，**它允许外设或内存模块通过绕过中央处理器（CPU）直接与系统内存进行数据传输**。DMA的目标是提高数据传输效率，减轻CPU的负担，使CPU能够专注于执行其他任务。\n\n以下是关于DMA的一些重要概念和特性：\n\n#### DMA的工作原理\n\nDMA通过在系统总线上控制数据传输而不涉及CPU来工作。它可以在CPU不介入的情况下，直接将数据从一个位置传输到另一个位置。\n\n1. 配置： CPU负责配置DMA，确定源地址、目标地址、传输方向、传输大小等参数。\n2. 启动： 一旦DMA被配置，CPU就可以启动DMA控制器，它将负责管理数据传输。\n3. 传输： DMA控制器在总线上控制数据传输，无需CPU的干预。数据在源和目标之间直接传输。\n4. 中断通知： DMA传输完成后，通常会发出一个中断信号，以通知CPU或其他系统组件。\n\n#### DMA的优点\n\n1. 提高性能： 通过绕过CPU，减轻了CPU的负担，使其能够执行其他任务，提高了整体系统性能。\n2. 实时数据传输： 特别适用于实时数据传输，如音频、视频流等。\n3. 高效处理大量数据： 对于大量数据的块传输，DMA比CPU执行这样的传输更为高效。\n\n#### DMA的应用领域\n\nDMA在多种应用场景中都得到了广泛应用，包括但不限于：\n\n1. 嵌入式系统： 用于处理外设和内存之间的数据传输，例如，处理音频、图像等。\n2. 网络通信： 在网络接口控制器和系统内存之间快速传输数据。\n3. 存储系统： 用于在磁盘、固态硬盘等存储设备和系统内存之间进行数据传输。\n4. 图形处理： 在图形卡和系统内存之间进行大规模图形数据的传输。\n\n#### DMA控制器\n\nDMA通常由专门的硬件单元，称为DMA控制器，来管理。DMA控制器的设计和功能因芯片架构而异，但通常包括寄存器用于配置、启动和监视传输。\n\n总的来说，DMA是一项重要的技术，对于需要高效数据传输的系统是至关重要的。通过减轻CPU的负担，DMA提高了系统的整体性能和响应速度。\n\n### DMA功能框图讲解\n\n![DMA功能框图讲解](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261122722.png)\n\n#### DMA请求映射\n\nDMA1请求映射\n\n![DMA1请求映射](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261126729.png)\n\nDMA2请求映射\n\n![DMA2请求映射](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261127579.png)\n\n#### DMA仲裁器\n\n![DMA仲裁器](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261128690.png)\n\n软件配置在寄存器DMA_CCRx:PL[1:0]进行通道优先级配置\n\n### DMA固件库-初始化结构体\n\n初始化结构体在stm32f10x_dma.h文件中\n\n```c\n/** \n  * @brief  DMA Init structure definition\n  */\n\ntypedef struct\n{\n  /*--------------------------------------------------------------------------------\n   * 外设地址\n   * 由寄存器 DMA_CPARx 进行配置\n   *---------------------------------------------------------------------------- */\n  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器地址\n   * 由寄存器 DMA_CMARx 进行配置\n   *---------------------------------------------------------------------------- */\n  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */\n\n  /*--------------------------------------------------------------------------------\n   * 传输方向\n   * P->M 和 M->P 由寄存器 DMA_CCRx:DIR[4] 进行配置\n   * M->M 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.\n                                        This parameter can be a value of @ref DMA_data_transfer_direction */\n\n  /*--------------------------------------------------------------------------------\n   * 缓冲区大小, 传输数目\n   * 由寄存器 DMA_CNDTRx 进行配置\n   *-------------------------------------------------------------------------------*/\n  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. \n                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize\n                                        or DMA_MemoryDataSize members depending in the transfer direction. */\n\n  /*--------------------------------------------------------------------------------\n   * 外设增量模式\n   * 由寄存器 DMA_CCRx:PINC[6] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器增量模式\n   * 由寄存器 DMA_CCRx:MINC[7] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_memory_incremented_mode */\n\n  /*--------------------------------------------------------------------------------\n   * 外设数据宽度\n   * 由寄存器 DMA_CCRx:PSIZE[9:8] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.\n                                        This parameter can be a value of @ref DMA_peripheral_data_size */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器数据宽度\n   * 由寄存器 DMA_CCRx:MSIZE[11:10] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.\n                                        This parameter can be a value of @ref DMA_memory_data_size */\n\n  /*--------------------------------------------------------------------------------\n   * 传输模式\n   * 由寄存器 DMA_CCRx:CIRC[5] 进行配置\n   * 通过 DMA_ISR 判断传输状态来判断传输完成, 传输一半, 传输错误\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_circular_normal_mode.\n                                        @note: The circular buffer mode cannot be used if the memory-to-memory\n                                              data transfer is configured on the selected Channel */\n\n  /*--------------------------------------------------------------------------------\n   * 优先级\n   * 由寄存器 DMA_CCRx:PL[1:0] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_priority_level */\n\n  /*--------------------------------------------------------------------------------\n   * 存储器到存储器模式\n   * 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置\n   *--------------------------------------------------------------------------------*/\n  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.\n                                        This parameter can be a value of @ref DMA_memory_to_memory */\n}DMA_InitTypeDef;\n```\n\n### DMA固件库-固件库函数\n\n在stm32f10x_dma.h文件中可以找到DMA固件库函数的声明, 以下是常用的函数\n\n```c\nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct); // 初始化函数\nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState); // 使能DMA\nFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG); // 判断标志位\n```\n\n### DMA实验1: M to M\n\n项目地址: **22-DMA-MtoM**\n\n**实验需求**: FLASH to SRAM, 把内部FLASH的数据传输到内部的SRAM\n\n#### 在bsp_dma_m2m.h增加宏定义\n\n```c\n// 当使用存储器到存储器模式时候，通道可以随便选，没有硬性的规定\n#define M2M_DMA_CHANNEL     DMA1_Channel6\n#define M2M_DMA_CLOCK       RCC_AHBPeriph_DMA1\n// 传输完成标志\n#define M2M_DMA_FLAG_TC     DMA1_FLAG_TC6\n// 要发送的数据大小\n#define BUFFER_SIZE     32\n```\n\n#### 在bsp_dma_m2m.c中定义源和目标变量\n\n```c\n/* 定义aSRC_Const_Buffer数组作为DMA传输数据源\n * const关键字将aSRC_Const_Buffer数组变量定义为常量类型\n * 表示数据存储在内部的FLASH中\n */\nconst uint32_t aSRC_Const_Buffer[BUFFER_SIZE]= {\n                                    0x01020304,0x05060708,0x090A0B0C,0x0D0E0F10,\n                                    0x11121314,0x15161718,0x191A1B1C,0x1D1E1F20,\n                                    0x21222324,0x25262728,0x292A2B2C,0x2D2E2F30,\n                                    0x31323334,0x35363738,0x393A3B3C,0x3D3E3F40,\n                                    0x41424344,0x45464748,0x494A4B4C,0x4D4E4F50,\n                                    0x51525354,0x55565758,0x595A5B5C,0x5D5E5F60,\n                                    0x61626364,0x65666768,0x696A6B6C,0x6D6E6F70,\n                                    0x71727374,0x75767778,0x797A7B7C,0x7D7E7F80};\n\n/**\n * 定义DMA传输目标存储器\n * 存储在内部的SRAM中                  \n */\nuint32_t aDST_Buffer[BUFFER_SIZE];\n\n```\n\n#### 在bsp_dma_m2m.c中增加DMA初始化函数\n\n```c\n/**\n * @brief 配置存储器到存储器的DMA传输\n * \n * @param None\n * @return None\n */\nvoid M2M_DMA_Config(void)\n{\n    DMA_InitTypeDef DMA_InitStructure; // 定义DMA初始化结构体变量\n    \n    RCC_AHBPeriphClockCmd(M2M_DMA_CLOCK, ENABLE); // 打开DMA时钟\n\n    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)aSRC_Const_Buffer; // 配置外设地址, 实际将FLASH的数据配置成了外设\n    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)aDST_Buffer; // 配置存储器地址\n    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; // 配置传输方向，从外设读取数据发送到存储器\n    DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE; // 配置传输数据大小\n    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable; // 配置外设地址自增\n    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; // 配置存储器地址自增\n    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; // 配置外设数据大小\n    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; // 配置存储器数据大小\n    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; // 配置传输模式，非循环模式\n    DMA_InitStructure.DMA_Priority = DMA_Priority_High; // 配置传输通道优先级\n    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; // 配置存储器到存储器模式\n\n    DMA_Init(M2M_DMA_CHANNEL, &DMA_InitStructure); // 初始化DMA通道\n    DMA_ClearFlag(M2M_DMA_FLAG_TC); // 清除DMA通道传输完成标志位\n    DMA_Cmd(M2M_DMA_CHANNEL, ENABLE); // 使能DMA通道\n}\n```\n\n#### 在bsp_dma_m2m.c中增加判断数据相等的函数\n\n```c\n/**\n * @brief 比较两个缓冲区的数据是否相等\n * \n * @param pBuffer 指向第一个缓冲区的指针\n * @param pBuffer1 指向第二个缓冲区的指针\n * @param BufferLength 缓冲区的长度\n * @return uint8_t 如果两个缓冲区的数据相等，则返回1；否则返回0\n */\nuint8_t Buffercmp(const uint32_t* pBuffer, uint32_t* pBuffer1, uint16_t BufferLength)\n{\n    /* 数据长度递减 */\n    while(BufferLength--)\n    {\n        /* 判断两个数据源是否对应相等 */\n        if(*pBuffer != *pBuffer1)\n        {\n            /* 对应数据源不相等马上退出函数，并返回0 */\n            return 0;\n        }\n        /* 递增两个数据源的地址指针 */\n        pBuffer++;\n        pBuffer1++;\n    }\n    /* 完成判断并且对应数据相对 */\n    return 1;  \n}\n```\n\n#### 在main.c函数中进行DMA测试\n\n```c\n// 声明以下变量来自外部文件\nextern const uint32_t aSRC_Const_Buffer[BUFFER_SIZE];\nextern uint32_t aDST_Buffer[BUFFER_SIZE];\n\n/**\n * @brief Delays the execution for a specified number of milliseconds.(Not Sure)\n * @param ms The number of milliseconds to delay.\n * @return None.\n */\nvoid Delay_ms(uint32_t ms)\n{\n    uint32_t i = 0;\n    for(i = 0; i < ms; i++)\n    {\n        uint16_t j = 0;\n        for(j = 0; j < 1000; j++)\n        {\n            ;\n        }\n    }\n}\n\nint main(void)\n{\n    uint8_t status = 0; // 接收比较的结构\n\n    LED_GPIO_Config(); // 初始化LED\n    M2M_DMA_Config(); // 初始化DMA\n     \n    // 等待DMA1传送完毕\n    while(DMA_GetFlagStatus(M2M_DMA_FLAG_TC) == RESET)\n    {\n        ;\n    }\n\n    LED_YELLOW;\n    Delay_ms(10000); // DMA初始化完成后亮黄灯\n\n    status = Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE); // 比较两个数组的数据是否相等\n    if(status == 0)\n    {\n        LED_RED; // 数据不相等亮红灯\n    }\n    else\n    {\n        LED_GREEN; // 数据相等亮绿灯\n    }\n\n    while(1)\n    {\n        ;\n    }\n}\n```\n\n### DMA实验2: M to P\n\n项目地址: **22-DMA-MtoP**\n\n**实验需求**: SRAM to 串口, 同时LED灯闪烁, 演示DMA数据不需占用CPU\n\n### 在bsp_dma_m2p.h中加入宏定义\n\n```c\n// 串口工作参数宏定义\n#define  DEBUG_USARTx                   USART1\n#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1\n#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_BAUDRATE           115200\n\n// USART GPIO 引脚宏定义\n#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)\n#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd\n#define  DEBUG_USART_TX_GPIO_PORT       GPIOA   \n#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9\n#define  DEBUG_USART_RX_GPIO_PORT       GPIOA\n#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10\n\n#define USART_TX_DMA_CLK RCC_AHBPeriph_DMA1 // 串口DMA时钟\n#define  USART_TX_DMA_CHANNEL     DMA1_Channel4 // 串口对应的DMA请求通道\n#define  USART_DR_ADDRESS        (USART1_BASE+0x04) // 外设寄存器地址\n#define  SENDBUFF_SIZE            5000 // 一次发送的数据量\n#define  USART_TX_DMA_FLAG_TC DMA1_FLAG_TC4 // 标志位\n```\n\n#### 在bsp_dma_m2p.c中加入USART的初始化函数\n\n```c\n/**\n  * @brief  USART GPIO 配置,工作参数配置\n  * @param  无\n  * @retval 无\n  */\nvoid USART_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    // 打开串口GPIO的时钟\n    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n\n    // 打开串口外设的时钟\n    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n    // 将USART Tx的GPIO配置为推挽复用模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);\n\n       // 将USART Rx的GPIO配置为浮空输入模式\n    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);\n\n    // 配置串口的工作参数\n    // 配置波特率\n    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n    // 配置 针数据字长\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    // 配置停止位\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    // 配置校验位\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    // 配置硬件流控制\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    // 配置工作模式，收发一起\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    // 完成串口的初始化配置\n    USART_Init(DEBUG_USARTx, &USART_InitStructure); \n\n    // 使能串口\n    USART_Cmd(DEBUG_USARTx, ENABLE);     \n}\n```\n\n#### 在bsp_dma_m2p.c中加入USARTx_TX DMA配置\n\n实现内存到外设(USART1->DR)\n\n```c\n/**\n  * @brief  USARTx TX DMA 配置，内存到外设(USART1->DR)\n  * @param  无\n  * @retval 无\n  */\nvoid USARTx_DMA_Config(void)\n{\n    DMA_InitTypeDef DMA_InitStructure;\n    \n    // 开启DMA时钟\n    RCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);\n    // 设置DMA源地址：串口数据寄存器地址*/\n       DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;\n    // 内存地址(要传输的变量的指针)\n    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff;\n    // 方向：从内存到外设 \n    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\n    // 传输大小 \n    DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;\n    // 外设地址不增     \n    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n    // 内存地址自增\n    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n    // 外设数据单位 \n    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\n    // 内存数据单位\n    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  \n    // DMA模式，一次或者循环模式\n    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;\n    // DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; \n    // 优先级：中 \n    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; \n    // 禁止内存到内存的传输\n    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n    // 配置DMA通道     \n    DMA_Init(USART_TX_DMA_CHANNEL, &DMA_InitStructure);  \n    // 清除TC标志位\n    DMA_ClearFlag(USART_TX_DMA_FLAG_TC);\n    // 使能DMA\n    DMA_Cmd (USART_TX_DMA_CHANNEL, ENABLE);\n    \n```\n\n#### 在bsp_dma_m2p.c中声明在内存的变量\n\n```c\nuint8_t SendBuff[SENDBUFF_SIZE];\n```\n\n#### 在main.c中声明外部变量\n\n```c\nextern uint8_t SendBuff[SENDBUFF_SIZE];\n```\n\n#### 在main.c中测试DMA\n\n实现DMA将储存器中的数据发送到USART->DR, 并实现LED1闪烁\n\n```c\n/**\n * @brief 实现DMA将储存器中的数据发送到USART->DR, 并实现LED1闪烁\n * \n * @return int \n */\nint main(void)\n{\n\n    LED_GPIO_Config(); // 初始化LED\n    USART_Config(); // 串口初始化\n\n    for(uint16_t i = 0; i < SENDBUFF_SIZE; i++)\n    {\n        SendBuff[i] = 'P';\n    }\n\n    USARTx_DMA_Config(); // 初始化DMA\n    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); // 使能DMA发送\n\n    while(1)\n    {\n        LED1_TOGGLE;\n        Delay_ms(10000);\n    }\n}\n```\n\n## 常用存储器\n\n### 存储器的种类\n\n易失性和非易失性区别在于**掉电数据是否会丢失**, 易失性存储器**读写速度相对较快**\n\n- 易失性存储器(RAM)\n  - DRAM(动态RAM, 常用于PC机)\n    - SDRAM(STM32F429)\n    - DDR SDRAM\n    - DDRII SDRAM\n    - DDRIII SDRAM(常用于PC机)\n  - SRAM(静态RAM, STM32F103)\n- 非易失性存储器\n  - ROM(半导体类)\n    - MASK ROM(对于STM32可读不可写)\n    - PROM(可编程ROM)\n      - OTPROM(可写一次的ROM)\n      - EPROM(可用高电压擦除的ROM)\n      - EEPROM(STM32F103, 可用较低电压3.3V擦除的ROM)\n    - FLASH(半导体类)\n    - NOR FLASH(一般用来存储程序)\n    - NAND FLASH(一般用来存储数据)\n    - 光盘\n    - 软盘\n    - 机械硬盘\n\n### RAM存储器(易失性存储器)\n\n#### RAM介绍\n\n![RAM介绍](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262322421.png)\n\n#### DRAM的存储单元结构\n\n![DRAM的存储单元结构](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262327533.png)\n\n**DRAM通过电容充放电与MOS管配合产生高低电平**, 需要配合电平检测阈值来减少电容漏电带来的影响\n\n#### SRAM的存储单元结构\n\n![SRAM的存储单元结构](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262328328.png)\n\n**SRAM以锁存器结构来存储数据**, 锁存器结构在没有输入的情况下会一直保持原来的状态\n\n#### SRAM和DRAM的比较\n\n![SRAM和DRAM的比较](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262336065.png)\n\nSDRAM使用同步通信方式\n\n![SDRAM同步通信](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262341860.png)\n\nSRAM使用异步方式通信\n\n![SRAM异步通信](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270000903.png)\n\n### 非易失性存储器\n\n#### ROM简介\n\n![ROM简介](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270001764.png)\n\n#### FLASH简介\n\n![FLASH简介](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270007166.png)\n\n在嵌入式开发中选择 NOR FLASH 主要因为坏区较少, 基于字节读写可以支持XIP\n\nXIP(Execute In Place，就地执行)功能，它是一种特性，允许直接从 Flash 存储器中执行代码，而无需将代码首先复制到RAM中。XIP功能在嵌入式系统中很常见，它带来了一些优势，包括更少的RAM使用和更快的启动速度\n\n与ROM不同, FLASH必须先按块擦除数据后才能写入数据\n\n## I2C-读写EEPROM\n\n### 补充: I2C简介\n\nI2C（Inter-Integrated Circuit）是一种串行通信协议，**用于在集成电路之间进行短距离通信** I2C 由飞利浦公司（Philips）于1982年开发，并且现在由多家公司支持和采用。该协议通常用于连接芯片、传感器、存储器、外设等设备。\n\n以下是 I2C 协议的一些关键特点和基本概念：\n\n1. 总线结构\n   - 主从结构： I2C 使用主从结构，其中一个设备充当主设备（通常是微控制器或处理器），而其他设备则充当从设备。主设备负责发起通信和生成时钟信号。\n   - 双线制： I2C 使用两根线，一根是数据线（SDA），另一根是时钟线（SCL）。这两根线上都有上拉电阻，以便在设备不主动拉低时保持高电平。\n2. 数据传输：\n   - 起始和停止条件： 数据传输始于主设备发送起始条件（Start Condition），并以主设备发送停止条件（Stop Condition）结束。这两个条件都是由主设备在总线上生成的。\n   - 地址帧： 每个数据传输都以地址帧开始，其中包含目标设备的地址和读写位。地址帧由主设备发送。\n   - 数据帧： 在地址帧之后是一个或多个数据帧，其中包含实际的数据。数据帧的传输由主设备和从设备之间交替进行。\n   - 应答（Acknowledge）： 在每个数据帧之后，接收方发送一个应答信号，通常是一个低电平，以确认数据的接收。\n3. 速率和模式：\n   - 速率： I2C 支持不同的传输速率，常见的有 100 kHz、400 kHz 和 1 MHz 等。\n   - 模式： I2C 支持标准模式（100 kHz），快速模式（400 kHz），高速模式（1 MHz）等不同的工作模式。\n4. 多主设备和重复启动：\n   - 多主设备： I2C 支持多主设备共享同一总线。主设备之间通过仲裁（Arbitration）来确定哪个主设备能够继续发送。\n   - 重复启动： 主设备可以在一个传输结束后发送重复启动条件，而无需先发送停止条件，从而在同一次通信中与另一个从设备建立连接。\n5. I2C设备地址：\n   - 7位或10位地址： I2C 设备使用 7 位或 10 位地址来识别自己。大多数设备使用 7 位地址。\n\nI2C 协议的简洁性和灵活性使得它在连接各种设备和传感器时非常有用，尤其是在嵌入式系统中。\n\n### 补充: 高阻态\n\n在嵌入式领域中，高阻态的概念同样非常重要，并涉及到数字电路设计和信号完整性的方面。以下是在嵌入式系统中高阻态的一些关键应用和概念：\n\n1. 输入端口的高阻态： 很多嵌入式系统包括微控制器或微处理器，**其输入端口通常具有高阻抗特性。这意味着当输入端口未连接到任何外部设备时，输入端口会处于高阻态状态。这有助于避免在未连接设备时引入不必要的电流，同时防止信号线上的悬空状态(floating)**。\n2. 悬空输入的高阻态： 在数字电路中，当一个输入端未连接时，它被称为悬空输入。在悬空输入的情况下，该输入端常常设计为高阻态，以减少对电路的干扰和功耗。\n3. 总线冲突的高阻态： **在多主设备共享总线的系统中，当多个主设备尝试在同一时刻传输数据时可能会发生总线冲突。为了避免冲突设备之间的干扰，某些设备在冲突时会将总线设置为高阻态，以允许其他设备继续操作**。\n4. 三态逻辑门： 一些数字逻辑门（如三态门）具有高阻态输出。这允许将多个门连接到同一总线上，当其中一个门处于高阻态时，其他门仍能够正常工作。\n5. 输入缓冲器的高阻态： 在输入缓冲器中，当输入未被有效驱动时，输入缓冲器通常进入高阻态，以避免对电路产生负面影响。\n\n在这些情况下，高阻态的概念有助于确保电路在非活动状态时不引入不必要的电流，提高系统的稳定性和可靠性。这对于嵌入式系统中对功耗、信号完整性和总线冲突等方面的考虑非常重要。\n\n### I2C物理层\n\n![I2C物理层](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270111246.png)\n\n![I2C物理层](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270140896.png)\n\n#### I2C物理层主要特点\n\n- I2C是支持多设备的总线, 可支持多个通讯主机和从机\n- I2C使用两条线路, 一条SDA(双向串行数据线)来表示数据, 一条SCL(串行时钟线)来同步数据, 属于同步通信\n- 连接到总线的设备分配独立地址(7位或10位)\n- 总线接上拉电阻到电源(一般4.7KΩ, 具体看手册)\n  1. 当设备空闲时输出高阻态*防止短路总线上的其他接地设备*\n  2. 当所有设备都空闲时全部输出高阻态, 可通过上拉电阻把总线拉到高电平\n  3. 输出高阻态的特性需要GPIO的开漏输出\n- 多设备占用总线会仲裁\n- 具有三种传输速度模式, **实际开发中可使用低于最高速的速度, 协调总线设备速度一致即可**\n- I2C可接入的设备数量受到最大电容负载的限制, 一般为400pF, *也就是说总线上的设备数量越多, 传输速度越慢*\n\n### I2C协议层\n\nI2C协议定义了**通讯的起始和停止信号, 数据有效性, 响应, 仲裁, 时钟同步和地址广播等环节**\n\n#### I2C基本读写过程\n\n##### 主机写数据到从机\n\n![I2C基本读写过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270157626.png)\n\n1. S: 主机传输开始信号\n2. SLAVE ADDRESS: 主机传输需要通信的从机地址\n3. R/!W: 主机传输读或写信号, *若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据*\n4. A: 从机传输响应\n5. DATA: 主机传输数据段\n6. A: 从机响应\n7. DATA: 主机继续发送数据段\n8. A/!A: 从机响应是否继续接收\n9. P: 若从机响应不继续接收, 则主机传输停止位\n\n##### 主机由从机读数据\n\n![I2C基本读写过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270207508.png)\n\n1. S: 主机传输开始信号\n2. SLAVE ADDRESS: 主机传输需要通信的从机地址\n3. R/!W: 主机传输读或写信号, *若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据*\n4. A: 从机传输响应\n5. DATA: 从机传输数据段\n6. A: 主机响应\n7. DATA: 从机继续发送数据段\n8. A/!A: 主机响应是否继续接收\n9. P: 若主机响应不继续接收, 则主机传输停止位\n\n注意:\n\n- S: 开始信号只能由主机产生\n- SLAVE ADDRESS: 进行通信的从机地址只能由主机产生\n- R/!W: 读/写信号只能由主机产生\n- P: 停止信号只能由主机产生\n- DATA 和 A: 数据段和响应段由主机和从机交替产生, 具体由主机和从机的读写决定\n\n##### 通信复合格式\n\n![通信复合格式](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270209992.png)\n\n常用的复合通信的方法, **即先写入外设地址后将外设的寄存器地址返回进行读取**\n\n- S: 主机传输开始信号\n- SLAVE ADDRESS: 进行通信的从机地址(一般为外设)\n- R/W!: 一般为写操作\n- DATA: 写入的外设地址\n- A/A!: 从机响应\n- Sr: 主机传输开始信号\n- SLAVE ADDRESS: 进行通信的从机地址(一般为同一个外设)\n- R/W!: 一般为读操作\n- DATA: 读取外设的寄存器的具体地址\n- A/A!: 逐个字节进行读取外设每个寄存器的地址并做出响应\n- P: 全部读取完毕后主机传输停止信号\n\n#### 通讯的起始和停止信号\n\n![通讯的起始和停止信号](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270225648.png)\n\n- 起始信号: **SCL高电平, SDA由高电平向低电平转换**\n- 停止信号: **SCL高电平, SDA由低电平向高电平转换**\n\n#### 数据的有效性\n\n![数据有效性](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270237788.png)\n\n- SDA: 负责传输数据\n- SCL: 高电平时采集SDA上1bit数据, 低电平时SDA进行电平转换\n\n#### 地址及数据方向\n\n![地址及数据方向](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270243764.png)\n\nI2C采用高位先行, 由高位到低位进行传输\n\n一般使用7位表示I2C上的设备地址, 设备地址加上其后的读写位可以凑成8位即1字节方便传输\n\n例如, 某设备在I2C上的设备地址为7位的0x78(0b01111000), 可加入读写位凑到八位\n\n- 8位设备的读地址位为0xF1(0b11110001)\n- 8位设备的写地址位为0xF0(0b11110000)\n\n#### 响应\n\n![响应](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270254565.png)\n\n1. 1-8个时钟信号中: 数据发送端控制SDA传输7位设备地址和1位读写信号\n2. 在第9个时钟信号时: 数据接收端获得SDA控制权, 发送应答信号(低电平表示应答)\n\n### STM32的I2C特性及架构\n\n![STM32的I2C特性及架构](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270305500.png)\n\n- 软件模拟协议: 较为繁琐\n- 硬件模拟协议: 较为方便, 减轻CPU负担\n\n注: *STM32硬件的I2C逻辑可能会有问题*\n\n#### STM32的I2C架构分析\n\n![STM32的I2C架构分析](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270315440.png)\n\n##### I2C的通讯引脚\n\n![I2C的通讯引脚](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270346561.png)\n\n![I2C的通讯引脚](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270316720.png)\n\n勘误: *I2C1_SCL默认映射到PB5, I2C1_SDA默认映射到PB7, 图片中有误*\n\nSTM32兼容smbus协议\n\n##### 时钟控制逻辑\n\n![时钟控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347794.png)\n![时钟控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270325594.png)\n\n注: *Tpck1: 指的是APB1时钟周期(1/36MHz)*\n\n###### 计算时钟频率的方法\n\n![计算时钟频率的方法](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270333989.png)\n\n实际就是解未知数CCR的一元一次方程\n\n##### 数据控制逻辑\n\n![数据控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347332.png)\n\n![数据控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270337311.png)\n\n1. 将8位数据写入数据寄存器(DR)\n2. 数据寄存器里面的数据会被发送到数据移位寄存器\n\n##### 整体控制逻辑\n\n![整体控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270348369.png)\n\n![整体控制逻辑](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270355991.png)\n\n### STM32硬件I2C的通讯过程\n\n#### STM32作为主发送器的通讯过程\n\n![STM32作为主发送器的通讯过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270357886.png)\n\n勘误: *EV8_2: TxE=1, BTF=1, 请求设置停止位. TxE和BTF位由硬件在产生停止条件时清除*\n\n- EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)\n- EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)\n- EV8: 在正常数据发送完毕后会产生EV8事件(I2C_SRx:TxE[7]置1表示数据寄存器空)\n- EV8_2: 在从机发送结束应答后会产生EV8_2事件(I2C_SRx:TxE[7]置1表示数据寄存器空, I2C_SRx:BTF[2]置1表示字节发送结束, I2C_CRx:STOP[9]置1表示在当前字节传输或在当前起始条件发出后产生停止条件, 产生停止条件后由硬件清除TxE和BTF位)\n\n#### STM32作为主接收器的通讯过程\n\n![STM32作为主接收器的通讯过程](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270423471.png)\n\n勘误: *EV7_1: RxNE=1, 读DR寄存器清除该事件. 设置ACK=0和STOP请求*\n\n- EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)\n- EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)\n- EV7: 在正常数据发送完毕后会产生EV7事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空)\n- EV7_1: 在主机发送结束应答后会产生EV7_1事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空, I2C_CRx:ACK[10]置0表示设置为无应答返回, I2C_CRx:STOP[9]置1表示在当前字节传输或释放SCL和SDA线)\n\n每个状态标志位的清除方法各不相同, 使用库函数的方法可以较方便的清除寄存器的标志位\n\n### I2C初始化结构体\n\n在stm32f10x_i2c.h中定义I2C初始化结构体\n\n```c\n/** \n  * @brief  I2C Init structure definition  \n  */\n\ntypedef struct\n{\n  /*---------------------------------------------------------------------------------\n   * 设置时钟频率\n   * 设置I2C的传输速率, 函数根据该值经过运算后写入I2C_CCR寄存器\n   * 不得高于400kHz, 即400 000\n   * 由于I2C_CCR寄存器不能写入浮点数, 可能会导致实际速率小于设定的传输速率参数\n   * 使得通讯稍慢, 但是并不会对I2C的通讯造成其他影响\n   *-------------------------------------------------------------------------------*/\n  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.\n                                         This parameter must be set to a value lower than 400kHz */\n\n  /*---------------------------------------------------------------------------------\n   * 设置I2C的模式\n   * I2C_Mode_I2C: 标准I2C模式\n   * I2C_Mode_SMBusDevice: SMBus设备模式\n   * I2C_Mode_SMBusHost: SMBus主机模式\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.\n                                         This parameter can be a value of @ref I2C_mode */\n\n  /*---------------------------------------------------------------------------------\n   * 设置I2C的SCL时钟的占空比\n   * I2C_DutyCycle_16_9: Tlow/Thigh = 16:9\n   * I2C_DutyCycle_2: Tlow/Thigh = 2:1\n   * 这两个选项差别不大, 开发中一般不会进行严格区分\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.\n                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */\n\n  /*---------------------------------------------------------------------------------\n   * 配置STM32的I2C设备自己的地址\n   * 此参数可以是 7 位或 10 位地址\n   * 第二个地址可以通过函数I2C_OwnAddress2Config进行配置, 只能是7位地址\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.\n                                         This parameter can be a 7-bit or 10-bit address. */\n\n  /*---------------------------------------------------------------------------------\n   * 配置I2C应答是否使能\n   * I2C_Ack_Enable: 允许应答使能\n   * I2C_Ack_Disable: 禁止应答使能\n   * 一般配置为允许应答使能, 改为禁止应答使能往往会导致通讯错误\n   *-------------------------------------------------------------------------------*/\n  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.\n                                         This parameter can be a value of @ref I2C_acknowledgement */\n\n  /*---------------------------------------------------------------------------------\n   * 配置I2C的寻址长度\n   * I2C_AcknowledgedAddress_7bit: 7位地址\n   * I2C_AcknowledgedAddress_10bit: 10位地址\n   * 需要根据连接到I2C总线上的设备进行选择, 确保地址长度一致, 才能进行通信\n   * 只有I2C_OwnAddress1才能配置10位地址, I2C_OwnAddress2只支持7位地址 *-------------------------------------------------------------------------------*/\n  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.\n                                         This parameter can be a value of @ref I2C_acknowledged_address */\n}I2C_InitTypeDef;\n```\n\n### I2C库函数\n\n#### I2C_GenerateSTART函数, 用于产生起始条件\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271607885.png)\n\n#### I2C_GetFlagStatus函数, 用于获取状态位\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271610721.png)\n\nI2C_FLAG参数列表对应I2C_SRx状态寄存器的各个位, 可通过查询手册查看其含义\n\n返回值说明\n\n![返回值说明](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271612900.png)\n\n```c\ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;\n```\n\n- RESET: 0, 返回RESET表示该状态位为0\n- SET: 1, 返回SET表示该状态位为1\n\n#### I2C_Send7bitAddress函数, 用于发送7位地址\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271616560.png)\n\n参数Address为八位读/写地址, 通过I2C_Direction实际配置读写方向, 最终方向以I2C_Direction配置为准, 参数Address的读写位失效\n\n#### I2C_SendDate函数, 通过I2Cx外设发送数据字节\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271618557.png)\n\n#### I2C_ReceiveData函数, 返回 I2Cx 外设最近接收的数据\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271622473.png)\n\n#### AcknowledgeConfig函数, 使能或禁用I2C的应答\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271623317.png)\n\n#### I2C_Cmd函数, 使能或禁用I2Cx外设\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271625131.png)\n\n#### I2C_CheckEvent函数, I2C状态监测函数\n\n监测的事件发生则返回SUCCESS\n\n![I2C库函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280036252.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037103.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037758.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038783.png)\n\n![I2C_CheckEvent函数](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038105.png)\n\n### EEPROM硬件结构\n\n![EEPROM](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271630443.png)\n\n#### 引脚说明\n\n- VCC: 电源引脚, 接3V3\n- GND: 地引脚, 接地\n- SCL: 时钟线, 经2.2K上拉电阻接3V3, 接PB6引脚(默认映射I2C1_SCL)\n- SDA: 数据线, 经2,2K上拉电阻接3V3, 接PB7引脚(默认映射I2C1_SDA)\n- HOLD: WP引脚, 接地, 不启用写保护(即可向AT24C02写数据)\n- A0-A2: 地址引脚, 接地, A0:A2为000, 如需拓展EEPROM则可通过配置A0-A2的地址引脚来进行区分(如: 配置A0:A2为001, 则可对两EEPROM进行区分)\n\n### AT24C02介绍\n\n![AT24C02](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271642465.png)\n\nAT24C02可存储256字节数据\n\n#### AT24C02引脚说明\n\n![AT24C02](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271648925.png)\n\n- A0-A2: AT24C02用来区分不同AT24C0x芯片的设备地址\n- SDA: 数据线\n- SCL: 时钟线\n- WP: 写保护, 置1启用写保护\n- NC: 不连接\n\n#### AT24C02设备地址\n\n![设备地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702961.png)\n\n![设备地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702718.png)\n\nAT24C02有256字节, 即属于2K(256*8)\n\n![设备地址](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271701248.png)\n\n根据原理图, 将A2-A0均接地, 则A2 = A1 = A0 = 0\n\nAT24C02的地址为0b1010000R/W, Bit0为R/!W位\n\n- AT24C02在A2:A1[000]情况下读地址: 0b10100001(0xA1)\n- AT24C02在A2:A1[000]情况下写地址: 0b10100000(0xA0)\n\n#### AT24C02的Byte Write(以字节方式写数据)操作\n\n![Byte Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271719435.png)\n\n第一个传输的数据段(DATA)为WORD ADDRESS(需要写入的字节所在的地址), 第二次传输数据段(DATA)才为真正需要写入的内容\n\n![Byte Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271723653.png)\n\n```tex\n翻译: Byte Write的工作流程\n\n1. 在发送完SLAVE ADDRESS和W/!R后, 需要发送一个字节的数据地址(WORD ADDRESS)(即需要写入的字节所在的地址)\n2. 收到地址(WORD ADDRESS)后, EEPROM会响应ACK, 然后接收一个字节的数据(DATA)(真正要写入的内容)\n3. 接收到数据(DATA)后, EEPROM响应ACK, 单片机必须发送STOP信号, 不能继续传输第二段数据(给EEPROM预留写入时间)\n4. 接收到停止信号后, EEPROM在tWR的周期时间内进行向内部写入数据\n5. 在此写入周期中, 所有输入被禁用, EEPROM不进行响应\n```\n\n#### AT24C02的Page Write(以页方式写数据)操作\n\n又称突发写入(即仅发送一个地址可写入多个数据)\n\nPage Write解决了Byte Write不能连续写入的缺陷\n\n![Page Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271734727.png)\n\n- WORD ADDRESS(n): 数据的起始地址\n- DATA(n): 写入到WORD ADDRESS(n)中\n- DATA(n+1): 写入到WORD ADDRESS(n+1)中\n- DATA(n+x): 写入到WORD ADDRESS(n+x)中\n\n![Page Write](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271741445.png)\n\n```tex\n翻译: Page Write工作流程\n\n1. AT24C02能以8字节进行Page Write\n2. 与Byte Write类似, 第一个字节是数据地址(WORD ADDRESS)(即需要写入的字节所在的地址), 在接受到第二个字节(DATA)后不会要求单片机发送STOP信号\n3. 相反, EEPROM在接收到第一个DATA(真正要写入的数据)后, 对于AT24C02来说, 能再最多传输7个DATA\n4. EEPROM每接收到一个数据位都会响应ACK, 单片机必须发送停止信号来结束Page Writting\n5. 收到每个DATA后, 对于AT24C02来说, 数据地址(WORD ADDRESS)的低三位会递增(低三位的取值情况为2^3 = 8, 即8字节)\n6. 高位地址不会递增, 从而保证原来的初始数据地址不发生改变(确保低三位正确递增)\n7. 当递增的地址到达Page的界限后, 剩下的8位数据会覆盖Page的开头\n8. 如果向EEPROM传输的DATA超过8个字节(对于AT24C02), 则数据会从头覆盖\n```\n\n#### AT24C02的ACKNOWLEDGE POLLING(确认轮询)\n\n![ACKNOWLEDGE POLLING](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280423663.png)\n\n```tex\n一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。\n这涉及发送一个启动条件，后跟设备地址。读/写位是代表所需的操作。\n仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列\n```\n\n需要在向AT24C02写入数据操作后, 进行确认询问, 主机需要发送启动条件, 设备地址, 读写位, 如果AT24C02准备完毕会响应0才能继续进行操作\n\n以I2C1为例, 软件编程实现如下\n\n```c\n/**\n * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认询问 \n *   STM32向EEPROM写入数据后, EEPROM需要时间向内部存储期间进行写入\n *   此时EEPROM不应答, 所以在发送下一次I2C请求之前,应等待EEPROM写入完成\n *   以上步骤称为ACKNOWLEDGE POLLING\n * @param None\n * @retval None\n */\nvoid EEPROM_ACK_Polling(void)\n{\n    do\n    {\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */\n    while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    } while (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); \n    /* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */\n    /* 结束询问 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n}\n\n```\n\n#### AT24C02的Current Address Read(从当前地址读数据)操作\n\n![Current Address Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271810617.png)\n\n一般不用, 因为在开发中不好确定当前地址的位置\n\n#### AT24C02的Random Read(随机读数据)操作\n\n![Random Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271813901.png)\n\n1. 产生起始信号, 向EEPROM发送要读取数据的数据地址(写方向)\n2. 再次产生起始信号, 从EEPROM中读取数据(读方向)\n3. EEPROM在被写入要读取数据的数据地址后会进行确认并输出该数据内容\n\n![Random Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271821179.png)\n\n```tex\n翻译: Random Read流程\n\n1. Random Read需要\"dummy\"来写入要读取数据(DATA)的数据地址(WORD ADDRESS)\n2. 一旦DEVICE ADDRESS和WORD ADDRESS被EEPROM响应, 单片机必须生成另一个START信号\n3. 单片机发送读信号来读取当前地址(DEVICE ADDRESS)\n4. EEPROM响应DEVICE ADDRESS并串行输出数据(DATA)\n5. 单片机响应NO ACK并紧跟生成STOP信号\n```\n\n#### AT24C02的Sequential Read(顺序读数据)操作\n\n![Sequential Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271838678.png)\n\n与Page Write类似\n\n![Sequential Read](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271841941.png)\n\n```tex\n翻译: Sequential Read流程\n\n1. Sequntial Read从当前地址读取或随机地址开始读取\n2. 单片机收到DATA后，会响应ACK\n3. 只要EEPROM收到ACK响应，它就会继续递增数据地址，并顺序串行输出DATA\n4. 当达到内存地址限制时，数据地址将\"roll over\"，顺序读取将继续从头开始重新读取数据\n5. 当单片机NO ACK响应并生成STOP，则终止Sequential Read\n```\n\n### I2C-读写EEPROM实验\n\n项目地址: **24-I2C-EEPROM**\n\n#### 操作流程\n\n1. 初始化I2C相关的GPIO\n2. 配置I2C外设的工作模式\n3. 编写I2C写入EEPROM的Byte Write函数\n4. 编写I2C读取EEPROM的Random Read函数\n5. 使用read函数和write函数进行读写校验\n6. 编写Page Write和Sequential Read函数进行校验\n\n#### 在bsp_i2c.h中定义相关宏\n\n```c\n/**\n * @defgroup I2C_EEPROM_Define \n * @{\n */\n\n/**\n * @brief I2C的宏定义\n */\n\n#define EEPROM_I2C I2C1 /*!< EEPROM所使用的I2Cx */\n#define EEPROM_I2C_CLK RCC_APB1Periph_I2C1 /*!< I2C的时钟 */\n#define EEPROM_I2C_APBxClkCmd RCC_APB1PeriphClockCmd /*!< I2C时钟的使能函数 */\n#define EEPROM_I2C_BAUDRATE 400000 /*!< I2C的通信速率 */\n#define STM32_I2C_OWN_ADDR 0x5F /*!< STM32在I2C总线上的自身地址, 可任意配置(只要在I2C总线上唯一即可) */\n#define EEPROM_I2C_WRITE_ADDRESS 0xA0 /*!< EEPROM在I2C总线上的8位写地址 */\n#define EEPROM_I2C_READ_ADDRESS 0xA1 /*!< EEPROM在I2C总线上的8位读地址 */\n\n/**\n * @brief I2C的GPIO引脚宏定义\n */\n\n#define EEPROM_I2C_SCL_GPIO_CLK (RCC_APB2Periph_GPIOB) /*!< I2C的SCL引脚的GPIO时钟 */\n#define EEPROM_I2C_SDA_GPIO_CLK (RCC_APB2Periph_GPIOB) /*!< I2C的SDA引脚的GPIO时钟 */\n#define EEPROM_I2C_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd /*!< I2C的GPIO时钟的使能函数 */\n#define EEPROM_I2C_SCL_GPIO_PORT GPIOB /*!< I2C的SCL引脚的GPIO端口 */\n#define EEPROM_I2C_SCL_GPIO_Pin GPIO_Pin_6 /*!< I2C的SCL引脚的GPIO引脚 */\n#define EEPROM_I2C_SDA_GPIO_PORT GPIOB /*!< I2C的SDA引脚的GPIO端口 */\n#define EEPROM_I2C_SDA_GPIO_Pin GPIO_Pin_7 /*!< I2C的SDA引脚的GPIO引脚 */\n\n/**\n * @} \n */\n```\n\n#### 在bsp_i2c.h中进行函数声明\n\n```c\n/**\n * @defgroup EEPROM_I2C_Functions \n * @{\n */\n\nvoid I2C_EEPROM_Config(void);\nvoid EEPROM_Byte_Writting(uint8_t WordAddress, uint8_t Data);\nvoid EEPROM_Page_Writting(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToWrite);\nvoid EEPROM_Random_Read(uint8_t WordAddress, uint8_t* Data);\nvoid EEPROM_Sequential_Read(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToRead);\nvoid EEPROM_ACK_Polling(void);\n\n/**\n * @} \n * \n */\n```\n\n#### 在bsp_i2c.c中编写I2C_EEPROM配置函数\n\n```c\n/**\n * @brief I2C EEPROM配置函数 \n * @param None\n * @retval None \n */\nvoid I2C_EEPROM_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    I2C_InitTypeDef I2C_InitStructure;\n\n    /*-------------------------- 时钟配置 ------------------------------*/\n    /* 使能I2C GPIO的时钟 */\n    EEPROM_I2C_GPIO_APBxClkCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);\n    /* 使能I2C的时钟 */\n    EEPROM_I2C_APBxClkCmd(EEPROM_I2C_CLK, ENABLE);\n\n    /*-------------------------- I2C_SCL的GPIO配置 ------------------------------*/\n    /* 配置引脚为I2C的SCL */\n    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_GPIO_Pin;\n    /* 配置输出速率为50MHz */\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    /* 配置模式开漏复用输出 */\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n    /* 初始化I2C_SCL的GPIO配置 */ \n    GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);\n\n    /*-------------------------- I2C_SDA的GPIO配置 ------------------------------*/\n    /* 配置引脚为I2C的SDA */\n    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_GPIO_Pin;\n    /* 配置输出速率为50MHz */\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    /* 配置模式开漏复用输出 */\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;\n    /* 初始化I2C_SDA的GPIO配置 */ \n    GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);\n\n    /*-------------------------- I2C的工作模式配置 ------------------------------*/\n    /* 使能响应 */\n    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;\n    /* 使用7位地址 */\n    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;\n    /* 时钟频率 400kHz*/\n    I2C_InitStructure.I2C_ClockSpeed = EEPROM_I2C_BAUDRATE;\n    /* 占空比 Tlow/Thigh = 2 */\n    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;\n    /* 模式 I2C */\n    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;\n    /* STM32主机地址 */\n    I2C_InitStructure.I2C_OwnAddress1 = STM32_I2C_OWN_ADDR;\n    /* 初始化I2C */\n    I2C_Init(EEPROM_I2C, &I2C_InitStructure); \n    /* 使能I2C */\n    I2C_Cmd(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Byte Writting方式的函数\n\n```c\n/**\n * @brief 函数实现了STM32作为主发送器向EEPROM以Byte Writting的方式写数据 \n * @param WordAddress: 需要写入的字节所在的地址\n * @param Data: 真正要写入的内容\n * @retval None\n */\nvoid EEPROM_Byte_Writting(uint8_t WordAddress, uint8_t Data)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n        ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n        ;\n    }\n/*---------------- STM32发送Data ----------------*/\n    /* STM32向EEPROM发送Data */\n    I2C_SendData(EEPROM_I2C, Data);\n    /* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)\n    {\n       ;\n    }\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n    /* STM32使能ACK信号, 恢复到默认状态 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Page Writting方式的函数\n\n```c\n/**\n * @brief 函数实现了STM32作为主发送器向EEPROM以Page Writting的方式写数据(每次不超过8字节) \n * @param WordAddress: 需要写入的字节所在的地址\n * @param Data: 真正要写入的数据的指针\n * @param NumByteToWrite: 要写入数据的个数小于8\n * @retval None\n */\nvoid EEPROM_Page_Writting(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToWrite)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n        ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n        ;\n    }\n/*---------------- STM32发送Data ----------------*/\n    /* 循环写入数据 */\n    while(NumByteToWrite)\n    {\n        /* STM32向EEPROM发送Data */\n        I2C_SendData(EEPROM_I2C, *Data);\n        /* 数据指针自增 */\n        Data++;\n        /* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */\n        while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)\n        {\n        ;\n        }\n        NumByteToWrite--;\n    }\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n    /* STM32使能ACK信号, 恢复到默认状态 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Random Read方式的函数\n\n```c\n/**\n * @brief 函数实现STM32从EEPROM以Random Read方式读取数据\n * @param WordAddress: 要读取数据的地址\n * @param Data: 读取数据要写入到的变量\n * @retval None\n */\nvoid EEPROM_Random_Read(uint8_t WordAddress, uint8_t* Data)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n       ;\n    }\n/*---------------- STM32接收Data ----------------*/\n    /* STM32另外产生一个START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的读地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);\n    /* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n\n    /*------------------------------------------------------------------------\n    * 注意: \n    * 该部分为STM32接收来自EEPROM的数据\n    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作\n    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据\n    * 而不是进行数据接收\n    *------------------------------------------------------------------------*/\n\n    /* 监测到EV7事件发生, 说明接收到了新数据 */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)\n    {\n       ;\n    }\n    /* 将接收到的数据赋值给Data变量 */\n    *Data = I2C_ReceiveData(EEPROM_I2C);\n    /* STM32产生NO ACK响应 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写Sequential Read方式的函数\n\n```c\n/**\n * @brief 函数实现STM32从EEPROM以Sequential Read方式读取数据\n * @param WordAddress: 要读取数据的地址\n * @param Data: 读取数据要写入到的变量\n * @param NumByteToRead: 要读取数据的个数\n * @retval None\n */\nvoid EEPROM_Sequential_Read(uint8_t WordAddress, uint8_t* Data, uint8_t NumByteToRead)\n{\n/*---------------- STM32发送WordAddress ----------------*/\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    /* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)\n    {\n      ;\n    }\n    /* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */\n    /* STM32向EEPROM发送WordAddress */\n    I2C_SendData(EEPROM_I2C, WordAddress);\n    /* 等待EV8事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)\n    {\n        ;\n    }\n  /*---------------- STM32接收Data ----------------*/\n    /* STM32另外产生一个START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的读地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);\n    /* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */\n    while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)\n    {\n       ;\n    }\n    /*------------------------------------------------------------------------\n    * 注意: \n    * 该部分为STM32接收来自EEPROM的数据\n    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作\n    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据\n    * 而不是进行数据接收\n    *------------------------------------------------------------------------*/\n    while(NumByteToRead)\n    {\n        if (NumByteToRead == 1) /* 如果为最后一个字节, 产生NO ACK响应 */\n        {\n            /* STM32产生NO ACK响应 */\n            I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);\n        }\n        /* 监测到EV7事件发生, 说明接收到了新数据 */\n        while(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)\n        {\n            \n        }\n        /* 将接收到的数据赋值给Data变量 */\n        *Data = I2C_ReceiveData(EEPROM_I2C);\n        /* Data 指针自增 */\n        Data++;\n        /* NumByteToRead递减 */\n        NumByteToRead--;\n    }\n    /* STM32产生STOP信号 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n    /* STM32使能ACK信号, 恢复到默认状态 */\n    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在bsp_i2c.c中编写确认询问函数\n\n```c\n/**\n * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认轮询\n *   一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。\n *   这涉及发送一个启动条件，后跟设备地址。\n *   读/写位是代表所需的操作。\n *   仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列\n *   以上步骤称为ACKNOWLEDGE POLLING\n * @param None\n * @retval None\n */\nvoid EEPROM_ACK_Polling(void)\n{\n    do\n    {\n    /* STM32产生START信号 */\n    I2C_GenerateSTART(EEPROM_I2C, ENABLE);\n    /* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */\n    while(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)\n    {\n       ;\n    }\n    /* STM32发送EEPROM的写地址 */\n    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);\n    } while (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); \n    /* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */\n    /* 结束轮询 */\n    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);\n}\n```\n\n#### 在main.c中进行读写测试\n\n```c\n/**\n  ******************************************************************************\n  * @file    main.c\n  * @author  eric\n  * @version V0.0.1\n  * @date    27-January-2024\n  * @brief   STM32与EEPROM通过I2C协议进行读写测试\n  ******************************************************************************\n  * @attention\n  *\n  * THE PRESENT FUNTIONS WHICH IS FOR GUIDANCE ONLY\n  ******************************************************************************\n  */\n\n/* Includes ------------------------------------------------------------------*/\n#include \"stm32f10x.h\"\n#include \"stm32f10x_conf.h\"\n#include \"bsp_led.h\"\n#include \"bsp_usart.h\"\n#include \"bsp_i2c.h\"\n\n/*----------------------------------------------------------------------------\n * 操作流程:\n * \n * 1. 初始化I2C相关的GPIO\n * 2. 配置I2C外设的工作模式\n * 3. 编写I2C写入EEPROM的Byte Write函数 \n * 4. 编写I2C读取EEPROM的Random Read函数\n * 5. 使用read函数和write函数进行读写校验\n * 6. 编写Page Write和Sequential Read函数进行校验\n *----------------------------------------------------------------------------*/\n\n/**\n * @defgroup: Global_Values\n * @{  \n */\n\nuint8_t ReadData[20] = {0};\nuint8_t WriteData[3] = {3, 4, 5};\n\n/**\n * @} \n * \n */\n\n/**\n * @brief STM32与EEPROM通过I2C协议进行读写测试 \n * @param None\n * @retval None \n */\nint main(void)\n{\n    /* 初始化USART */\n    USART_Config(); \n    /* 串口打印 */\n    printf(\"I2C-EEPROM\\n\");\n    /* 初始化I2C */\n    I2C_EEPROM_Config();\n    /* STM32向EEPROM 地址1写入数据0x01 */\n    EEPROM_Byte_Writting(1, 0x01);\n    /* ACKNOWLEDGE POLLING 确认询问 */\n    EEPROM_ACK_Polling();\n    /* STM32向EEPROM 地址2写入数据0x02 */\n    EEPROM_Byte_Writting(2, 0x02);\n    /* ACKNOWLEDGE POLLING 确认询问 */\n    EEPROM_ACK_Polling();\n    /*----------------------------------------\n     * Page Writting的地址对齐\n     * 为保证数据无误需addr%8 == 0\n     *----------------------------------------*/ \n    /* STM32向EEPROM 地址3-5写入数据0x03-0x05 */\n    EEPROM_Page_Writting(0x03, WriteData, 3);\n    /* ACKNOWLEDGE POLLING 确认询问 */\n    EEPROM_ACK_Polling();\n    /* STM32从EEPROM以SequentialRead方式读取地址1-4的数据 */ \n    EEPROM_Sequential_Read((uint8_t)1, ReadData, 4);\n    /* STM32从EEPROM以RandomRead方式读取地址5的数据 */ \n    EEPROM_Random_Read((uint8_t)5, &ReadData[4]);\n    /* 将读出的数据循环打印 */\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        printf(\"ReadData[%d] = 0x%x\\n\", i, ReadData[i]);\n    }\n    \n    /* 空循环 */\n    while(1)\n    {\n        ;\n    }\n}\n\n```\n\n#### 串口实验现象\n\n![实验现象](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280831099.png)\n\n#### 完善功能\n\n以下函数是对实验中出现函数的进一步完善, 源文件不在工程中\n\n##### 增加的宏定义\n\n```c\n/* STM32 I2C 快速模式 */\n#define I2C_Speed              400000  //*\n\n/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */\n#define I2Cx_OWN_ADDRESS7      0X0A   \n\n/* AT24C01/02每页有8个字节 */\n#define I2C_PageSize           8\n\n/* AT24C04/08A/16A每页有16个字节 */\n//#define I2C_PageSize           16\n\n/*等待超时时间*/\n#define I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)\n#define I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT)\n```\n\n##### 调试功能\n\n```c\n#define EEPROM_DEBUG_ON         0\n\n#define EEPROM_INFO(fmt,arg...)           printf(\"<<-EEPROM-INFO->> \"fmt\"\\n\",##arg)\n#define EEPROM_ERROR(fmt,arg...)          printf(\"<<-EEPROM-ERROR->> \"fmt\"\\n\",##arg)\n#define EEPROM_DEBUG(fmt,arg...)          do{\\\n                                          if(EEPROM_DEBUG_ON)\\\n                                          printf(\"<<-EEPROM-DEBUG->> [%s][%d]\"fmt\"\\n\", __FILE__, __LINE__, ##arg);\\\n                                          }while(0)\n```\n\n##### 超时处理函数\n\n完善了对于超时的处理\n\n###### 超时处理相关宏定义\n\n```c\n/*等待超时时间*/\n#define I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)\n#define I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))\n```\n\n###### 超时处理相关变量声明\n\n```c\nstatic __IO uint32_t  I2CTimeout = I2CT_LONG_TIMEOUT;\n\nstatic uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode);\n```\n\n###### 超时状态函数\n\n```c\n/**\n  * @brief  Basic management of the timeout situation.\n  * @param  errorCode：错误代码，可以用来定位是哪个环节出错.\n  * @retval 返回0，表示IIC读取失败.\n  */\nstatic  uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)\n{\n  /* Block communication and all processes */\n  EEPROM_ERROR(\"I2C 等待超时!errorCode = %d\",errorCode);\n  \n  return 0;\n}\n```\n\n##### 多字节写入函数\n\n完善了在Page Write中字节对齐的情况\n\n```c\n/**\n  * @brief   将缓冲区中的数据写到I2C EEPROM中\n  * @param   \n  *  @arg pBuffer:缓冲区指针\n  *  @arg WriteAddr:写地址\n  *     @arg NumByteToWrite:写的字节数\n  * @retval  无\n  */\nvoid I2C_EE_BufferWrite(u8* pBuffer, u8 WriteAddr, u16 NumByteToWrite)\n{\n  u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;\n\n  Addr = WriteAddr % I2C_PageSize;\n  count = I2C_PageSize - Addr;\n  NumOfPage =  NumByteToWrite / I2C_PageSize;\n  NumOfSingle = NumByteToWrite % I2C_PageSize;\n \n  /* If WriteAddr is I2C_PageSize aligned  */\n  if(Addr == 0) \n  {\n    /* If NumByteToWrite < I2C_PageSize */\n    if(NumOfPage == 0) \n    {\n      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);\n      I2C_EE_WaitEepromStandbyState();\n    }\n    /* If NumByteToWrite > I2C_PageSize */\n    else  \n    {\n      while(NumOfPage--)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); \n     I2C_EE_WaitEepromStandbyState();\n        WriteAddr +=  I2C_PageSize;\n        pBuffer += I2C_PageSize;\n      }\n\n      if(NumOfSingle!=0)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);\n        I2C_EE_WaitEepromStandbyState();\n      }\n    }\n  }\n  /* If WriteAddr is not I2C_PageSize aligned  */\n  else \n  {\n    /* If NumByteToWrite < I2C_PageSize */\n    if(NumOfPage== 0) \n    {\n      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);\n      I2C_EE_WaitEepromStandbyState();\n    }\n    /* If NumByteToWrite > I2C_PageSize */\n    else\n    {\n      NumByteToWrite -= count;\n      NumOfPage =  NumByteToWrite / I2C_PageSize;\n      NumOfSingle = NumByteToWrite % I2C_PageSize; \n      \n      if(count != 0)\n      {  \n        I2C_EE_PageWrite(pBuffer, WriteAddr, count);\n        I2C_EE_WaitEepromStandbyState();\n        WriteAddr += count;\n        pBuffer += count;\n      } \n      \n      while(NumOfPage--)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);\n        I2C_EE_WaitEepromStandbyState();\n        WriteAddr +=  I2C_PageSize;\n        pBuffer += I2C_PageSize;  \n      }\n      if(NumOfSingle != 0)\n      {\n        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); \n        I2C_EE_WaitEepromStandbyState();\n      }\n    }\n  }  \n}\n```\n\n##### 单字节写入函数\n\n增加超时处理\n\n```c\n/**\n  * @brief   写一个字节到I2C EEPROM中\n  * @param   \n  * @arg pBuffer:缓冲区指针\n  * @arg WriteAddr:写地址 \n  * @retval  无\n  */\nuint32_t I2C_EE_ByteWrite(u8* pBuffer, u8 WriteAddr) \n{\n  /* Send START condition */\n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n\n  I2CTimeout = I2CT_FLAG_TIMEOUT;  \n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);\n  } \n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Send EEPROM address for write */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n  \n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);\n  }  \n  /* Send the EEPROM's internal address to write to */\n  I2C_SendData(EEPROM_I2Cx, WriteAddr);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV8 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(2);\n  } \n  \n  /* Send the byte to be written */\n  I2C_SendData(EEPROM_I2Cx, *pBuffer); \n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;  \n  /* Test on EV8 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);\n  } \n  \n  /* Send STOP condition */\n  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);\n  \n  return 1;\n}\n```\n\n##### 单页写入函数\n\n```c\n/**\n  * @brief   在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数\n  *          不能超过EEPROM页的大小，AT24C02每页有8个字节\n  * @param   \n  *     @arg pBuffer:缓冲区指针\n  *     @arg WriteAddr:写地址\n  *     @arg NumByteToWrite:写的字节数\n  * @retval  无\n  */\nuint32_t I2C_EE_PageWrite(u8* pBuffer, u8 WriteAddr, u8 NumByteToWrite)\n{\n  I2CTimeout = I2CT_LONG_TIMEOUT;\n\n  while(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))   \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);\n  } \n  \n  /* Send START condition */\n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(5);\n  } \n  \n  /* Send EEPROM address for write */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  \n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(6);\n  } \n  \n  /* Send the EEPROM's internal address to write to */    \n  I2C_SendData(EEPROM_I2Cx, WriteAddr);  \n\n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV8 and clear it */\n  while(! I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(7);\n  } \n\n  /* While there is data to be written */\n  while(NumByteToWrite--)  \n  {\n    /* Send the current byte */\n    I2C_SendData(EEPROM_I2Cx, *pBuffer); \n\n    /* Point to the next byte to be written */\n    pBuffer++; \n  \n    I2CTimeout = I2CT_FLAG_TIMEOUT;\n\n    /* Test on EV8 and clear it */\n    while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n    {\n      if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);\n    } \n  }\n\n  /* Send STOP condition */\n  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);\n  \n  return 1;\n}\n```\n\n##### 读取数据函数\n\n```c\n/**\n  * @brief   从EEPROM里面读取一块数据 \n  * @param   \n  *     @arg pBuffer:存放从EEPROM读取的数据的缓冲区指针\n  *     @arg WriteAddr:接收数据的EEPROM的地址\n  *     @arg NumByteToWrite:要从EEPROM读取的字节数\n  * @retval  无\n  */\nuint32_t I2C_EE_BufferRead(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)\n{  \n  \n  I2CTimeout = I2CT_LONG_TIMEOUT;\n  \n  //*((u8 *)0x4001080c) |=0x80; \n  while(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);\n   }\n  \n  /* Send START condition */\n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n  //*((u8 *)0x4001080c) &=~0x80;\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);\n   }\n  \n  /* Send EEPROM address for write */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n\n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(11);\n   }\n    \n  /* Clear EV6 by setting again the PE bit */\n  I2C_Cmd(EEPROM_I2Cx, ENABLE);\n\n  /* Send the EEPROM's internal address to write to */\n  I2C_SendData(EEPROM_I2Cx, ReadAddr);  \n\n   \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV8 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(12);\n   }\n    \n  /* Send START condition a second time */  \n  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV5 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(13);\n   }\n    \n  /* Send EEPROM address for read */\n  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver);\n  \n  I2CTimeout = I2CT_FLAG_TIMEOUT;\n  /* Test on EV6 and clear it */\n  while(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))\n  {\n    if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);\n   }\n  \n  /* While there is data to be read */\n  while(NumByteToRead)  \n  {\n    if(NumByteToRead == 1)\n    {\n      /* Disable Acknowledgement */\n      I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);\n      \n      /* Send STOP Condition */\n      I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);\n    }\n\n    /* Test on EV7 and clear it */    \n    I2CTimeout = I2CT_LONG_TIMEOUT;\n    \n    while(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==0)  \n    {\n        if((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);\n    } \n    {      \n      /* Read a byte from the EEPROM */\n      *pBuffer = I2C_ReceiveData(EEPROM_I2Cx);\n\n      /* Point to the next location where the byte read will be saved */\n      pBuffer++; \n      \n      /* Decrement the read bytes counter */\n      NumByteToRead--;        \n    }   \n  }\n\n  /* Enable Acknowledgement to be ready for another reception */\n  I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);\n  \n    return 1;\n}\n```\n\n##### 等待EEPROM函数\n\n```c\n/**\n  * @brief  Wait for EEPROM Standby state \n  * @param  无\n  * @retval 无\n  */\nvoid I2C_EE_WaitEepromStandbyState(void)      \n{\n  vu16 SR1_Tmp = 0;\n\n  do\n  {\n    /* Send START condition */\n    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);\n    /* Read I2C1 SR1 register */\n    SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1);\n    /* Send EEPROM address for write */\n    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);\n  }while(!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) & 0x0002));\n  \n  /* Clear AF flag */\n  I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF);\n    /* STOP condition */    \n    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); \n}\n```\n\n","slug":"STM32F103学习笔记","published":1,"updated":"2024-01-29T08:41:57.574Z","_id":"clrgok3h30000ck974lk05ny7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"stm32f103学习笔记\">STM32F103学习笔记</h1>\n<h2 id=\"说明\">说明</h2>\n<p>本库仅供学习交流使用</p>\n<ul>\n<li>开发板: 野火霸道V2开发板</li>\n<li>编译器： ARM v5.06</li>\n<li>C编译版本: C99</li>\n<li>固件库版本: V3.5.0</li>\n<li>MDK version: 538A</li>\n<li>芯片包: Keil.STM32F1xx_DFP.2.4.1</li>\n<li>芯片型号: STM32F103ZET6</li>\n<li>参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道/指南者/MINI)【全】(刘火良老师出品) (无字幕)】 <a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4</a></li>\n<li>仓库地址: <a href=\"https://github.com/See-YouL/Fire-Projects.git\">https://github.com/See-YouL/Fire-Projects.git</a></li>\n</ul>\n<h2 id=\"基础配置\">基础配置</h2>\n<h3 id=\"配置keilmdk\">配置KeilMDK</h3>\n<p>看视频配置KeilMDK,P2</p>\n<p><a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw\">看视频配置Keil MDK</a></p>\n<h3 id=\"配置串口下载程序\">配置串口下载程序</h3>\n<p>看视频配置串口下载程序,P4</p>\n<p><a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw\">看视频配置串口下载程序</a></p>\n<h3 id=\"美化keil界面\">美化Keil界面</h3>\n<p><strong>非必须步骤</strong>, 用来美化界面</p>\n<p><a href=\"https://www.bilibili.com/video/BV1uT411S7mB/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">使用该方案的插件</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Df4y1k75Z/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">使用该方案的主题配色</a></p>\n<h3 id=\"配置vscode\">配置VScode</h3>\n<p><strong>非必须步骤</strong>, 用来使用VScode开发, <em>也可使用Keil MDK则不需要该步骤</em></p>\n<p>方案一: 使用VScode + Keil5 MDK进行开发(主要插件<strong>Keil Assistant</strong>)</p>\n<ul>\n<li>优点: 不需要使用Keil进行编辑</li>\n<li>缺点: 不具备Debug功能,只有编译和烧录</li>\n</ul>\n<p><a href=\"https://www.bilibili.com/video/BV19V411g7gD/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">方案一参考视频</a></p>\n<p>方案二: 使用Vscode + EIDE进行开发(主要插件<strong>EIDE</strong>)</p>\n<ul>\n<li>优点: 可在VScode中进行调试</li>\n<li>缺点: 依赖Keil的编译环境</li>\n</ul>\n<p><a href=\"https://www.bilibili.com/video/BV1nr4y1R7Jb/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">方案二参考视频</a></p>\n<h2 id=\"理论知识\">理论知识</h2>\n<h3 id=\"stm32命名方式\">STM32命名方式</h3>\n<ul>\n<li>STM32: 32bit的MCU</li>\n<li>F或L: F表示基础型(Foundation)或高性能型(High-Performance), L表示低功耗型(Ultra-low-power)</li>\n<li>xxx: 芯片特性, 如性能级别、内存大小、特殊功能等</li>\n<li>系列:\n<ul>\n<li>F0, F1, F2, F3, F4, F7：这些数字代表不同的性能级别，数字越大，性能通常越高。</li>\n<li>L0, L1, L4, L5：这些是低功耗系列，数字越大，性能和功能通常越丰富。</li>\n</ul>\n</li>\n<li>性能级别: 通常由一到两位数字表示，如STM32F103或STM32L152。这些数字表示不同的性能级别、内存大小和外设</li>\n<li>包装类型: 通常由一个字母表示，如STM32F103C8T6中的C表示LQFP48封装</li>\n<li>额外特性: 如STM32F103C8T6中的8表示该芯片有64KB闪存，T表示温度范围（-40°C 到 85°C），6表示批次号或版本</li>\n</ul>\n<h4 id=\"例子\">例子</h4>\n<p>以 STM32F103C8T6 为例：</p>\n<ul>\n<li>STM32：STMicroelectronics的32位微控制器。</li>\n<li>F：Foundation系列。</li>\n<li>103：该系列中的特定型号，具有特定的性能、内存和外设配置。</li>\n<li>C：封装类型，这里是LQFP48。</li>\n<li>8：闪存大小，这里是64KB。</li>\n<li>T：温度范围，这里是-40°C 到 85°C。</li>\n<li>6：批次号或版本。</li>\n</ul>\n<h2 id=\"置位与清零\">置位与清零</h2>\n<ul>\n<li>&amp;= ~(1 &lt;&lt; n); <strong>将bit n清零,其他位保持不变</strong></li>\n<li>|= (1 &lt;&lt; n); <strong>将bit n置1,其他位保持不变</strong></li>\n</ul>\n<h2 id=\"gpio\">GPIO</h2>\n<h3 id=\"gpio简介\">GPIO简介</h3>\n<p>GPIO(General purpose input output)通用输入输出端口的简称,<strong>软件可以控制的引脚,可输入可输出</strong></p>\n<h4 id=\"gpio和引脚的区别\">GPIO和引脚的区别</h4>\n<p>引脚（Pin）</p>\n<ul>\n<li>定义：引脚是指微控制器、微处理器或其他电子组件上的物理接点。它们是硬件设备的一部分，用于连接电路板、传递信号或供电。</li>\n<li>通用性：引脚可以有多种功能，包括但不限于传输数据、供电、接地或作为特殊功能的接口（如模拟输入、PWM输出等）。</li>\n<li>物理特性：引脚是实体的、物理存在的，可以是金属的脚或焊盘。</li>\n</ul>\n<p>GPIO（General-Purpose Input/Output）</p>\n<ul>\n<li>定义：GPIO是指在微控制器或其他数字电路设备上的一种特定类型的引脚，可以通过编程设置为输入或输出模式。</li>\n<li>功能：GPIO引脚的功能非常灵活，可以用于读取数字信号（如按钮的按压）或输出数字信号（如控制LED灯的开关）。</li>\n<li>编程控制：GPIO引脚的主要特点是它们可以通过软件编程来控制其行为，这使得它们非常适合于各种通用的数字输入输出任务。</li>\n</ul>\n<p>区别</p>\n<ul>\n<li>功能范围：所有GPIO都是引脚，但并非所有引脚都是GPIO。引脚是一个更广泛的概念，包括GPIO以及其他专用功能的引脚。</li>\n<li>灵活性和用途：GPIO引脚特别设计用于通用的数字输入输出任务，并且它们的行为可以通过软件编程来改变。而其他类型的引脚可能有固定的功能，如电源、接地或特定的通信功能。</li>\n<li>编程控制：GPIO的关键特性是它们可以被编程来执行不同的任务（输入或输出），而其他类型的引脚可能不具备这种灵活性。</li>\n</ul>\n<p>总的来说，<strong>GPIO是引脚的一个子集，专门用于可编程的通用数字输入输出任务。而引脚是一个更广泛的概念，涵盖了电子设备上的所有物理接点。</strong></p>\n<h4 id=\"引脚的分类\">引脚的分类</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png\" alt=\"引脚的分类\"></p>\n<h3 id=\"gpio-框图讲解\">GPIO 框图讲解</h3>\n<h4 id=\"保护二极管\">保护二极管</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.41.14.png\" alt=\"保护二极管\"></p>\n<ul>\n<li><strong>如果引脚电压大于VDD则上面的保护二极管导通</strong>,防止高电压进入芯片内部,如果电压过高则会烧坏二极管进而烧坏芯片</li>\n<li><strong>如果引脚电压低于VSS则下面的保护二极管导通</strong>,保护芯片</li>\n</ul>\n<h4 id=\"推挽输出\">推挽输出</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.09.27.png\" alt=\"ODR=1时推挽输出原理图\"></p>\n<p>推挽输出部分的INT来自ODR寄存器</p>\n<p>若ODR为1, 经过反相器后为0, 此时PMOS和NMOS的Ug=0V</p>\n<p>对于PMOS, Us=3.3V &gt; Ug=0V, PMOS管导通, OUT=VDD</p>\n<p>对于NMOS, Us=0V = Ug=0V, 简单认为, NMOS管截止</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.20.46.png\" alt=\"ODR=0时推挽输出原理图\"></p>\n<p>若ODR为0,经过反相器后为1, 此时PMOS和NMOS的Ug=3.3V</p>\n<p>对于PMOS, Us=3.3V = Ug=3.3V, 简单认为, PMOS管截止</p>\n<p>对于NMOS, Us=0V &lt; Ug=3.3V, NMOS管导通, OUT=GND=0V</p>\n<h5 id=\"推挽输出的含义\">推挽输出的含义</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.23.18.png\" alt=\"推挽输出含义图\"></p>\n<ul>\n<li>PMOS导通时, OUT处电流向外称为<strong>推</strong>, 此时电流称为<strong>灌电流</strong></li>\n<li>NMOS导通时, OUT处电流向里称为<strong>挽</strong>, 此时电流称为<strong>拉电流</strong></li>\n</ul>\n<p>推挽输出（Push-Pull Output）是一种常见的电子电路输出类型，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的<strong>主要特点是它使用两个晶体管（一个N型和一个P型）来控制输出引脚的电压状态。</strong></p>\n<h5 id=\"推挽输出的原理\">推挽输出的原理</h5>\n<p>在推挽配置中，通常有两个晶体管：</p>\n<ul>\n<li>N型晶体管：当被激活（或导通）时，它将输出引脚连接到地（GND），从而产生低电平（0）输出。</li>\n<li>P型晶体管：当被激活时，它将输出引脚连接到正电源（VCC），从而产生高电平（1）输出。</li>\n</ul>\n<p>这两个晶体管不会同时导通，以避免短路。在任何给定的时刻，要么N型晶体管导通将输出拉低，要么P型晶体管导通将输出拉高。</p>\n<h5 id=\"推挽输出的特点\">推挽输出的特点</h5>\n<ul>\n<li>强驱动能力：<strong>推挽输出可以提供较强的电流驱动能力</strong>，无论是向输出引脚提供电流（高电平）还是从引脚吸收电流（低电平）。</li>\n<li>确定的逻辑状态：输出要么明确地是高电平，要么是低电平，<strong>不会处于悬空（高阻态）状态</strong>。</li>\n<li>无需外部上拉或下拉电阻：由于<strong>推挽输出自身就可以明确地驱动高电平或低电平</strong>，因此不需要外部的上拉或下拉电阻来确保稳定的输出状态。</li>\n</ul>\n<h5 id=\"推挽输出的应用\">推挽输出的应用</h5>\n<p>推挽输出广泛应用于各种数字电路，特别是<strong>在需要驱动LED、继电器或其他需要较高电流的负载时</strong>。由于其<strong>强大的驱动能力和清晰的逻辑电平</strong>，推挽输出是实现<strong>数字信号传输</strong>的理想选择。</p>\n<h5 id=\"推挽输出对比开漏/开集输出\">推挽输出对比开漏/开集输出</h5>\n<p>与推挽输出相对的是开漏（在MOSFET技术中）或开集（在双极晶体管技术中）输出，<strong>这种类型的输出只有一个晶体管，要么将输出拉低，要么让它悬空（高阻态）</strong>。开漏/开集输出<strong>需要外部上拉电阻来确保高电平状态</strong>，常用于需要多个设备共享同一输出线的应用，如I2C通信协议。</p>\n<h4 id=\"开漏输出\">开漏输出</h4>\n<p>内部只能输出低电平,不能输出高电平</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png\" alt=\"当ODR为1时开漏输出原理图\"></p>\n<p>该图片标注有误, 实际用的是ODR=0时的图, 但是结构相同, 不影响分析</p>\n<p>ODR=1, 经反相器为0, Vg=0V=Vs=0V, NMOS管截止, 此时OUT为高阻态悬空, 加入外部上拉电阻后, OUT=1</p>\n<p>如果外部需要高电平驱动可以通过更换外部上拉电路来进行更换</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png\" alt=\"当ODR为0时开漏输出原理图\"></p>\n<p>ODR=0, 经反相器为1, Vg=1 &gt; Vs=0, NMOS管导通, 此时OUT=0V</p>\n<p>开漏输出（Open-Drain Output，在使用MOSFET技术的情况下称为开漏，而在使用双极性晶体管的情况下称为开集（Open-Collector）输出）是一种常见的电子电路设计，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的<strong>主要特点是它使用单个晶体管来控制输出引脚的电压状态，而不是像推挽输出那样使用两个晶体管。</strong></p>\n<h5 id=\"开漏输出的原理\">开漏输出的原理</h5>\n<p>在开漏配置中，只有一个N型晶体管：</p>\n<ul>\n<li>N型晶体管：当晶体管导通（激活）时，它将输出引脚连接到地（GND），产生低电平（0）输出。当晶体管关闭（非激活）时，输出引脚不连接到任何东西，处于悬空状态。</li>\n<li>由于输出在晶体管关闭时处于悬空状态，因此通常需要一个外部的上拉电阻连接到正电源（VCC），以确保当晶体管关闭时输出能够达到高电平（1）。</li>\n</ul>\n<h5 id=\"开漏输出的特点\">开漏输出的特点</h5>\n<ul>\n<li>单向驱动能力：开漏输出<strong>只能将输出拉低，不能主动驱动高电平</strong>。</li>\n<li>需要外部上拉电阻：<strong>为了确保输出能够达到高电平，需要外部上拉电阻</strong>。</li>\n<li>适合于总线和共享线路：开漏输出非常<strong>适合于多个设备共享同一输出线的应用</strong>，因为任何一个设备都可以将线路拉低，而不会对其他设备造成干扰。</li>\n</ul>\n<h5 id=\"开漏输出的应用\">开漏输出的应用</h5>\n<p>开漏输出<strong>常用于需要多个设备共享同一通信线路的场合</strong>，如I2C和1-Wire通信协议。在这些应用中，<strong>多个设备可以连接到同一条线路上，每个设备都可以通过将线路拉低来发送信号，而不会影响其他设备。</strong></p>\n<h5 id=\"开漏输出对比推挽输出\">开漏输出对比推挽输出</h5>\n<p>与开漏输出相对的是推挽输出，后者使用两个晶体管（一个N型和一个P型）来分别驱动高电平和低电平。推挽输出可以主动驱动高电平和低电平，而<strong>开漏输出只能驱动低电平，需要外部上拉电阻来实现高电平状态。</strong></p>\n<h4 id=\"补充:-高阻态与悬空\">补充: 高阻态与悬空</h4>\n<p><strong>高阻态（High-Impedance State），通常简称为Hi-Z</strong>，是电子电路中的一个术语，用来描述一个电路节点在特定条件下呈现出非常高电阻的状态。在这种状态下，<strong>电路节点既不明显地连接到电源（高电平），也不明显地连接到地（低电平）</strong>。换句话说，这个节点处于一种“断开”或“浮空”的状态，对电路中的其他部分几乎没有任何电气影响。</p>\n<h5 id=\"高阻态的应用\">高阻态的应用</h5>\n<ul>\n<li><strong>三态逻辑（Tri-state Logic）</strong>：在数字电路中，高阻态常用于三态逻辑，<strong>允许多个输出连接到同一个线路或总线上，而不会相互干扰</strong>只有被选中的设备会将其输出置于低电阻状态（高电平或低电平），其他设备的输出则处于高阻态。</li>\n<li><strong>总线系统</strong>：在微处理器、微控制器和其他数字系统的总线（如数据总线、地址总线）上，高阻态用于控制哪个设备可以在特定时刻向总线发送数据。</li>\n<li><strong>输入/输出端口</strong>：在可编程的微控制器的GPIO（通用输入/输出）端口中，<strong>高阻态可以用来防止未使用的或被配置为输入的端口对电路造成影响</strong>。</li>\n</ul>\n<h5 id=\"高阻态的重要性\">高阻态的重要性</h5>\n<ul>\n<li><strong>避免冲突</strong>：在多个设备共享同一通信线路时，高阻态可以防止输出冲突。</li>\n<li><strong>节能</strong>：当端口处于高阻态时，它几乎不消耗电流，有助于降低功耗。</li>\n<li><strong>灵活性</strong>：高阻态提供了电路设计的灵活性，特别是在需要多个设备共享同一资源的情况下。</li>\n</ul>\n<h5 id=\"高阻态的注意事项\">高阻态的注意事项</h5>\n<ul>\n<li><strong>浮动电压</strong>：当一个端口或线路处于高阻态时，它可能会因为电磁干扰或静电感应而捕获不确定的电压，<strong>有时可能需要通过上拉或下拉电阻来确保稳定的逻辑状态</strong>。</li>\n<li><strong>设计考虑</strong>：在设计电路和编写程序时，需要考虑到高阻态的影响，确保在适当的时候启用或禁用高阻态。</li>\n</ul>\n<p>在电子电路中，<strong>“悬空”（Floating）是指一个电路节点没有被明确连接到电源（高电平）或地（低电平），也没有通过任何电阻或其他电子元件连接到其他电路节点的状态</strong>这种状态下的节点电压是不确定的，因为它既不是被固定在逻辑高也不是逻辑低，而是可以随外部电磁场或附近电路的状态变化而变化。</p>\n<h5 id=\"悬空状态的特点\">悬空状态的特点</h5>\n<ul>\n<li>不确定的电压：悬空的节点可能会随机地捕获周围环境的电磁干扰，导致其电压处于不确定的状态。</li>\n<li>易受干扰：由于没有明确的电气连接，悬空的节点容易受到外部电磁干扰的影响。</li>\n<li>可能导致问题：在数字电路中，悬空的输入引脚可能导致不稳定的逻辑状态，从而引发电路的不可预测行为。</li>\n</ul>\n<h5 id=\"高阻态与悬空的关系\">高阻态与悬空的关系</h5>\n<p>高阻态是一种特定的电路配置，<strong>其中一个节点（如微控制器的GPIO引脚）被设置为非常高的电阻状态。这意味着该节点对电路的其他部分几乎没有电气影响，类似于断开连接</strong>因此，<strong>当一个引脚被设置为高阻态时，它实际上是在悬空状态</strong>，因为它既不是明确地连接到高电平也不是低电平。</p>\n<h5 id=\"高阻态与悬空区别和联系\">高阻态与悬空区别和联系</h5>\n<ul>\n<li>联系：<strong>高阻态通常会导致节点悬空</strong>当一个节点处于高阻态时，由于其极高的电阻值，它实际上与电路的其他部分隔离，从而处于悬空状态。</li>\n<li>区别：<strong>高阻态是一种有意设置的电路状态</strong>，用于特定的目的（如防止总线冲突）。而<strong>悬空可能是无意的</strong>，可能是由于设计不当或电路未完成造成的。</li>\n</ul>\n<h5 id=\"悬空的注意事项\">悬空的注意事项</h5>\n<ul>\n<li>设计考虑：在设计电子电路和系统时，<strong>应避免输入引脚悬空，因为这可能导致不稳定的行为</strong>。通常<strong>使用上拉或下拉电阻来确保这些引脚有一个确定的逻辑状态。</strong></li>\n<li>高阻态应用：在某些情况下，如<strong>多个设备共享一个通信总线，高阻态是必要的，以确保只有一个设备在任何时刻控制总线。</strong></li>\n</ul>\n<h4 id=\"复用功能输出\">复用功能输出</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.18.55.png\" alt=\"复用功能输出原理框图\"></p>\n<p>通过片上外设如EXTI到引脚输出</p>\n<h4 id=\"输入模式\">输入模式</h4>\n<p>ISR读出</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.24.03.png\" alt=\"普通模式的输入\"></p>\n<p>I/O引脚至上拉/下拉输入(通过BSRR寄存器软件配置), 经TTL肖特基触发器(&gt;2V &lt;1.2V), 至IDR寄存器读出</p>\n<p>复用功能输入</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.29.40.png\" alt=\"复用功能输入\"></p>\n<p>以EXTI为例,RX数据经由TTL肖特基触发器到DR寄存器</p>\n<p>模拟输入</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.33.21.png\" alt=\"模拟输入框图\"></p>\n<p>不经过TTL肖特基触发器直接被读出</p>\n<h4 id=\"gpio框图对应寄存器\">GPIO框图对应寄存器</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.35.42.png\" alt=\"GPIO框图\"></p>\n<ul>\n<li>2部分: 推挽,开漏输出对应CRL,CRH寄存器</li>\n<li>3部分: 输出数据寄存器对应ODR; 位设置/清除寄存器对应BSRR</li>\n<li>上拉/下拉输入: 对应CRL,CRH,具体选择上拉还是下拉需要软件配置BSRR</li>\n<li>5部分: 输入数据寄存器对应IDR</li>\n</ul>\n<h3 id=\"gpio输出初始化顺序\">GPIO输出初始化顺序</h3>\n<ol>\n<li>时钟使能</li>\n<li>选择具体的GPIO</li>\n<li>配置GPIO的工作模式(CRL CRH)</li>\n<li>控制GPIO输出高低电平(ODR,BRR和BSRR)</li>\n</ol>\n<h2 id=\"手写库\">手写库</h2>\n<h3 id=\"通过地址使用寄存器\">通过地址使用寄存器</h3>\n<p>项目地址: <strong>REG-LED</strong></p>\n<h4 id=\"mainc中的主要代码\">main.c中的主要代码</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">0x40021018</span>) |= ((<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span>); <span class=\"comment\">// RCC_APB2ENR的bit3置1</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">开启GPIOB的时钟</span></span><br><span class=\"line\"><span class=\"comment\">GPIOB挂载在APB2总线</span></span><br><span class=\"line\"><span class=\"comment\">RCC_APB2ENR的偏移量为0x18</span></span><br><span class=\"line\"><span class=\"comment\">RCC的基地址为0x40021000</span></span><br><span class=\"line\"><span class=\"comment\">RCC_APB2ENR的bit3为IOPBEN(IO端口B时钟使能) 1开启</span></span><br><span class=\"line\"><span class=\"comment\">****************************************************************************/</span></span><br><span class=\"line\">*(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">0x40010C00</span>) |= ((<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>)); <span class=\"comment\">// GPIOB_CRL的bit4-0置0001</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">将GPIOB设置为推挽输出</span></span><br><span class=\"line\"><span class=\"comment\">GPIOB 基地址 0x40010C00</span></span><br><span class=\"line\"><span class=\"comment\">GPIOx_CRL 偏移量 00h </span></span><br><span class=\"line\"><span class=\"comment\">bit1-0: 01 输出模式，最大速度10MHz</span></span><br><span class=\"line\"><span class=\"comment\">bit4-3: 00 通用推挽输出模式</span></span><br><span class=\"line\"><span class=\"comment\">((1) &lt;&lt; (4*0)) // 若修改PB1则为(4*1)</span></span><br><span class=\"line\"><span class=\"comment\">****************************************************************************/</span></span><br><span class=\"line\">*(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">0x40010C0C</span>) &amp;= ~(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>); <span class=\"comment\">// GPIOB_ODR的bit0置0</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">修改PB0为1</span></span><br><span class=\"line\"><span class=\"comment\">GPIOB 基地址 0x40010C00</span></span><br><span class=\"line\"><span class=\"comment\">GPIOx_ODR 偏移量 0Ch </span></span><br><span class=\"line\"><span class=\"comment\">****************************************************************************/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"通过头文件定义使用寄存器\">通过头文件定义使用寄存器</h3>\n<p>项目地址: <strong>REG-LED-Register</strong></p>\n<p>确定总线基地址, 其中AHB的基地址是从DMA1开始的,即从0x40020000开始</p>\n<h4 id=\"在stm32f10xh中增加宏定义\">在stm32f10x.h中增加宏定义</h4>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存放stm32寄存器映射的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外设 Peripheral</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PERIPH_BASE ((unsigned int)0x40000000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APB1PERIPH_BASE (PERIPH_BASE) <span class=\"comment\">// 从TIM2开始</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APB2PERIPH_BASE (PERIPH_BASE + 0x10000) <span class=\"comment\">// 从AFIO开始</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AHBPERIPH_BASE (PERIPH_BASE + 0x20000) <span class=\"comment\">// 从DMA1开始</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RCC</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RCC_BASE (AHBPERIPH_BASE + 0x1000) <span class=\"comment\">// RCC基地址 </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIOB</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_BASE (APB2PERIPH_BASE + 0x0C00) <span class=\"comment\">// GPIOB基地址</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义寄存器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x18)) <span class=\"comment\">// APB2外设时钟使能寄存器</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_CRL (*(volatile unsigned int *)(GPIOB_BASE + 0x00))<span class=\"comment\">// GPIOB_CRL</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_CRH (*(volatile unsigned int *)(GPIOB_BASE + 0x04)) <span class=\"comment\">// GPIOB_CRH</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_ODR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C)) <span class=\"comment\">// GPIOB_CRH</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中的主函数代码改为\">在main.c中的主函数代码改为</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC_APB2ENR |= ((<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span>); <span class=\"comment\">// 开启GPIOB的时钟</span></span><br><span class=\"line\">GPIOB_CRL &amp;= ~((<span class=\"number\">0x0F</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>)); <span class=\"comment\">// 将GPIOB状态清零</span></span><br><span class=\"line\">GPIOB_CRL |= ((<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>)); <span class=\"comment\">// 将GPIOB设置为推挽输出</span></span><br><span class=\"line\">GPIOB_ODR &amp;= ~(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>); <span class=\"comment\">// PB0置0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-关键字volatile的作用\">补充: 关键字volatile的作用</h4>\n<p>在C语言中，尤其是在嵌入式领域，volatile 关键字用于告诉编译器，<strong>定义为 volatile 的变量可能会以编译器不可预知的方式被改变</strong>。这意味着编译器在处理这些变量时，<strong>应避免进行某些优化，确保每次访问都直接从内存中读取变量的值</strong>。</p>\n<h4 id=\"关键字volatile含义\">关键字volatile含义</h4>\n<p>当一个变量被声明为 volatile 时，编译器会对该变量的处理方式做出以下调整：</p>\n<ul>\n<li><strong>防止优化</strong>：编译器不会对这些变量进行优化，这可能包括消除看似多余的读取或写入操作。</li>\n<li><strong>直接访问</strong>：每次访问 volatile 变量时，都会直接从其内存地址读取数据，而不是使用可能存储在寄存器中的副本。</li>\n</ul>\n<h4 id=\"关键字volatile的应用场景\">关键字volatile的应用场景</h4>\n<p>在嵌入式编程中，volatile 关键字的使用场景主要包括：</p>\n<ul>\n<li><strong>硬件寄存器访问</strong>：当编程与硬件寄存器交互时，如读取一个传感器的数据寄存器或写入一个控制寄存器。这些寄存器的值可能会在任何时候改变，因此需要使用 volatile 来确保每次读取或写入都是最新的值。</li>\n<li><strong>中断服务例程</strong>：在中断服务例程（ISR）中使用的变量，这些变量可能在ISR中被改变，并在程序的其他部分被访问。使用 volatile 可以确保主程序中的代码能够看到在ISR中对这些变量所做的更改。</li>\n<li><strong>多线程和并发</strong>：在多线程或并发环境中，一个线程可能修改另一个线程正在访问的变量。volatile 确保每个线程都能访问到最新的值。</li>\n</ul>\n<h4 id=\"关键字volative的注意事项\">关键字volative的注意事项</h4>\n<ul>\n<li><strong>不是并发解决方案</strong>：volatile 关键字不能替代互斥锁或其他并发控制机制。它不保证操作的原子性或内存可见性。</li>\n<li><strong>性能影响</strong>：由于 volatile 防止了某些优化，过度使用它可能会降低程序的性能。</li>\n<li><strong>正确使用</strong>：只有在上述特定场景中才应使用 volatile。错误地使用 volatile 可能会导致难以发现的错误。</li>\n</ul>\n<h3 id=\"通过结构体操作寄存器\">通过结构体操作寄存器</h3>\n<p>项目地址: <strong>FWlib-LED</strong></p>\n<h4 id=\"在stm32f10xh中添加结构体定义\">在stm32f10x.h中添加结构体定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"type\">uint32_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">uint16_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CRL;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CRH;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> IDR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ODR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> BSRR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> BRR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> LCKR;</span><br><span class=\"line\">&#125;GPIO_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB ((GPIO_TypeDef *)GPIOB_BASE) <span class=\"comment\">// 使用GPIOB-&gt;访问成员变量</span></span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">若定义为 #define GPIOB (*(GPIO_TypeDef *)(GPIOB_BASE))</span></span><br><span class=\"line\"><span class=\"comment\">则使用GPIOB.XXX来访问成员变量</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>\n<p>在main.c中使用GPIOB-&gt;XXX的方式来访问结构体成员(即寄存器), 主要代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOB-&gt;CRL &amp;= ~((<span class=\"number\">0x0F</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">1</span>)); <span class=\"comment\">// 将GPIOB状态复位</span></span><br><span class=\"line\">GPIOB-&gt;CRL |= ((<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">1</span>)); <span class=\"comment\">// 将GPIOB设置为推挽输出</span></span><br><span class=\"line\">GPIOB-&gt;ODR &amp;= ~(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>); <span class=\"comment\">// PB0置0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10xh中增加rcc的结构体定义,如下\">在stm32f10x.h中增加RCC的结构体定义,如下</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CFGR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CIR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB2RSTR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB1RSTR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> AHBENR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB2ENR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB1ENR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> BDCR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CSR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> AHBRSTR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CFGR2;</span><br><span class=\"line\">&#125;RCC_Typedef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RCC ((RCC_Typedef*)RCC_BASE) <span class=\"comment\">// 使用RCC-&gt;访问成员变量</span></span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">若定义为 #define RCC (*(RCC_Typedef*)RCC_Base)</span></span><br><span class=\"line\"><span class=\"comment\">则使用RCC.XXX来访问成员变量</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中通过结构体访问rcc寄存器,代码如下\">在main.c中通过结构体访问RCC寄存器,代码如下</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC-&gt;APB2ENR |= ((<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span>); <span class=\"comment\">// 开启GPIOB的时钟</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"更换led说明\">更换LED说明</h4>\n<p>由于我的开发板，PB0总是点亮蓝灯(本应该是绿灯), 以后的测试换为测试蓝灯，<strong>PB0换为PB1进行测试</strong></p>\n<h3 id=\"增加端口置位/复位函数\">增加端口置位/复位函数</h3>\n<p>项目地址: <strong>FWlib-LED</strong></p>\n<p>增加stm32f10x_gpio.c和stm32f10x_gpio.h文件</p>\n<h4 id=\"在stm32f10x_gpioc中增加置位/复位函数\">在stm32f10x_gpio.c中增加置位/复位函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 端口置位函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_SetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIOx-&gt;BSRR |= Pin;</span><br><span class=\"line\">    <span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    BSRR寄存器:</span></span><br><span class=\"line\"><span class=\"comment\">    低16位写1置1，写0不改变</span></span><br><span class=\"line\"><span class=\"comment\">    高16位写1置0，写0不改变</span></span><br><span class=\"line\"><span class=\"comment\">    *----------------------------------------------------------------*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 端口复位函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_ResetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIOx-&gt;BRR |= Pin;</span><br><span class=\"line\">    <span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    BRR寄存器:</span></span><br><span class=\"line\"><span class=\"comment\">    低16位写1置0，写0不改变</span></span><br><span class=\"line\"><span class=\"comment\">    高16位保留</span></span><br><span class=\"line\"><span class=\"comment\">    ----------------------------------------------------------------*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_gpioh中添加16位pin置1的宏定义与函数声明\">在stm32f10x_gpio.h中添加16位PIN置1的宏定义与函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __STM32F10X_GPIO_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义端口</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_0    ((uint16_t)0x0001)  <span class=\"comment\">/*!&lt; 选择Pin0 */</span>    <span class=\"comment\">//(00000000 00000001)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_1    ((uint16_t)0x0002)  <span class=\"comment\">/*!&lt; 选择Pin1 */</span>    <span class=\"comment\">//(00000000 00000010)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_2    ((uint16_t)0x0004)  <span class=\"comment\">/*!&lt; 选择Pin2 */</span>    <span class=\"comment\">//(00000000 00000100)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_3    ((uint16_t)0x0008)  <span class=\"comment\">/*!&lt; 选择Pin3 */</span>    <span class=\"comment\">//(00000000 00001000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_4    ((uint16_t)0x0010)  <span class=\"comment\">/*!&lt; 选择Pin4 */</span>    <span class=\"comment\">//(00000000 00010000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_5    ((uint16_t)0x0020)  <span class=\"comment\">/*!&lt; 选择Pin5 */</span>    <span class=\"comment\">//(00000000 00100000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_6    ((uint16_t)0x0040)  <span class=\"comment\">/*!&lt; 选择Pin6 */</span>    <span class=\"comment\">//(00000000 01000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_7    ((uint16_t)0x0080)  <span class=\"comment\">/*!&lt; 选择Pin7 */</span>    <span class=\"comment\">//(00000000 10000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_8    ((uint16_t)0x0100)  <span class=\"comment\">/*!&lt; 选择Pin8 */</span>    <span class=\"comment\">//(00000001 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_9    ((uint16_t)0x0200)  <span class=\"comment\">/*!&lt; 选择Pin9 */</span>    <span class=\"comment\">//(00000010 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_10   ((uint16_t)0x0400)  <span class=\"comment\">/*!&lt; 选择Pin10 */</span>   <span class=\"comment\">//(00000100 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_11   ((uint16_t)0x0800)  <span class=\"comment\">/*!&lt; 选择Pin11 */</span>   <span class=\"comment\">//(00001000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_12   ((uint16_t)0x1000)  <span class=\"comment\">/*!&lt; 选择Pin12 */</span>   <span class=\"comment\">//(00010000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_13   ((uint16_t)0x2000)  <span class=\"comment\">/*!&lt; 选择Pin13 */</span>   <span class=\"comment\">//(00100000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_14   ((uint16_t)0x4000)  <span class=\"comment\">/*!&lt; 选择Pin14 */</span>   <span class=\"comment\">//(01000000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_15   ((uint16_t)0x8000)  <span class=\"comment\">/*!&lt; 选择Pin15 */</span>   <span class=\"comment\">//(10000000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_All  ((uint16_t)0xFFFF)  <span class=\"comment\">/*!&lt; 选择全部引脚*/</span> <span class=\"comment\">//(11111111 11111111)b</span></span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">对于类似于GPIOx_BSRR, GPIOx_BRR寄存器通过写1来进行置位/复位操作的寄存器来说</span></span><br><span class=\"line\"><span class=\"comment\">宏定义16位端口的1值很有必要</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_SetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_ResetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__STM32F10X_GPIO</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc函数中使用置位/复位函数\">在main.c函数中使用置位/复位函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 增加复位/置位函数</span></span><br><span class=\"line\">RCC-&gt;APB2ENR  |=  ( (<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span> );</span><br><span class=\"line\">GPIOB-&gt;CRL &amp;=  ~( (<span class=\"number\">0x0f</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>) );</span><br><span class=\"line\">GPIOB-&gt;CRL |=  ( (<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>) );</span><br><span class=\"line\">GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class=\"line\">GPIO_ResetBits( GPIOB,GPIO_Pin_1 );</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10xh中增加#ifndef\">在stm32f10x.h中增加#ifndef</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __STM32F10X_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __STM32F10X_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中间代码省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__STM32F10X_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-在c语言中#ifndef的作用\">补充: 在C语言中#ifndef的作用</h4>\n<p>在C语言中，#ifndef 是一种预处理指令，用于条件编译。它的全称是 “if not defined”，意思是“如果没有定义”。#ifndef 通常与 #define 和 #endif 一起使用，<strong>用于防止头文件的内容被多次包含（重复包含）</strong>。</p>\n<h5 id=\"ifndef的作用\">ifndef的作用</h5>\n<p>&quot;#ifndef&quot;的主要作用是<strong>确保一个头文件中的内容只被包含一次，防止因重复包含同一头文件而导致的编译错误</strong>这种技术被称为“包含卫士”（Include Guards）或“头文件卫士”（Header Guards）。</p>\n<h5 id=\"ifndef的使用方式\">ifndef的使用方式</h5>\n<p>一个典型的使用 #ifndef 的例子如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设这是一个头文件 example.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> EXAMPLE_H    <span class=\"comment\">// 如果没有定义 EXAMPLE_H</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXAMPLE_H    <span class=\"comment\">// 定义 EXAMPLE_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 头文件的内容</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">someFunction</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 更多的声明...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// 结束 #ifndef</span></span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中：</p>\n<ol>\n<li>当编译器首次遇到 example.h 时，EXAMPLE_H 还没有被定义，所以编译器会处理 #define EXAMPLE_H 和随后的头文件内容。</li>\n<li>如果同一源文件或其他包含了 example.h 的文件再次尝试包含 example.h，EXAMPLE_H 已经被定义了，因此 #ifndef EXAMPLE_H 条件失败，编译器将跳过文件的其余部分，防止重复包含。</li>\n</ol>\n<h5 id=\"ifndef的重要性\">ifndef的重要性</h5>\n<p>在C语言项目中，特别是在大型项目中，头文件经常被多个源文件包含，或者一个头文件包含其他头文件。如果没有包含卫士，头文件中的定义（如函数声明、宏定义、类型定义等）可能会被重复包含，导致编译错误（如重复定义错误）。使用 #ifndef 可以有效地避免这种情况。</p>\n<h4 id=\"补充:-使用#ifndef命名使用双下划线说明\">补充: 使用#ifndef命名使用双下划线说明</h4>\n<p>在C语言中，当使用 #ifndef（和 #define、#endif）作为头文件的包含卫士时，通常会在文件名前加上双下划线 __ 或其他类似的前缀/后缀，<strong>这是一种非正式的约定，用于减少命名冲突的风险</strong>然而，需要注意的是，<strong>使用双下划线作为前缀或后缀在某些情况下可能并不是最佳实践</strong>。</p>\n<h5 id=\"使用双下划线的原因\">使用双下划线的原因</h5>\n<ul>\n<li><strong>唯一性</strong>：在大型项目中，可能会有许多不同的头文件。使用文件名作为宏的一部分可以帮助确保每个包含卫士的宏是唯一的。</li>\n<li><strong>减少冲突</strong>：添加额外的字符（如双下划线）可以进一步减少不同头文件之间宏名称冲突的可能性。</li>\n</ul>\n<h5 id=\"使用双下划线的注意事项\">使用双下划线的注意事项</h5>\n<p><strong>保留标识符</strong>：根据C和C++标准，<strong>以双下划线开头或以单下划线后跟大写字母开头的标识符是保留给实现（编译器和标准库）使用的</strong>。因此，使用这样的标识符作为宏名称<strong>可能会导致与标准库或编译器的内部标识符冲突</strong>。</p>\n<p>建议的做法：更安全的做法是<strong>使用文件名的大写形式加上一个后缀（如 _H），而不是使用双下划线</strong>。例如，对于 example.h 头文件，可以使用 EXAMPLE_H 作为包含卫士的宏。</p>\n<h5 id=\"示例\">示例</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> EXAMPLE_H    <span class=\"comment\">// 更安全的做法</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXAMPLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 头文件内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure>\n<p>总之，<strong>虽然在文件名前加上双下划线是一种常见做法，但为了避免与编译器或标准库的内部标识符冲突，建议使用其他方法来确保宏名称的唯一性和安全性</strong>。</p>\n<h3 id=\"增加gpio初始化结构体\">增加GPIO初始化结构体</h3>\n<p>项目地址: <strong>FWlib-LED</strong></p>\n<p>配置GPIO工作模式的宏定义(GPIOMode_TypeDef)参考下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202312301523539.png\" alt=\"GPIO工作模式图\"></p>\n<p>实际写入寄存器的是bit3-0,bit7-4并不写入寄存器</p>\n<p>勘误：上拉输入和下拉输入两行的bit3-2应该为10</p>\n<ul>\n<li>bit1-0: 置0, 配置输出速度，通过GPIOSpeed_TypeDef进行覆盖配置</li>\n<li>bit3-2: 配置输入/输出模式</li>\n<li>bi4: <strong>不写入寄存器</strong>, 用来标志是输入还是输出</li>\n<li>bit6-5: <strong>不写入寄存器</strong>， 用来判断是上拉输入还是下拉输入</li>\n<li>bit7: <strong>不写入寄存器</strong></li>\n</ul>\n<h4 id=\"在stm32f10x_gpioh中增加宏定义\">在stm32f10x_gpio.h中增加宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过枚举 限定GPIO_Speed的选择</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    GPIO_Speed_10MHZ = <span class=\"number\">1</span>, <span class=\"comment\">// 01 输出模式，最大速度10MHz</span></span><br><span class=\"line\">    GPIO_Speed_2MHZ, <span class=\"comment\">// 10 输出模式，最大速度2MHz</span></span><br><span class=\"line\">    GPIO_Speed_50MHZ <span class=\"comment\">// 11 输出模式，最大速度50MHz</span></span><br><span class=\"line\">&#125;GPIOSpeed_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过枚举限定GPIO_Mode的选择</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span> GPIO_Mode_AIN = <span class=\"number\">0x0</span>,           <span class=\"comment\">// 模拟输入     (0000 0000)b</span></span><br><span class=\"line\">  GPIO_Mode_IN_FLOATING = <span class=\"number\">0x04</span>,  <span class=\"comment\">// 浮空输入     (0000 0100)b</span></span><br><span class=\"line\">  GPIO_Mode_IPD = <span class=\"number\">0x28</span>,          <span class=\"comment\">// 下拉输入     (0010 1000)b</span></span><br><span class=\"line\">  GPIO_Mode_IPU = <span class=\"number\">0x48</span>,          <span class=\"comment\">// 上拉输入     (0100 1000)b</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  GPIO_Mode_Out_OD = <span class=\"number\">0x14</span>,       <span class=\"comment\">// 开漏输出     (0001 0100)b</span></span><br><span class=\"line\">  GPIO_Mode_Out_PP = <span class=\"number\">0x10</span>,       <span class=\"comment\">// 推挽输出     (0001 0000)b</span></span><br><span class=\"line\">  GPIO_Mode_AF_OD = <span class=\"number\">0x1C</span>,        <span class=\"comment\">// 复用开漏输出 (0001 1100)b</span></span><br><span class=\"line\">  GPIO_Mode_AF_PP = <span class=\"number\">0x18</span>         <span class=\"comment\">// 复用推挽输出 (0001 1000)b</span></span><br><span class=\"line\">&#125;GPIOMode_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义GPIO初始化结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> GPIO_Pin;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> GPIO_Speed;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> GPIO_Mode;</span><br><span class=\"line\">&#125;GPIO_InitTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_gpioc中写入gpio初始化函数\">在stm32f10x_gpio.c中写入GPIO初始化函数</h4>\n<p>该函数是从库函数中复制得到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> currentmode = <span class=\"number\">0x00</span>, currentpin = <span class=\"number\">0x00</span>, pinpos = <span class=\"number\">0x00</span>, pos = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> tmpreg = <span class=\"number\">0x00</span>, pinmask = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*---------------------- GPIO 模式配置 --------------------------*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 把输入参数GPIO_Mode的低四位暂存在currentmode</span></span><br><span class=\"line\">  currentmode = ((<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// bit4是1表示输出，bit4是0则是输入 </span></span><br><span class=\"line\">  <span class=\"comment\">// 判断bit4是1还是0，即首选判断是输入还是输出模式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((((<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x10</span>)) != <span class=\"number\">0x00</span>)</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 输出模式则要设置输出速度</span></span><br><span class=\"line\">    currentmode |= (<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">/*-------------GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- -------*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 配置端口低8位，即Pin0~Pin7</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (((<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x00FF</span>)) != <span class=\"number\">0x00</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先备份CRL寄存器的值</span></span><br><span class=\"line\">    tmpreg = GPIOx-&gt;CRL;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 循环，从Pin0开始配对，找出具体的Pin</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pinpos = <span class=\"number\">0x00</span>; pinpos &lt; <span class=\"number\">0x08</span>; pinpos++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// pos的值为1左移pinpos位</span></span><br><span class=\"line\">      pos = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; pinpos;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 令pos与输入参数GPIO_PIN作位与运算，为下面的判断作准备</span></span><br><span class=\"line\">      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">//若currentpin=pos,则找到使用的引脚</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentpin == pos)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚</span></span><br><span class=\"line\">        pos = pinpos &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class=\"line\">        pinmask = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>) &lt;&lt; pos;</span><br><span class=\"line\">        tmpreg &amp;= ~pinmask;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class=\"line\">        tmpreg |= (currentmode &lt;&lt; pos);  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为下拉输入模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0</span></span><br><span class=\"line\">          GPIOx-&gt;BRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; pinpos);</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 判断是否为上拉输入模式</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1</span></span><br><span class=\"line\">            GPIOx-&gt;BSRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; pinpos);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把前面处理后的暂存值写入到CRL寄存器之中</span></span><br><span class=\"line\">    GPIOx-&gt;CRL = tmpreg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">/*-------------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----------*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 配置端口高8位，即Pin8~Pin15</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class=\"number\">0x00FF</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先备份CRH寄存器的值</span></span><br><span class=\"line\">    tmpreg = GPIOx-&gt;CRH;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 循环，从Pin8开始配对，找出具体的Pin</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pinpos = <span class=\"number\">0x00</span>; pinpos &lt; <span class=\"number\">0x08</span>; pinpos++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      pos = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; (pinpos + <span class=\"number\">0x08</span>));</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">// pos与输入参数GPIO_PIN作位与运算</span></span><br><span class=\"line\">      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">//若currentpin=pos,则找到使用的引脚</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentpin == pos)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">//pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚</span></span><br><span class=\"line\">        pos = pinpos &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class=\"line\">        pinmask = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>) &lt;&lt; pos;</span><br><span class=\"line\">        tmpreg &amp;= ~pinmask;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class=\"line\">        tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为下拉输入模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0</span></span><br><span class=\"line\">          GPIOx-&gt;BRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; (pinpos + <span class=\"number\">0x08</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"comment\">// 判断是否为上拉输入模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1</span></span><br><span class=\"line\">          GPIOx-&gt;BSRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; (pinpos + <span class=\"number\">0x08</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把前面处理后的暂存值写入到CRH寄存器之中</span></span><br><span class=\"line\">    GPIOx-&gt;CRH = tmpreg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用gpio初始化函数\">在main.c中使用GPIO初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;</span><br><span class=\"line\">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加宏定义来增强代码可移植性\">增加宏定义来增强代码可移植性</h3>\n<p>项目地址： <strong>FWlib-LED</strong></p>\n<h4 id=\"在mainc中增加宏定义\">在main.c中增加宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PORT GPIOB</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_CLK_ENABLE (RCC-&gt;APB2ENR |= ((1) &lt;&lt; 3)) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PIN GPIO_Pin_0</span></span><br></pre></td></tr></table></figure>\n<p>在main.c中增加延时函数，实现LED闪烁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>( ; count != <span class=\"number\">0</span>; count-- )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用宏定义后的代码实现led闪烁\">在main.c中使用宏定义后的代码实现LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加宏定义以增强代码可移植性</span></span><br><span class=\"line\">LED_B_GPIO_CLK_ENABLE;</span><br><span class=\"line\">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Pin = LED_B_GPIO_PIN;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;</span><br><span class=\"line\">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); <span class=\"comment\">// PB1置1 蓝灯灭</span></span><br><span class=\"line\">  Delay(<span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">  GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); <span class=\"comment\">// PB1置0 蓝灯亮</span></span><br><span class=\"line\">  Delay(<span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"固件库编程\">固件库编程</h2>\n<h3 id=\"stm32固件库文件分析\">STM32固件库文件分析</h3>\n<ol>\n<li>汇编编写的启动文件 startup_stm32f10x_h.s: 设置堆栈指针,设置PC指针，初始化中断向量表，配置系统时钟，调用C库函数_main最终去C的世界</li>\n<li>时钟配置文件 system_stm32f10x.c: 把外部时钟HSE=8M，经过PLL倍频成72M</li>\n<li>外设相关\n<ul>\n<li>stm32f10x.h: 实现了内核之外的外设的寄存器映射</li>\n<li>xx: GPIO, USART, I2C</li>\n<li>stm32f10x_xx.c: 外设的驱动函数库文件</li>\n<li>stm32f10x_xx.h: 存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库的头文件声明</li>\n</ul>\n</li>\n<li>内核相关\n<ul>\n<li>CMSIS: Cortex微控制器软件接口标准</li>\n<li>core_cm3.h: 实现了内核里面外设的寄存器映射</li>\n<li>core_cm3.c: 内核外设的驱动固件库</li>\n<li>NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器), misc.h, misc.c</li>\n</ul>\n</li>\n<li>头文件的配置文件 stm32f10x_conf.h里面包含\n<ul>\n<li>stm32f10x_usar.c</li>\n<li>stm32f10x_i2c.h</li>\n<li>stm32f10x_spi.h</li>\n<li>stm32f10x_adc.h</li>\n<li>stm32f10x_fsmc.h</li>\n</ul>\n</li>\n<li>专门存放终端服务函数的C文件(可以放在其他地方，不一定要放在stm32f10x_it.c中)\n<ul>\n<li>stm32f10x_it.c</li>\n<li>stm32f10x_it.h</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"新建固件库版本工程\">新建固件库版本工程</h3>\n<p>项目地址: <strong>Fwlib-Template</strong></p>\n<ul>\n<li>Doc: 用来存放程序说明的文件，由写程序的人添加</li>\n<li>Libraries: 存放库文件</li>\n<li>Project: 存放工程</li>\n<li>User: 用户编写的驱动文件</li>\n</ul>\n<p>其余按照视频配置，P18, 视频链接: <a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw/?p=18&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">按照P18进行库移植</a></p>\n<h3 id=\"gpio输出-使用固件库点亮led\">GPIO输出-使用固件库点亮LED</h3>\n<p>项目地址: <strong>12-GPIO输出-使用固件库点亮LED</strong></p>\n<p>在User目录下新建led文件夹，添加bsp_led.c和bsp_led.h</p>\n<h4 id=\"在bsp_ledh中添加所使用的宏定义和函数声明\">在bsp_led.h中添加所使用的宏定义和函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_LED_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_LED_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PIN GPIO_Pin_1 <span class=\"comment\">// stm32f10x_gpio.h中定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PORT GPIOB <span class=\"comment\">// stm32f10x.h中定义 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_CLK RCC_APB2Periph_GPIOB</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_LED_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledc中添加初始化函数\">在bsp_led.c中添加初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bsp: board support package 板级支持包</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(LED_B_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = LED_B_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(LED_B_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用初始化函数，并进行软件延时，实现led闪烁\">在main.c中调用初始化函数，并进行软件延时，实现LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; count != <span class=\"number\">0</span>; count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> current;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(current = count; current != <span class=\"number\">0</span>; current--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LED_GPIO_Config();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">        GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledh中增加函数宏定义\">在bsp_led.h中增加函数宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ON 1 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFF 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B(a) <span class=\"keyword\">if</span> (a)\\</span></span><br><span class=\"line\"><span class=\"meta\">                     GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); \\</span></span><br><span class=\"line\"><span class=\"meta\">                     <span class=\"keyword\">else</span>\\</span></span><br><span class=\"line\"><span class=\"meta\">                     GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span></span><br><span class=\"line\"><span class=\"comment\">// 使用\\可以进行换行，其后不能跟空格，\\后应该直接回车</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用宏定义的函数\">在main.c中使用宏定义的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LED_B(OFF);</span><br><span class=\"line\">Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">LED_B(ON);</span><br><span class=\"line\">Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-c语言反斜杠\\换行\">补充: C语言反斜杠\\换行</h4>\n<p>在C语言中使用反斜杠 \\ 进行换行时，确实有一些需要注意的事项。这种用法通常出现在宏定义或是将长代码行分割为多行以提高代码的可读性。正确使用时，\\ 应该放在行尾，紧接着是换行符。</p>\n<h5 id=\"c语言反斜杠\\换行的注意事项\">C语言反斜杠\\换行的注意事项</h5>\n<ul>\n<li><strong>无空格</strong>：在行尾使用 \\ 时，它之后直到行末不能有任何字符，包括空格或制表符。任何在 \\ 之后的空格都会使得换行转义失效，导致编译错误。</li>\n<li><strong>紧跟换行符</strong>：\\ 应该直接紧跟换行符。这告诉编译器忽略换行符，将下一行视为当前行的延续。</li>\n<li><strong>可读性</strong>：虽然使用 \\ 可以将长代码行分割为多行，但过度使用可能会降低代码的可读性。适当使用，以保持代码整洁和可维护。</li>\n<li><strong>宏定义中的使用</strong>：在宏定义中使用 \\ 进行换行是常见的做法，<strong>因为宏定义必须是单行的</strong>。在这种情况下，确保每一行（除了最后一行）都以 \\ 结尾。</li>\n</ul>\n<h5 id=\"c语言反斜杠\\换行的示例\">C语言反斜杠\\换行的示例</h5>\n<p>正确的使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MY_MACRO(a, b) \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">        a = 2; \\</span></span><br><span class=\"line\"><span class=\"meta\">        b = 3; \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; while(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    MY_MACRO(x, y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，宏 MY_MACRO 被分成了多行，每行的末尾都使用了 \\ 来实现。</p>\n<p>错误的使用（如果 \\ 后有空格）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MY_MACRO(a, b) \\ </span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; \\</span><br><span class=\"line\">        b = <span class=\"number\">3</span>; \\</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>在这个错误的例子中，<strong>第一行的 \\ 后面如果有空格，将导致编译错误</strong>。</p>\n<p>总之，当在C语言中使用 \\ 进行换行时，<strong>确保 \\ 是每行的最后一个字符，并且紧接着换行符</strong>，以避免编译错误并保持代码的清晰</p>\n<h3 id=\"gpio输入\">GPIO输入</h3>\n<p>项目地址: <strong>13-GPIO输入-按键检测</strong></p>\n<p>通过原理图可知<strong>KEY1接PA0口, 按键按下后为高电平</strong>, 原理图如下</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401011723631.png\" alt=\"KEY1原理图\"></p>\n<p>实现<strong>按下KEY1后蓝灯状态翻转</strong></p>\n<h4 id=\"在bsp_ledh中宏定义电平翻转函数\">在bsp_led.h中宏定义电平翻转函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_TOGGLE &#123;LED_B_GPIO_PORT-&gt;ODR ^= LED_B_GPIO_PIN;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">^= 异或运算 (a ^ b) 则ab不同为1，相同则为0</span></span><br><span class=\"line\"><span class=\"comment\">ODR低16位和GPIO_Pin_1作异或并重新赋值给ODR可实现ODR的Bit0翻转</span></span><br><span class=\"line\"><span class=\"comment\">若Bit0=1则Bit0 = 1 ^ 1 = 0, 下一次运算时, Bit0=0则Bit0 = 0^1 = 1</span></span><br><span class=\"line\"><span class=\"comment\">实际上是ODR的Bit0在和1进行异或操作</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_keyh中进行宏定义和函数声明\">在bsp_key.h中进行宏定义和函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_KEY_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_KEY_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY_ON 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY_OFF 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY1_GPIO_PIN GPIO_Pin_0 <span class=\"comment\">// stm32f10x_gpio.h中定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY1_GPIO_PORT GPIOA <span class=\"comment\">// stm32f10x.h中定义 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY1_GPIO_CLK RCC_APB2Periph_GPIOA</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">KEY_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">Key_Scan</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_KEY_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_keyc中写初始化函数和端口扫描函数\">在bsp_key.c中写初始化函数和端口扫描函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_key.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">KEY_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 端口扫面函数 检测按下返回1，否则返回0</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">Key_Scan</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> KEY_ON;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KEY_OFF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中进行调用\">在main.c中进行调用</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LED_GPIO_Config();</span><br><span class=\"line\">    KEY_GPIO_Config();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            LED_B_TOGGLE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-c语言中的异或操作\">补充: C语言中的异或操作</h4>\n<p>在C语言中，异或运算是一种基本的位运算，使用符号 ^ 表示。<strong>异或运算符对两个操作数的对应位进行比较，如果两个相应的位不同，则结果为1，如果相同，则结果为0</strong>换句话说，它在以下情况下返回1：</p>\n<ul>\n<li>第一个操作数的位是0，第二个操作数的位是1。</li>\n<li>第一个操作数的位是1，第二个操作数的位是0。</li>\n</ul>\n<h5 id=\"c语言异或运算的特性\">C语言异或运算的特性</h5>\n<ul>\n<li>交换律：a ^ b 等于 b ^ a。</li>\n<li>结合律：(a ^ b) ^ c 等于 a ^ (b ^ c)。</li>\n<li>自反性：任何数与自身异或的结果都是0，即 a ^ a 等于 0。</li>\n<li>与0的异或：任何数与0异或都等于它本身，即 a ^ 0 等于 a。</li>\n</ul>\n<h5 id=\"c语言异或操作的应用\">C语言异或操作的应用</h5>\n<p>异或运算在C语言编程中有多种应用：</p>\n<p><strong>值交换</strong>：不使用临时变量交换两个变量的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a ^ b;</span><br><span class=\"line\">b = a ^ b;</span><br><span class=\"line\">a = a ^ b;</span><br></pre></td></tr></table></figure>\n<p>这种方法虽然巧妙，但<strong>在实际编程中不常用</strong>，因为如果 a 和 b 指向同一内存位置，这会导致结果为0。</p>\n<p><strong>反转特定位</strong>：可以使用异或运算来反转数值中的特定位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = x ^ (<span class=\"number\">1</span> &lt;&lt; n);  <span class=\"comment\">// 反转x的第n位</span></span><br></pre></td></tr></table></figure>\n<p><strong>检查奇偶性</strong>：通过检查数的最低位是否为1，可以使用异或运算来快速检查一个数是奇数还是偶数。</p>\n<p><strong>加密和解密</strong>：由于异或运算的自反性，它可以用于简单的加密和解密操作。</p>\n<h5 id=\"c语言异或操作的示例\">C语言异或操作的示例</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">5</span>;  <span class=\"comment\">// 二进制: 0101</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">3</span>;  <span class=\"comment\">// 二进制: 0011</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行异或运算</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> result = a ^ b;  <span class=\"comment\">// 结果是 6，二进制: 0110</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result = %d\\n&quot;</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，5（二进制0101）和3（二进制0011）进行异或运算的结果是6（二进制0110），因为每一位都被相应地比较并计算出结果。</p>\n<h2 id=\"位带操作\">位带操作</h2>\n<h3 id=\"位带简介\">位带简介</h3>\n<p>Cortex-M3微控制器，作为ARM的Cortex-M系列的一部分，提供了位带（Bit-banding）功能，<strong>这是一种允许对单个位进行原子读写操作的机制</strong>。这种功能在需要精确控制或原子性操作单个位的场合非常有用，例如在多任务环境中操作共享资源。</p>\n<p>在 CM3 中，有两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，<strong>它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个 32 位的字</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021935413.png\" alt=\"位带地址\"></p>\n<p>在CM3权威指南CnR2中<strong>支持位带操作的两个内存区的范围</strong>如下</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021941642.png\" alt=\"内存区范围\"></p>\n<h3 id=\"位带操作的原理\">位带操作的原理</h3>\n<p>位带操作在Cortex-M3中是<strong>通过将一个较大的地址空间（位带区域）映射到一个较小的地址空间（位带别名区域）来实现的</strong>。在Cortex-M3中，有两个主要的位带区域：</p>\n<ol>\n<li>SRAM位带区域：通常用于内存中的变量。</li>\n<li>外设位带区域：用于外设寄存器。</li>\n</ol>\n<p>每个位带区域的一个字（32位）对应主存储区的一个位。这意味着，通过写入位带区域的地址，你可以设置或清除主存储区相应位的值。</p>\n<h3 id=\"位带操作的地址映射\">位带操作的地址映射</h3>\n<p>位带操作的地址映射通常遵循以下规则：</p>\n<p>位带别名地址 = 位带基地址 + (字节偏移量 x 32) + (位编号 x 4)</p>\n<p>其中，<strong>字节偏移量是目标地址相对于位带区域基地址的偏移量</strong>，<strong>位编号是要操作的位</strong>。</p>\n<h3 id=\"位带操作的示例\">位带操作的示例</h3>\n<p>假设有一个外设寄存器的地址为 0x40000000，我们要设置这个寄存器的第2位。首先，我们需要计算这个位在位带别名区域中的地址。</p>\n<p>假设外设位带区域的基地址是 0x42000000，那么：</p>\n<ul>\n<li>字节偏移量 = 0x40000000 - 0x40000000 = 0x00000000</li>\n<li>位编号 = 2</li>\n<li>位带别名地址 = 0x42000000 + (0x00000000 x 32) + (2 x 4) = 0x42000008</li>\n</ul>\n<p>然后，你可以直接写入这个位带别名地址来设置或清除该位：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BITBAND_PERIPH(address, bit) ((void*)(0x42000000 + ((address) - 0x40000000) * 32 + (bit) * 4))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> *alias_address = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)BITBAND_PERIPH(<span class=\"number\">0x40000000</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">*alias_address = <span class=\"number\">1</span>;  <span class=\"comment\">// 设置第2位, 将第二位值设置为1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"位带操作的注意事项\">位带操作的注意事项</h3>\n<ul>\n<li>硬件支持：确保你的Cortex-M3微控制器支持位带操作。</li>\n<li>地址计算：正确的地址计算对于位带操作至关重要。</li>\n<li>原子操作：位带操作是原子的，这意味着在多任务或中断驱动的环境中，它们是安全的。</li>\n</ul>\n<h3 id=\"使用位带操作实现gpio的输出和输入\">使用位带操作实现GPIO的输出和输入</h3>\n<p>项目地址: <strong>14-位带操作-GPIO的输出和输入</strong></p>\n<p>使用位带操作实现GPIO输出: LED_B的闪烁</p>\n<h4 id=\"在mainc中添加位带操作的宏定义\">在main.c中添加位带操作的宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_ODR_Addr (GPIOB_BASE+0x0C)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PBout(n) *(unsigned int*)((GPIOB_ODR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOB_ODR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用位带操作点灯\">在main.c中使用位带操作点灯</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    PBout(<span class=\"number\">1</span>) = <span class=\"number\">1</span>;</span><br><span class=\"line\">    Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">    PBout(<span class=\"number\">1</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用位带操作实现GPIO输入: KEY1和KEY2控制LED_B状态翻转</p>\n<h4 id=\"在bsp_keyh中添加key2的宏定义\">在bsp_key.h中添加KEY2的宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY2_GPIO_PIN GPIO_Pin_13 <span class=\"comment\">// stm32f10x_gpio.h中定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY2_GPIO_PORT GPIOC <span class=\"comment\">// stm32f10x.h中定义 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY2_GPIO_CLK RCC_APB2Periph_GPIOC</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bspc中增加key2的gpio初始化\">在bsp.c中增加KEY2的GPIO初始化</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">KEY_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// KEY1 初始化</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// KEY2 初始化</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(KEY2_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中添加gpio输入位带操作的宏定义\">在main.c中添加GPIO输入位带操作的宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOA_IDR_Addr (GPIOA_BASE+0x08)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOC_IDR_Addr (GPIOC_BASE+0x08)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PAin(n) *(unsigned int*)((GPIOA_IDR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOA_IDR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PCin(n) *(unsigned int*)((GPIOC_IDR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOC_IDR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中测试led闪烁\">在main.c中测试LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(PAin(<span class=\"number\">0</span>) == KEY_ON)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 加入软件消抖后可正常运行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(PAin(<span class=\"number\">0</span>) == KEY_ON) <span class=\"comment\">// 等待按键释放</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LED_B_TOGGLE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(PCin(<span class=\"number\">13</span>) == KEY_ON)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 加入软件消抖后可正常运行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(PCin(<span class=\"number\">13</span>) == KEY_ON) <span class=\"comment\">// 等待按键释放</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LED_B_TOGGLE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动文件详解\">启动文件详解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************</span><br><span class=\"line\">;* File Name          : startup_stm32f10x_hd.s</span><br><span class=\"line\">;* Author             : MCD Application Team</span><br><span class=\"line\">;* Version            : V3.5.0</span><br><span class=\"line\">;* Date               : 11-March-2011</span><br><span class=\"line\">;* Description        : STM32F10x High Density Devices vector table for MDK-ARM </span><br><span class=\"line\">;*                      toolchain. </span><br><span class=\"line\">;*                      This module performs:</span><br><span class=\"line\">;*                      - Set the initial SP </span><br><span class=\"line\">;                       初始化堆栈指针</span><br><span class=\"line\">;*                      - Set the initial PC == Reset_Handler </span><br><span class=\"line\">;                       初始化PC指针 == Reset_Handler程序</span><br><span class=\"line\">;*                      - Set the vector table entries with the exceptions ISR address </span><br><span class=\"line\">;                       初始化中断向量表</span><br><span class=\"line\">;*                      - Configure the clock system and also configure the external </span><br><span class=\"line\">;*                        SRAM mounted on STM3210E-EVAL board to be used as data </span><br><span class=\"line\">;*                        memory (optional, to be enabled by user) </span><br><span class=\"line\">;                       配置系统时钟</span><br><span class=\"line\">;*                      - Branches to __main in the C library (which eventually</span><br><span class=\"line\">;*                        calls main()). </span><br><span class=\"line\">;                       调用C库函数, 最终去到C的世界</span><br><span class=\"line\">;*                      After Reset the CortexM3 processor is in Thread mode,</span><br><span class=\"line\">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class=\"line\">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\">; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS</span><br><span class=\"line\">; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.</span><br><span class=\"line\">; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,</span><br><span class=\"line\">; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE</span><br><span class=\"line\">; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING</span><br><span class=\"line\">; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">;****************************************************************************</span><br><span class=\"line\">;* 1- 栈的配置</span><br><span class=\"line\">;****************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Amount of memory (in bytes) allocated for Stack</span><br><span class=\"line\">; Tailor this value to your application needs</span><br><span class=\"line\">; &lt;h&gt; Stack Configuration </span><br><span class=\"line\">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class=\"line\">; &lt;/h&gt;</span><br><span class=\"line\">; 配置栈: 用于变量存储(局部/全局), 函数调用</span><br><span class=\"line\"></span><br><span class=\"line\">Stack_Size      EQU     0x00000400 </span><br><span class=\"line\">; 宏定义的伪指令，相当于等于，类似与 C 中的 define。</span><br><span class=\"line\">; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小</span><br><span class=\"line\"></span><br><span class=\"line\">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class=\"line\">                ; 告诉汇编器汇编一个新的代码段或者数据段。</span><br><span class=\"line\">                ; STACK 表示段名，这个可以任意命名</span><br><span class=\"line\">                ; NOINIT 表示不初始化</span><br><span class=\"line\">                ; READWRITE 表示可读可写</span><br><span class=\"line\">                ; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐</span><br><span class=\"line\">Stack_Mem       SPACE   Stack_Size</span><br><span class=\"line\">__initial_sp</span><br><span class=\"line\">; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</span><br><span class=\"line\">; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</span><br><span class=\"line\">的。 </span><br><span class=\"line\">                                                  </span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 2-堆的配置</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;h&gt; Heap Configuration</span><br><span class=\"line\">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class=\"line\">; &lt;/h&gt;</span><br><span class=\"line\">; 配置堆: 主要用于动态内存的分配, 如malloc()函数</span><br><span class=\"line\"></span><br><span class=\"line\">Heap_Size       EQU     0x00000200</span><br><span class=\"line\">; 将0x00000200命名为Heap_Size, 0x00000200为512Type</span><br><span class=\"line\"></span><br><span class=\"line\">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class=\"line\">                ; 汇编数据段</span><br><span class=\"line\">                ; 名字叫HEAP</span><br><span class=\"line\">                ; 不初始化</span><br><span class=\"line\">                ; 可读可写</span><br><span class=\"line\">                ; 2^3即8字节对齐</span><br><span class=\"line\">__heap_base</span><br><span class=\"line\">Heap_Mem        SPACE   Heap_Size</span><br><span class=\"line\">__heap_limit</span><br><span class=\"line\">; __heap_base 表示对的起始地址</span><br><span class=\"line\">; SPACE 分配大小为Heap_Size即512字节的内存空间</span><br><span class=\"line\">; __heap_limit 表示堆的结束地址</span><br><span class=\"line\">; 堆是由低向高生长的，跟栈的生长方向相反。</span><br><span class=\"line\"></span><br><span class=\"line\">                PRESERVE8</span><br><span class=\"line\">                ; 指定当前文件的堆栈按照 8 字节对齐</span><br><span class=\"line\">                THUMB</span><br><span class=\"line\">                ; 表示后面指令兼容 THUMB 指令</span><br><span class=\"line\"></span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 3-初始化中断向量表</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Vector Table Mapped to Address 0 at Reset</span><br><span class=\"line\">                AREA    RESET, DATA, READONLY</span><br><span class=\"line\">                ; 区域名称为RESET</span><br><span class=\"line\">                ; 区域类型为DATA, 与CODE相对,后者用于包含可执行指令</span><br><span class=\"line\">                ; 区域属性为只读</span><br><span class=\"line\">                EXPORT  __Vectors</span><br><span class=\"line\">                EXPORT  __Vectors_End</span><br><span class=\"line\">                EXPORT  __Vectors_Size</span><br><span class=\"line\">                ; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用</span><br><span class=\"line\"></span><br><span class=\"line\">__Vectors       DCD     __initial_sp               ; Top of Stack ; 栈顶地址</span><br><span class=\"line\">                DCD     Reset_Handler              ; Reset Handler ; 复位程序地址</span><br><span class=\"line\">                DCD     NMI_Handler                ; NMI Handler</span><br><span class=\"line\">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class=\"line\">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class=\"line\">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class=\"line\">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class=\"line\">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class=\"line\">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class=\"line\"></span><br><span class=\"line\">                ; External Interrupts</span><br><span class=\"line\">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class=\"line\">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect</span><br><span class=\"line\">                DCD     TAMPER_IRQHandler          ; Tamper</span><br><span class=\"line\">                DCD     RTC_IRQHandler             ; RTC</span><br><span class=\"line\">                DCD     FLASH_IRQHandler           ; Flash</span><br><span class=\"line\">                DCD     RCC_IRQHandler             ; RCC</span><br><span class=\"line\">                DCD     EXTI0_IRQHandler           ; EXTI Line 0</span><br><span class=\"line\">                DCD     EXTI1_IRQHandler           ; EXTI Line 1</span><br><span class=\"line\">                DCD     EXTI2_IRQHandler           ; EXTI Line 2</span><br><span class=\"line\">                DCD     EXTI3_IRQHandler           ; EXTI Line 3</span><br><span class=\"line\">                DCD     EXTI4_IRQHandler           ; EXTI Line 4</span><br><span class=\"line\">                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1</span><br><span class=\"line\">                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2</span><br><span class=\"line\">                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3</span><br><span class=\"line\">                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4</span><br><span class=\"line\">                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5</span><br><span class=\"line\">                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6</span><br><span class=\"line\">                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7</span><br><span class=\"line\">                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2</span><br><span class=\"line\">                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX</span><br><span class=\"line\">                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0</span><br><span class=\"line\">                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1</span><br><span class=\"line\">                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE</span><br><span class=\"line\">                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5</span><br><span class=\"line\">                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break</span><br><span class=\"line\">                DCD     TIM1_UP_IRQHandler         ; TIM1 Update</span><br><span class=\"line\">                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation</span><br><span class=\"line\">                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare</span><br><span class=\"line\">                DCD     TIM2_IRQHandler            ; TIM2</span><br><span class=\"line\">                DCD     TIM3_IRQHandler            ; TIM3</span><br><span class=\"line\">                DCD     TIM4_IRQHandler            ; TIM4</span><br><span class=\"line\">                DCD     I2C1_EV_IRQHandler         ; I2C1 Event</span><br><span class=\"line\">                DCD     I2C1_ER_IRQHandler         ; I2C1 Error</span><br><span class=\"line\">                DCD     I2C2_EV_IRQHandler         ; I2C2 Event</span><br><span class=\"line\">                DCD     I2C2_ER_IRQHandler         ; I2C2 Error</span><br><span class=\"line\">                DCD     SPI1_IRQHandler            ; SPI1</span><br><span class=\"line\">                DCD     SPI2_IRQHandler            ; SPI2</span><br><span class=\"line\">                DCD     USART1_IRQHandler          ; USART1</span><br><span class=\"line\">                DCD     USART2_IRQHandler          ; USART2</span><br><span class=\"line\">                DCD     USART3_IRQHandler          ; USART3</span><br><span class=\"line\">                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10</span><br><span class=\"line\">                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line</span><br><span class=\"line\">                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend</span><br><span class=\"line\">                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break</span><br><span class=\"line\">                DCD     TIM8_UP_IRQHandler         ; TIM8 Update</span><br><span class=\"line\">                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation</span><br><span class=\"line\">                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare</span><br><span class=\"line\">                DCD     ADC3_IRQHandler            ; ADC3</span><br><span class=\"line\">                DCD     FSMC_IRQHandler            ; FSMC</span><br><span class=\"line\">                DCD     SDIO_IRQHandler            ; SDIO</span><br><span class=\"line\">                DCD     TIM5_IRQHandler            ; TIM5</span><br><span class=\"line\">                DCD     SPI3_IRQHandler            ; SPI3</span><br><span class=\"line\">                DCD     UART4_IRQHandler           ; UART4</span><br><span class=\"line\">                DCD     UART5_IRQHandler           ; UART5</span><br><span class=\"line\">                DCD     TIM6_IRQHandler            ; TIM6</span><br><span class=\"line\">                DCD     TIM7_IRQHandler            ; TIM7</span><br><span class=\"line\">                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1</span><br><span class=\"line\">                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2</span><br><span class=\"line\">                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3</span><br><span class=\"line\">                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5</span><br><span class=\"line\">__Vectors_End</span><br><span class=\"line\">; _Vectors 为向量表起始地址，__Vectors_End 为向量表结束地址</span><br><span class=\"line\">; 向量表中，DCD 分配了一堆内存，并且以 ESR 的入口地址初始化它们 </span><br><span class=\"line\"></span><br><span class=\"line\">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class=\"line\">; 向量表的大小为结束地址减去起始地址</span><br><span class=\"line\"></span><br><span class=\"line\">                AREA    |.text|, CODE, READONLY</span><br><span class=\"line\">                ; 定义一个名称为.text 的代码段，只读</span><br><span class=\"line\">                </span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 4-复位程序</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Reset handler</span><br><span class=\"line\">Reset_Handler   PROC</span><br><span class=\"line\">                EXPORT  Reset_Handler             [WEAK]</span><br><span class=\"line\">                ; WEAK 表示弱定义, 如果在其他地方定义了Reset_Handler就使用其他地方的定义</span><br><span class=\"line\">                ; 可以理解为C++中的&quot;可以重载&quot;</span><br><span class=\"line\">                IMPORT  __main</span><br><span class=\"line\">                IMPORT  SystemInit</span><br><span class=\"line\">                ;表示 SystemInit和 __main 这两个函数均来自外部的文件</span><br><span class=\"line\"></span><br><span class=\"line\">                LDR     R0, =SystemInit</span><br><span class=\"line\">                ; 把SystemInit的地址加载到R0中</span><br><span class=\"line\">                BLX     R0               </span><br><span class=\"line\">                ; 跳转到R0执行, 执行完毕后返回</span><br><span class=\"line\">                LDR     R0, =__main</span><br><span class=\"line\">                ; 把__main的地址加载到R0中</span><br><span class=\"line\">                BX      R0</span><br><span class=\"line\">                ; 跳转到R0执行, 执行完毕后不返回</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">                </span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 5-中断服务函数</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class=\"line\">; 中断服务函数均跳转到无限循环</span><br><span class=\"line\">; 目的是用户在未定义中断服务函数的情况下调用可进入无限循环状态中(兜底作用)</span><br><span class=\"line\"></span><br><span class=\"line\">NMI_Handler     PROC</span><br><span class=\"line\">                EXPORT  NMI_Handler                [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ; B 表示跳转指令</span><br><span class=\"line\">                ; . 表示无限循环</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">HardFault_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  HardFault_Handler          [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">MemManage_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  MemManage_Handler          [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">BusFault_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  BusFault_Handler           [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">UsageFault_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  UsageFault_Handler         [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">SVC_Handler     PROC</span><br><span class=\"line\">                EXPORT  SVC_Handler                [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">DebugMon_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  DebugMon_Handler           [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">PendSV_Handler  PROC</span><br><span class=\"line\">                EXPORT  PendSV_Handler             [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">SysTick_Handler PROC</span><br><span class=\"line\">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">Default_Handler PROC</span><br><span class=\"line\"></span><br><span class=\"line\">                EXPORT  WWDG_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  PVD_IRQHandler             [WEAK]</span><br><span class=\"line\">                EXPORT  TAMPER_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  RTC_IRQHandler             [WEAK]</span><br><span class=\"line\">                EXPORT  FLASH_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  RCC_IRQHandler             [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI0_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI1_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI2_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI3_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI4_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  ADC1_2_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]</span><br><span class=\"line\">                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]</span><br><span class=\"line\">                EXPORT  CAN1_RX1_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  CAN1_SCE_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI9_5_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_BRK_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_UP_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_CC_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM2_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM3_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM4_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  I2C1_EV_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  I2C1_ER_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  I2C2_EV_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  I2C2_ER_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  SPI1_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  SPI2_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  USART1_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  USART2_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  USART3_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI15_10_IRQHandler       [WEAK]</span><br><span class=\"line\">                EXPORT  RTCAlarm_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  USBWakeUp_IRQHandler       [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_BRK_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_UP_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_CC_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  ADC3_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  FSMC_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  SDIO_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM5_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  SPI3_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  UART4_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  UART5_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  TIM6_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM7_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]</span><br><span class=\"line\"></span><br><span class=\"line\">WWDG_IRQHandler</span><br><span class=\"line\">PVD_IRQHandler</span><br><span class=\"line\">TAMPER_IRQHandler</span><br><span class=\"line\">RTC_IRQHandler</span><br><span class=\"line\">FLASH_IRQHandler</span><br><span class=\"line\">RCC_IRQHandler</span><br><span class=\"line\">EXTI0_IRQHandler</span><br><span class=\"line\">EXTI1_IRQHandler</span><br><span class=\"line\">EXTI2_IRQHandler</span><br><span class=\"line\">EXTI3_IRQHandler</span><br><span class=\"line\">EXTI4_IRQHandler</span><br><span class=\"line\">DMA1_Channel1_IRQHandler</span><br><span class=\"line\">DMA1_Channel2_IRQHandler</span><br><span class=\"line\">DMA1_Channel3_IRQHandler</span><br><span class=\"line\">DMA1_Channel4_IRQHandler</span><br><span class=\"line\">DMA1_Channel5_IRQHandler</span><br><span class=\"line\">DMA1_Channel6_IRQHandler</span><br><span class=\"line\">DMA1_Channel7_IRQHandler</span><br><span class=\"line\">ADC1_2_IRQHandler</span><br><span class=\"line\">USB_HP_CAN1_TX_IRQHandler</span><br><span class=\"line\">USB_LP_CAN1_RX0_IRQHandler</span><br><span class=\"line\">CAN1_RX1_IRQHandler</span><br><span class=\"line\">CAN1_SCE_IRQHandler</span><br><span class=\"line\">EXTI9_5_IRQHandler</span><br><span class=\"line\">TIM1_BRK_IRQHandler</span><br><span class=\"line\">TIM1_UP_IRQHandler</span><br><span class=\"line\">TIM1_TRG_COM_IRQHandler</span><br><span class=\"line\">TIM1_CC_IRQHandler</span><br><span class=\"line\">TIM2_IRQHandler</span><br><span class=\"line\">TIM3_IRQHandler</span><br><span class=\"line\">TIM4_IRQHandler</span><br><span class=\"line\">I2C1_EV_IRQHandler</span><br><span class=\"line\">I2C1_ER_IRQHandler</span><br><span class=\"line\">I2C2_EV_IRQHandler</span><br><span class=\"line\">I2C2_ER_IRQHandler</span><br><span class=\"line\">SPI1_IRQHandler</span><br><span class=\"line\">SPI2_IRQHandler</span><br><span class=\"line\">USART1_IRQHandler</span><br><span class=\"line\">USART2_IRQHandler</span><br><span class=\"line\">USART3_IRQHandler</span><br><span class=\"line\">EXTI15_10_IRQHandler</span><br><span class=\"line\">RTCAlarm_IRQHandler</span><br><span class=\"line\">USBWakeUp_IRQHandler</span><br><span class=\"line\">TIM8_BRK_IRQHandler</span><br><span class=\"line\">TIM8_UP_IRQHandler</span><br><span class=\"line\">TIM8_TRG_COM_IRQHandler</span><br><span class=\"line\">TIM8_CC_IRQHandler</span><br><span class=\"line\">ADC3_IRQHandler</span><br><span class=\"line\">FSMC_IRQHandler</span><br><span class=\"line\">SDIO_IRQHandler</span><br><span class=\"line\">TIM5_IRQHandler</span><br><span class=\"line\">SPI3_IRQHandler</span><br><span class=\"line\">UART4_IRQHandler</span><br><span class=\"line\">UART5_IRQHandler</span><br><span class=\"line\">TIM6_IRQHandler</span><br><span class=\"line\">TIM7_IRQHandler</span><br><span class=\"line\">DMA2_Channel1_IRQHandler</span><br><span class=\"line\">DMA2_Channel2_IRQHandler</span><br><span class=\"line\">DMA2_Channel3_IRQHandler</span><br><span class=\"line\">DMA2_Channel4_5_IRQHandler</span><br><span class=\"line\">                B       .</span><br><span class=\"line\"></span><br><span class=\"line\">                ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">                ALIGN</span><br><span class=\"line\">                ; ALIGN 表示4字节对齐(参数缺省时)</span><br><span class=\"line\"></span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 6-堆栈的初始化, 由C库函数__main实现</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\">; User Stack and Heap initialization</span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\">                 IF      :DEF:__MICROLIB ; __MICROLIB在ide里定义, 在Keil5 MDK中勾选Use MicroLIB选项</span><br><span class=\"line\">                </span><br><span class=\"line\">                 EXPORT  __initial_sp</span><br><span class=\"line\">                 EXPORT  __heap_base</span><br><span class=\"line\">                 EXPORT  __heap_limit</span><br><span class=\"line\">                </span><br><span class=\"line\">                 ELSE</span><br><span class=\"line\">                </span><br><span class=\"line\">                 IMPORT  __use_two_region_memory ; 如果__MICROLIB未定义, 则由用户自己实现</span><br><span class=\"line\">                 EXPORT  __user_initial_stackheap</span><br><span class=\"line\">                 </span><br><span class=\"line\">__user_initial_stackheap</span><br><span class=\"line\"></span><br><span class=\"line\">                 LDR     R0, =  Heap_Mem</span><br><span class=\"line\">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class=\"line\">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class=\"line\">                 LDR     R3, = Stack_Mem</span><br><span class=\"line\">                 BX      LR</span><br><span class=\"line\"></span><br><span class=\"line\">                 ALIGN</span><br><span class=\"line\"></span><br><span class=\"line\">                 ENDIF</span><br><span class=\"line\"></span><br><span class=\"line\">                 END</span><br><span class=\"line\"></span><br><span class=\"line\">;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"equ指令\">EQU指令</h3>\n<p>作用: The EQU directive is a register-relative address, a PC-relative address, an absolute address, or a 32-bit integer constant. // 为数值常量、寄存器相对值或 PC 相对值提供符号名称。(<em>可以理解为重命名</em>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack_Size      EQU     0x00000400 </span><br><span class=\"line\">; 宏定义的伪指令，相当于等于，类似与 C 中的 define。</span><br><span class=\"line\">; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小</span><br></pre></td></tr></table></figure>\n<h4 id=\"equ手册说明\">EQU手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031428875.png\" alt=\"EQU指令\"></p>\n<h3 id=\"area指令\">AREA指令</h3>\n<p>AREA: 汇编一个新的代码段或数据段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class=\"line\">; 告诉汇编器汇编一个新的代码段或者数据段。</span><br><span class=\"line\">; STACK 表示段名，这个可以任意命名</span><br><span class=\"line\">; NOINIT 表示不初始化</span><br><span class=\"line\">; READWRITE 表示可读可写</span><br><span class=\"line\">; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐</span><br></pre></td></tr></table></figure>\n<h4 id=\"area手册说明\">AREA手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031529274.png\" alt=\"AREA\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530123.png\" alt=\"AREA\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530696.png\" alt=\"AREA\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031531689.png\" alt=\"AREA\"></p>\n<h3 id=\"space指令\">SPACE指令</h3>\n<p>SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size, 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack_Mem       SPACE   Stack_Size</span><br><span class=\"line\">; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</span><br><span class=\"line\">__initial_sp</span><br><span class=\"line\">; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</span><br></pre></td></tr></table></figure>\n<h4 id=\"space手册说明\">SPACE手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031539781.png\" alt=\"SPACE\"></p>\n<h3 id=\"preserve8指令\">PRESERVE8指令</h3>\n<p>PRESERVE8：指定当前文件的堆栈按照 8 字节对齐</p>\n<h4 id=\"preserve8手册说明\">PRESERVE8手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031556307.png\" alt=\"PRESERVE8\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031557775.png\" alt=\"PRESERVE8\"></p>\n<h3 id=\"thumb指令\">THUMB指令</h3>\n<p>野火的解释: <strong>THUMB：表示后面指令兼容 THUMB 指令。THUBM 是 ARM 以前的指令集，16bit，现在 Cortex-M系列的都使用 THUMB-2 指令集，THUMB-2 是 32 位的，兼容 16 位和 32 位的指令，是 THUMB的超集</strong></p>\n<h4 id=\"thumb手册说明\">THUMB手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031600256.png\" alt=\"THUMB\"></p>\n<h3 id=\"export指令\">EXPORT指令</h3>\n<p>EXPORT：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 IAR 编译器，则使用的是 GLOBAL 这个指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPORT  __Vectors</span><br><span class=\"line\">EXPORT  __Vectors_End</span><br><span class=\"line\">EXPORT  __Vectors_Size</span><br><span class=\"line\">; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用</span><br></pre></td></tr></table></figure>\n<h4 id=\"export手册说明\">EXPORT手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031623174.png\" alt=\"EXPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624509.png\" alt=\"EXPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624882.png\" alt=\"EXPORT\"></p>\n<h3 id=\"dcd指令\">DCD指令</h3>\n<p>DCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存</p>\n<h4 id=\"dcd手册说明\">DCD手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032016385.png\" alt=\"DCD\"></p>\n<h3 id=\"proc指令\">PROC指令</h3>\n<p>PROC: 定义子程序, 与ENDP成对使用, 表示子程序结束</p>\n<h4 id=\"proc手册说明\">PROC手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032025440.png\" alt=\"PROC\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032026200.png\" alt=\"PROC\"></p>\n<h3 id=\"import指令\">IMPORT指令</h3>\n<p>IMPORT：表示该标号来自外部文件，跟 C 语言中的 EXTERN 关键字类似</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IMPORT  __main</span><br><span class=\"line\">IMPORT  SystemInit</span><br><span class=\"line\">;表示 SystemInit和 __main 这两个函数均来自外部的文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"import手册说明\">IMPORT手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034894.png\" alt=\"IMPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034604.png\" alt=\"IMPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032035341.png\" alt=\"IMPORT\"></p>\n<h3 id=\"ldr指令\">LDR指令</h3>\n<p>LDR: 从存储器中加载字到一个寄存器中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDR     R0, =SystemInit</span><br><span class=\"line\">; 把SystemInit的地址加载到R0中</span><br><span class=\"line\">BLX     R0               </span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后返回</span><br><span class=\"line\">LDR     R0, =__main</span><br><span class=\"line\">; 把__main的地址加载到R0中</span><br><span class=\"line\">BX      R0</span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后不返回</span><br></pre></td></tr></table></figure>\n<h4 id=\"ldr手册说明\">LDR手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046548.png\" alt=\"LDR\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046349.png\" alt=\"LDR\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032047305.png\" alt=\"LDR\"></p>\n<h3 id=\"blx指令\">BLX指令</h3>\n<p>BLX: 跳转到由寄存器给出的地址, 并根据寄存器的LSE确定处理器的状态, 还要把跳转前的下条指令地址保存到LR</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BLX     R0               </span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后返回</span><br></pre></td></tr></table></figure>\n<h3 id=\"bx指令\">BX指令</h3>\n<p>BX: 跳转到由寄存器/标号给出的地址, 不用返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BX      R0</span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后不返回</span><br></pre></td></tr></table></figure>\n<h3 id=\"align指令\">ALIGN指令</h3>\n<p>ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐</p>\n<h4 id=\"align手册说明\">ALIGN手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103293.png\" alt=\"ALIGN\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103739.png\" alt=\"ALIGN\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103256.png\" alt=\"ALIGN\"></p>\n<h2 id=\"时钟\">时钟</h2>\n<h3 id=\"时钟系统框图\">时钟系统框图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2009.47.02.png\" alt=\"时钟系统框图\"></p>\n<h4 id=\"sysclk系统时钟源选择\">SYSCLK系统时钟源选择</h4>\n<ul>\n<li>HSI_RC: 高速内部时钟, RC 震荡产生(频率约为 8MHz)</li>\n<li>HSE: 高速外部时钟,通过外接晶振产生(频率范围: 4-16MHz)</li>\n<li>PLL: 锁相环,倍频到72MHz</li>\n</ul>\n<h5 id=\"sysclk-系统时钟的选择\">SYSCLK 系统时钟的选择</h5>\n<ol>\n<li>HSI_RC 约 8MHz</li>\n<li>PLLCLK 倍频至72MHz</li>\n<li>HSE_Osc直接使用</li>\n</ol>\n<h5 id=\"pll锁相环的选择\">PLL锁相环的选择</h5>\n<ol>\n<li>HSI_RC 两分频后</li>\n<li>HSE_Osc or HSE_Osc二分频后</li>\n</ol>\n<p>CSS: 时钟监视系统, 监视 HSE_Osc 是否正常工作,若 外部时钟源异常则将 SYSCLK 切换为 HSI_RC</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.03.07.png\" alt=\"时钟系统框图\"></p>\n<h4 id=\"rtcclk时钟源选择\">RTCCLK时钟源选择</h4>\n<ul>\n<li>LSE_Osc: 低速外部时钟源, 频率为36.768KHz</li>\n<li>LSI_RC: 低速内部时钟源, 频率约为40KHz, 由 RC 震荡产生</li>\n</ul>\n<h5 id=\"rtc_clk(rtc-时钟)的选择\">RTC_CLK(RTC 时钟)的选择</h5>\n<ol>\n<li>HSE_Osc 128 分频后</li>\n<li>LSE_Osc</li>\n<li>LSI_RC</li>\n</ol>\n<h4 id=\"iwdgclk独立看门狗时钟源\">IWDGCLK独立看门狗时钟源</h4>\n<p>IWDGCLK独立看门狗时钟源由LSI_RC 提供</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401291156077.png\" alt=\"IWDGCLK独立看门狗时钟源\"></p>\n<h4 id=\"mco-的选择\">MCO 的选择</h4>\n<p>MCO是一个引脚来输出内部时钟</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.13.53.png\" alt=\"系统时钟框图\"></p>\n<ol>\n<li>SYSCLK</li>\n<li>HSI</li>\n<li>HSE</li>\n<li>PLLCLK 二分频</li>\n</ol>\n<h4 id=\"各类总线时钟\">各类总线时钟</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.26.21.png\" alt=\"时钟系统框图\"></p>\n<ol>\n<li>USBCLK_48MHz (USB 时钟): 由 PLLCLK经USB_Prescaler预分频至 48MHz</li>\n<li>HCLK: SYSCLK-&gt;AHB_Prescaler 最高 72MHz</li>\n<li>PCLK1: SYSCLK-&gt;AHB_Prescaler-&gt;APB1_Prescaler 最高36MHz</li>\n<li>TIMxCLK(通用定时器时钟): SYSCLK-&gt;AHB_Prescaler-&gt;APB1_Prescaler-&gt;TIM2,3,4_Multiplier</li>\n<li>PCKL2: SYSCLK-&gt;AHB_Prescaler-&gt;APB2_Prescaler 最高72MHz</li>\n<li>TIM1CLK(TIM1 时钟): SYSCLK-&gt;AHB_Prescal-&gt;APB2_Prescaler-&gt;TIM1_Multiplier</li>\n<li>ADCCLK(ADC 时钟): SYSCLK-&gt;AHB_Prescaler-&gt;APB2_Prescaler-&gt;ADC_Prescaler</li>\n</ol>\n<h4 id=\"总结\">总结</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2011.09.39.png\" alt=\"知识总结\"></p>\n<h3 id=\"系统时钟配置函数-setsysclockto72()分析\">系统时钟配置函数 SetSysClockTo72()分析</h3>\n<p>在启动文件startup_stm32f10x_hd.s中执行SystemInit函数, 如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; Reset handler</span><br><span class=\"line\">Reset_Handler   PROC</span><br><span class=\"line\">                EXPORT  Reset_Handler             [WEAK]</span><br><span class=\"line\">                IMPORT  __main</span><br><span class=\"line\">                IMPORT  SystemInit</span><br><span class=\"line\">                LDR     R0, =SystemInit</span><br><span class=\"line\">                BLX     R0               </span><br><span class=\"line\">                LDR     R0, =__main</span><br><span class=\"line\">                BX      R0</span><br><span class=\"line\">                ENDP</span><br></pre></td></tr></table></figure>\n<p>在system_stm32f10x.c文件中调用SystemInit函数, SystemInit函数在末尾调用SetSysClock()函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SystemInit</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Reset the RCC clock configuration to the default reset state(for debug purpose) */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Set HSION bit */</span></span><br><span class=\"line\">  RCC-&gt;CR |= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x00000001</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> STM32F10X_CL</span></span><br><span class=\"line\">  RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xF8FF0000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xF0FF0000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* STM32F10X_CL */</span>   </span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Reset HSEON, CSSON and PLLON bits */</span></span><br><span class=\"line\">  RCC-&gt;CR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xFEF6FFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset HSEBYP bit */</span></span><br><span class=\"line\">  RCC-&gt;CR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xFFFBFFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span></span><br><span class=\"line\">  RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xFF80FFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> STM32F10X_CL</span></span><br><span class=\"line\">  <span class=\"comment\">/* Reset PLL2ON and PLL3ON bits */</span></span><br><span class=\"line\">  RCC-&gt;CR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xEBFFFFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Disable all interrupts and clear pending bits  */</span></span><br><span class=\"line\">  RCC-&gt;CIR = <span class=\"number\">0x00FF0000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset CFGR2 register */</span></span><br><span class=\"line\">  RCC-&gt;CFGR2 = <span class=\"number\">0x00000000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class=\"line\">  <span class=\"comment\">/* Disable all interrupts and clear pending bits  */</span></span><br><span class=\"line\">  RCC-&gt;CIR = <span class=\"number\">0x009F0000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset CFGR2 register */</span></span><br><span class=\"line\">  RCC-&gt;CFGR2 = <span class=\"number\">0x00000000</span>;      </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"comment\">/* Disable all interrupts and clear pending bits  */</span></span><br><span class=\"line\">  RCC-&gt;CIR = <span class=\"number\">0x009F0000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* STM32F10X_CL */</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)</span></span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> DATA_IN_ExtSRAM</span></span><br><span class=\"line\">    SystemInit_ExtMemCtl(); </span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* DATA_IN_ExtSRAM */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Configure the Flash Latency cycles and enable prefetch buffer */</span></span><br><span class=\"line\">  SetSysClock(); <span class=\"comment\">// 末尾调用SetSysClock()函数 </span></span><br></pre></td></tr></table></figure>\n<p>调用system_stm32f10x.c中SetSysClock()</p>\n<p>默认情况下定义SYSCLK_FREQ_72MHz宏, 调用SetSysClockTo72()函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  None</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">SetSysClock</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SYSCLK_FREQ_HSE</span></span><br><span class=\"line\">  SetSysClockToHSE();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_24MHz</span></span><br><span class=\"line\">  SetSysClockTo24();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_36MHz</span></span><br><span class=\"line\">  SetSysClockTo36();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_48MHz</span></span><br><span class=\"line\">  SetSysClockTo48();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_56MHz</span></span><br><span class=\"line\">  SetSysClockTo56();  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class=\"line\">  SetSysClockTo72();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/* If none of the define above is enabled, the HSI is used as System clock</span></span><br><span class=\"line\"><span class=\"comment\">    source (default after reset) */</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在system_stm32f10x.c中宏定义, 默认宏定义SYSTEMCLK_FREQ_72MHz</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_HSE    HSE_VALUE */</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> SYSCLK_FREQ_24MHz  24000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_HSE    HSE_VALUE */</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_24MHz  24000000 */</span> </span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_36MHz  36000000 */</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_48MHz  48000000 */</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_56MHz  56000000 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SYSCLK_FREQ_72MHz  72000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>在system_stem32f10x.c中定义SetSysClockTo72()函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 </span></span><br><span class=\"line\"><span class=\"comment\">  *         and PCLK1 prescalers. </span></span><br><span class=\"line\"><span class=\"comment\">  * @note   This function should be used only after reset.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  None</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">SetSysClockTo72</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> StartUpCounter = <span class=\"number\">0</span>, HSEStatus = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/</span>    </span><br><span class=\"line\">  <span class=\"comment\">/* Enable HSE */</span>    </span><br><span class=\"line\">  <span class=\"comment\">// 使能HSE</span></span><br><span class=\"line\">  RCC-&gt;CR |= ((<span class=\"type\">uint32_t</span>)RCC_CR_HSEON);</span><br><span class=\"line\">  </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class=\"line\">  <span class=\"comment\">// 等待 HSE 就绪并作超时处理</span></span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class=\"line\">    StartUpCounter++;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span>((HSEStatus == <span class=\"number\">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    HSEStatus = (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    HSEStatus = (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x00</span>;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果 HSE启动成功, 程序则继续往下执行</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (HSEStatus == (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Enable Prefetch Buffer */</span></span><br><span class=\"line\">    <span class=\"comment\">// 启用 Flsh  预取缓冲区</span></span><br><span class=\"line\">    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Flash 2 wait state */</span></span><br><span class=\"line\">    <span class=\"comment\">// flash 时延两个等待状态</span></span><br><span class=\"line\">    FLASH-&gt;ACR &amp;= (<span class=\"type\">uint32_t</span>)((<span class=\"type\">uint32_t</span>)~FLASH_ACR_LATENCY);</span><br><span class=\"line\">    FLASH-&gt;ACR |= (<span class=\"type\">uint32_t</span>)FLASH_ACR_LATENCY_2;    </span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/* HCLK = SYSCLK */</span></span><br><span class=\"line\">    <span class=\"comment\">// 72MHz</span></span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_HPRE_DIV1;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/* PCLK2 = HCLK */</span></span><br><span class=\"line\">    <span class=\"comment\">// 72MHz</span></span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_PPRE2_DIV1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* PCLK1 = HCLK */</span></span><br><span class=\"line\">    <span class=\"comment\">// 36MHz</span></span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 互联型芯片 F105, F107 以下代码不进行分析</span></span><br><span class=\"line\"><span class=\"comment\"> *---------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**********************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> STM32F10X_CL</span></span><br><span class=\"line\">    <span class=\"comment\">/* Configure PLLs ------------------------------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */</span></span><br><span class=\"line\">    <span class=\"comment\">/* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    RCC-&gt;CFGR2 &amp;= (<span class=\"type\">uint32_t</span>)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |</span><br><span class=\"line\">                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);</span><br><span class=\"line\">    RCC-&gt;CFGR2 |= (<span class=\"type\">uint32_t</span>)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |</span><br><span class=\"line\">                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* Enable PLL2 */</span></span><br><span class=\"line\">    RCC-&gt;CR |= RCC_CR_PLL2ON;</span><br><span class=\"line\">    <span class=\"comment\">/* Wait till PLL2 is ready */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */</span> </span><br><span class=\"line\">    <span class=\"comment\">// 锁相环配置</span></span><br><span class=\"line\">    RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);</span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | </span><br><span class=\"line\">                            RCC_CFGR_PLLMULL9); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span>    </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Enable PLL */</span></span><br><span class=\"line\">    <span class=\"comment\">// 使能 PLL</span></span><br><span class=\"line\">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Wait till PLL is ready */</span></span><br><span class=\"line\">    <span class=\"comment\">//  等待 PLL 稳定</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* Select PLL as system clock source */</span></span><br><span class=\"line\">    <span class=\"comment\">// 选择 PLLCLK 作为系统时钟</span></span><br><span class=\"line\">    RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)((<span class=\"type\">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_SW_PLL;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Wait till PLL is used as system clock source */</span></span><br><span class=\"line\">    <span class=\"comment\">// 等待 PLLCLK 切换为系统时钟</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((RCC-&gt;CFGR &amp; (<span class=\"type\">uint32_t</span>)RCC_CFGR_SWS) != (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x08</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123; <span class=\"comment\">/* If HSE fails to start-up, the application will have wrong clock </span></span><br><span class=\"line\"><span class=\"comment\">         configuration. User can add here some code to deal with this error */</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 HSE 启动失败,用户可以在这里添加处理错误的代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hse配置系统时钟\">HSE配置系统时钟</h3>\n<p>项目地址: <strong>16-使用HSE配置系统时钟并使用MCO输出监控系统时钟</strong></p>\n<h4 id=\"在bsp_rccclkconfigc中写入hse的配置函数\">在bsp_rccclkconfig.c中写入HSE的配置函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 设置系统时钟为外部高速晶振（HSE）时钟，并配置PLL倍频系数。</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param RCC_PLLMul_x PLL倍频系数，范围为2-16。</span></span><br><span class=\"line\"><span class=\"comment\"> * @note 该函数会将RCC模块复位，并使能HSE。如果HSE启动成功，则设置FLASH预取指令使能、FLASH等待周期、AHB总线时钟、APB1总线时钟、APB2总线时钟、PLL倍频系数，并等待PLL稳定后将系统时钟设置为PLL时钟。</span></span><br><span class=\"line\"><span class=\"comment\"> *       如果HSE启动失败，则用户可以在函数中添加处理错误的代码。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSE_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RCC_DeInit(); <span class=\"comment\">// RCC复位</span></span><br><span class=\"line\">    ErrorStatus HSEStatus;</span><br><span class=\"line\">    RCC_HSEConfig(RCC_HSE_ON); <span class=\"comment\">// 使能HSE</span></span><br><span class=\"line\">    HSEStatus = RCC_WaitForHSEStartUp(); <span class=\"comment\">// 获取HSE启动状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(HSEStatus == SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class=\"comment\">// 使能预取指</span></span><br><span class=\"line\">        FLASH_SetLatency(FLASH_ACR_LATENCY_2); <span class=\"comment\">// 设置等待</span></span><br><span class=\"line\">        RCC_HCLKConfig(RCC_SYSCLK_Div1); <span class=\"comment\">//HCLK = SYSCLK = 72MHz</span></span><br><span class=\"line\">        RCC_PCLK1Config(RCC_SYSCLK_Div2); <span class=\"comment\">//PCLK1 = HCLK / 2 = 36MHz</span></span><br><span class=\"line\">        RCC_PCLK2Config(RCC_SYSCLK_Div1); <span class=\"comment\">//PCLK2 = HCLK / 1 = 72MHz</span></span><br><span class=\"line\">        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_x); <span class=\"comment\">// RCC_RLLMul_x 用来超频 频率:(8*x)MHz</span></span><br><span class=\"line\">        RCC_PLLCmd(ENABLE); <span class=\"comment\">// 使能PLL</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待PLL稳定</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); <span class=\"comment\">// 设置系统时钟为PLL时钟</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetSYSCLKSource() != <span class=\"number\">0x08</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待设置系统时钟</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果HSE启动失败, 用户在此添加处理错误代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_rccclkconfigc中编写mco的gpio初始化函数\">在bsp_rccclkconfig.c中编写MCO的GPIO初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Configures the GPIO for MCO (Microcontroller Clock Output).</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This function initializes the GPIO pin for MCO and configures it as an alternate function push-pull output.</span></span><br><span class=\"line\"><span class=\"comment\"> * The GPIO pin used for MCO is GPIOA Pin 8.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @return None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MCO_GPIO_Config</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// MCO的GPIO初始化</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_rccclkconfigh中添加函数声明\">在bsp_rccclkconfig.h中添加函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_RCCCLKCONFIG_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_RCCCLKCONFIG_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSE_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MCO_GPIO_Config</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_RCCCLKCONFIG_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用hse配置系统时钟函数和mco的gpio初始化函数\">在main.c中调用HSE配置系统时钟函数和MCO的GPIO初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_rccclkconfig.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延时函数Delay()</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; count != <span class=\"number\">0</span>; count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">0x2AFF</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HSE_SetSysClk(RCC_PLLMul_9); <span class=\"comment\">// 72MHz</span></span><br><span class=\"line\">    <span class=\"comment\">// HSE_SetSysClk(RCC_PLLMul_16); // 128MHz</span></span><br><span class=\"line\">    MCO_GPIO_Config();</span><br><span class=\"line\">    RCC_MCOConfig(RCC_MCO_SYSCLK); <span class=\"comment\">// 配置MCO选择系统时钟</span></span><br><span class=\"line\">    LED_GPIO_Config();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_B(OFF);</span><br><span class=\"line\">        Delay(<span class=\"number\">50</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">        LED_B(ON);</span><br><span class=\"line\">        Delay(<span class=\"number\">50</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用hsi配置系统时钟并用mco监控系统时钟\">使用HSI配置系统时钟并用MCO监控系统时钟</h3>\n<p>项目地址: <strong>16-使用HSI配置系统时钟并用MCO监控系统时钟</strong></p>\n<h4 id=\"在bsp_rccclkconfigc中编写hsi配置系统时钟函数\">在bsp_rccclkconfig.c中编写HSI配置系统时钟函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 设置系统时钟为HSI，并配置PLL倍频系数</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param RCC_PLLMul_x PLL倍频系数，范围为2-16</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @note 该函数将系统时钟设置为HSI，并根据传入的PLL倍频系数配置PLL，以实现超频功能。</span></span><br><span class=\"line\"><span class=\"comment\"> *       如果HSI启动失败，用户可以在函数的else分支中添加处理错误的代码。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSI_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Function implementation</span></span><br><span class=\"line\">    __IO <span class=\"type\">uint32_t</span> HSIStatus = <span class=\"number\">0</span>; <span class=\"comment\">// 参考固件库源码</span></span><br><span class=\"line\">    RCC_DeInit(); <span class=\"comment\">// RCC复位</span></span><br><span class=\"line\">    RCC_HSICmd(ENABLE); <span class=\"comment\">// 使能HSI</span></span><br><span class=\"line\">    HSIStatus = RCC-&gt;CR &amp; RCC_CR_HSIRDY; <span class=\"comment\">// 获取HSI启动状态, 参考固件库源码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(HSIStatus == RCC_CR_HSIRDY)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class=\"comment\">// 使能预取指</span></span><br><span class=\"line\">        FLASH_SetLatency(FLASH_ACR_LATENCY_2); <span class=\"comment\">// 设置等待</span></span><br><span class=\"line\">        RCC_HCLKConfig(RCC_SYSCLK_Div1); <span class=\"comment\">//HCLK = SYSCLK = 72MHz</span></span><br><span class=\"line\">        RCC_PCLK1Config(RCC_SYSCLK_Div2); <span class=\"comment\">//PCLK1 = HCLK / 2 = 36MHz</span></span><br><span class=\"line\">        RCC_PCLK2Config(RCC_SYSCLK_Div1); <span class=\"comment\">//PCLK2 = HCLK / 1 = 72MHz</span></span><br><span class=\"line\">        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_x); <span class=\"comment\">// RCC_RLLMul_x 用来超频 频率:(8*x)MHz</span></span><br><span class=\"line\">        RCC_PLLCmd(ENABLE); <span class=\"comment\">// 使能PLL</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待PLL稳定</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); <span class=\"comment\">// 设置系统时钟为PLL时钟</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetSYSCLKSource() != <span class=\"number\">0x08</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待设置系统时钟</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果HSI启动失败, 用户在此添加处理错误代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_rccclkconfigh中加入函数声明\">在bsp_rccclkconfig.h中加入函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSI_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用hsi配置系统时钟函数\">在main.c中调用HSI配置系统时钟函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSI_SetSysClk(RCC_PLLMul_12); <span class=\"comment\">// 4*12=48MHz</span></span><br><span class=\"line\">MCO_GPIO_Config();</span><br><span class=\"line\">RCC_MCOConfig(RCC_MCO_SYSCLK); <span class=\"comment\">// 配置MCO选择系统时钟</span></span><br><span class=\"line\">LED_GPIO_Config();</span><br></pre></td></tr></table></figure>\n<h2 id=\"中断\">中断</h2>\n<h3 id=\"stm32中断应用概览\">STM32中断应用概览</h3>\n<h4 id=\"中断类型\">中断类型</h4>\n<ul>\n<li>系统异常: 体现在内核水平</li>\n<li>外部中断: 体现在外设水平</li>\n</ul>\n<h4 id=\"nvic\">NVIC</h4>\n<p>NVIC负责管理中断</p>\n<p>在core_cm3.h中的定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC</span></span><br><span class=\"line\"><span class=\"comment\">  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)</span></span><br><span class=\"line\"><span class=\"comment\">  @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 中断使能寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ISER[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x000  Interrupt Set Enable Register           */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED0[<span class=\"number\">24</span>];                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断清除寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ICER[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x080  Interrupt Clear Enable Register         */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RSERVED1[<span class=\"number\">24</span>];                                    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断使能悬起寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ISPR[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x100  Interrupt Set Pending Register          */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED2[<span class=\"number\">24</span>];                                   </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 中断清除悬起寄存器 </span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ICPR[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x180  Interrupt Clear Pending Register        */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED3[<span class=\"number\">24</span>];                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断有效位寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> IABR[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x200  Interrupt Active bit Register           */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED4[<span class=\"number\">56</span>];                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断优先级寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint8_t</span>  IP[<span class=\"number\">240</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x300  Interrupt Priority Register (8Bit wide) */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED5[<span class=\"number\">644</span>];                                  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 软件触发中断寄存器</span></span><br><span class=\"line\">  __O  <span class=\"type\">uint32_t</span> STIR;                         <span class=\"comment\">/*!&lt; Offset: 0xE00  Software Trigger Interrupt Register     */</span></span><br><span class=\"line\">&#125;  NVIC_Type;                                               </span><br><span class=\"line\"><span class=\"comment\">/*@&#125;*/</span> <span class=\"comment\">/* end of group CMSIS_CM3_NVIC */</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"nvic的优先级分组\">NVIC的优先级分组</h5>\n<p>通过<strong>SCB-&gt;AIRCR寄存器的PRIGROUP部分(即bit[10:8])进行分组</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401140238595.png\" alt=\"NVIC优先级\"></p>\n<h3 id=\"中断编程的顺序\">中断编程的顺序</h3>\n<ol>\n<li>使能中断请求(<strong>使能外设中断, 使能 NVIC 中断</strong>)</li>\n<li>配置中断优先级分组(NVIC_PriorityGroupConfig)</li>\n<li>配置 NVIC 寄存器, 初始化NVIC_InitTypeDef</li>\n<li>编写中断服务函数</li>\n</ol>\n<h2 id=\"exti\">EXTI</h2>\n<h3 id=\"exti-输入线\">EXTI 输入线</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.13.32.png\" alt=\"EXTI 输入线\"></p>\n<p>通过寄存器 AFIO_EXTICR1, 2, 3, 4配置</p>\n<h3 id=\"exti-框图讲解\">EXTI 框图讲解</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.18.42.png\" alt=\"EXTI 框图\"></p>\n<h4 id=\"外部中断流程\">外部中断流程</h4>\n<ol>\n<li>通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1</li>\n<li>通过 EXTI_SWIER 来配置软件中断, 配置后为 1</li>\n<li>经过逻辑与门后, 进入请求挂起寄存器</li>\n<li>通过 EXTI_PR 配置挂起</li>\n<li>通过 EXTI_IMR 配置中断屏蔽</li>\n<li>请求挂起寄存器的逻辑值与中断屏蔽寄存器的逻辑值做逻辑与至 NVIC 中断控制器</li>\n</ol>\n<h4 id=\"外部事件流程\">外部事件流程</h4>\n<ol>\n<li>通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1</li>\n<li>通过 EXTI_SWIER 来配置软件中断, 配置后为 1</li>\n<li>经过逻辑与门后, 向下跟事件屏蔽寄存器相与</li>\n<li>通过 EXTI_EMR 配置事件屏蔽</li>\n<li>若为 1 产生脉冲</li>\n</ol>\n<h3 id=\"exti-结构体\">EXTI 结构体</h3>\n<p>EXTI_InitTypeDef</p>\n<ul>\n<li>EXTI_Line : 用于产生中断/事件线</li>\n<li>EXTI_Mode : EXTI 模式(中断/事件)</li>\n<li>EXTI_Trigger : 触发(上/下/上下)</li>\n<li>EXTI_LineCmd :  使能或者失能(IMR/EMR)</li>\n</ul>\n<h4 id=\"exti-的结构体定义\">EXTI 的结构体定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  EXTI Init Structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> EXTI_Line;               <span class=\"comment\">/*!&lt; Specifies the EXTI lines to be enabled or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be any combination of @ref EXTI_Lines */</span></span><br><span class=\"line\">   </span><br><span class=\"line\">  EXTIMode_TypeDef EXTI_Mode;       <span class=\"comment\">/*!&lt; Specifies the mode for the EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref EXTIMode_TypeDef */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  EXTITrigger_TypeDef EXTI_Trigger; <span class=\"comment\">/*!&lt; Specifies the trigger signal active edge for the EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref EXTIMode_TypeDef */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  FunctionalState EXTI_LineCmd;     <span class=\"comment\">/*!&lt; Specifies the new state of the selected EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be set either to ENABLE or DISABLE */</span> </span><br><span class=\"line\">&#125;EXTI_InitTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"exti_line-的定义\">EXTI_Line 的定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @defgroup EXTI_Lines </span></span><br><span class=\"line\"><span class=\"comment\">  * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line0       ((uint32_t)0x00001)  <span class=\"comment\">/*!&lt; External interrupt line 0 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line1       ((uint32_t)0x00002)  <span class=\"comment\">/*!&lt; External interrupt line 1 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line2       ((uint32_t)0x00004)  <span class=\"comment\">/*!&lt; External interrupt line 2 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line3       ((uint32_t)0x00008)  <span class=\"comment\">/*!&lt; External interrupt line 3 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line4       ((uint32_t)0x00010)  <span class=\"comment\">/*!&lt; External interrupt line 4 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line5       ((uint32_t)0x00020)  <span class=\"comment\">/*!&lt; External interrupt line 5 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line6       ((uint32_t)0x00040)  <span class=\"comment\">/*!&lt; External interrupt line 6 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line7       ((uint32_t)0x00080)  <span class=\"comment\">/*!&lt; External interrupt line 7 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line8       ((uint32_t)0x00100)  <span class=\"comment\">/*!&lt; External interrupt line 8 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line9       ((uint32_t)0x00200)  <span class=\"comment\">/*!&lt; External interrupt line 9 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line10      ((uint32_t)0x00400)  <span class=\"comment\">/*!&lt; External interrupt line 10 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line11      ((uint32_t)0x00800)  <span class=\"comment\">/*!&lt; External interrupt line 11 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line12      ((uint32_t)0x01000)  <span class=\"comment\">/*!&lt; External interrupt line 12 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line13      ((uint32_t)0x02000)  <span class=\"comment\">/*!&lt; External interrupt line 13 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line14      ((uint32_t)0x04000)  <span class=\"comment\">/*!&lt; External interrupt line 14 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line15      ((uint32_t)0x08000)  <span class=\"comment\">/*!&lt; External interrupt line 15 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line16      ((uint32_t)0x10000)  <span class=\"comment\">/*!&lt; External interrupt line 16 Connected to the PVD Output */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line17      ((uint32_t)0x20000)  <span class=\"comment\">/*!&lt; External interrupt line 17 Connected to the RTC Alarm event */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line18      ((uint32_t)0x40000)  <span class=\"comment\">/*!&lt; External interrupt line 18 Connected to the USB Device/USB OTG FS</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"meta\">                                                   Wakeup from suspend event */</span>                                    </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line19      ((uint32_t)0x80000)  <span class=\"comment\">/*!&lt; External interrupt line 19 Connected to the Ethernet Wakeup event */</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"exti_mode-的定义\">EXTI_Mode 的定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  EXTI mode enumeration  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  EXTI_Mode_Interrupt = <span class=\"number\">0x00</span>,</span><br><span class=\"line\">  EXTI_Mode_Event = <span class=\"number\">0x04</span></span><br><span class=\"line\">&#125;EXTIMode_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"exti_trigger-的定义\">EXTI_Trigger 的定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  EXTI Trigger enumeration  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  EXTI_Trigger_Rising = <span class=\"number\">0x08</span>,</span><br><span class=\"line\">  EXTI_Trigger_Falling = <span class=\"number\">0x0C</span>,  </span><br><span class=\"line\">  EXTI_Trigger_Rising_Falling = <span class=\"number\">0x10</span></span><br><span class=\"line\">&#125;EXTITrigger_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \\</span></span><br><span class=\"line\"><span class=\"meta\">                                  ((TRIGGER) == EXTI_Trigger_Falling) || \\</span></span><br><span class=\"line\"><span class=\"meta\">                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"gpio-作为 exti 输入线的配置\">GPIO 作为 EXTI 输入线的配置</h3>\n<p>在 stm32f10x_gpio.c 中, 使用 GPIO_EXTILineConfig 函数进行配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Selects the GPIO pin used as EXTI Line.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  GPIO_PinSource: specifies the EXTI line to be configured.</span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be GPIO_PinSourcex where x can be (0..15).</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_EXTILineConfig</span><span class=\"params\">(<span class=\"type\">uint8_t</span> GPIO_PortSource, <span class=\"type\">uint8_t</span> GPIO_PinSource)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> tmp = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* Check the parameters */</span></span><br><span class=\"line\">  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));</span><br><span class=\"line\">  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));</span><br><span class=\"line\">  </span><br><span class=\"line\">  tmp = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>) &lt;&lt; (<span class=\"number\">0x04</span> * (GPIO_PinSource &amp; (<span class=\"type\">uint8_t</span>)<span class=\"number\">0x03</span>));</span><br><span class=\"line\">  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; <span class=\"number\">0x02</span>] &amp;= ~tmp;</span><br><span class=\"line\">  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; <span class=\"number\">0x02</span>] |= (((<span class=\"type\">uint32_t</span>)GPIO_PortSource) &lt;&lt; (<span class=\"number\">0x04</span> * (GPIO_PinSource &amp; (<span class=\"type\">uint8_t</span>)<span class=\"number\">0x03</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"exti中断实验\">EXTI中断实验</h3>\n<p>项目地址: <strong>18-EXTI</strong></p>\n<p><strong>项目需求:</strong></p>\n<ol>\n<li>PA0 连接到 EXTI 用于产生中断, PA0 的电平变化通过按键来控制</li>\n<li>产生一次中断, LED 反转一次</li>\n</ol>\n<h4 id=\"在bsp_extic中初始化要连接到exti的gpio\">在bsp_exti.c中初始化要连接到EXTI的GPIO</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 Key1(PA0)</span></span><br><span class=\"line\">RCC_APB2PeriphClockCmd(KEY1_INT_GPIO_CLK, ENABLE);</span><br><span class=\"line\">GPIO_InitStruct.GPIO_Pin = KEY1_INT_GPIO_PIN;</span><br><span class=\"line\">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">GPIO_Init(KEY1_INT_GPIO_PORT, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_extic中初始化exti用于产生中断/事件\">在bsp_exti.c中初始化EXTI用于产生中断/事件</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); <span class=\"comment\">// 选择输入线</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_Line = EXTI_Line0;                     <span class=\"comment\">// 选择EXTI线路</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class=\"comment\">// 选择中断模式</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;         <span class=\"comment\">// 选择触发模式</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_LineCmd = ENABLE;                          <span class=\"comment\">// 使能EXTI线路</span></span><br><span class=\"line\">EXTI_Init(&amp;EXTI_InitStruct);</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_extic中初始化nvic,-用于处理中断\">在bsp_exti.c中初始化NVIC, 用于处理中断</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class=\"line\"></span><br><span class=\"line\">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); <span class=\"comment\">// 配置中断优先级分组</span></span><br><span class=\"line\"></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn; <span class=\"comment\">// 选择中断源</span></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">1</span>; <span class=\"comment\">// 抢占优先级</span></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class=\"number\">1</span>; <span class=\"comment\">// 子优先级</span></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; <span class=\"comment\">// 使能中断</span></span><br><span class=\"line\">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_itc中编写中断服务函数\">在stm32f10x_it.c中编写中断服务函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief EXTI0_IRQHandler: Interrupt handler for EXTI Line 0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This function is the interrupt handler for EXTI Line 0. It toggles the state of the blue LED.</span></span><br><span class=\"line\"><span class=\"comment\"> * It checks the interrupt status of EXTI Line 0 and clears the interrupt pending bit.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI0_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(EXTI_GetITStatus(EXTI_Line0) != RESET) <span class=\"comment\">// 判断中断位</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    LED_B_TOGGLE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  EXTI_ClearITPendingBit(EXTI_Line0); <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledh中编写电平反转函数\">在bsp_led.h中编写电平反转函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_TOGGLE &#123;LED_B_GPIO_PORT-&gt;ODR ^= LED_B_GPIO_PIN;&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"补充:-使能afio时钟\">补充: 使能AFIO时钟</h3>\n<p>在STM32微控制器系列中，使用外部中断（EXTI）时需要开启AFIO（Alternate Function IO）时钟的原因与STM32的硬件设计和引脚复用功能有关。</p>\n<h4 id=\"afio的作用\">AFIO的作用</h4>\n<ol>\n<li><strong>引脚复用</strong>：STM32的GPIO（通用输入输出）引脚具有多功能性。一个物理引脚可以用作普通的I/O，也可以被配置为特殊功能，如USART、SPI、I2C通信或外部中断（EXTI）等。AFIO（Alternate Function IO）模块负责管理这些引脚的复用功能。</li>\n<li><strong>EXTI配置</strong>：在STM32中，外部中断线（EXTI）可以映射到不同的GPIO引脚上。AFIO模块提供了这种映射功能。例如，如果你想将EXTI0配置为由PA0、PB0、PC0等其中一个引脚触发，就需要通过AFIO模块来设置这种映射。</li>\n</ol>\n<h4 id=\"开启afio时钟的原因\">开启AFIO时钟的原因</h4>\n<p><strong>由于AFIO模块负责处理引脚的复用功能，包括EXTI的引脚映射，因此在使用EXTI功能之前，必须确保AFIO模块的时钟是使能的</strong>如果没有使能AFIO时钟，对AFIO寄存器的任何配置操作都不会生效，这意味着EXTI线路无法正确地映射到相应的GPIO引脚上，从而导致外部中断功能无法正常工作。</p>\n<h4 id=\"afio的实际操作\">AFIO的实际操作</h4>\n<p>在STM32的标准固件库或HAL（硬件抽象层）库中，通常会看到类似以下的代码片段，用于使能AFIO时钟：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br></pre></td></tr></table></figure>\n<p>或在使用HAL库时：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__HAL_RCC_AFIO_CLK_ENABLE();</span><br></pre></td></tr></table></figure>\n<p>这些函数调用确保了AFIO模块的时钟被使能，从而使得外部中断的相关配置（如引脚映射）能够正确执行。</p>\n<h4 id=\"afio的总结\">AFIO的总结</h4>\n<p>开启AFIO时钟是使用STM32的EXTI功能的必要步骤，因为AFIO模块控制着GPIO引脚的复用功能，包括将外部中断线路映射到特定的GPIO引脚。未使能AFIO时钟可能导致外部中断配置无效，进而影响整个中断处理机制的正常工作。</p>\n<h2 id=\"systick\">SysTick</h2>\n<h3 id=\"systick简介\">SysTick简介</h3>\n<p>SysTick: 系统定时器, <strong>24位, 只能递减, 存在于内核中</strong>, 嵌套在NVIC中, 所有的Cotex-M内核的单片机都具有这个定时器.</p>\n<h3 id=\"systick-功能框图\">SysTick 功能框图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170017620.png\" alt=\"框图\"></p>\n<p>重装载寄存器把值写入递减计数器, 可通过STK_VAL实时查询其中的值, 递减计数器从reload值开始递减, 减为0后可产生中断并且置位COUNTFLAG标志位, 置位后从reload获取值重复以上操作</p>\n<h3 id=\"systick-寄存器描述\">SysTick 寄存器描述</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170023320.png\" alt=\"SysTick 寄存器描述\"></p>\n<h3 id=\"systick-定时时间计算\">SysTick 定时时间计算</h3>\n<p>需要计算的参数</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025237.png\" alt=\"计算参数\"></p>\n<p>计算过程</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025314.png\" alt=\"计算过程\"></p>\n<ul>\n<li>Clk = 72M时</li>\n<li>reload = 72, t = 1us</li>\n<li>reload = 72000, t = 1ms</li>\n</ul>\n<h3 id=\"补充:-systick 介绍\">补充: SysTick 介绍</h3>\n<p>SysTick（System Tick Timer）是ARM Cortex-M微控制器内核的一个内置组件，用于提供一个简单但高效的系统定时器。这个定时器通常用于实现操作系统的节拍（tick），也可以用于简单的延时功能。</p>\n<h4 id=\"systick的主要特点\">SysTick的主要特点</h4>\n<ol>\n<li>24位递减计数器：SysTick包含一个24位的递减计数器，当计数器值递减到零时，定时器溢出并触发一个中断。</li>\n<li>可编程重载值：可以设置计数器的重载值，这决定了定时器的溢出时间间隔。</li>\n<li>可配置的时钟源：SysTick定时器可以配置为使用内核时钟或外部时钟（通常是内核时钟的一半）。</li>\n<li>自动重载：在计数到零时，计数器会自动重新加载预设的重载值，从而实现周期性定时。</li>\n<li>中断功能：当计数器达到零时，SysTick定时器可以产生一个中断。这个中断可以用于各种定时任务，如操作系统的任务调度。</li>\n</ol>\n<h4 id=\"systick的应用场景\">SysTick的应用场景</h4>\n<ol>\n<li>操作系统节拍：在实时操作系统（RTOS）中，SysTick常用于生成操作系统的节拍，这对于任务调度和时间管理非常重要。</li>\n<li>延时功能：在不需要RTOS的简单应用中，SysTick可用于生成精确的延时，例如在两个事件之间等待固定的时间。</li>\n<li>时间基准：SysTick还可以作为程序中的时间基准，用于测量时间间隔或产生定时事件。</li>\n</ol>\n<h4 id=\"systick的配置和使用\">SysTick的配置和使用</h4>\n<p>在使用SysTick时，一般需要进行以下配置：</p>\n<ol>\n<li>设置重载值：根据所需的定时周期和时钟源频率设置重载值。</li>\n<li>选择时钟源：选择使用内核时钟还是外部时钟作为SysTick的时钟源。</li>\n<li>启用中断（可选）：如果需要在定时器溢出时执行特定操作，可以启<br>\n用SysTick中断。</li>\n<li>启动定时器：启用SysTick定时器开始计数</li>\n</ol>\n<h4 id=\"systick的编程示例\">SysTick的编程示例</h4>\n<p>在STM32等ARM Cortex-M微控制器上，SysTick的配置和使用通常涉及直接操作其控制和状态寄存器。以下是一个简单的示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SysTick_Config(SystemCoreClock / <span class=\"number\">1000</span>);  <span class=\"comment\">// 配置SysTick产生</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"systick-源码分析\">SysTick 源码分析</h3>\n<p>SysTick_Type定义在core_cm3.h中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick</span></span><br><span class=\"line\"><span class=\"comment\">  memory mapped structure for SysTick</span></span><br><span class=\"line\"><span class=\"comment\">  @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> CTRL;                         <span class=\"comment\">/*!&lt; Offset: 0x00  SysTick Control and Status Register */</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> LOAD;                         <span class=\"comment\">/*!&lt; Offset: 0x04  SysTick Reload Value Register       */</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> VAL;                          <span class=\"comment\">/*!&lt; Offset: 0x08  SysTick Current Value Register      */</span></span><br><span class=\"line\">  __I  <span class=\"type\">uint32_t</span> CALIB;                        <span class=\"comment\">/*!&lt; Offset: 0x0C  SysTick Calibration Register        */</span></span><br><span class=\"line\">&#125; SysTick_Type;</span><br></pre></td></tr></table></figure>\n<p>SysTick_Config函数在core_cm3.h中定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief  Initialize and start the SysTick counter and its interrupt.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param   ticks   number of ticks between two interrupts</span></span><br><span class=\"line\"><span class=\"comment\"> * @return  1 = failed, 0 = successful</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialise the system tick timer and its interrupt and start the</span></span><br><span class=\"line\"><span class=\"comment\"> * system tick timer / counter in free running mode to generate </span></span><br><span class=\"line\"><span class=\"comment\"> * periodical interrupts.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> __INLINE <span class=\"type\">uint32_t</span> <span class=\"title function_\">SysTick_Config</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ticks)</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">  <span class=\"comment\">// 判断ticks的值是否大于2^24, 若大于则违法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class=\"keyword\">return</span> (<span class=\"number\">1</span>);            <span class=\"comment\">/* Reload value impossible */</span></span><br><span class=\"line\">                                                               </span><br><span class=\"line\">  <span class=\"comment\">// 初始化reaload寄存器的值</span></span><br><span class=\"line\">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class=\"number\">1</span>;      <span class=\"comment\">/* set reload register */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置中断优先级, 配置为15, 默认为最低的优先级</span></span><br><span class=\"line\">  <span class=\"comment\">/*-------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 注: </span></span><br><span class=\"line\"><span class=\"comment\">   * 内核优先级的判断方式:</span></span><br><span class=\"line\"><span class=\"comment\">   * 将内核外设的中断优先级的四个位按照外设的中断优先级进行分组</span></span><br><span class=\"line\"><span class=\"comment\">   * 分组后可判断内核的抢占优先级和响应优先级</span></span><br><span class=\"line\"><span class=\"comment\">   * 即人为分出抢占和响应优先级</span></span><br><span class=\"line\"><span class=\"comment\">   * </span></span><br><span class=\"line\"><span class=\"comment\">   * 例:</span></span><br><span class=\"line\"><span class=\"comment\">   * 这里SysTick的中断优先级为15, 二进制为1111</span></span><br><span class=\"line\"><span class=\"comment\">   * 若分组为2位抢占, 2位响应</span></span><br><span class=\"line\"><span class=\"comment\">   * 则SysTick的抢占优先级为11即3, 响应优先级为11即3</span></span><br><span class=\"line\"><span class=\"comment\">   * 若分组为1位抢占, 3位响应</span></span><br><span class=\"line\"><span class=\"comment\">   * 则SysTick的抢占优先级为1即1, 响应优先级为111即7</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过该方法可以比较内核优先级与外设的优先级谁更高</span></span><br><span class=\"line\"><span class=\"comment\">   * ----------------------------------------------------------*/</span></span><br><span class=\"line\">  NVIC_SetPriority (SysTick_IRQn, (<span class=\"number\">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class=\"number\">1</span>);  <span class=\"comment\">/* set Priority for Cortex-M0 System Interrupts */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化counter的值为0</span></span><br><span class=\"line\">  SysTick-&gt;VAL   = <span class=\"number\">0</span>;                                          <span class=\"comment\">/* Load the SysTick Counter Value */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置 SysTick的时钟为 72M</span></span><br><span class=\"line\">  <span class=\"comment\">// 使能中断</span></span><br><span class=\"line\">  <span class=\"comment\">// 使能 SysTick </span></span><br><span class=\"line\">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class=\"line\">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class=\"line\">                   SysTick_CTRL_ENABLE_Msk;                    <span class=\"comment\">/* Enable SysTick IRQ and SysTick Timer */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"number\">0</span>);                                                  <span class=\"comment\">/* Function successful */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"systick-实验\">SysTick 实验</h3>\n<p>项目地址: <strong>19-SysTick</strong></p>\n<p>实验要求:</p>\n<ol>\n<li>编写一个微妙延时函数</li>\n<li>编写一个毫秒延时函数</li>\n</ol>\n<h4 id=\"在bsp_systickc中编写微妙延时函数\">在bsp_systick.c中编写微妙延时函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 延时指定的微秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param us 延时的微秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_us</span><span class=\"params\">(<span class=\"type\">uint32_t</span> us)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SysTick_Config(SystemCoreClock / <span class=\"number\">1000000</span>); <span class=\"comment\">// reload 设置为 72, t = 1us</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; us; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!(SysTick-&gt;CTRL &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>)))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ; <span class=\"comment\">// 等待CTRL的Bit16置1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; <span class=\"comment\">// 状态位清除</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_systickc中编写毫秒延时函数\">在bsp_systick.c中编写毫秒延时函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 延时指定的毫秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ms 延时的毫秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 无</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_ms</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SysTick_Config(SystemCoreClock / <span class=\"number\">1000</span>); <span class=\"comment\">// reload 设置为 72000, t = 1ms</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ms; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!(SysTick-&gt;CTRL &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>)))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ; <span class=\"comment\">// 等待CTRL的Bit16置1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; <span class=\"comment\">// 状态位清除</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_systickh中引用库文件和进行函数声明\">在bsp_systick.h中引用库文件和进行函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_SYSTICK_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_SYSTICK_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;core_cm3.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_ms</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ms)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_us</span><span class=\"params\">(<span class=\"type\">uint32_t</span> us)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_SYSTICK_H</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用延时函数,实现led闪烁\">在main.c中调用延时函数,实现LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Main function of the program.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This function initializes the LED GPIO and enters an infinite loop. </span></span><br><span class=\"line\"><span class=\"comment\"> * In each iteration of the loop, it turns off the blue LED, delays for 0.5 seconds,</span></span><br><span class=\"line\"><span class=\"comment\"> * turns on the blue LED, and delays for 0.5 seconds again.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @return int The exit status of the program.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// Initialize the LED GPIO</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_B(OFF); <span class=\"comment\">// Turn off the blue LED</span></span><br><span class=\"line\">        SysTick_Delay_ms(<span class=\"number\">500</span>); <span class=\"comment\">// Delay for 0.5 seconds</span></span><br><span class=\"line\">        LED_B(ON); <span class=\"comment\">// Turn on the blue LED</span></span><br><span class=\"line\">        SysTick_Delay_us(<span class=\"number\">500000</span>); <span class=\"comment\">// Delay for 0.5 seconds</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"通信的基本概念\">通信的基本概念</h2>\n<h3 id=\"串行和并行通信\">串行和并行通信</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171542012.png\" alt=\"串行和并行通信\"></p>\n<ul>\n<li>串行协议: USART, I2C, SPI, W500, CAN, LIN</li>\n<li>并行协议: FSMC, SDIO</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171546066.png\" alt=\"对比\"></p>\n<h3 id=\"全双工,-半双工和单工\">全双工, 半双工和单工</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171548657.png\" alt=\"全双工,半双工和单工\"></p>\n<h3 id=\"同步与异步\">同步与异步</h3>\n<p>同步传输通过时钟信号进行同步, 保证数据传输的准确性</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171550768.png\" alt=\"同步\"></p>\n<p>异步传输通过加入辅助的标识符, 保证数据传输的准确性</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171552733.png\" alt=\"异步\"></p>\n<h4 id=\"同步与异步的区别\">同步与异步的区别</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171554763.png\" alt=\"区别\"></p>\n<h3 id=\"通信的速率\">通信的速率</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171555519.png\" alt=\"通信的速率\"></p>\n<p>当用一个二进制位表示一个码元时, 比特率和波特率相等</p>\n<h2 id=\"usart-串口通信\">USART-串口通信</h2>\n<h3 id=\"串口通信协议简介\">串口通信协议简介</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610065.png\" alt=\"USART\"></p>\n<h4 id=\"物理层的常用标准\">物理层的常用标准</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610887.png\" alt=\"USART\"></p>\n<h5 id=\"232和ttl电平区别\">232和TTL电平区别</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171611637.png\" alt=\"USART\"></p>\n<ul>\n<li>TTL: 从芯片出来的基本是TTL电平</li>\n<li>232: 负逻辑, 压差大</li>\n</ul>\n<h6 id=\"232通信通讯结构图\">232通信通讯结构图</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171631235.png\" alt=\"232\"></p>\n<p>DB9接口图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171634288.png\" alt=\"DB9接口\"></p>\n<h6 id=\"usb转串口通讯结构图\">USB转串口通讯结构图</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171644660.png\" alt=\"USB转串口\"></p>\n<h5 id=\"串口到串口通讯结构图\">串口到串口通讯结构图</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171655718.png\" alt=\"串口到串口\"></p>\n<h4 id=\"串口数据包的组成\">串口数据包的组成</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171658813.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171659831.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171702232.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703446.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703050.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171704956.png\" alt=\"串口数据包\"></p>\n<h3 id=\"stm32串口功能框图讲解\">STM32串口功能框图讲解</h3>\n<h4 id=\"引脚部分讲解\">引脚部分讲解</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708669.png\" alt=\"STM32串口功能框图\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708578.png\" alt=\"STM32串口功能框图\"></p>\n<h5 id=\"引脚对应\">引脚对应</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171710068.png\" alt=\"引脚对应\"></p>\n<h4 id=\"数据寄存器部分\">数据寄存器部分</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171723621.png\" alt=\"数据寄存器部分\"></p>\n<h5 id=\"数据格式\">数据格式</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171725627.png\" alt=\"数据格式\"></p>\n<h6 id=\"usart_cr1的bit12-m控制字长\">USART_CR1的bit12 M控制字长</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727509.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_cr2的bit[13:12]-stop控制停止位的位数\">USART_CR2的bit[13:12] STOP控制停止位的位数</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727238.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_cr1的bit10(pse),-bit9(ps)来使能校验和选择校验模式\">USART_CR1的bit10(PSE), bit9(PS)来使能校验和选择校验模式</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171730822.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_cr1的bit8(peie)来使能中断\">USART_CR1的bit8(PEIE)来使能中断</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171731175.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_sr的bit0(pe)来检测校验错误\">USART_SR的bit0(PE)来检测校验错误</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171732400.png\" alt=\"寄存器\"></p>\n<h4 id=\"发送数据部分\">发送数据部分</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171739676.png\" alt=\"发送数据\"></p>\n<ol>\n<li>先将USART_CR1的UE位置1(<em>使能USART模块</em>), 再将USART_CR1的TE位置1(<em>使能发送</em>)</li>\n<li>数据从CPU或DMA中写入发送数据寄存器(TDR), TDR发送完毕后, USART_SR的TXE位置1(<em>数据已经被转移到移位寄存器中</em>)</li>\n<li>发送移位寄存器发送完毕后, USART_SR的TC位置1(<em>表示发送完成</em>)</li>\n</ol>\n<h4 id=\"接收数据部分\">接收数据部分</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171900970.png\" alt=\"接收数据部分\"></p>\n<ol>\n<li>先将USART_CR1的UE位置1(<em>使能USART模块</em>), 再将USART_CR1的RE位置1(<em>使能接收</em>)</li>\n<li>数据从RX到接收移位寄存器到接收数据寄存器(RDR), 接收完毕后, USART_SR的RXNE位置1(<em>收到数据, 可以读出</em>)</li>\n</ol>\n<h4 id=\"波特率设置\">波特率设置</h4>\n<h5 id=\"使用usart_brr进行配置\">使用USART_BRR进行配置</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171906798.png\" alt=\"USART_BRR\"></p>\n<h5 id=\"波特率的计算公式\">波特率的计算公式</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171909589.png\" alt=\"波特率的计算公式\"></p>\n<ul>\n<li>APB2时钟: 72MHz, 挂载USART1</li>\n<li>APB1时钟: 36MHz, 挂载USART2, 3, 4, 5</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171910703.png\" alt=\"波特率\"></p>\n<h3 id=\"串口初始化结构体和固件库讲解\">串口初始化结构体和固件库讲解</h3>\n<h4 id=\"串口初始化结构体\">串口初始化结构体</h4>\n<p>在stm32f10x_usart.h中定义串口初始化结构体(异步)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART Init Structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span> </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 设置波特率</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> USART_BaudRate;            <span class=\"comment\">/*!&lt; This member configures the USART communication baud rate.</span></span><br><span class=\"line\"><span class=\"comment\">                                           The baud rate is computed using the following formula:</span></span><br><span class=\"line\"><span class=\"comment\">                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))</span></span><br><span class=\"line\"><span class=\"comment\">                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置字长</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_WordLength_8b                  ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_WordLength_9b                  ((uint16_t)0x1000)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_WordLength;          <span class=\"comment\">/*!&lt; Specifies the number of data bits transmitted or received in a frame.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Word_Length */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置停止位</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_1                     ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_0_5                   ((uint16_t)0x1000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_2                     ((uint16_t)0x2000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_1_5                   ((uint16_t)0x3000)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_StopBits;            <span class=\"comment\">/*!&lt; Specifies the number of stop bits transmitted.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Stop_Bits */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置校验</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Parity_No                      ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Parity_Even                    ((uint16_t)0x0400)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Parity_Odd                     ((uint16_t)0x0600)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_Parity;              <span class=\"comment\">/*!&lt; Specifies the parity mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Parity</span></span><br><span class=\"line\"><span class=\"comment\">                                           @note When parity is enabled, the computed parity is inserted</span></span><br><span class=\"line\"><span class=\"comment\">                                                 at the MSB position of the transmitted data (9th bit when</span></span><br><span class=\"line\"><span class=\"comment\">                                                 the word length is set to 9 data bits; 8th bit when the</span></span><br><span class=\"line\"><span class=\"comment\">                                                 word length is set to 8 data bits). */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 设置模式</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Mode_Rx                        ((uint16_t)0x0004)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Mode_Tx                        ((uint16_t)0x0008)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_Mode;                <span class=\"comment\">/*!&lt; Specifies wether the Receive or Transmit mode is enabled or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置硬件控制流</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_HardwareFlowControl; <span class=\"comment\">/*!&lt; Specifies wether the hardware flow control mode is enabled</span></span><br><span class=\"line\"><span class=\"comment\">                                           or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */</span></span><br><span class=\"line\">&#125; USART_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<p>在stm32f10x_usart.h中定义串口初始化结构体(同步)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART Clock Init Structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span> </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置使能时钟</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Clock_Disable                  ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Clock_Enable                   ((uint16_t)0x0800)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_Clock;   <span class=\"comment\">/*!&lt; Specifies whether the USART clock is enabled or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Clock */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置时钟的极性, 即总线空闲时CK引脚保持低电平还是高电平</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPOL_Low                       ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPOL_High                      ((uint16_t)0x0400)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_CPOL;    <span class=\"comment\">/*!&lt; Specifies the steady state value of the serial clock.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Clock_Polarity */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置时钟的相位, 即数据采样的时机为第一个边沿还是第二个边沿</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPHA_1Edge                     ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPHA_2Edge                     ((uint16_t)0x0200)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_CPHA;    <span class=\"comment\">/*!&lt; Specifies the clock transition on which the bit capture is made.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Clock_Phase */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置时钟的最后一个数据位的时钟脉冲是否输出到SCLK引脚</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_LastBit_Disable                ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_LastBit_Enable                 ((uint16_t)0x0100)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_LastBit; <span class=\"comment\">/*!&lt; Specifies whether the clock pulse corresponding to the last transmitted</span></span><br><span class=\"line\"><span class=\"comment\">                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Last_Bit */</span></span><br><span class=\"line\">&#125; USART_ClockInitTypeDef;</span><br></pre></td></tr></table></figure>\n<h4 id=\"串口库函数\">串口库函数</h4>\n<ul>\n<li><strong>串口初始化函数</strong>: void USART_Init(USART_TypeDef<em>USARTx, USART_InitTypeDef</em> USART_InitStruct);</li>\n<li><strong>中断配置函数</strong>: void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);</li>\n<li><strong>串口使能函数</strong>: void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);</li>\n<li><strong>数据发送函数</strong>: void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</li>\n<li><strong>数据接收函数</strong>: void USART_ReceiveData(USART_TypeDef* USARTx);</li>\n<li><strong>中断状态位获取函数</strong>: ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);</li>\n</ul>\n<h3 id=\"usb转串口的硬件原理图\">USB转串口的硬件原理图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401172002602.png\" alt=\"硬件原理图\"></p>\n<h3 id=\"串口gpio汇总\">串口GPIO汇总</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220859886.png\" alt=\"串口GPIO\"></p>\n<h3 id=\"补充:-外设的gpio配置\">补充: 外设的GPIO配置</h3>\n<p>在STM32F10x参考手册中的8.1.11节可找到外设的GPIO配置, 其中关于USART部分的GPIO配置如下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220904826.png\" alt=\"USART的GPIO配置\"></p>\n<h3 id=\"配置串口助手\">配置串口助手</h3>\n<p>本项目使用的串口助手: 野火多功能调试助手V1.0.2.9</p>\n<p>串口配置如下图(<em>串口配置参数与串口的初始化配置有关, 该配置符合下文代码的初始化</em>)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401250242370.png\" alt=\"串口助手配置\"></p>\n<h3 id=\"usart接收和发送实验\">USART接收和发送实验</h3>\n<p>项目地址: <strong>21-USART-接收和发送</strong></p>\n<p><strong>实验需求</strong>: 单片机给电脑发送数据, 电脑上位机把数据打印出来; 电脑上位机给单片机发数据, 单片机接收到数据之后立马发回给电脑, 并打印出来.</p>\n<h4 id=\"在bsp_usarth中进行串口的宏定义,-并使用条件编译来选择串口\">在bsp_usart.h中进行串口的宏定义, 并使用条件编译来选择串口</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏</span></span><br><span class=\"line\"><span class=\"comment\">  * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线</span></span><br><span class=\"line\"><span class=\"comment\">  * 2-修改GPIO的宏</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 通过条件编译选择串口, 使用的串口置1，其余置0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART1 1</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART2 0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART3 0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART4 0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART5 0</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_USART1</span></span><br><span class=\"line\"><span class=\"comment\">// 串口1-USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB2Periph_USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                USART1_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         USART1_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_USART2</span></span><br><span class=\"line\"><span class=\"comment\">// 串口2-USART2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_USART2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                USART2_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         USART2_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_USART3</span></span><br><span class=\"line\"><span class=\"comment\">// 串口3-USART3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_USART3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOB   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOB</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                USART3_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         USART3_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_USART4</span></span><br><span class=\"line\"><span class=\"comment\">//串口4-UART4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   UART4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_UART4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOC   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOC</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                UART4_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         UART4_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_UART5</span></span><br><span class=\"line\"><span class=\"comment\">// 串口5-UART5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   UART5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_UART5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOC   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOD</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                UART5_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         UART5_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写usart的初始化函数\">在bsp_usart.c中编写usart的初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口GPIO的时钟</span></span><br><span class=\"line\">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开串口外设的时钟</span></span><br><span class=\"line\">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"comment\">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 配置串口的工作参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置波特率</span></span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">// 配置 针数据字长</span></span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    <span class=\"comment\">// 配置停止位</span></span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    <span class=\"comment\">// 配置校验位</span></span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class=\"line\">    <span class=\"comment\">// 配置硬件流控制</span></span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = </span><br><span class=\"line\">    USART_HardwareFlowControl_None;</span><br><span class=\"line\">    <span class=\"comment\">// 配置工作模式，收发一起</span></span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class=\"line\">    <span class=\"comment\">// 完成串口的初始化配置</span></span><br><span class=\"line\">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 串口中断优先级配置</span></span><br><span class=\"line\">    NVIC_Configuration();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使能串口接收中断</span></span><br><span class=\"line\">    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使能串口</span></span><br><span class=\"line\">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写串口中断优先级配置函数\">在bsp_usart.c中编写串口中断优先级配置函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  配置嵌套向量中断控制器NVIC</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">NVIC_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* 嵌套向量中断控制器组选择 */</span></span><br><span class=\"line\">  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* 配置USART为中断源 */</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;</span><br><span class=\"line\">  <span class=\"comment\">/* 抢断优先级*/</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* 子优先级 */</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* 使能中断 */</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">  <span class=\"comment\">/* 初始化配置NVIC */</span></span><br><span class=\"line\">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送一个字节到串口的函数\">在bsp_usart.c中编写发送一个字节到串口的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 发送一个字节到指定的USART外设</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx USART外设指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ch 要发送的字节</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendByte</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint8_t</span> ch)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发送一个字节</span></span><br><span class=\"line\">    USART_SendData(pUSARTx, ch);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 等待发送数据寄存器为空</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送两个字节到串口的函数\">在bsp_usart.c中编写发送两个字节到串口的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 发送两个字节的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx USART外设指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ch 要发送的16位数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendHalfWord</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint16_t</span> ch)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> tmp_h, tmp_l;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp_h = (ch &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>; <span class=\"comment\">// 取出高八位</span></span><br><span class=\"line\">    tmp_l = (ch &amp; <span class=\"number\">0xFF</span>) &gt;&gt; <span class=\"number\">0</span>; <span class=\"comment\">// 取出低八位</span></span><br><span class=\"line\"></span><br><span class=\"line\">    USART_SendData(pUSARTx, tmp_h); <span class=\"comment\">// 发送高八位</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    USART_SendData(pUSARTx, tmp_l); <span class=\"comment\">// 发送低八位</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送数组的函数\">在bsp_usart.c中编写发送数组的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Sends an array of bytes over USART.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This function sends an array of bytes over the specified USART peripheral.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx The USART peripheral to use.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param array Pointer to the array of bytes to send.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param num The number of bytes to send.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendArray</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint8_t</span>* <span class=\"built_in\">array</span>, <span class=\"type\">uint16_t</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     Usart_SendByte(pUSARTx, <span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送字符串的函数\">在bsp_usart.c中编写发送字符串的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 发送字符串到USART外设</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx USART外设指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param str 要发送的字符串</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendString</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint8_t</span>* str)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     Usart_SendByte(pUSARTx, *(str + i));</span><br><span class=\"line\">     i++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (*(str + i) != <span class=\"string\">&#x27;\\0&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待发送完成</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写重定向标准输出输入函数,-使得串口可使用scanf printf等函数\">在bsp_usart.c中编写重定向标准输出输入函数, 使得串口可使用scanf printf等函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重定向c库函数printf, putchar到串口，重定向后可使用printf, putchar函数</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 重定向标准输出函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ch 要发送的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param f 文件指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval 发送的字符</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE* f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    USART_SendData(DEBUG_USARTx, (<span class=\"type\">uint8_t</span>)ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param f 文件指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @return int 从串口接收到的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fgetc</span><span class=\"params\">(FILE *f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 等待串口输入数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)USART_ReceiveData(DEBUG_USARTx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc函数中进行测试\">在main.c函数中进行测试</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_usart.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    USART_Config(); <span class=\"comment\">// 初始化USART</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送1字节数据</span></span><br><span class=\"line\">    Usart_SendByte(DEBUG_USARTx, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    Usart_SendByte(DEBUG_USARTx, <span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送2字节数据</span></span><br><span class=\"line\">    Usart_SendHalfWord(DEBUG_USARTx, <span class=\"number\">0xFF56</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送数组</span></span><br><span class=\"line\">    Usart_SendArray(DEBUG_USARTx, (<span class=\"type\">uint8_t</span>*)<span class=\"string\">&quot;Hello World!&quot;</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> <span class=\"built_in\">array</span>[<span class=\"number\">11</span>] = &#123;<span class=\"string\">&quot;Hello World!&quot;</span>&#125;;</span><br><span class=\"line\">    Usart_SendArray(DEBUG_USARTx, <span class=\"built_in\">array</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送字符串</span></span><br><span class=\"line\">    Usart_SendString(DEBUG_USARTx, <span class=\"string\">&quot;\\nString: Hello World\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重定向printf函数</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;printf: Hello World\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重定向putchar函数</span></span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;u&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;t&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;c&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;h&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;r&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_itc中编写中断服务函数实现串口数据的接收并发送\">在stm32f10x_it.c中编写中断服务函数实现串口数据的接收并发送</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Interrupt handler for the DEBUG_USART.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This function is called when there is a receive interrupt from the DEBUG_USART.</span></span><br><span class=\"line\"><span class=\"comment\"> * It receives data from the DEBUG_USART and sends it back.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DEBUG_USART_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> ucTemp;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(USART_GetITStatus(DEBUG_USARTx, USART_IT_RXNE) != RESET)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ucTemp = USART_ReceiveData(DEBUG_USARTx); <span class=\"comment\">// Receive data into ucTemp</span></span><br><span class=\"line\">    USART_SendData(DEBUG_USARTx, ucTemp); <span class=\"comment\">// Send data</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充:-通过重写fputc函数重定向c库函数printf到串口\">补充: 通过重写fputc函数重定向C库函数printf到串口</h3>\n<p>通过重写 fputc 函数可以实现重定向 printf 到串口的效果。这是因为 printf 函数实际上是通过 C 标准库中的输出函数 fputc 来将字符一个个地发送到输出设备的。当你重写了 fputc 函数，实际上就改变了字符的输出方式，使得字符被发送到你所定义的输出设备，比如串口。</p>\n<p>下面是一个简单的示例，演示了如何通过重写 fputc 函数来重定向 printf 到串口。这里假设你已经在系统中初始化了串口的硬件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 串口初始化函数，假设已经在系统中实现</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">initSerialPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 串口初始化的相关代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重定向标准输出函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE *f)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将字符发送到串口</span></span><br><span class=\"line\">    <span class=\"comment\">// 你需要在这里添加实际的串口发送代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如：sendCharacterToSerialPort(ch);</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口</span></span><br><span class=\"line\">    initSerialPort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在这之后，调用printf将输出信息发送到串口</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello, Serial Port!\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他代码...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们重写了 fputc 函数，使其将字符发送到串口。当 printf 调用 fputc 函数时，字符就会被发送到串口。这样就实现了将 printf 输出重定向到串口的效果。</p>\n<p>需要注意的是，具体的串口发送函数实现（比如 sendCharacterToSerialPort）需要根据你的具体硬件和系统来编写。这个示例只是演示了重定向的基本原理。</p>\n<h3 id=\"usart控制rgb灯实验\">USART控制RGB灯实验</h3>\n<p>项目地址: <strong>21-USART-控制RGB灯</strong></p>\n<p><strong>实验需求</strong>: 电脑给单片机发命令, 用于控制开发板上的RGB灯.</p>\n<h4 id=\"在bsp_ledh中定义rgb灯的宏\">在bsp_led.h中定义RGB灯的宏</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __LED_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __LED_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */</span></span><br><span class=\"line\"><span class=\"comment\">// R-红色</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_GPIO_PORT     GPIOB                 <span class=\"comment\">/* GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class=\"comment\">/* GPIO端口时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_GPIO_PIN  GPIO_Pin_5           <span class=\"comment\">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// G-绿色</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_GPIO_PORT     GPIOB                 <span class=\"comment\">/* GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class=\"comment\">/* GPIO端口时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_GPIO_PIN  GPIO_Pin_0           <span class=\"comment\">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B-蓝色</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_GPIO_PORT     GPIOB                 <span class=\"comment\">/* GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class=\"comment\">/* GPIO端口时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_GPIO_PIN  GPIO_Pin_1           <span class=\"comment\">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** the macro definition to trigger the led on or off </span></span><br><span class=\"line\"><span class=\"comment\">  * 1 - off</span></span><br><span class=\"line\"><span class=\"comment\">  *0 - on</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ON  0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFF 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用标准的固件库控制IO*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1(a) <span class=\"keyword\">if</span> (a) \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\\</span></span><br><span class=\"line\"><span class=\"meta\">     <span class=\"keyword\">else</span>  \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2(a) <span class=\"keyword\">if</span> (a) \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\\</span></span><br><span class=\"line\"><span class=\"meta\">     <span class=\"keyword\">else</span>  \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3(a) <span class=\"keyword\">if</span> (a) \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);\\</span></span><br><span class=\"line\"><span class=\"meta\">     <span class=\"keyword\">else</span>  \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 直接操作寄存器的方法控制IO */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> digitalHi(p,i)   &#123;p-&gt;BSRR=i;&#125;  <span class=\"comment\">//输出为高电平  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> digitalLo(p,i)   &#123;p-&gt;BRR=i;&#125;  <span class=\"comment\">//输出低电平</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> digitalToggle(p,i) &#123;p-&gt;ODR ^=i;&#125; <span class=\"comment\">//输出反转状态</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 定义控制IO的宏 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_TOGGLE   digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_OFF     digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_ON      digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_TOGGLE   digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_OFF     digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_ON      digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_TOGGLE   digitalToggle(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_OFF     digitalHi(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_ON      digitalLo(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//红</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_RED  \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//绿</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_GREEN  \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//蓝</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_BLUE \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\"></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">//黄(红+绿)     </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_YELLOW \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"><span class=\"comment\">//紫(红+蓝)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_PURPLE \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//青(绿+蓝)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_CYAN \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">//白(红+绿+蓝)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_WHITE \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">//黑(全部关闭)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_RGBOFF \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __LED_H */</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledc中编写led初始化函数\">在bsp_led.c中编写led初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @file    bsp_led.c</span></span><br><span class=\"line\"><span class=\"comment\">  * @author  fire</span></span><br><span class=\"line\"><span class=\"comment\">  * @version V1.0</span></span><br><span class=\"line\"><span class=\"comment\">  * @date    2013-xx-xx</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   led应用函数接口</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @attention</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * 实验平台:野火 F103-霸道 STM32 开发板 </span></span><br><span class=\"line\"><span class=\"comment\">  * 论坛    :http://www.firebbs.cn</span></span><br><span class=\"line\"><span class=\"comment\">  * 淘宝    :https://fire-stm32.taobao.com</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;./led/bsp_led.h&quot;</span>   </span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  初始化控制LED的IO</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/*定义一个GPIO_InitTypeDef类型的结构体*/</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*开启LED相关的GPIO外设时钟*/</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK | LED3_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/*选择要控制的GPIO引脚*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*设置引脚模式为通用推挽输出*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*设置引脚速率为50MHz */</span>   </span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用库函数，初始化GPIO*/</span></span><br><span class=\"line\">    GPIO_Init(LED1_GPIO_PORT, &amp;GPIO_InitStructure); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*选择要控制的GPIO引脚*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用库函数，初始化GPIO*/</span></span><br><span class=\"line\">    GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*选择要控制的GPIO引脚*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = LED3_GPIO_PIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用库函数，初始化GPIOF*/</span></span><br><span class=\"line\">    GPIO_Init(LED3_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 关闭所有led灯 */</span></span><br><span class=\"line\">    GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 关闭所有led灯 */</span></span><br><span class=\"line\">    GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);  </span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">/* 关闭所有led灯 */</span></span><br><span class=\"line\">    GPIO_SetBits(LED3_GPIO_PORT, LED3_GPIO_PIN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">assert_failed</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* file, <span class=\"type\">uint32_t</span> line)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 断言错误时执行的代码</span></span><br><span class=\"line\">    LED1_ON;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*********************************************END OF FILE**********************/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中关闭串口中断\">在bsp_usart.c中关闭串口中断</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口GPIO的时钟</span></span><br><span class=\"line\">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开串口外设的时钟</span></span><br><span class=\"line\">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 配置串口的工作参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置波特率</span></span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">// 配置 针数据字长</span></span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    <span class=\"comment\">// 配置停止位</span></span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    <span class=\"comment\">// 配置校验位</span></span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class=\"line\">    <span class=\"comment\">// 配置硬件流控制</span></span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = </span><br><span class=\"line\">    USART_HardwareFlowControl_None;</span><br><span class=\"line\">    <span class=\"comment\">// 配置工作模式，收发一起</span></span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class=\"line\">    <span class=\"comment\">// 完成串口的初始化配置</span></span><br><span class=\"line\">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将中断失能</span></span><br><span class=\"line\">    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, DISABLE); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使能串口</span></span><br><span class=\"line\">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中编写测试程序\">在main.c中编写测试程序</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> ch = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    USART_Config(); <span class=\"comment\">// 初始化USART</span></span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// 初始化LED</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;USART-RGB\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;1:RED, 2:GREEN, 3:BLUE, 4:YELLOW, 5:PURPLE, 6:CYAN, 7:WHITE\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Others: BLACK\\n&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ch = getchar();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ch = %c\\n&quot;</span>, ch);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(ch)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;1&#x27;</span>: LED_RED;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;2&#x27;</span>: LED_GREEN;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;3&#x27;</span>: LED_BLUE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;4&#x27;</span>: LED_YELLOW;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;5&#x27;</span>: LED_PURPLE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;6&#x27;</span>: LED_CYAN;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;7&#x27;</span>: LED_WHITE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">default</span>: LED_RGBOFF;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"dma\">DMA</h2>\n<p>DMA: Direct Memory Access, 直接寄存器访问. 主要功能是可以把数据从一个地方搬到另一个地方, 而且不占用CPU</p>\n<ul>\n<li>DMA1: 有7个通道, 可实现P-&gt;M, M-&gt;P, M-&gt;M</li>\n<li>DMA2: 有5个通道, 可实现P-&gt;M, M-&gt;P, M-&gt;M(<em>只存在于大容量和互联型产品中</em>)</li>\n</ul>\n<h3 id=\"补充:-dma介绍\">补充: DMA介绍</h3>\n<p>DMA（Direct Memory Access，直接内存访问）是计算机系统中的一种技术，<strong>它允许外设或内存模块通过绕过中央处理器（CPU）直接与系统内存进行数据传输</strong>。DMA的目标是提高数据传输效率，减轻CPU的负担，使CPU能够专注于执行其他任务。</p>\n<p>以下是关于DMA的一些重要概念和特性：</p>\n<h4 id=\"dma的工作原理\">DMA的工作原理</h4>\n<p>DMA通过在系统总线上控制数据传输而不涉及CPU来工作。它可以在CPU不介入的情况下，直接将数据从一个位置传输到另一个位置。</p>\n<ol>\n<li>配置： CPU负责配置DMA，确定源地址、目标地址、传输方向、传输大小等参数。</li>\n<li>启动： 一旦DMA被配置，CPU就可以启动DMA控制器，它将负责管理数据传输。</li>\n<li>传输： DMA控制器在总线上控制数据传输，无需CPU的干预。数据在源和目标之间直接传输。</li>\n<li>中断通知： DMA传输完成后，通常会发出一个中断信号，以通知CPU或其他系统组件。</li>\n</ol>\n<h4 id=\"dma的优点\">DMA的优点</h4>\n<ol>\n<li>提高性能： 通过绕过CPU，减轻了CPU的负担，使其能够执行其他任务，提高了整体系统性能。</li>\n<li>实时数据传输： 特别适用于实时数据传输，如音频、视频流等。</li>\n<li>高效处理大量数据： 对于大量数据的块传输，DMA比CPU执行这样的传输更为高效。</li>\n</ol>\n<h4 id=\"dma的应用领域\">DMA的应用领域</h4>\n<p>DMA在多种应用场景中都得到了广泛应用，包括但不限于：</p>\n<ol>\n<li>嵌入式系统： 用于处理外设和内存之间的数据传输，例如，处理音频、图像等。</li>\n<li>网络通信： 在网络接口控制器和系统内存之间快速传输数据。</li>\n<li>存储系统： 用于在磁盘、固态硬盘等存储设备和系统内存之间进行数据传输。</li>\n<li>图形处理： 在图形卡和系统内存之间进行大规模图形数据的传输。</li>\n</ol>\n<h4 id=\"dma控制器\">DMA控制器</h4>\n<p>DMA通常由专门的硬件单元，称为DMA控制器，来管理。DMA控制器的设计和功能因芯片架构而异，但通常包括寄存器用于配置、启动和监视传输。</p>\n<p>总的来说，DMA是一项重要的技术，对于需要高效数据传输的系统是至关重要的。通过减轻CPU的负担，DMA提高了系统的整体性能和响应速度。</p>\n<h3 id=\"dma功能框图讲解\">DMA功能框图讲解</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261122722.png\" alt=\"DMA功能框图讲解\"></p>\n<h4 id=\"dma请求映射\">DMA请求映射</h4>\n<p>DMA1请求映射</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261126729.png\" alt=\"DMA1请求映射\"></p>\n<p>DMA2请求映射</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261127579.png\" alt=\"DMA2请求映射\"></p>\n<h4 id=\"dma仲裁器\">DMA仲裁器</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261128690.png\" alt=\"DMA仲裁器\"></p>\n<p>软件配置在寄存器DMA_CCRx:PL[1:0]进行通道优先级配置</p>\n<h3 id=\"dma固件库-初始化结构体\">DMA固件库-初始化结构体</h3>\n<p>初始化结构体在stm32f10x_dma.h文件中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  DMA Init structure definition</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 外设地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CPARx 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *---------------------------------------------------------------------------- */</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralBaseAddr; <span class=\"comment\">/*!&lt; Specifies the peripheral base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CMARx 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *---------------------------------------------------------------------------- */</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryBaseAddr;     <span class=\"comment\">/*!&lt; Specifies the memory base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 传输方向</span></span><br><span class=\"line\"><span class=\"comment\">   * P-&gt;M 和 M-&gt;P 由寄存器 DMA_CCRx:DIR[4] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   * M-&gt;M 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_DIR;                <span class=\"comment\">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 缓冲区大小, 传输数目</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CNDTRx 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_BufferSize;         <span class=\"comment\">/*!&lt; Specifies the buffer size, in data unit, of the specified Channel. </span></span><br><span class=\"line\"><span class=\"comment\">                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize</span></span><br><span class=\"line\"><span class=\"comment\">                                        or DMA_MemoryDataSize members depending in the transfer direction. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 外设增量模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:PINC[6] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralInc;      <span class=\"comment\">/*!&lt; Specifies whether the Peripheral address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器增量模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:MINC[7] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryInc;          <span class=\"comment\">/*!&lt; Specifies whether the memory address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 外设数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:PSIZE[9:8] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralDataSize; <span class=\"comment\">/*!&lt; Specifies the Peripheral data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:MSIZE[11:10] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryDataSize;     <span class=\"comment\">/*!&lt; Specifies the Memory data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 传输模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:CIRC[5] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过 DMA_ISR 判断传输状态来判断传输完成, 传输一半, 传输错误</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Mode;               <span class=\"comment\">/*!&lt; Specifies the operation mode of the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_circular_normal_mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                        @note: The circular buffer mode cannot be used if the memory-to-memory</span></span><br><span class=\"line\"><span class=\"comment\">                                              data transfer is configured on the selected Channel */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 优先级</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:PL[1:0] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Priority;           <span class=\"comment\">/*!&lt; Specifies the software priority for the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_priority_level */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器到存储器模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_M2M;                <span class=\"comment\">/*!&lt; Specifies if the DMAy Channelx will be used in memory-to-memory transfer.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_to_memory */</span></span><br><span class=\"line\">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dma固件库-固件库函数\">DMA固件库-固件库函数</h3>\n<p>在stm32f10x_dma.h文件中可以找到DMA固件库函数的声明, 以下是常用的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DMA_Init</span><span class=\"params\">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>; <span class=\"comment\">// 初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DMA_Cmd</span><span class=\"params\">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>; <span class=\"comment\">// 使能DMA</span></span><br><span class=\"line\">FlagStatus <span class=\"title function_\">DMA_GetFlagStatus</span><span class=\"params\">(<span class=\"type\">uint32_t</span> DMAy_FLAG)</span>; <span class=\"comment\">// 判断标志位</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"dma实验1:-m to m\">DMA实验1: M to M</h3>\n<p>项目地址: <strong>22-DMA-MtoM</strong></p>\n<p><strong>实验需求</strong>: FLASH to SRAM, 把内部FLASH的数据传输到内部的SRAM</p>\n<h4 id=\"在bsp_dma_m2mh增加宏定义\">在bsp_dma_m2m.h增加宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当使用存储器到存储器模式时候，通道可以随便选，没有硬性的规定</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> M2M_DMA_CHANNEL     DMA1_Channel6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> M2M_DMA_CLOCK       RCC_AHBPeriph_DMA1</span></span><br><span class=\"line\"><span class=\"comment\">// 传输完成标志</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> M2M_DMA_FLAG_TC     DMA1_FLAG_TC6</span></span><br><span class=\"line\"><span class=\"comment\">// 要发送的数据大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUFFER_SIZE     32</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2mc中定义源和目标变量\">在bsp_dma_m2m.c中定义源和目标变量</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 定义aSRC_Const_Buffer数组作为DMA传输数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * const关键字将aSRC_Const_Buffer数组变量定义为常量类型</span></span><br><span class=\"line\"><span class=\"comment\"> * 表示数据存储在内部的FLASH中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE]= &#123;</span><br><span class=\"line\">                                    <span class=\"number\">0x01020304</span>,<span class=\"number\">0x05060708</span>,<span class=\"number\">0x090A0B0C</span>,<span class=\"number\">0x0D0E0F10</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x11121314</span>,<span class=\"number\">0x15161718</span>,<span class=\"number\">0x191A1B1C</span>,<span class=\"number\">0x1D1E1F20</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x21222324</span>,<span class=\"number\">0x25262728</span>,<span class=\"number\">0x292A2B2C</span>,<span class=\"number\">0x2D2E2F30</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x31323334</span>,<span class=\"number\">0x35363738</span>,<span class=\"number\">0x393A3B3C</span>,<span class=\"number\">0x3D3E3F40</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x41424344</span>,<span class=\"number\">0x45464748</span>,<span class=\"number\">0x494A4B4C</span>,<span class=\"number\">0x4D4E4F50</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x51525354</span>,<span class=\"number\">0x55565758</span>,<span class=\"number\">0x595A5B5C</span>,<span class=\"number\">0x5D5E5F60</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x61626364</span>,<span class=\"number\">0x65666768</span>,<span class=\"number\">0x696A6B6C</span>,<span class=\"number\">0x6D6E6F70</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x71727374</span>,<span class=\"number\">0x75767778</span>,<span class=\"number\">0x797A7B7C</span>,<span class=\"number\">0x7D7E7F80</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义DMA传输目标存储器</span></span><br><span class=\"line\"><span class=\"comment\"> * 存储在内部的SRAM中                  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2mc中增加dma初始化函数\">在bsp_dma_m2m.c中增加DMA初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 配置存储器到存储器的DMA传输</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @return None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">M2M_DMA_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DMA_InitTypeDef DMA_InitStructure; <span class=\"comment\">// 定义DMA初始化结构体变量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    RCC_AHBPeriphClockCmd(M2M_DMA_CLOCK, ENABLE); <span class=\"comment\">// 打开DMA时钟</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class=\"type\">uint32_t</span>)aSRC_Const_Buffer; <span class=\"comment\">// 配置外设地址, 实际将FLASH的数据配置成了外设</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryBaseAddr = (<span class=\"type\">uint32_t</span>)aDST_Buffer; <span class=\"comment\">// 配置存储器地址</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; <span class=\"comment\">// 配置传输方向，从外设读取数据发送到存储器</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE; <span class=\"comment\">// 配置传输数据大小</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable; <span class=\"comment\">// 配置外设地址自增</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; <span class=\"comment\">// 配置存储器地址自增</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; <span class=\"comment\">// 配置外设数据大小</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; <span class=\"comment\">// 配置存储器数据大小</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; <span class=\"comment\">// 配置传输模式，非循环模式</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Priority = DMA_Priority_High; <span class=\"comment\">// 配置传输通道优先级</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; <span class=\"comment\">// 配置存储器到存储器模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DMA_Init(M2M_DMA_CHANNEL, &amp;DMA_InitStructure); <span class=\"comment\">// 初始化DMA通道</span></span><br><span class=\"line\">    DMA_ClearFlag(M2M_DMA_FLAG_TC); <span class=\"comment\">// 清除DMA通道传输完成标志位</span></span><br><span class=\"line\">    DMA_Cmd(M2M_DMA_CHANNEL, ENABLE); <span class=\"comment\">// 使能DMA通道</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2mc中增加判断数据相等的函数\">在bsp_dma_m2m.c中增加判断数据相等的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 比较两个缓冲区的数据是否相等</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pBuffer 指向第一个缓冲区的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pBuffer1 指向第二个缓冲区的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param BufferLength 缓冲区的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return uint8_t 如果两个缓冲区的数据相等，则返回1；否则返回0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">Buffercmp</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uint32_t</span>* pBuffer, <span class=\"type\">uint32_t</span>* pBuffer1, <span class=\"type\">uint16_t</span> BufferLength)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 数据长度递减 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(BufferLength--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 判断两个数据源是否对应相等 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*pBuffer != *pBuffer1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 对应数据源不相等马上退出函数，并返回0 */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 递增两个数据源的地址指针 */</span></span><br><span class=\"line\">        pBuffer++;</span><br><span class=\"line\">        pBuffer1++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 完成判断并且对应数据相对 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc函数中进行dma测试\">在main.c函数中进行DMA测试</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明以下变量来自外部文件</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> <span class=\"type\">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE];</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Delays the execution for a specified number of milliseconds.(Not Sure)</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ms The number of milliseconds to delay.</span></span><br><span class=\"line\"><span class=\"comment\"> * @return None.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay_ms</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; ms; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">uint16_t</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> status = <span class=\"number\">0</span>; <span class=\"comment\">// 接收比较的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// 初始化LED</span></span><br><span class=\"line\">    M2M_DMA_Config(); <span class=\"comment\">// 初始化DMA</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">// 等待DMA1传送完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(DMA_GetFlagStatus(M2M_DMA_FLAG_TC) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LED_YELLOW;</span><br><span class=\"line\">    Delay_ms(<span class=\"number\">10000</span>); <span class=\"comment\">// DMA初始化完成后亮黄灯</span></span><br><span class=\"line\"></span><br><span class=\"line\">    status = Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE); <span class=\"comment\">// 比较两个数组的数据是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(status == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_RED; <span class=\"comment\">// 数据不相等亮红灯</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_GREEN; <span class=\"comment\">// 数据相等亮绿灯</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dma实验2:-m to p\">DMA实验2: M to P</h3>\n<p>项目地址: <strong>22-DMA-MtoP</strong></p>\n<p><strong>实验需求</strong>: SRAM to 串口, 同时LED灯闪烁, 演示DMA数据不需占用CPU</p>\n<h3 id=\"在bsp_dma_m2ph中加入宏定义\">在bsp_dma_m2p.h中加入宏定义</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 串口工作参数宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB2Periph_USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_DMA_CLK RCC_AHBPeriph_DMA1 <span class=\"comment\">// 串口DMA时钟</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  USART_TX_DMA_CHANNEL     DMA1_Channel4 <span class=\"comment\">// 串口对应的DMA请求通道</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  USART_DR_ADDRESS        (USART1_BASE+0x04) <span class=\"comment\">// 外设寄存器地址</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  SENDBUFF_SIZE            5000 <span class=\"comment\">// 一次发送的数据量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  USART_TX_DMA_FLAG_TC DMA1_FLAG_TC4 <span class=\"comment\">// 标志位</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2pc中加入usart的初始化函数\">在bsp_dma_m2p.c中加入USART的初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口GPIO的时钟</span></span><br><span class=\"line\">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口外设的时钟</span></span><br><span class=\"line\">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置串口的工作参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置波特率</span></span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">// 配置 针数据字长</span></span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    <span class=\"comment\">// 配置停止位</span></span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    <span class=\"comment\">// 配置校验位</span></span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class=\"line\">    <span class=\"comment\">// 配置硬件流控制</span></span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    <span class=\"comment\">// 配置工作模式，收发一起</span></span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class=\"line\">    <span class=\"comment\">// 完成串口的初始化配置</span></span><br><span class=\"line\">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能串口</span></span><br><span class=\"line\">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2pc中加入usartx_tx-dma配置\">在bsp_dma_m2p.c中加入USARTx_TX DMA配置</h4>\n<p>实现内存到外设(USART1-&gt;DR)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USARTx TX DMA 配置，内存到外设(USART1-&gt;DR)</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USARTx_DMA_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 开启DMA时钟</span></span><br><span class=\"line\">    RCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">// 设置DMA源地址：串口数据寄存器地址*/</span></span><br><span class=\"line\">       DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;</span><br><span class=\"line\">    <span class=\"comment\">// 内存地址(要传输的变量的指针)</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff;</span><br><span class=\"line\">    <span class=\"comment\">// 方向：从内存到外设 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;</span><br><span class=\"line\">    <span class=\"comment\">// 传输大小 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;</span><br><span class=\"line\">    <span class=\"comment\">// 外设地址不增     </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class=\"line\">    <span class=\"comment\">// 内存地址自增</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class=\"line\">    <span class=\"comment\">// 外设数据单位 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class=\"line\">    <span class=\"comment\">// 内存数据单位</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  </span><br><span class=\"line\">    <span class=\"comment\">// DMA模式，一次或者循环模式</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;</span><br><span class=\"line\">    <span class=\"comment\">// DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; </span></span><br><span class=\"line\">    <span class=\"comment\">// 优先级：中 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; </span><br><span class=\"line\">    <span class=\"comment\">// 禁止内存到内存的传输</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class=\"line\">    <span class=\"comment\">// 配置DMA通道     </span></span><br><span class=\"line\">    DMA_Init(USART_TX_DMA_CHANNEL, &amp;DMA_InitStructure);  </span><br><span class=\"line\">    <span class=\"comment\">// 清除TC标志位</span></span><br><span class=\"line\">    DMA_ClearFlag(USART_TX_DMA_FLAG_TC);</span><br><span class=\"line\">    <span class=\"comment\">// 使能DMA</span></span><br><span class=\"line\">    DMA_Cmd (USART_TX_DMA_CHANNEL, ENABLE);</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2pc中声明在内存的变量\">在bsp_dma_m2p.c中声明在内存的变量</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中声明外部变量\">在main.c中声明外部变量</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中测试dma\">在main.c中测试DMA</h4>\n<p>实现DMA将储存器中的数据发送到USART-&gt;DR, 并实现LED1闪烁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现DMA将储存器中的数据发送到USART-&gt;DR, 并实现LED1闪烁</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @return int </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// 初始化LED</span></span><br><span class=\"line\">    USART_Config(); <span class=\"comment\">// 串口初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; SENDBUFF_SIZE; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SendBuff[i] = <span class=\"string\">&#x27;P&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    USARTx_DMA_Config(); <span class=\"comment\">// 初始化DMA</span></span><br><span class=\"line\">    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); <span class=\"comment\">// 使能DMA发送</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED1_TOGGLE;</span><br><span class=\"line\">        Delay_ms(<span class=\"number\">10000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用存储器\">常用存储器</h2>\n<h3 id=\"存储器的种类\">存储器的种类</h3>\n<p>易失性和非易失性区别在于<strong>掉电数据是否会丢失</strong>, 易失性存储器<strong>读写速度相对较快</strong></p>\n<ul>\n<li>易失性存储器(RAM)\n<ul>\n<li>DRAM(动态RAM, 常用于PC机)\n<ul>\n<li>SDRAM(STM32F429)</li>\n<li>DDR SDRAM</li>\n<li>DDRII SDRAM</li>\n<li>DDRIII SDRAM(常用于PC机)</li>\n</ul>\n</li>\n<li>SRAM(静态RAM, STM32F103)</li>\n</ul>\n</li>\n<li>非易失性存储器\n<ul>\n<li>ROM(半导体类)\n<ul>\n<li>MASK ROM(对于STM32可读不可写)</li>\n<li>PROM(可编程ROM)\n<ul>\n<li>OTPROM(可写一次的ROM)</li>\n<li>EPROM(可用高电压擦除的ROM)</li>\n<li>EEPROM(STM32F103, 可用较低电压3.3V擦除的ROM)</li>\n</ul>\n</li>\n<li>FLASH(半导体类)</li>\n<li>NOR FLASH(一般用来存储程序)</li>\n<li>NAND FLASH(一般用来存储数据)</li>\n<li>光盘</li>\n<li>软盘</li>\n<li>机械硬盘</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ram存储器(易失性存储器)\">RAM存储器(易失性存储器)</h3>\n<h4 id=\"ram介绍\">RAM介绍</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262322421.png\" alt=\"RAM介绍\"></p>\n<h4 id=\"dram的存储单元结构\">DRAM的存储单元结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262327533.png\" alt=\"DRAM的存储单元结构\"></p>\n<p><strong>DRAM通过电容充放电与MOS管配合产生高低电平</strong>, 需要配合电平检测阈值来减少电容漏电带来的影响</p>\n<h4 id=\"sram的存储单元结构\">SRAM的存储单元结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262328328.png\" alt=\"SRAM的存储单元结构\"></p>\n<p><strong>SRAM以锁存器结构来存储数据</strong>, 锁存器结构在没有输入的情况下会一直保持原来的状态</p>\n<h4 id=\"sram和dram的比较\">SRAM和DRAM的比较</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262336065.png\" alt=\"SRAM和DRAM的比较\"></p>\n<p>SDRAM使用同步通信方式</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262341860.png\" alt=\"SDRAM同步通信\"></p>\n<p>SRAM使用异步方式通信</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270000903.png\" alt=\"SRAM异步通信\"></p>\n<h3 id=\"非易失性存储器\">非易失性存储器</h3>\n<h4 id=\"rom简介\">ROM简介</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270001764.png\" alt=\"ROM简介\"></p>\n<h4 id=\"flash简介\">FLASH简介</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270007166.png\" alt=\"FLASH简介\"></p>\n<p>在嵌入式开发中选择 NOR FLASH 主要因为坏区较少, 基于字节读写可以支持XIP</p>\n<p>XIP(Execute In Place，就地执行)功能，它是一种特性，允许直接从 Flash 存储器中执行代码，而无需将代码首先复制到RAM中。XIP功能在嵌入式系统中很常见，它带来了一些优势，包括更少的RAM使用和更快的启动速度</p>\n<p>与ROM不同, FLASH必须先按块擦除数据后才能写入数据</p>\n<h2 id=\"i2c-读写eeprom\">I2C-读写EEPROM</h2>\n<h3 id=\"补充:-i2c简介\">补充: I2C简介</h3>\n<p>I2C（Inter-Integrated Circuit）是一种串行通信协议，<strong>用于在集成电路之间进行短距离通信</strong> I2C 由飞利浦公司（Philips）于1982年开发，并且现在由多家公司支持和采用。该协议通常用于连接芯片、传感器、存储器、外设等设备。</p>\n<p>以下是 I2C 协议的一些关键特点和基本概念：</p>\n<ol>\n<li>总线结构\n<ul>\n<li>主从结构： I2C 使用主从结构，其中一个设备充当主设备（通常是微控制器或处理器），而其他设备则充当从设备。主设备负责发起通信和生成时钟信号。</li>\n<li>双线制： I2C 使用两根线，一根是数据线（SDA），另一根是时钟线（SCL）。这两根线上都有上拉电阻，以便在设备不主动拉低时保持高电平。</li>\n</ul>\n</li>\n<li>数据传输：\n<ul>\n<li>起始和停止条件： 数据传输始于主设备发送起始条件（Start Condition），并以主设备发送停止条件（Stop Condition）结束。这两个条件都是由主设备在总线上生成的。</li>\n<li>地址帧： 每个数据传输都以地址帧开始，其中包含目标设备的地址和读写位。地址帧由主设备发送。</li>\n<li>数据帧： 在地址帧之后是一个或多个数据帧，其中包含实际的数据。数据帧的传输由主设备和从设备之间交替进行。</li>\n<li>应答（Acknowledge）： 在每个数据帧之后，接收方发送一个应答信号，通常是一个低电平，以确认数据的接收。</li>\n</ul>\n</li>\n<li>速率和模式：\n<ul>\n<li>速率： I2C 支持不同的传输速率，常见的有 100 kHz、400 kHz 和 1 MHz 等。</li>\n<li>模式： I2C 支持标准模式（100 kHz），快速模式（400 kHz），高速模式（1 MHz）等不同的工作模式。</li>\n</ul>\n</li>\n<li>多主设备和重复启动：\n<ul>\n<li>多主设备： I2C 支持多主设备共享同一总线。主设备之间通过仲裁（Arbitration）来确定哪个主设备能够继续发送。</li>\n<li>重复启动： 主设备可以在一个传输结束后发送重复启动条件，而无需先发送停止条件，从而在同一次通信中与另一个从设备建立连接。</li>\n</ul>\n</li>\n<li>I2C设备地址：\n<ul>\n<li>7位或10位地址： I2C 设备使用 7 位或 10 位地址来识别自己。大多数设备使用 7 位地址。</li>\n</ul>\n</li>\n</ol>\n<p>I2C 协议的简洁性和灵活性使得它在连接各种设备和传感器时非常有用，尤其是在嵌入式系统中。</p>\n<h3 id=\"补充:-高阻态\">补充: 高阻态</h3>\n<p>在嵌入式领域中，高阻态的概念同样非常重要，并涉及到数字电路设计和信号完整性的方面。以下是在嵌入式系统中高阻态的一些关键应用和概念：</p>\n<ol>\n<li>输入端口的高阻态： 很多嵌入式系统包括微控制器或微处理器，<strong>其输入端口通常具有高阻抗特性。这意味着当输入端口未连接到任何外部设备时，输入端口会处于高阻态状态。这有助于避免在未连接设备时引入不必要的电流，同时防止信号线上的悬空状态(floating)</strong>。</li>\n<li>悬空输入的高阻态： 在数字电路中，当一个输入端未连接时，它被称为悬空输入。在悬空输入的情况下，该输入端常常设计为高阻态，以减少对电路的干扰和功耗。</li>\n<li>总线冲突的高阻态： <strong>在多主设备共享总线的系统中，当多个主设备尝试在同一时刻传输数据时可能会发生总线冲突。为了避免冲突设备之间的干扰，某些设备在冲突时会将总线设置为高阻态，以允许其他设备继续操作</strong>。</li>\n<li>三态逻辑门： 一些数字逻辑门（如三态门）具有高阻态输出。这允许将多个门连接到同一总线上，当其中一个门处于高阻态时，其他门仍能够正常工作。</li>\n<li>输入缓冲器的高阻态： 在输入缓冲器中，当输入未被有效驱动时，输入缓冲器通常进入高阻态，以避免对电路产生负面影响。</li>\n</ol>\n<p>在这些情况下，高阻态的概念有助于确保电路在非活动状态时不引入不必要的电流，提高系统的稳定性和可靠性。这对于嵌入式系统中对功耗、信号完整性和总线冲突等方面的考虑非常重要。</p>\n<h3 id=\"i2c物理层\">I2C物理层</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270111246.png\" alt=\"I2C物理层\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270140896.png\" alt=\"I2C物理层\"></p>\n<h4 id=\"i2c物理层主要特点\">I2C物理层主要特点</h4>\n<ul>\n<li>I2C是支持多设备的总线, 可支持多个通讯主机和从机</li>\n<li>I2C使用两条线路, 一条SDA(双向串行数据线)来表示数据, 一条SCL(串行时钟线)来同步数据, 属于同步通信</li>\n<li>连接到总线的设备分配独立地址(7位或10位)</li>\n<li>总线接上拉电阻到电源(一般4.7KΩ, 具体看手册)\n<ol>\n<li>当设备空闲时输出高阻态<em>防止短路总线上的其他接地设备</em></li>\n<li>当所有设备都空闲时全部输出高阻态, 可通过上拉电阻把总线拉到高电平</li>\n<li>输出高阻态的特性需要GPIO的开漏输出</li>\n</ol>\n</li>\n<li>多设备占用总线会仲裁</li>\n<li>具有三种传输速度模式, <strong>实际开发中可使用低于最高速的速度, 协调总线设备速度一致即可</strong></li>\n<li>I2C可接入的设备数量受到最大电容负载的限制, 一般为400pF, <em>也就是说总线上的设备数量越多, 传输速度越慢</em></li>\n</ul>\n<h3 id=\"i2c协议层\">I2C协议层</h3>\n<p>I2C协议定义了<strong>通讯的起始和停止信号, 数据有效性, 响应, 仲裁, 时钟同步和地址广播等环节</strong></p>\n<h4 id=\"i2c基本读写过程\">I2C基本读写过程</h4>\n<h5 id=\"主机写数据到从机\">主机写数据到从机</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270157626.png\" alt=\"I2C基本读写过程\"></p>\n<ol>\n<li>S: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 主机传输需要通信的从机地址</li>\n<li>R/!W: 主机传输读或写信号, <em>若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据</em></li>\n<li>A: 从机传输响应</li>\n<li>DATA: 主机传输数据段</li>\n<li>A: 从机响应</li>\n<li>DATA: 主机继续发送数据段</li>\n<li>A/!A: 从机响应是否继续接收</li>\n<li>P: 若从机响应不继续接收, 则主机传输停止位</li>\n</ol>\n<h5 id=\"主机由从机读数据\">主机由从机读数据</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270207508.png\" alt=\"I2C基本读写过程\"></p>\n<ol>\n<li>S: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 主机传输需要通信的从机地址</li>\n<li>R/!W: 主机传输读或写信号, <em>若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据</em></li>\n<li>A: 从机传输响应</li>\n<li>DATA: 从机传输数据段</li>\n<li>A: 主机响应</li>\n<li>DATA: 从机继续发送数据段</li>\n<li>A/!A: 主机响应是否继续接收</li>\n<li>P: 若主机响应不继续接收, 则主机传输停止位</li>\n</ol>\n<p>注意:</p>\n<ul>\n<li>S: 开始信号只能由主机产生</li>\n<li>SLAVE ADDRESS: 进行通信的从机地址只能由主机产生</li>\n<li>R/!W: 读/写信号只能由主机产生</li>\n<li>P: 停止信号只能由主机产生</li>\n<li>DATA 和 A: 数据段和响应段由主机和从机交替产生, 具体由主机和从机的读写决定</li>\n</ul>\n<h5 id=\"通信复合格式\">通信复合格式</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270209992.png\" alt=\"通信复合格式\"></p>\n<p>常用的复合通信的方法, <strong>即先写入外设地址后将外设的寄存器地址返回进行读取</strong></p>\n<ul>\n<li>S: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 进行通信的从机地址(一般为外设)</li>\n<li>R/W!: 一般为写操作</li>\n<li>DATA: 写入的外设地址</li>\n<li>A/A!: 从机响应</li>\n<li>Sr: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 进行通信的从机地址(一般为同一个外设)</li>\n<li>R/W!: 一般为读操作</li>\n<li>DATA: 读取外设的寄存器的具体地址</li>\n<li>A/A!: 逐个字节进行读取外设每个寄存器的地址并做出响应</li>\n<li>P: 全部读取完毕后主机传输停止信号</li>\n</ul>\n<h4 id=\"通讯的起始和停止信号\">通讯的起始和停止信号</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270225648.png\" alt=\"通讯的起始和停止信号\"></p>\n<ul>\n<li>起始信号: <strong>SCL高电平, SDA由高电平向低电平转换</strong></li>\n<li>停止信号: <strong>SCL高电平, SDA由低电平向高电平转换</strong></li>\n</ul>\n<h4 id=\"数据的有效性\">数据的有效性</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270237788.png\" alt=\"数据有效性\"></p>\n<ul>\n<li>SDA: 负责传输数据</li>\n<li>SCL: 高电平时采集SDA上1bit数据, 低电平时SDA进行电平转换</li>\n</ul>\n<h4 id=\"地址及数据方向\">地址及数据方向</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270243764.png\" alt=\"地址及数据方向\"></p>\n<p>I2C采用高位先行, 由高位到低位进行传输</p>\n<p>一般使用7位表示I2C上的设备地址, 设备地址加上其后的读写位可以凑成8位即1字节方便传输</p>\n<p>例如, 某设备在I2C上的设备地址为7位的0x78(0b01111000), 可加入读写位凑到八位</p>\n<ul>\n<li>8位设备的读地址位为0xF1(0b11110001)</li>\n<li>8位设备的写地址位为0xF0(0b11110000)</li>\n</ul>\n<h4 id=\"响应\">响应</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270254565.png\" alt=\"响应\"></p>\n<ol>\n<li>1-8个时钟信号中: 数据发送端控制SDA传输7位设备地址和1位读写信号</li>\n<li>在第9个时钟信号时: 数据接收端获得SDA控制权, 发送应答信号(低电平表示应答)</li>\n</ol>\n<h3 id=\"stm32的i2c特性及架构\">STM32的I2C特性及架构</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270305500.png\" alt=\"STM32的I2C特性及架构\"></p>\n<ul>\n<li>软件模拟协议: 较为繁琐</li>\n<li>硬件模拟协议: 较为方便, 减轻CPU负担</li>\n</ul>\n<p>注: <em>STM32硬件的I2C逻辑可能会有问题</em></p>\n<h4 id=\"stm32的i2c架构分析\">STM32的I2C架构分析</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270315440.png\" alt=\"STM32的I2C架构分析\"></p>\n<h5 id=\"i2c的通讯引脚\">I2C的通讯引脚</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270346561.png\" alt=\"I2C的通讯引脚\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270316720.png\" alt=\"I2C的通讯引脚\"></p>\n<p>勘误: <em>I2C1_SCL默认映射到PB5, I2C1_SDA默认映射到PB7, 图片中有误</em></p>\n<p>STM32兼容smbus协议</p>\n<h5 id=\"时钟控制逻辑\">时钟控制逻辑</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347794.png\" alt=\"时钟控制逻辑\"><br>\n<img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270325594.png\" alt=\"时钟控制逻辑\"></p>\n<p>注: <em>Tpck1: 指的是APB1时钟周期(1/36MHz)</em></p>\n<h6 id=\"计算时钟频率的方法\">计算时钟频率的方法</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270333989.png\" alt=\"计算时钟频率的方法\"></p>\n<p>实际就是解未知数CCR的一元一次方程</p>\n<h5 id=\"数据控制逻辑\">数据控制逻辑</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347332.png\" alt=\"数据控制逻辑\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270337311.png\" alt=\"数据控制逻辑\"></p>\n<ol>\n<li>将8位数据写入数据寄存器(DR)</li>\n<li>数据寄存器里面的数据会被发送到数据移位寄存器</li>\n</ol>\n<h5 id=\"整体控制逻辑\">整体控制逻辑</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270348369.png\" alt=\"整体控制逻辑\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270355991.png\" alt=\"整体控制逻辑\"></p>\n<h3 id=\"stm32硬件i2c的通讯过程\">STM32硬件I2C的通讯过程</h3>\n<h4 id=\"stm32作为主发送器的通讯过程\">STM32作为主发送器的通讯过程</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270357886.png\" alt=\"STM32作为主发送器的通讯过程\"></p>\n<p>勘误: <em>EV8_2: TxE=1, BTF=1, 请求设置停止位. TxE和BTF位由硬件在产生停止条件时清除</em></p>\n<ul>\n<li>EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)</li>\n<li>EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)</li>\n<li>EV8: 在正常数据发送完毕后会产生EV8事件(I2C_SRx:TxE[7]置1表示数据寄存器空)</li>\n<li>EV8_2: 在从机发送结束应答后会产生EV8_2事件(I2C_SRx:TxE[7]置1表示数据寄存器空, I2C_SRx:BTF[2]置1表示字节发送结束, I2C_CRx:STOP[9]置1表示在当前字节传输或在当前起始条件发出后产生停止条件, 产生停止条件后由硬件清除TxE和BTF位)</li>\n</ul>\n<h4 id=\"stm32作为主接收器的通讯过程\">STM32作为主接收器的通讯过程</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270423471.png\" alt=\"STM32作为主接收器的通讯过程\"></p>\n<p>勘误: <em>EV7_1: RxNE=1, 读DR寄存器清除该事件. 设置ACK=0和STOP请求</em></p>\n<ul>\n<li>EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)</li>\n<li>EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)</li>\n<li>EV7: 在正常数据发送完毕后会产生EV7事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空)</li>\n<li>EV7_1: 在主机发送结束应答后会产生EV7_1事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空, I2C_CRx:ACK[10]置0表示设置为无应答返回, I2C_CRx:STOP[9]置1表示在当前字节传输或释放SCL和SDA线)</li>\n</ul>\n<p>每个状态标志位的清除方法各不相同, 使用库函数的方法可以较方便的清除寄存器的标志位</p>\n<h3 id=\"i2c初始化结构体\">I2C初始化结构体</h3>\n<p>在stm32f10x_i2c.h中定义I2C初始化结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  I2C Init structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置时钟频率</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置I2C的传输速率, 函数根据该值经过运算后写入I2C_CCR寄存器</span></span><br><span class=\"line\"><span class=\"comment\">   * 不得高于400kHz, 即400 000</span></span><br><span class=\"line\"><span class=\"comment\">   * 由于I2C_CCR寄存器不能写入浮点数, 可能会导致实际速率小于设定的传输速率参数</span></span><br><span class=\"line\"><span class=\"comment\">   * 使得通讯稍慢, 但是并不会对I2C的通讯造成其他影响</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> I2C_ClockSpeed;          <span class=\"comment\">/*!&lt; Specifies the clock frequency.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter must be set to a value lower than 400kHz */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置I2C的模式</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Mode_I2C: 标准I2C模式</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Mode_SMBusDevice: SMBus设备模式</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Mode_SMBusHost: SMBus主机模式</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_Mode;                <span class=\"comment\">/*!&lt; Specifies the I2C mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置I2C的SCL时钟的占空比</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_DutyCycle_16_9: Tlow/Thigh = 16:9</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_DutyCycle_2: Tlow/Thigh = 2:1</span></span><br><span class=\"line\"><span class=\"comment\">   * 这两个选项差别不大, 开发中一般不会进行严格区分</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_DutyCycle;           <span class=\"comment\">/*!&lt; Specifies the I2C fast mode duty cycle.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 配置STM32的I2C设备自己的地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 此参数可以是 7 位或 10 位地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 第二个地址可以通过函数I2C_OwnAddress2Config进行配置, 只能是7位地址</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_OwnAddress1;         <span class=\"comment\">/*!&lt; Specifies the first device own address.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a 7-bit or 10-bit address. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 配置I2C应答是否使能</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Ack_Enable: 允许应答使能</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Ack_Disable: 禁止应答使能</span></span><br><span class=\"line\"><span class=\"comment\">   * 一般配置为允许应答使能, 改为禁止应答使能往往会导致通讯错误</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_Ack;                 <span class=\"comment\">/*!&lt; Enables or disables the acknowledgement.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_acknowledgement */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 配置I2C的寻址长度</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_AcknowledgedAddress_7bit: 7位地址</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_AcknowledgedAddress_10bit: 10位地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 需要根据连接到I2C总线上的设备进行选择, 确保地址长度一致, 才能进行通信</span></span><br><span class=\"line\"><span class=\"comment\">   * 只有I2C_OwnAddress1才能配置10位地址, I2C_OwnAddress2只支持7位地址 *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_AcknowledgedAddress; <span class=\"comment\">/*!&lt; Specifies if 7-bit or 10-bit address is acknowledged.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_acknowledged_address */</span></span><br><span class=\"line\">&#125;I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<h3 id=\"i2c库函数\">I2C库函数</h3>\n<h4 id=\"i2c_generatestart函数,-用于产生起始条件\">I2C_GenerateSTART函数, 用于产生起始条件</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271607885.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_getflagstatus函数,-用于获取状态位\">I2C_GetFlagStatus函数, 用于获取状态位</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271610721.png\" alt=\"I2C库函数\"></p>\n<p>I2C_FLAG参数列表对应I2C_SRx状态寄存器的各个位, 可通过查询手册查看其含义</p>\n<p>返回值说明</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271612900.png\" alt=\"返回值说明\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span>RESET = <span class=\"number\">0</span>, SET = !RESET&#125; FlagStatus, ITStatus;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>RESET: 0, 返回RESET表示该状态位为0</li>\n<li>SET: 1, 返回SET表示该状态位为1</li>\n</ul>\n<h4 id=\"i2c_send7bitaddress函数,-用于发送7位地址\">I2C_Send7bitAddress函数, 用于发送7位地址</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271616560.png\" alt=\"I2C库函数\"></p>\n<p>参数Address为八位读/写地址, 通过I2C_Direction实际配置读写方向, 最终方向以I2C_Direction配置为准, 参数Address的读写位失效</p>\n<h4 id=\"i2c_senddate函数,-通过i2cx外设发送数据字节\">I2C_SendDate函数, 通过I2Cx外设发送数据字节</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271618557.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_receivedata函数,-返回 i2cx 外设最近接收的数据\">I2C_ReceiveData函数, 返回 I2Cx 外设最近接收的数据</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271622473.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"acknowledgeconfig函数,-使能或禁用i2c的应答\">AcknowledgeConfig函数, 使能或禁用I2C的应答</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271623317.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_cmd函数,-使能或禁用i2cx外设\">I2C_Cmd函数, 使能或禁用I2Cx外设</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271625131.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_checkevent函数,-i2c状态监测函数\">I2C_CheckEvent函数, I2C状态监测函数</h4>\n<p>监测的事件发生则返回SUCCESS</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280036252.png\" alt=\"I2C库函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037103.png\" alt=\"I2C_CheckEvent函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037758.png\" alt=\"I2C_CheckEvent函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038783.png\" alt=\"I2C_CheckEvent函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038105.png\" alt=\"I2C_CheckEvent函数\"></p>\n<h3 id=\"eeprom硬件结构\">EEPROM硬件结构</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271630443.png\" alt=\"EEPROM\"></p>\n<h4 id=\"引脚说明\">引脚说明</h4>\n<ul>\n<li>VCC: 电源引脚, 接3V3</li>\n<li>GND: 地引脚, 接地</li>\n<li>SCL: 时钟线, 经2.2K上拉电阻接3V3, 接PB6引脚(默认映射I2C1_SCL)</li>\n<li>SDA: 数据线, 经2,2K上拉电阻接3V3, 接PB7引脚(默认映射I2C1_SDA)</li>\n<li>HOLD: WP引脚, 接地, 不启用写保护(即可向AT24C02写数据)</li>\n<li>A0-A2: 地址引脚, 接地, A0:A2为000, 如需拓展EEPROM则可通过配置A0-A2的地址引脚来进行区分(如: 配置A0:A2为001, 则可对两EEPROM进行区分)</li>\n</ul>\n<h3 id=\"at24c02介绍\">AT24C02介绍</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271642465.png\" alt=\"AT24C02\"></p>\n<p>AT24C02可存储256字节数据</p>\n<h4 id=\"at24c02引脚说明\">AT24C02引脚说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271648925.png\" alt=\"AT24C02\"></p>\n<ul>\n<li>A0-A2: AT24C02用来区分不同AT24C0x芯片的设备地址</li>\n<li>SDA: 数据线</li>\n<li>SCL: 时钟线</li>\n<li>WP: 写保护, 置1启用写保护</li>\n<li>NC: 不连接</li>\n</ul>\n<h4 id=\"at24c02设备地址\">AT24C02设备地址</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702961.png\" alt=\"设备地址\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702718.png\" alt=\"设备地址\"></p>\n<p>AT24C02有256字节, 即属于2K(256*8)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271701248.png\" alt=\"设备地址\"></p>\n<p>根据原理图, 将A2-A0均接地, 则A2 = A1 = A0 = 0</p>\n<p>AT24C02的地址为0b1010000R/W, Bit0为R/!W位</p>\n<ul>\n<li>AT24C02在A2:A1[000]情况下读地址: 0b10100001(0xA1)</li>\n<li>AT24C02在A2:A1[000]情况下写地址: 0b10100000(0xA0)</li>\n</ul>\n<h4 id=\"at24c02的byte-write(以字节方式写数据)操作\">AT24C02的Byte Write(以字节方式写数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271719435.png\" alt=\"Byte Write\"></p>\n<p>第一个传输的数据段(DATA)为WORD ADDRESS(需要写入的字节所在的地址), 第二次传输数据段(DATA)才为真正需要写入的内容</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271723653.png\" alt=\"Byte Write\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Byte Write的工作流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. 在发送完SLAVE ADDRESS和W/!R后, 需要发送一个字节的数据地址(WORD ADDRESS)(即需要写入的字节所在的地址)</span><br><span class=\"line\">2. 收到地址(WORD ADDRESS)后, EEPROM会响应ACK, 然后接收一个字节的数据(DATA)(真正要写入的内容)</span><br><span class=\"line\">3. 接收到数据(DATA)后, EEPROM响应ACK, 单片机必须发送STOP信号, 不能继续传输第二段数据(给EEPROM预留写入时间)</span><br><span class=\"line\">4. 接收到停止信号后, EEPROM在tWR的周期时间内进行向内部写入数据</span><br><span class=\"line\">5. 在此写入周期中, 所有输入被禁用, EEPROM不进行响应</span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的page-write(以页方式写数据)操作\">AT24C02的Page Write(以页方式写数据)操作</h4>\n<p>又称突发写入(即仅发送一个地址可写入多个数据)</p>\n<p>Page Write解决了Byte Write不能连续写入的缺陷</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271734727.png\" alt=\"Page Write\"></p>\n<ul>\n<li>WORD ADDRESS(n): 数据的起始地址</li>\n<li>DATA(n): 写入到WORD ADDRESS(n)中</li>\n<li>DATA(n+1): 写入到WORD ADDRESS(n+1)中</li>\n<li>DATA(n+x): 写入到WORD ADDRESS(n+x)中</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271741445.png\" alt=\"Page Write\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Page Write工作流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. AT24C02能以8字节进行Page Write</span><br><span class=\"line\">2. 与Byte Write类似, 第一个字节是数据地址(WORD ADDRESS)(即需要写入的字节所在的地址), 在接受到第二个字节(DATA)后不会要求单片机发送STOP信号</span><br><span class=\"line\">3. 相反, EEPROM在接收到第一个DATA(真正要写入的数据)后, 对于AT24C02来说, 能再最多传输7个DATA</span><br><span class=\"line\">4. EEPROM每接收到一个数据位都会响应ACK, 单片机必须发送停止信号来结束Page Writting</span><br><span class=\"line\">5. 收到每个DATA后, 对于AT24C02来说, 数据地址(WORD ADDRESS)的低三位会递增(低三位的取值情况为2<span class=\"built_in\">^</span>3 = 8, 即8字节)</span><br><span class=\"line\">6. 高位地址不会递增, 从而保证原来的初始数据地址不发生改变(确保低三位正确递增)</span><br><span class=\"line\">7. 当递增的地址到达Page的界限后, 剩下的8位数据会覆盖Page的开头</span><br><span class=\"line\">8. 如果向EEPROM传输的DATA超过8个字节(对于AT24C02), 则数据会从头覆盖</span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的acknowledge-polling(确认轮询)\">AT24C02的ACKNOWLEDGE POLLING(确认轮询)</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280423663.png\" alt=\"ACKNOWLEDGE POLLING\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。</span><br><span class=\"line\">这涉及发送一个启动条件，后跟设备地址。读/写位是代表所需的操作。</span><br><span class=\"line\">仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列</span><br></pre></td></tr></table></figure>\n<p>需要在向AT24C02写入数据操作后, 进行确认询问, 主机需要发送启动条件, 设备地址, 读写位, 如果AT24C02准备完毕会响应0才能继续进行操作</p>\n<p>以I2C1为例, 软件编程实现如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认询问 </span></span><br><span class=\"line\"><span class=\"comment\"> *   STM32向EEPROM写入数据后, EEPROM需要时间向内部存储期间进行写入</span></span><br><span class=\"line\"><span class=\"comment\"> *   此时EEPROM不应答, 所以在发送下一次I2C请求之前,应等待EEPROM写入完成</span></span><br><span class=\"line\"><span class=\"comment\"> *   以上步骤称为ACKNOWLEDGE POLLING</span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_ACK_Polling</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); </span><br><span class=\"line\">    <span class=\"comment\">/* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* 结束询问 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的current-address read(从当前地址读数据)操作\">AT24C02的Current Address Read(从当前地址读数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271810617.png\" alt=\"Current Address Read\"></p>\n<p>一般不用, 因为在开发中不好确定当前地址的位置</p>\n<h4 id=\"at24c02的random-read(随机读数据)操作\">AT24C02的Random Read(随机读数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271813901.png\" alt=\"Random Read\"></p>\n<ol>\n<li>产生起始信号, 向EEPROM发送要读取数据的数据地址(写方向)</li>\n<li>再次产生起始信号, 从EEPROM中读取数据(读方向)</li>\n<li>EEPROM在被写入要读取数据的数据地址后会进行确认并输出该数据内容</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271821179.png\" alt=\"Random Read\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Random Read流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. Random Read需要&quot;dummy&quot;来写入要读取数据(DATA)的数据地址(WORD ADDRESS)</span><br><span class=\"line\">2. 一旦DEVICE ADDRESS和WORD ADDRESS被EEPROM响应, 单片机必须生成另一个START信号</span><br><span class=\"line\">3. 单片机发送读信号来读取当前地址(DEVICE ADDRESS)</span><br><span class=\"line\">4. EEPROM响应DEVICE ADDRESS并串行输出数据(DATA)</span><br><span class=\"line\">5. 单片机响应NO ACK并紧跟生成STOP信号</span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的sequential-read(顺序读数据)操作\">AT24C02的Sequential Read(顺序读数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271838678.png\" alt=\"Sequential Read\"></p>\n<p>与Page Write类似</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271841941.png\" alt=\"Sequential Read\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Sequential Read流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. Sequntial Read从当前地址读取或随机地址开始读取</span><br><span class=\"line\">2. 单片机收到DATA后，会响应ACK</span><br><span class=\"line\">3. 只要EEPROM收到ACK响应，它就会继续递增数据地址，并顺序串行输出DATA</span><br><span class=\"line\">4. 当达到内存地址限制时，数据地址将&quot;roll over&quot;，顺序读取将继续从头开始重新读取数据</span><br><span class=\"line\">5. 当单片机NO ACK响应并生成STOP，则终止Sequential Read</span><br></pre></td></tr></table></figure>\n<h3 id=\"i2c-读写eeprom实验\">I2C-读写EEPROM实验</h3>\n<p>项目地址: <strong>24-I2C-EEPROM</strong></p>\n<h4 id=\"操作流程\">操作流程</h4>\n<ol>\n<li>初始化I2C相关的GPIO</li>\n<li>配置I2C外设的工作模式</li>\n<li>编写I2C写入EEPROM的Byte Write函数</li>\n<li>编写I2C读取EEPROM的Random Read函数</li>\n<li>使用read函数和write函数进行读写校验</li>\n<li>编写Page Write和Sequential Read函数进行校验</li>\n</ol>\n<h4 id=\"在bsp_i2ch中定义相关宏\">在bsp_i2c.h中定义相关宏</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @defgroup I2C_EEPROM_Define </span></span><br><span class=\"line\"><span class=\"comment\"> * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief I2C的宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C I2C1 <span class=\"comment\">/*!&lt; EEPROM所使用的I2Cx */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_CLK RCC_APB1Periph_I2C1 <span class=\"comment\">/*!&lt; I2C的时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_APBxClkCmd RCC_APB1PeriphClockCmd <span class=\"comment\">/*!&lt; I2C时钟的使能函数 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_BAUDRATE 400000 <span class=\"comment\">/*!&lt; I2C的通信速率 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STM32_I2C_OWN_ADDR 0x5F <span class=\"comment\">/*!&lt; STM32在I2C总线上的自身地址, 可任意配置(只要在I2C总线上唯一即可) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_WRITE_ADDRESS 0xA0 <span class=\"comment\">/*!&lt; EEPROM在I2C总线上的8位写地址 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_READ_ADDRESS 0xA1 <span class=\"comment\">/*!&lt; EEPROM在I2C总线上的8位读地址 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief I2C的GPIO引脚宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SCL_GPIO_CLK (RCC_APB2Periph_GPIOB) <span class=\"comment\">/*!&lt; I2C的SCL引脚的GPIO时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SDA_GPIO_CLK (RCC_APB2Periph_GPIOB) <span class=\"comment\">/*!&lt; I2C的SDA引脚的GPIO时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd <span class=\"comment\">/*!&lt; I2C的GPIO时钟的使能函数 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SCL_GPIO_PORT GPIOB <span class=\"comment\">/*!&lt; I2C的SCL引脚的GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SCL_GPIO_Pin GPIO_Pin_6 <span class=\"comment\">/*!&lt; I2C的SCL引脚的GPIO引脚 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SDA_GPIO_PORT GPIOB <span class=\"comment\">/*!&lt; I2C的SDA引脚的GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SDA_GPIO_Pin GPIO_Pin_7 <span class=\"comment\">/*!&lt; I2C的SDA引脚的GPIO引脚 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2ch中进行函数声明\">在bsp_i2c.h中进行函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @defgroup EEPROM_I2C_Functions </span></span><br><span class=\"line\"><span class=\"comment\"> * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EEPROM_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Byte_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span> Data)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Page_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToWrite)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Random_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Sequential_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToRead)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_ACK_Polling</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写i2c_eeprom配置函数\">在bsp_i2c.c中编写I2C_EEPROM配置函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief I2C EEPROM配置函数 </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EEPROM_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    I2C_InitTypeDef I2C_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- 时钟配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 使能I2C GPIO的时钟 */</span></span><br><span class=\"line\">    EEPROM_I2C_GPIO_APBxClkCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 使能I2C的时钟 */</span></span><br><span class=\"line\">    EEPROM_I2C_APBxClkCmd(EEPROM_I2C_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- I2C_SCL的GPIO配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 配置引脚为I2C的SCL */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_GPIO_Pin;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置输出速率为50MHz */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置模式开漏复用输出 */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C_SCL的GPIO配置 */</span> </span><br><span class=\"line\">    GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- I2C_SDA的GPIO配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 配置引脚为I2C的SDA */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_GPIO_Pin;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置输出速率为50MHz */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置模式开漏复用输出 */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C_SDA的GPIO配置 */</span> </span><br><span class=\"line\">    GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- I2C的工作模式配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 使能响应 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class=\"line\">    <span class=\"comment\">/* 使用7位地址 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class=\"line\">    <span class=\"comment\">/* 时钟频率 400kHz*/</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_ClockSpeed = EEPROM_I2C_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">/* 占空比 Tlow/Thigh = 2 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class=\"line\">    <span class=\"comment\">/* 模式 I2C */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32主机地址 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_OwnAddress1 = STM32_I2C_OWN_ADDR;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C */</span></span><br><span class=\"line\">    I2C_Init(EEPROM_I2C, &amp;I2C_InitStructure); </span><br><span class=\"line\">    <span class=\"comment\">/* 使能I2C */</span></span><br><span class=\"line\">    I2C_Cmd(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写byte-writting方式的函数\">在bsp_i2c.c中编写Byte Writting方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现了STM32作为主发送器向EEPROM以Byte Writting的方式写数据 </span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 需要写入的字节所在的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 真正要写入的内容</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Byte_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span> Data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送Data */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, Data);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写page-writting方式的函数\">在bsp_i2c.c中编写Page Writting方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现了STM32作为主发送器向EEPROM以Page Writting的方式写数据(每次不超过8字节) </span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 需要写入的字节所在的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 真正要写入的数据的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param NumByteToWrite: 要写入数据的个数小于8</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Page_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToWrite)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 循环写入数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(NumByteToWrite)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* STM32向EEPROM发送Data */</span></span><br><span class=\"line\">        I2C_SendData(EEPROM_I2C, *Data);</span><br><span class=\"line\">        <span class=\"comment\">/* 数据指针自增 */</span></span><br><span class=\"line\">        Data++;</span><br><span class=\"line\">        <span class=\"comment\">/* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NumByteToWrite--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写random-read方式的函数\">在bsp_i2c.c中编写Random Read方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现STM32从EEPROM以Random Read方式读取数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 要读取数据的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 读取数据要写入到的变量</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Random_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32接收Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32另外产生一个START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的读地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    * 注意: </span></span><br><span class=\"line\"><span class=\"comment\">    * 该部分为STM32接收来自EEPROM的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作</span></span><br><span class=\"line\"><span class=\"comment\">    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 而不是进行数据接收</span></span><br><span class=\"line\"><span class=\"comment\">    *------------------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 监测到EV7事件发生, 说明接收到了新数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 将接收到的数据赋值给Data变量 */</span></span><br><span class=\"line\">    *Data = I2C_ReceiveData(EEPROM_I2C);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生NO ACK响应 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写sequential-read方式的函数\">在bsp_i2c.c中编写Sequential Read方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现STM32从EEPROM以Sequential Read方式读取数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 要读取数据的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 读取数据要写入到的变量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param NumByteToRead: 要读取数据的个数</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Sequential_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToRead)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*---------------- STM32接收Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32另外产生一个START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的读地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    * 注意: </span></span><br><span class=\"line\"><span class=\"comment\">    * 该部分为STM32接收来自EEPROM的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作</span></span><br><span class=\"line\"><span class=\"comment\">    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 而不是进行数据接收</span></span><br><span class=\"line\"><span class=\"comment\">    *------------------------------------------------------------------------*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(NumByteToRead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (NumByteToRead == <span class=\"number\">1</span>) <span class=\"comment\">/* 如果为最后一个字节, 产生NO ACK响应 */</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* STM32产生NO ACK响应 */</span></span><br><span class=\"line\">            I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 监测到EV7事件发生, 说明接收到了新数据 */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 将接收到的数据赋值给Data变量 */</span></span><br><span class=\"line\">        *Data = I2C_ReceiveData(EEPROM_I2C);</span><br><span class=\"line\">        <span class=\"comment\">/* Data 指针自增 */</span></span><br><span class=\"line\">        Data++;</span><br><span class=\"line\">        <span class=\"comment\">/* NumByteToRead递减 */</span></span><br><span class=\"line\">        NumByteToRead--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写确认询问函数\">在bsp_i2c.c中编写确认询问函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认轮询</span></span><br><span class=\"line\"><span class=\"comment\"> *   一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。</span></span><br><span class=\"line\"><span class=\"comment\"> *   这涉及发送一个启动条件，后跟设备地址。</span></span><br><span class=\"line\"><span class=\"comment\"> *   读/写位是代表所需的操作。</span></span><br><span class=\"line\"><span class=\"comment\"> *   仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列</span></span><br><span class=\"line\"><span class=\"comment\"> *   以上步骤称为ACKNOWLEDGE POLLING</span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_ACK_Polling</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); </span><br><span class=\"line\">    <span class=\"comment\">/* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* 结束轮询 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中进行读写测试\">在main.c中进行读写测试</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @file    main.c</span></span><br><span class=\"line\"><span class=\"comment\">  * @author  eric</span></span><br><span class=\"line\"><span class=\"comment\">  * @version V0.0.1</span></span><br><span class=\"line\"><span class=\"comment\">  * @date    27-January-2024</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   STM32与EEPROM通过I2C协议进行读写测试</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @attention</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * THE PRESENT FUNTIONS WHICH IS FOR GUIDANCE ONLY</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Includes ------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_conf.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_usart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_i2c.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 操作流程:</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 初始化I2C相关的GPIO</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 配置I2C外设的工作模式</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 编写I2C写入EEPROM的Byte Write函数 </span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 编写I2C读取EEPROM的Random Read函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 使用read函数和write函数进行读写校验</span></span><br><span class=\"line\"><span class=\"comment\"> * 6. 编写Page Write和Sequential Read函数进行校验</span></span><br><span class=\"line\"><span class=\"comment\"> *----------------------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @defgroup: Global_Values</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> ReadData[<span class=\"number\">20</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">uint8_t</span> WriteData[<span class=\"number\">3</span>] = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief STM32与EEPROM通过I2C协议进行读写测试 </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化USART */</span></span><br><span class=\"line\">    USART_Config(); </span><br><span class=\"line\">    <span class=\"comment\">/* 串口打印 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I2C-EEPROM\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C */</span></span><br><span class=\"line\">    I2C_EEPROM_Config();</span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM 地址1写入数据0x01 */</span></span><br><span class=\"line\">    EEPROM_Byte_Writting(<span class=\"number\">1</span>, <span class=\"number\">0x01</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class=\"line\">    EEPROM_ACK_Polling();</span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM 地址2写入数据0x02 */</span></span><br><span class=\"line\">    EEPROM_Byte_Writting(<span class=\"number\">2</span>, <span class=\"number\">0x02</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class=\"line\">    EEPROM_ACK_Polling();</span><br><span class=\"line\">    <span class=\"comment\">/*----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">     * Page Writting的地址对齐</span></span><br><span class=\"line\"><span class=\"comment\">     * 为保证数据无误需addr%8 == 0</span></span><br><span class=\"line\"><span class=\"comment\">     *----------------------------------------*/</span> </span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM 地址3-5写入数据0x03-0x05 */</span></span><br><span class=\"line\">    EEPROM_Page_Writting(<span class=\"number\">0x03</span>, WriteData, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class=\"line\">    EEPROM_ACK_Polling();</span><br><span class=\"line\">    <span class=\"comment\">/* STM32从EEPROM以SequentialRead方式读取地址1-4的数据 */</span> </span><br><span class=\"line\">    EEPROM_Sequential_Read((<span class=\"type\">uint8_t</span>)<span class=\"number\">1</span>, ReadData, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32从EEPROM以RandomRead方式读取地址5的数据 */</span> </span><br><span class=\"line\">    EEPROM_Random_Read((<span class=\"type\">uint8_t</span>)<span class=\"number\">5</span>, &amp;ReadData[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* 将读出的数据循环打印 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ReadData[%d] = 0x%x\\n&quot;</span>, i, ReadData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 空循环 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"串口实验现象\">串口实验现象</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280831099.png\" alt=\"实验现象\"></p>\n<h4 id=\"完善功能\">完善功能</h4>\n<p>以下函数是对实验中出现函数的进一步完善, 源文件不在工程中</p>\n<h5 id=\"增加的宏定义\">增加的宏定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* STM32 I2C 快速模式 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_Speed              400000  <span class=\"comment\">//*</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2Cx_OWN_ADDRESS7      0X0A   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* AT24C01/02每页有8个字节 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_PageSize           8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* AT24C04/08A/16A每页有16个字节 */</span></span><br><span class=\"line\"><span class=\"comment\">//#define I2C_PageSize           16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*等待超时时间*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT)</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"调试功能\">调试功能</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_DEBUG_ON         0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_INFO(fmt,arg...)           printf(<span class=\"string\">&quot;&lt;&lt;-EEPROM-INFO-&gt;&gt; &quot;</span>fmt<span class=\"string\">&quot;\\n&quot;</span>,##arg)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_ERROR(fmt,arg...)          printf(<span class=\"string\">&quot;&lt;&lt;-EEPROM-ERROR-&gt;&gt; &quot;</span>fmt<span class=\"string\">&quot;\\n&quot;</span>,##arg)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_DEBUG(fmt,arg...)          do&#123;\\</span></span><br><span class=\"line\"><span class=\"meta\">                                          <span class=\"keyword\">if</span>(EEPROM_DEBUG_ON)\\</span></span><br><span class=\"line\"><span class=\"meta\">                                          printf(<span class=\"string\">&quot;&lt;&lt;-EEPROM-DEBUG-&gt;&gt; [%s][%d]&quot;</span>fmt<span class=\"string\">&quot;\\n&quot;</span>, __FILE__, __LINE__, ##arg);\\</span></span><br><span class=\"line\"><span class=\"meta\">                                          &#125;while(0)</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"超时处理函数\">超时处理函数</h5>\n<p>完善了对于超时的处理</p>\n<h6 id=\"超时处理相关宏定义\">超时处理相关宏定义</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*等待超时时间*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"超时处理相关变量声明\">超时处理相关变量声明</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __IO <span class=\"type\">uint32_t</span>  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_TIMEOUT_UserCallback</span><span class=\"params\">(<span class=\"type\">uint8_t</span> errorCode)</span>;</span><br></pre></td></tr></table></figure>\n<h6 id=\"超时状态函数\">超时状态函数</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Basic management of the timeout situation.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  errorCode：错误代码，可以用来定位是哪个环节出错.</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 返回0，表示IIC读取失败.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span>  <span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_TIMEOUT_UserCallback</span><span class=\"params\">(<span class=\"type\">uint8_t</span> errorCode)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Block communication and all processes */</span></span><br><span class=\"line\">  EEPROM_ERROR(<span class=\"string\">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"多字节写入函数\">多字节写入函数</h5>\n<p>完善了在Page Write中字节对齐的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   将缓冲区中的数据写到I2C EEPROM中</span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  *  @arg pBuffer:缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  *  @arg WriteAddr:写地址</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg NumByteToWrite:写的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EE_BufferWrite</span><span class=\"params\">(u8* pBuffer, u8 WriteAddr, u16 NumByteToWrite)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  u8 NumOfPage = <span class=\"number\">0</span>, NumOfSingle = <span class=\"number\">0</span>, Addr = <span class=\"number\">0</span>, count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Addr = WriteAddr % I2C_PageSize;</span><br><span class=\"line\">  count = I2C_PageSize - Addr;</span><br><span class=\"line\">  NumOfPage =  NumByteToWrite / I2C_PageSize;</span><br><span class=\"line\">  NumOfSingle = NumByteToWrite % I2C_PageSize;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* If WriteAddr is I2C_PageSize aligned  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Addr == <span class=\"number\">0</span>) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &lt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(NumOfPage == <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class=\"line\">      I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &gt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(NumOfPage--)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); </span><br><span class=\"line\">     I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">        WriteAddr +=  I2C_PageSize;</span><br><span class=\"line\">        pBuffer += I2C_PageSize;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(NumOfSingle!=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* If WriteAddr is not I2C_PageSize aligned  */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &lt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(NumOfPage== <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class=\"line\">      I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &gt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      NumByteToWrite -= count;</span><br><span class=\"line\">      NumOfPage =  NumByteToWrite / I2C_PageSize;</span><br><span class=\"line\">      NumOfSingle = NumByteToWrite % I2C_PageSize; </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(count != <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, count);</span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">        WriteAddr += count;</span><br><span class=\"line\">        pBuffer += count;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span>(NumOfPage--)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);</span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">        WriteAddr +=  I2C_PageSize;</span><br><span class=\"line\">        pBuffer += I2C_PageSize;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(NumOfSingle != <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); </span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"单字节写入函数\">单字节写入函数</h5>\n<p>增加超时处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   写一个字节到I2C EEPROM中</span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  * @arg pBuffer:缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  * @arg WriteAddr:写地址 </span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_EE_ByteWrite</span><span class=\"params\">(u8* pBuffer, u8 WriteAddr)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;  </span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"comment\">/* Send the EEPROM&#x27;s internal address to write to */</span></span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, WriteAddr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send the byte to be written */</span></span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, *pBuffer); </span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;  </span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">3</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send STOP condition */</span></span><br><span class=\"line\">  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"单页写入函数\">单页写入函数</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  *          不能超过EEPROM页的大小，AT24C02每页有8个字节</span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg pBuffer:缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg WriteAddr:写地址</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg NumByteToWrite:写的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_EE_PageWrite</span><span class=\"params\">(u8* pBuffer, u8 WriteAddr, u8 NumByteToWrite)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))   </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">5</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">6</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send the EEPROM&#x27;s internal address to write to */</span>    </span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, WriteAddr);  </span><br><span class=\"line\"></span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(! I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">7</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* While there is data to be written */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(NumByteToWrite--)  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Send the current byte */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2Cx, *pBuffer); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Point to the next byte to be written */</span></span><br><span class=\"line\">    pBuffer++; </span><br><span class=\"line\">  </span><br><span class=\"line\">    I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">8</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Send STOP condition */</span></span><br><span class=\"line\">  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"读取数据函数\">读取数据函数</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   从EEPROM里面读取一块数据 </span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg pBuffer:存放从EEPROM读取的数据的缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg WriteAddr:接收数据的EEPROM的地址</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg NumByteToWrite:要从EEPROM读取的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_EE_BufferRead</span><span class=\"params\">(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//*((u8 *)0x4001080c) |=0x80; </span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">9</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  <span class=\"comment\">//*((u8 *)0x4001080c) &amp;=~0x80;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">10</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\"></span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">11</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Clear EV6 by setting again the PE bit */</span></span><br><span class=\"line\">  I2C_Cmd(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Send the EEPROM&#x27;s internal address to write to */</span></span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, ReadAddr);  </span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">12</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition a second time */</span>  </span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">13</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for read */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">14</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* While there is data to be read */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(NumByteToRead)  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(NumByteToRead == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Disable Acknowledgement */</span></span><br><span class=\"line\">      I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* Send STOP Condition */</span></span><br><span class=\"line\">      I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Test on EV7 and clear it */</span>    </span><br><span class=\"line\">    I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==<span class=\"number\">0</span>)  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    &#123;      </span><br><span class=\"line\">      <span class=\"comment\">/* Read a byte from the EEPROM */</span></span><br><span class=\"line\">      *pBuffer = I2C_ReceiveData(EEPROM_I2Cx);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* Point to the next location where the byte read will be saved */</span></span><br><span class=\"line\">      pBuffer++; </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* Decrement the read bytes counter */</span></span><br><span class=\"line\">      NumByteToRead--;        </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Enable Acknowledgement to be ready for another reception */</span></span><br><span class=\"line\">  I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"等待eeprom函数\">等待EEPROM函数</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Wait for EEPROM Standby state </span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EE_WaitEepromStandbyState</span><span class=\"params\">(<span class=\"type\">void</span>)</span>      </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vu16 SR1_Tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* Read I2C1 SR1 register */</span></span><br><span class=\"line\">    SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1);</span><br><span class=\"line\">    <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">while</span>(!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) &amp; <span class=\"number\">0x0002</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Clear AF flag */</span></span><br><span class=\"line\">  I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF);</span><br><span class=\"line\">    <span class=\"comment\">/* STOP condition */</span>    </span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"stm32f103学习笔记\">STM32F103学习笔记</h1>\n<h2 id=\"说明\">说明</h2>\n<p>本库仅供学习交流使用</p>\n<ul>\n<li>开发板: 野火霸道V2开发板</li>\n<li>编译器： ARM v5.06</li>\n<li>C编译版本: C99</li>\n<li>固件库版本: V3.5.0</li>\n<li>MDK version: 538A</li>\n<li>芯片包: Keil.STM32F1xx_DFP.2.4.1</li>\n<li>芯片型号: STM32F103ZET6</li>\n<li>参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道/指南者/MINI)【全】(刘火良老师出品) (无字幕)】 <a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4</a></li>\n<li>仓库地址: <a href=\"https://github.com/See-YouL/Fire-Projects.git\">https://github.com/See-YouL/Fire-Projects.git</a></li>\n</ul>\n<h2 id=\"基础配置\">基础配置</h2>\n<h3 id=\"配置keilmdk\">配置KeilMDK</h3>\n<p>看视频配置KeilMDK,P2</p>\n<p><a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw\">看视频配置Keil MDK</a></p>\n<h3 id=\"配置串口下载程序\">配置串口下载程序</h3>\n<p>看视频配置串口下载程序,P4</p>\n<p><a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw\">看视频配置串口下载程序</a></p>\n<h3 id=\"美化keil界面\">美化Keil界面</h3>\n<p><strong>非必须步骤</strong>, 用来美化界面</p>\n<p><a href=\"https://www.bilibili.com/video/BV1uT411S7mB/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">使用该方案的插件</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Df4y1k75Z/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">使用该方案的主题配色</a></p>\n<h3 id=\"配置vscode\">配置VScode</h3>\n<p><strong>非必须步骤</strong>, 用来使用VScode开发, <em>也可使用Keil MDK则不需要该步骤</em></p>\n<p>方案一: 使用VScode + Keil5 MDK进行开发(主要插件<strong>Keil Assistant</strong>)</p>\n<ul>\n<li>优点: 不需要使用Keil进行编辑</li>\n<li>缺点: 不具备Debug功能,只有编译和烧录</li>\n</ul>\n<p><a href=\"https://www.bilibili.com/video/BV19V411g7gD/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">方案一参考视频</a></p>\n<p>方案二: 使用Vscode + EIDE进行开发(主要插件<strong>EIDE</strong>)</p>\n<ul>\n<li>优点: 可在VScode中进行调试</li>\n<li>缺点: 依赖Keil的编译环境</li>\n</ul>\n<p><a href=\"https://www.bilibili.com/video/BV1nr4y1R7Jb/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">方案二参考视频</a></p>\n<h2 id=\"理论知识\">理论知识</h2>\n<h3 id=\"stm32命名方式\">STM32命名方式</h3>\n<ul>\n<li>STM32: 32bit的MCU</li>\n<li>F或L: F表示基础型(Foundation)或高性能型(High-Performance), L表示低功耗型(Ultra-low-power)</li>\n<li>xxx: 芯片特性, 如性能级别、内存大小、特殊功能等</li>\n<li>系列:\n<ul>\n<li>F0, F1, F2, F3, F4, F7：这些数字代表不同的性能级别，数字越大，性能通常越高。</li>\n<li>L0, L1, L4, L5：这些是低功耗系列，数字越大，性能和功能通常越丰富。</li>\n</ul>\n</li>\n<li>性能级别: 通常由一到两位数字表示，如STM32F103或STM32L152。这些数字表示不同的性能级别、内存大小和外设</li>\n<li>包装类型: 通常由一个字母表示，如STM32F103C8T6中的C表示LQFP48封装</li>\n<li>额外特性: 如STM32F103C8T6中的8表示该芯片有64KB闪存，T表示温度范围（-40°C 到 85°C），6表示批次号或版本</li>\n</ul>\n<h4 id=\"例子\">例子</h4>\n<p>以 STM32F103C8T6 为例：</p>\n<ul>\n<li>STM32：STMicroelectronics的32位微控制器。</li>\n<li>F：Foundation系列。</li>\n<li>103：该系列中的特定型号，具有特定的性能、内存和外设配置。</li>\n<li>C：封装类型，这里是LQFP48。</li>\n<li>8：闪存大小，这里是64KB。</li>\n<li>T：温度范围，这里是-40°C 到 85°C。</li>\n<li>6：批次号或版本。</li>\n</ul>\n<h2 id=\"置位与清零\">置位与清零</h2>\n<ul>\n<li>&amp;= ~(1 &lt;&lt; n); <strong>将bit n清零,其他位保持不变</strong></li>\n<li>|= (1 &lt;&lt; n); <strong>将bit n置1,其他位保持不变</strong></li>\n</ul>\n<h2 id=\"gpio\">GPIO</h2>\n<h3 id=\"gpio简介\">GPIO简介</h3>\n<p>GPIO(General purpose input output)通用输入输出端口的简称,<strong>软件可以控制的引脚,可输入可输出</strong></p>\n<h4 id=\"gpio和引脚的区别\">GPIO和引脚的区别</h4>\n<p>引脚（Pin）</p>\n<ul>\n<li>定义：引脚是指微控制器、微处理器或其他电子组件上的物理接点。它们是硬件设备的一部分，用于连接电路板、传递信号或供电。</li>\n<li>通用性：引脚可以有多种功能，包括但不限于传输数据、供电、接地或作为特殊功能的接口（如模拟输入、PWM输出等）。</li>\n<li>物理特性：引脚是实体的、物理存在的，可以是金属的脚或焊盘。</li>\n</ul>\n<p>GPIO（General-Purpose Input/Output）</p>\n<ul>\n<li>定义：GPIO是指在微控制器或其他数字电路设备上的一种特定类型的引脚，可以通过编程设置为输入或输出模式。</li>\n<li>功能：GPIO引脚的功能非常灵活，可以用于读取数字信号（如按钮的按压）或输出数字信号（如控制LED灯的开关）。</li>\n<li>编程控制：GPIO引脚的主要特点是它们可以通过软件编程来控制其行为，这使得它们非常适合于各种通用的数字输入输出任务。</li>\n</ul>\n<p>区别</p>\n<ul>\n<li>功能范围：所有GPIO都是引脚，但并非所有引脚都是GPIO。引脚是一个更广泛的概念，包括GPIO以及其他专用功能的引脚。</li>\n<li>灵活性和用途：GPIO引脚特别设计用于通用的数字输入输出任务，并且它们的行为可以通过软件编程来改变。而其他类型的引脚可能有固定的功能，如电源、接地或特定的通信功能。</li>\n<li>编程控制：GPIO的关键特性是它们可以被编程来执行不同的任务（输入或输出），而其他类型的引脚可能不具备这种灵活性。</li>\n</ul>\n<p>总的来说，<strong>GPIO是引脚的一个子集，专门用于可编程的通用数字输入输出任务。而引脚是一个更广泛的概念，涵盖了电子设备上的所有物理接点。</strong></p>\n<h4 id=\"引脚的分类\">引脚的分类</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png\" alt=\"引脚的分类\"></p>\n<h3 id=\"gpio-框图讲解\">GPIO 框图讲解</h3>\n<h4 id=\"保护二极管\">保护二极管</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.41.14.png\" alt=\"保护二极管\"></p>\n<ul>\n<li><strong>如果引脚电压大于VDD则上面的保护二极管导通</strong>,防止高电压进入芯片内部,如果电压过高则会烧坏二极管进而烧坏芯片</li>\n<li><strong>如果引脚电压低于VSS则下面的保护二极管导通</strong>,保护芯片</li>\n</ul>\n<h4 id=\"推挽输出\">推挽输出</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.09.27.png\" alt=\"ODR=1时推挽输出原理图\"></p>\n<p>推挽输出部分的INT来自ODR寄存器</p>\n<p>若ODR为1, 经过反相器后为0, 此时PMOS和NMOS的Ug=0V</p>\n<p>对于PMOS, Us=3.3V &gt; Ug=0V, PMOS管导通, OUT=VDD</p>\n<p>对于NMOS, Us=0V = Ug=0V, 简单认为, NMOS管截止</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.20.46.png\" alt=\"ODR=0时推挽输出原理图\"></p>\n<p>若ODR为0,经过反相器后为1, 此时PMOS和NMOS的Ug=3.3V</p>\n<p>对于PMOS, Us=3.3V = Ug=3.3V, 简单认为, PMOS管截止</p>\n<p>对于NMOS, Us=0V &lt; Ug=3.3V, NMOS管导通, OUT=GND=0V</p>\n<h5 id=\"推挽输出的含义\">推挽输出的含义</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.23.18.png\" alt=\"推挽输出含义图\"></p>\n<ul>\n<li>PMOS导通时, OUT处电流向外称为<strong>推</strong>, 此时电流称为<strong>灌电流</strong></li>\n<li>NMOS导通时, OUT处电流向里称为<strong>挽</strong>, 此时电流称为<strong>拉电流</strong></li>\n</ul>\n<p>推挽输出（Push-Pull Output）是一种常见的电子电路输出类型，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的<strong>主要特点是它使用两个晶体管（一个N型和一个P型）来控制输出引脚的电压状态。</strong></p>\n<h5 id=\"推挽输出的原理\">推挽输出的原理</h5>\n<p>在推挽配置中，通常有两个晶体管：</p>\n<ul>\n<li>N型晶体管：当被激活（或导通）时，它将输出引脚连接到地（GND），从而产生低电平（0）输出。</li>\n<li>P型晶体管：当被激活时，它将输出引脚连接到正电源（VCC），从而产生高电平（1）输出。</li>\n</ul>\n<p>这两个晶体管不会同时导通，以避免短路。在任何给定的时刻，要么N型晶体管导通将输出拉低，要么P型晶体管导通将输出拉高。</p>\n<h5 id=\"推挽输出的特点\">推挽输出的特点</h5>\n<ul>\n<li>强驱动能力：<strong>推挽输出可以提供较强的电流驱动能力</strong>，无论是向输出引脚提供电流（高电平）还是从引脚吸收电流（低电平）。</li>\n<li>确定的逻辑状态：输出要么明确地是高电平，要么是低电平，<strong>不会处于悬空（高阻态）状态</strong>。</li>\n<li>无需外部上拉或下拉电阻：由于<strong>推挽输出自身就可以明确地驱动高电平或低电平</strong>，因此不需要外部的上拉或下拉电阻来确保稳定的输出状态。</li>\n</ul>\n<h5 id=\"推挽输出的应用\">推挽输出的应用</h5>\n<p>推挽输出广泛应用于各种数字电路，特别是<strong>在需要驱动LED、继电器或其他需要较高电流的负载时</strong>。由于其<strong>强大的驱动能力和清晰的逻辑电平</strong>，推挽输出是实现<strong>数字信号传输</strong>的理想选择。</p>\n<h5 id=\"推挽输出对比开漏/开集输出\">推挽输出对比开漏/开集输出</h5>\n<p>与推挽输出相对的是开漏（在MOSFET技术中）或开集（在双极晶体管技术中）输出，<strong>这种类型的输出只有一个晶体管，要么将输出拉低，要么让它悬空（高阻态）</strong>。开漏/开集输出<strong>需要外部上拉电阻来确保高电平状态</strong>，常用于需要多个设备共享同一输出线的应用，如I2C通信协议。</p>\n<h4 id=\"开漏输出\">开漏输出</h4>\n<p>内部只能输出低电平,不能输出高电平</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png\" alt=\"当ODR为1时开漏输出原理图\"></p>\n<p>该图片标注有误, 实际用的是ODR=0时的图, 但是结构相同, 不影响分析</p>\n<p>ODR=1, 经反相器为0, Vg=0V=Vs=0V, NMOS管截止, 此时OUT为高阻态悬空, 加入外部上拉电阻后, OUT=1</p>\n<p>如果外部需要高电平驱动可以通过更换外部上拉电路来进行更换</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png\" alt=\"当ODR为0时开漏输出原理图\"></p>\n<p>ODR=0, 经反相器为1, Vg=1 &gt; Vs=0, NMOS管导通, 此时OUT=0V</p>\n<p>开漏输出（Open-Drain Output，在使用MOSFET技术的情况下称为开漏，而在使用双极性晶体管的情况下称为开集（Open-Collector）输出）是一种常见的电子电路设计，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的<strong>主要特点是它使用单个晶体管来控制输出引脚的电压状态，而不是像推挽输出那样使用两个晶体管。</strong></p>\n<h5 id=\"开漏输出的原理\">开漏输出的原理</h5>\n<p>在开漏配置中，只有一个N型晶体管：</p>\n<ul>\n<li>N型晶体管：当晶体管导通（激活）时，它将输出引脚连接到地（GND），产生低电平（0）输出。当晶体管关闭（非激活）时，输出引脚不连接到任何东西，处于悬空状态。</li>\n<li>由于输出在晶体管关闭时处于悬空状态，因此通常需要一个外部的上拉电阻连接到正电源（VCC），以确保当晶体管关闭时输出能够达到高电平（1）。</li>\n</ul>\n<h5 id=\"开漏输出的特点\">开漏输出的特点</h5>\n<ul>\n<li>单向驱动能力：开漏输出<strong>只能将输出拉低，不能主动驱动高电平</strong>。</li>\n<li>需要外部上拉电阻：<strong>为了确保输出能够达到高电平，需要外部上拉电阻</strong>。</li>\n<li>适合于总线和共享线路：开漏输出非常<strong>适合于多个设备共享同一输出线的应用</strong>，因为任何一个设备都可以将线路拉低，而不会对其他设备造成干扰。</li>\n</ul>\n<h5 id=\"开漏输出的应用\">开漏输出的应用</h5>\n<p>开漏输出<strong>常用于需要多个设备共享同一通信线路的场合</strong>，如I2C和1-Wire通信协议。在这些应用中，<strong>多个设备可以连接到同一条线路上，每个设备都可以通过将线路拉低来发送信号，而不会影响其他设备。</strong></p>\n<h5 id=\"开漏输出对比推挽输出\">开漏输出对比推挽输出</h5>\n<p>与开漏输出相对的是推挽输出，后者使用两个晶体管（一个N型和一个P型）来分别驱动高电平和低电平。推挽输出可以主动驱动高电平和低电平，而<strong>开漏输出只能驱动低电平，需要外部上拉电阻来实现高电平状态。</strong></p>\n<h4 id=\"补充:-高阻态与悬空\">补充: 高阻态与悬空</h4>\n<p><strong>高阻态（High-Impedance State），通常简称为Hi-Z</strong>，是电子电路中的一个术语，用来描述一个电路节点在特定条件下呈现出非常高电阻的状态。在这种状态下，<strong>电路节点既不明显地连接到电源（高电平），也不明显地连接到地（低电平）</strong>。换句话说，这个节点处于一种“断开”或“浮空”的状态，对电路中的其他部分几乎没有任何电气影响。</p>\n<h5 id=\"高阻态的应用\">高阻态的应用</h5>\n<ul>\n<li><strong>三态逻辑（Tri-state Logic）</strong>：在数字电路中，高阻态常用于三态逻辑，<strong>允许多个输出连接到同一个线路或总线上，而不会相互干扰</strong>只有被选中的设备会将其输出置于低电阻状态（高电平或低电平），其他设备的输出则处于高阻态。</li>\n<li><strong>总线系统</strong>：在微处理器、微控制器和其他数字系统的总线（如数据总线、地址总线）上，高阻态用于控制哪个设备可以在特定时刻向总线发送数据。</li>\n<li><strong>输入/输出端口</strong>：在可编程的微控制器的GPIO（通用输入/输出）端口中，<strong>高阻态可以用来防止未使用的或被配置为输入的端口对电路造成影响</strong>。</li>\n</ul>\n<h5 id=\"高阻态的重要性\">高阻态的重要性</h5>\n<ul>\n<li><strong>避免冲突</strong>：在多个设备共享同一通信线路时，高阻态可以防止输出冲突。</li>\n<li><strong>节能</strong>：当端口处于高阻态时，它几乎不消耗电流，有助于降低功耗。</li>\n<li><strong>灵活性</strong>：高阻态提供了电路设计的灵活性，特别是在需要多个设备共享同一资源的情况下。</li>\n</ul>\n<h5 id=\"高阻态的注意事项\">高阻态的注意事项</h5>\n<ul>\n<li><strong>浮动电压</strong>：当一个端口或线路处于高阻态时，它可能会因为电磁干扰或静电感应而捕获不确定的电压，<strong>有时可能需要通过上拉或下拉电阻来确保稳定的逻辑状态</strong>。</li>\n<li><strong>设计考虑</strong>：在设计电路和编写程序时，需要考虑到高阻态的影响，确保在适当的时候启用或禁用高阻态。</li>\n</ul>\n<p>在电子电路中，<strong>“悬空”（Floating）是指一个电路节点没有被明确连接到电源（高电平）或地（低电平），也没有通过任何电阻或其他电子元件连接到其他电路节点的状态</strong>这种状态下的节点电压是不确定的，因为它既不是被固定在逻辑高也不是逻辑低，而是可以随外部电磁场或附近电路的状态变化而变化。</p>\n<h5 id=\"悬空状态的特点\">悬空状态的特点</h5>\n<ul>\n<li>不确定的电压：悬空的节点可能会随机地捕获周围环境的电磁干扰，导致其电压处于不确定的状态。</li>\n<li>易受干扰：由于没有明确的电气连接，悬空的节点容易受到外部电磁干扰的影响。</li>\n<li>可能导致问题：在数字电路中，悬空的输入引脚可能导致不稳定的逻辑状态，从而引发电路的不可预测行为。</li>\n</ul>\n<h5 id=\"高阻态与悬空的关系\">高阻态与悬空的关系</h5>\n<p>高阻态是一种特定的电路配置，<strong>其中一个节点（如微控制器的GPIO引脚）被设置为非常高的电阻状态。这意味着该节点对电路的其他部分几乎没有电气影响，类似于断开连接</strong>因此，<strong>当一个引脚被设置为高阻态时，它实际上是在悬空状态</strong>，因为它既不是明确地连接到高电平也不是低电平。</p>\n<h5 id=\"高阻态与悬空区别和联系\">高阻态与悬空区别和联系</h5>\n<ul>\n<li>联系：<strong>高阻态通常会导致节点悬空</strong>当一个节点处于高阻态时，由于其极高的电阻值，它实际上与电路的其他部分隔离，从而处于悬空状态。</li>\n<li>区别：<strong>高阻态是一种有意设置的电路状态</strong>，用于特定的目的（如防止总线冲突）。而<strong>悬空可能是无意的</strong>，可能是由于设计不当或电路未完成造成的。</li>\n</ul>\n<h5 id=\"悬空的注意事项\">悬空的注意事项</h5>\n<ul>\n<li>设计考虑：在设计电子电路和系统时，<strong>应避免输入引脚悬空，因为这可能导致不稳定的行为</strong>。通常<strong>使用上拉或下拉电阻来确保这些引脚有一个确定的逻辑状态。</strong></li>\n<li>高阻态应用：在某些情况下，如<strong>多个设备共享一个通信总线，高阻态是必要的，以确保只有一个设备在任何时刻控制总线。</strong></li>\n</ul>\n<h4 id=\"复用功能输出\">复用功能输出</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.18.55.png\" alt=\"复用功能输出原理框图\"></p>\n<p>通过片上外设如EXTI到引脚输出</p>\n<h4 id=\"输入模式\">输入模式</h4>\n<p>ISR读出</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.24.03.png\" alt=\"普通模式的输入\"></p>\n<p>I/O引脚至上拉/下拉输入(通过BSRR寄存器软件配置), 经TTL肖特基触发器(&gt;2V &lt;1.2V), 至IDR寄存器读出</p>\n<p>复用功能输入</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.29.40.png\" alt=\"复用功能输入\"></p>\n<p>以EXTI为例,RX数据经由TTL肖特基触发器到DR寄存器</p>\n<p>模拟输入</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.33.21.png\" alt=\"模拟输入框图\"></p>\n<p>不经过TTL肖特基触发器直接被读出</p>\n<h4 id=\"gpio框图对应寄存器\">GPIO框图对应寄存器</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.35.42.png\" alt=\"GPIO框图\"></p>\n<ul>\n<li>2部分: 推挽,开漏输出对应CRL,CRH寄存器</li>\n<li>3部分: 输出数据寄存器对应ODR; 位设置/清除寄存器对应BSRR</li>\n<li>上拉/下拉输入: 对应CRL,CRH,具体选择上拉还是下拉需要软件配置BSRR</li>\n<li>5部分: 输入数据寄存器对应IDR</li>\n</ul>\n<h3 id=\"gpio输出初始化顺序\">GPIO输出初始化顺序</h3>\n<ol>\n<li>时钟使能</li>\n<li>选择具体的GPIO</li>\n<li>配置GPIO的工作模式(CRL CRH)</li>\n<li>控制GPIO输出高低电平(ODR,BRR和BSRR)</li>\n</ol>\n<h2 id=\"手写库\">手写库</h2>\n<h3 id=\"通过地址使用寄存器\">通过地址使用寄存器</h3>\n<p>项目地址: <strong>REG-LED</strong></p>\n<h4 id=\"mainc中的主要代码\">main.c中的主要代码</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">0x40021018</span>) |= ((<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span>); <span class=\"comment\">// RCC_APB2ENR的bit3置1</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">开启GPIOB的时钟</span></span><br><span class=\"line\"><span class=\"comment\">GPIOB挂载在APB2总线</span></span><br><span class=\"line\"><span class=\"comment\">RCC_APB2ENR的偏移量为0x18</span></span><br><span class=\"line\"><span class=\"comment\">RCC的基地址为0x40021000</span></span><br><span class=\"line\"><span class=\"comment\">RCC_APB2ENR的bit3为IOPBEN(IO端口B时钟使能) 1开启</span></span><br><span class=\"line\"><span class=\"comment\">****************************************************************************/</span></span><br><span class=\"line\">*(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">0x40010C00</span>) |= ((<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>)); <span class=\"comment\">// GPIOB_CRL的bit4-0置0001</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">将GPIOB设置为推挽输出</span></span><br><span class=\"line\"><span class=\"comment\">GPIOB 基地址 0x40010C00</span></span><br><span class=\"line\"><span class=\"comment\">GPIOx_CRL 偏移量 00h </span></span><br><span class=\"line\"><span class=\"comment\">bit1-0: 01 输出模式，最大速度10MHz</span></span><br><span class=\"line\"><span class=\"comment\">bit4-3: 00 通用推挽输出模式</span></span><br><span class=\"line\"><span class=\"comment\">((1) &lt;&lt; (4*0)) // 若修改PB1则为(4*1)</span></span><br><span class=\"line\"><span class=\"comment\">****************************************************************************/</span></span><br><span class=\"line\">*(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">0x40010C0C</span>) &amp;= ~(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>); <span class=\"comment\">// GPIOB_ODR的bit0置0</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">修改PB0为1</span></span><br><span class=\"line\"><span class=\"comment\">GPIOB 基地址 0x40010C00</span></span><br><span class=\"line\"><span class=\"comment\">GPIOx_ODR 偏移量 0Ch </span></span><br><span class=\"line\"><span class=\"comment\">****************************************************************************/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"通过头文件定义使用寄存器\">通过头文件定义使用寄存器</h3>\n<p>项目地址: <strong>REG-LED-Register</strong></p>\n<p>确定总线基地址, 其中AHB的基地址是从DMA1开始的,即从0x40020000开始</p>\n<h4 id=\"在stm32f10xh中增加宏定义\">在stm32f10x.h中增加宏定义</h4>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存放stm32寄存器映射的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 外设 Peripheral</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PERIPH_BASE ((unsigned int)0x40000000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APB1PERIPH_BASE (PERIPH_BASE) <span class=\"comment\">// 从TIM2开始</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APB2PERIPH_BASE (PERIPH_BASE + 0x10000) <span class=\"comment\">// 从AFIO开始</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AHBPERIPH_BASE (PERIPH_BASE + 0x20000) <span class=\"comment\">// 从DMA1开始</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RCC</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RCC_BASE (AHBPERIPH_BASE + 0x1000) <span class=\"comment\">// RCC基地址 </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GPIOB</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_BASE (APB2PERIPH_BASE + 0x0C00) <span class=\"comment\">// GPIOB基地址</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义寄存器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x18)) <span class=\"comment\">// APB2外设时钟使能寄存器</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_CRL (*(volatile unsigned int *)(GPIOB_BASE + 0x00))<span class=\"comment\">// GPIOB_CRL</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_CRH (*(volatile unsigned int *)(GPIOB_BASE + 0x04)) <span class=\"comment\">// GPIOB_CRH</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_ODR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C)) <span class=\"comment\">// GPIOB_CRH</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中的主函数代码改为\">在main.c中的主函数代码改为</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC_APB2ENR |= ((<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span>); <span class=\"comment\">// 开启GPIOB的时钟</span></span><br><span class=\"line\">GPIOB_CRL &amp;= ~((<span class=\"number\">0x0F</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>)); <span class=\"comment\">// 将GPIOB状态清零</span></span><br><span class=\"line\">GPIOB_CRL |= ((<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>)); <span class=\"comment\">// 将GPIOB设置为推挽输出</span></span><br><span class=\"line\">GPIOB_ODR &amp;= ~(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>); <span class=\"comment\">// PB0置0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-关键字volatile的作用\">补充: 关键字volatile的作用</h4>\n<p>在C语言中，尤其是在嵌入式领域，volatile 关键字用于告诉编译器，<strong>定义为 volatile 的变量可能会以编译器不可预知的方式被改变</strong>。这意味着编译器在处理这些变量时，<strong>应避免进行某些优化，确保每次访问都直接从内存中读取变量的值</strong>。</p>\n<h4 id=\"关键字volatile含义\">关键字volatile含义</h4>\n<p>当一个变量被声明为 volatile 时，编译器会对该变量的处理方式做出以下调整：</p>\n<ul>\n<li><strong>防止优化</strong>：编译器不会对这些变量进行优化，这可能包括消除看似多余的读取或写入操作。</li>\n<li><strong>直接访问</strong>：每次访问 volatile 变量时，都会直接从其内存地址读取数据，而不是使用可能存储在寄存器中的副本。</li>\n</ul>\n<h4 id=\"关键字volatile的应用场景\">关键字volatile的应用场景</h4>\n<p>在嵌入式编程中，volatile 关键字的使用场景主要包括：</p>\n<ul>\n<li><strong>硬件寄存器访问</strong>：当编程与硬件寄存器交互时，如读取一个传感器的数据寄存器或写入一个控制寄存器。这些寄存器的值可能会在任何时候改变，因此需要使用 volatile 来确保每次读取或写入都是最新的值。</li>\n<li><strong>中断服务例程</strong>：在中断服务例程（ISR）中使用的变量，这些变量可能在ISR中被改变，并在程序的其他部分被访问。使用 volatile 可以确保主程序中的代码能够看到在ISR中对这些变量所做的更改。</li>\n<li><strong>多线程和并发</strong>：在多线程或并发环境中，一个线程可能修改另一个线程正在访问的变量。volatile 确保每个线程都能访问到最新的值。</li>\n</ul>\n<h4 id=\"关键字volative的注意事项\">关键字volative的注意事项</h4>\n<ul>\n<li><strong>不是并发解决方案</strong>：volatile 关键字不能替代互斥锁或其他并发控制机制。它不保证操作的原子性或内存可见性。</li>\n<li><strong>性能影响</strong>：由于 volatile 防止了某些优化，过度使用它可能会降低程序的性能。</li>\n<li><strong>正确使用</strong>：只有在上述特定场景中才应使用 volatile。错误地使用 volatile 可能会导致难以发现的错误。</li>\n</ul>\n<h3 id=\"通过结构体操作寄存器\">通过结构体操作寄存器</h3>\n<p>项目地址: <strong>FWlib-LED</strong></p>\n<h4 id=\"在stm32f10xh中添加结构体定义\">在stm32f10x.h中添加结构体定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"type\">uint32_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">uint16_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CRL;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CRH;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> IDR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ODR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> BSRR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> BRR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> LCKR;</span><br><span class=\"line\">&#125;GPIO_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB ((GPIO_TypeDef *)GPIOB_BASE) <span class=\"comment\">// 使用GPIOB-&gt;访问成员变量</span></span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">若定义为 #define GPIOB (*(GPIO_TypeDef *)(GPIOB_BASE))</span></span><br><span class=\"line\"><span class=\"comment\">则使用GPIOB.XXX来访问成员变量</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>\n<p>在main.c中使用GPIOB-&gt;XXX的方式来访问结构体成员(即寄存器), 主要代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIOB-&gt;CRL &amp;= ~((<span class=\"number\">0x0F</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">1</span>)); <span class=\"comment\">// 将GPIOB状态复位</span></span><br><span class=\"line\">GPIOB-&gt;CRL |= ((<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">1</span>)); <span class=\"comment\">// 将GPIOB设置为推挽输出</span></span><br><span class=\"line\">GPIOB-&gt;ODR &amp;= ~(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>); <span class=\"comment\">// PB0置0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10xh中增加rcc的结构体定义,如下\">在stm32f10x.h中增加RCC的结构体定义,如下</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CFGR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CIR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB2RSTR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB1RSTR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> AHBENR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB2ENR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> APB1ENR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> BDCR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CSR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> AHBRSTR;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> CFGR2;</span><br><span class=\"line\">&#125;RCC_Typedef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RCC ((RCC_Typedef*)RCC_BASE) <span class=\"comment\">// 使用RCC-&gt;访问成员变量</span></span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">若定义为 #define RCC (*(RCC_Typedef*)RCC_Base)</span></span><br><span class=\"line\"><span class=\"comment\">则使用RCC.XXX来访问成员变量</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中通过结构体访问rcc寄存器,代码如下\">在main.c中通过结构体访问RCC寄存器,代码如下</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC-&gt;APB2ENR |= ((<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span>); <span class=\"comment\">// 开启GPIOB的时钟</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"更换led说明\">更换LED说明</h4>\n<p>由于我的开发板，PB0总是点亮蓝灯(本应该是绿灯), 以后的测试换为测试蓝灯，<strong>PB0换为PB1进行测试</strong></p>\n<h3 id=\"增加端口置位/复位函数\">增加端口置位/复位函数</h3>\n<p>项目地址: <strong>FWlib-LED</strong></p>\n<p>增加stm32f10x_gpio.c和stm32f10x_gpio.h文件</p>\n<h4 id=\"在stm32f10x_gpioc中增加置位/复位函数\">在stm32f10x_gpio.c中增加置位/复位函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 端口置位函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_SetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIOx-&gt;BSRR |= Pin;</span><br><span class=\"line\">    <span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    BSRR寄存器:</span></span><br><span class=\"line\"><span class=\"comment\">    低16位写1置1，写0不改变</span></span><br><span class=\"line\"><span class=\"comment\">    高16位写1置0，写0不改变</span></span><br><span class=\"line\"><span class=\"comment\">    *----------------------------------------------------------------*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 端口复位函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_ResetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIOx-&gt;BRR |= Pin;</span><br><span class=\"line\">    <span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    BRR寄存器:</span></span><br><span class=\"line\"><span class=\"comment\">    低16位写1置0，写0不改变</span></span><br><span class=\"line\"><span class=\"comment\">    高16位保留</span></span><br><span class=\"line\"><span class=\"comment\">    ----------------------------------------------------------------*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_gpioh中添加16位pin置1的宏定义与函数声明\">在stm32f10x_gpio.h中添加16位PIN置1的宏定义与函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __STM32F10X_GPIO_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义端口</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_0    ((uint16_t)0x0001)  <span class=\"comment\">/*!&lt; 选择Pin0 */</span>    <span class=\"comment\">//(00000000 00000001)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_1    ((uint16_t)0x0002)  <span class=\"comment\">/*!&lt; 选择Pin1 */</span>    <span class=\"comment\">//(00000000 00000010)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_2    ((uint16_t)0x0004)  <span class=\"comment\">/*!&lt; 选择Pin2 */</span>    <span class=\"comment\">//(00000000 00000100)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_3    ((uint16_t)0x0008)  <span class=\"comment\">/*!&lt; 选择Pin3 */</span>    <span class=\"comment\">//(00000000 00001000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_4    ((uint16_t)0x0010)  <span class=\"comment\">/*!&lt; 选择Pin4 */</span>    <span class=\"comment\">//(00000000 00010000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_5    ((uint16_t)0x0020)  <span class=\"comment\">/*!&lt; 选择Pin5 */</span>    <span class=\"comment\">//(00000000 00100000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_6    ((uint16_t)0x0040)  <span class=\"comment\">/*!&lt; 选择Pin6 */</span>    <span class=\"comment\">//(00000000 01000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_7    ((uint16_t)0x0080)  <span class=\"comment\">/*!&lt; 选择Pin7 */</span>    <span class=\"comment\">//(00000000 10000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_8    ((uint16_t)0x0100)  <span class=\"comment\">/*!&lt; 选择Pin8 */</span>    <span class=\"comment\">//(00000001 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_9    ((uint16_t)0x0200)  <span class=\"comment\">/*!&lt; 选择Pin9 */</span>    <span class=\"comment\">//(00000010 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_10   ((uint16_t)0x0400)  <span class=\"comment\">/*!&lt; 选择Pin10 */</span>   <span class=\"comment\">//(00000100 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_11   ((uint16_t)0x0800)  <span class=\"comment\">/*!&lt; 选择Pin11 */</span>   <span class=\"comment\">//(00001000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_12   ((uint16_t)0x1000)  <span class=\"comment\">/*!&lt; 选择Pin12 */</span>   <span class=\"comment\">//(00010000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_13   ((uint16_t)0x2000)  <span class=\"comment\">/*!&lt; 选择Pin13 */</span>   <span class=\"comment\">//(00100000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_14   ((uint16_t)0x4000)  <span class=\"comment\">/*!&lt; 选择Pin14 */</span>   <span class=\"comment\">//(01000000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_15   ((uint16_t)0x8000)  <span class=\"comment\">/*!&lt; 选择Pin15 */</span>   <span class=\"comment\">//(10000000 00000000)b</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIO_Pin_All  ((uint16_t)0xFFFF)  <span class=\"comment\">/*!&lt; 选择全部引脚*/</span> <span class=\"comment\">//(11111111 11111111)b</span></span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">对于类似于GPIOx_BSRR, GPIOx_BRR寄存器通过写1来进行置位/复位操作的寄存器来说</span></span><br><span class=\"line\"><span class=\"comment\">宏定义16位端口的1值很有必要</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_SetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_ResetBits</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> Pin)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__STM32F10X_GPIO</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc函数中使用置位/复位函数\">在main.c函数中使用置位/复位函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 增加复位/置位函数</span></span><br><span class=\"line\">RCC-&gt;APB2ENR  |=  ( (<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">3</span> );</span><br><span class=\"line\">GPIOB-&gt;CRL &amp;=  ~( (<span class=\"number\">0x0f</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>) );</span><br><span class=\"line\">GPIOB-&gt;CRL |=  ( (<span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">4</span>*<span class=\"number\">0</span>) );</span><br><span class=\"line\">GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class=\"line\">GPIO_ResetBits( GPIOB,GPIO_Pin_1 );</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10xh中增加#ifndef\">在stm32f10x.h中增加#ifndef</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __STM32F10X_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __STM32F10X_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 中间代码省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__STM32F10X_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-在c语言中#ifndef的作用\">补充: 在C语言中#ifndef的作用</h4>\n<p>在C语言中，#ifndef 是一种预处理指令，用于条件编译。它的全称是 “if not defined”，意思是“如果没有定义”。#ifndef 通常与 #define 和 #endif 一起使用，<strong>用于防止头文件的内容被多次包含（重复包含）</strong>。</p>\n<h5 id=\"ifndef的作用\">ifndef的作用</h5>\n<p>&quot;#ifndef&quot;的主要作用是<strong>确保一个头文件中的内容只被包含一次，防止因重复包含同一头文件而导致的编译错误</strong>这种技术被称为“包含卫士”（Include Guards）或“头文件卫士”（Header Guards）。</p>\n<h5 id=\"ifndef的使用方式\">ifndef的使用方式</h5>\n<p>一个典型的使用 #ifndef 的例子如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设这是一个头文件 example.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> EXAMPLE_H    <span class=\"comment\">// 如果没有定义 EXAMPLE_H</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXAMPLE_H    <span class=\"comment\">// 定义 EXAMPLE_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 头文件的内容</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">someFunction</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 更多的声明...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// 结束 #ifndef</span></span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中：</p>\n<ol>\n<li>当编译器首次遇到 example.h 时，EXAMPLE_H 还没有被定义，所以编译器会处理 #define EXAMPLE_H 和随后的头文件内容。</li>\n<li>如果同一源文件或其他包含了 example.h 的文件再次尝试包含 example.h，EXAMPLE_H 已经被定义了，因此 #ifndef EXAMPLE_H 条件失败，编译器将跳过文件的其余部分，防止重复包含。</li>\n</ol>\n<h5 id=\"ifndef的重要性\">ifndef的重要性</h5>\n<p>在C语言项目中，特别是在大型项目中，头文件经常被多个源文件包含，或者一个头文件包含其他头文件。如果没有包含卫士，头文件中的定义（如函数声明、宏定义、类型定义等）可能会被重复包含，导致编译错误（如重复定义错误）。使用 #ifndef 可以有效地避免这种情况。</p>\n<h4 id=\"补充:-使用#ifndef命名使用双下划线说明\">补充: 使用#ifndef命名使用双下划线说明</h4>\n<p>在C语言中，当使用 #ifndef（和 #define、#endif）作为头文件的包含卫士时，通常会在文件名前加上双下划线 __ 或其他类似的前缀/后缀，<strong>这是一种非正式的约定，用于减少命名冲突的风险</strong>然而，需要注意的是，<strong>使用双下划线作为前缀或后缀在某些情况下可能并不是最佳实践</strong>。</p>\n<h5 id=\"使用双下划线的原因\">使用双下划线的原因</h5>\n<ul>\n<li><strong>唯一性</strong>：在大型项目中，可能会有许多不同的头文件。使用文件名作为宏的一部分可以帮助确保每个包含卫士的宏是唯一的。</li>\n<li><strong>减少冲突</strong>：添加额外的字符（如双下划线）可以进一步减少不同头文件之间宏名称冲突的可能性。</li>\n</ul>\n<h5 id=\"使用双下划线的注意事项\">使用双下划线的注意事项</h5>\n<p><strong>保留标识符</strong>：根据C和C++标准，<strong>以双下划线开头或以单下划线后跟大写字母开头的标识符是保留给实现（编译器和标准库）使用的</strong>。因此，使用这样的标识符作为宏名称<strong>可能会导致与标准库或编译器的内部标识符冲突</strong>。</p>\n<p>建议的做法：更安全的做法是<strong>使用文件名的大写形式加上一个后缀（如 _H），而不是使用双下划线</strong>。例如，对于 example.h 头文件，可以使用 EXAMPLE_H 作为包含卫士的宏。</p>\n<h5 id=\"示例\">示例</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> EXAMPLE_H    <span class=\"comment\">// 更安全的做法</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXAMPLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 头文件内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure>\n<p>总之，<strong>虽然在文件名前加上双下划线是一种常见做法，但为了避免与编译器或标准库的内部标识符冲突，建议使用其他方法来确保宏名称的唯一性和安全性</strong>。</p>\n<h3 id=\"增加gpio初始化结构体\">增加GPIO初始化结构体</h3>\n<p>项目地址: <strong>FWlib-LED</strong></p>\n<p>配置GPIO工作模式的宏定义(GPIOMode_TypeDef)参考下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202312301523539.png\" alt=\"GPIO工作模式图\"></p>\n<p>实际写入寄存器的是bit3-0,bit7-4并不写入寄存器</p>\n<p>勘误：上拉输入和下拉输入两行的bit3-2应该为10</p>\n<ul>\n<li>bit1-0: 置0, 配置输出速度，通过GPIOSpeed_TypeDef进行覆盖配置</li>\n<li>bit3-2: 配置输入/输出模式</li>\n<li>bi4: <strong>不写入寄存器</strong>, 用来标志是输入还是输出</li>\n<li>bit6-5: <strong>不写入寄存器</strong>， 用来判断是上拉输入还是下拉输入</li>\n<li>bit7: <strong>不写入寄存器</strong></li>\n</ul>\n<h4 id=\"在stm32f10x_gpioh中增加宏定义\">在stm32f10x_gpio.h中增加宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过枚举 限定GPIO_Speed的选择</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    GPIO_Speed_10MHZ = <span class=\"number\">1</span>, <span class=\"comment\">// 01 输出模式，最大速度10MHz</span></span><br><span class=\"line\">    GPIO_Speed_2MHZ, <span class=\"comment\">// 10 输出模式，最大速度2MHz</span></span><br><span class=\"line\">    GPIO_Speed_50MHZ <span class=\"comment\">// 11 输出模式，最大速度50MHz</span></span><br><span class=\"line\">&#125;GPIOSpeed_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过枚举限定GPIO_Mode的选择</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span> GPIO_Mode_AIN = <span class=\"number\">0x0</span>,           <span class=\"comment\">// 模拟输入     (0000 0000)b</span></span><br><span class=\"line\">  GPIO_Mode_IN_FLOATING = <span class=\"number\">0x04</span>,  <span class=\"comment\">// 浮空输入     (0000 0100)b</span></span><br><span class=\"line\">  GPIO_Mode_IPD = <span class=\"number\">0x28</span>,          <span class=\"comment\">// 下拉输入     (0010 1000)b</span></span><br><span class=\"line\">  GPIO_Mode_IPU = <span class=\"number\">0x48</span>,          <span class=\"comment\">// 上拉输入     (0100 1000)b</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  GPIO_Mode_Out_OD = <span class=\"number\">0x14</span>,       <span class=\"comment\">// 开漏输出     (0001 0100)b</span></span><br><span class=\"line\">  GPIO_Mode_Out_PP = <span class=\"number\">0x10</span>,       <span class=\"comment\">// 推挽输出     (0001 0000)b</span></span><br><span class=\"line\">  GPIO_Mode_AF_OD = <span class=\"number\">0x1C</span>,        <span class=\"comment\">// 复用开漏输出 (0001 1100)b</span></span><br><span class=\"line\">  GPIO_Mode_AF_PP = <span class=\"number\">0x18</span>         <span class=\"comment\">// 复用推挽输出 (0001 1000)b</span></span><br><span class=\"line\">&#125;GPIOMode_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义GPIO初始化结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> GPIO_Pin;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> GPIO_Speed;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> GPIO_Mode;</span><br><span class=\"line\">&#125;GPIO_InitTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_gpioc中写入gpio初始化函数\">在stm32f10x_gpio.c中写入GPIO初始化函数</h4>\n<p>该函数是从库函数中复制得到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GPIO初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_Init</span><span class=\"params\">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> currentmode = <span class=\"number\">0x00</span>, currentpin = <span class=\"number\">0x00</span>, pinpos = <span class=\"number\">0x00</span>, pos = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> tmpreg = <span class=\"number\">0x00</span>, pinmask = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*---------------------- GPIO 模式配置 --------------------------*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 把输入参数GPIO_Mode的低四位暂存在currentmode</span></span><br><span class=\"line\">  currentmode = ((<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// bit4是1表示输出，bit4是0则是输入 </span></span><br><span class=\"line\">  <span class=\"comment\">// 判断bit4是1还是0，即首选判断是输入还是输出模式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((((<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x10</span>)) != <span class=\"number\">0x00</span>)</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 输出模式则要设置输出速度</span></span><br><span class=\"line\">    currentmode |= (<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">/*-------------GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- -------*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 配置端口低8位，即Pin0~Pin7</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (((<span class=\"type\">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x00FF</span>)) != <span class=\"number\">0x00</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先备份CRL寄存器的值</span></span><br><span class=\"line\">    tmpreg = GPIOx-&gt;CRL;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 循环，从Pin0开始配对，找出具体的Pin</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pinpos = <span class=\"number\">0x00</span>; pinpos &lt; <span class=\"number\">0x08</span>; pinpos++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// pos的值为1左移pinpos位</span></span><br><span class=\"line\">      pos = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; pinpos;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 令pos与输入参数GPIO_PIN作位与运算，为下面的判断作准备</span></span><br><span class=\"line\">      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">//若currentpin=pos,则找到使用的引脚</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentpin == pos)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚</span></span><br><span class=\"line\">        pos = pinpos &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class=\"line\">        pinmask = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>) &lt;&lt; pos;</span><br><span class=\"line\">        tmpreg &amp;= ~pinmask;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class=\"line\">        tmpreg |= (currentmode &lt;&lt; pos);  </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为下拉输入模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0</span></span><br><span class=\"line\">          GPIOx-&gt;BRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; pinpos);</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 判断是否为上拉输入模式</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1</span></span><br><span class=\"line\">            GPIOx-&gt;BSRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; pinpos);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把前面处理后的暂存值写入到CRL寄存器之中</span></span><br><span class=\"line\">    GPIOx-&gt;CRL = tmpreg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">/*-------------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----------*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 配置端口高8位，即Pin8~Pin15</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class=\"number\">0x00FF</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先备份CRH寄存器的值</span></span><br><span class=\"line\">    tmpreg = GPIOx-&gt;CRH;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 循环，从Pin8开始配对，找出具体的Pin</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pinpos = <span class=\"number\">0x00</span>; pinpos &lt; <span class=\"number\">0x08</span>; pinpos++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      pos = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; (pinpos + <span class=\"number\">0x08</span>));</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">// pos与输入参数GPIO_PIN作位与运算</span></span><br><span class=\"line\">      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">//若currentpin=pos,则找到使用的引脚</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentpin == pos)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">//pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚</span></span><br><span class=\"line\">        pos = pinpos &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class=\"line\">        pinmask = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>) &lt;&lt; pos;</span><br><span class=\"line\">        tmpreg &amp;= ~pinmask;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class=\"line\">        tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为下拉输入模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0</span></span><br><span class=\"line\">          GPIOx-&gt;BRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; (pinpos + <span class=\"number\">0x08</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"comment\">// 判断是否为上拉输入模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1</span></span><br><span class=\"line\">          GPIOx-&gt;BSRR = (((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>) &lt;&lt; (pinpos + <span class=\"number\">0x08</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把前面处理后的暂存值写入到CRH寄存器之中</span></span><br><span class=\"line\">    GPIOx-&gt;CRH = tmpreg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用gpio初始化函数\">在main.c中使用GPIO初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;</span><br><span class=\"line\">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加宏定义来增强代码可移植性\">增加宏定义来增强代码可移植性</h3>\n<p>项目地址： <strong>FWlib-LED</strong></p>\n<h4 id=\"在mainc中增加宏定义\">在main.c中增加宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PORT GPIOB</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_CLK_ENABLE (RCC-&gt;APB2ENR |= ((1) &lt;&lt; 3)) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PIN GPIO_Pin_0</span></span><br></pre></td></tr></table></figure>\n<p>在main.c中增加延时函数，实现LED闪烁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>( ; count != <span class=\"number\">0</span>; count-- )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用宏定义后的代码实现led闪烁\">在main.c中使用宏定义后的代码实现LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加宏定义以增强代码可移植性</span></span><br><span class=\"line\">LED_B_GPIO_CLK_ENABLE;</span><br><span class=\"line\">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Pin = LED_B_GPIO_PIN;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;</span><br><span class=\"line\">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); <span class=\"comment\">// PB1置1 蓝灯灭</span></span><br><span class=\"line\">  Delay(<span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">  GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); <span class=\"comment\">// PB1置0 蓝灯亮</span></span><br><span class=\"line\">  Delay(<span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"固件库编程\">固件库编程</h2>\n<h3 id=\"stm32固件库文件分析\">STM32固件库文件分析</h3>\n<ol>\n<li>汇编编写的启动文件 startup_stm32f10x_h.s: 设置堆栈指针,设置PC指针，初始化中断向量表，配置系统时钟，调用C库函数_main最终去C的世界</li>\n<li>时钟配置文件 system_stm32f10x.c: 把外部时钟HSE=8M，经过PLL倍频成72M</li>\n<li>外设相关\n<ul>\n<li>stm32f10x.h: 实现了内核之外的外设的寄存器映射</li>\n<li>xx: GPIO, USART, I2C</li>\n<li>stm32f10x_xx.c: 外设的驱动函数库文件</li>\n<li>stm32f10x_xx.h: 存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库的头文件声明</li>\n</ul>\n</li>\n<li>内核相关\n<ul>\n<li>CMSIS: Cortex微控制器软件接口标准</li>\n<li>core_cm3.h: 实现了内核里面外设的寄存器映射</li>\n<li>core_cm3.c: 内核外设的驱动固件库</li>\n<li>NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器), misc.h, misc.c</li>\n</ul>\n</li>\n<li>头文件的配置文件 stm32f10x_conf.h里面包含\n<ul>\n<li>stm32f10x_usar.c</li>\n<li>stm32f10x_i2c.h</li>\n<li>stm32f10x_spi.h</li>\n<li>stm32f10x_adc.h</li>\n<li>stm32f10x_fsmc.h</li>\n</ul>\n</li>\n<li>专门存放终端服务函数的C文件(可以放在其他地方，不一定要放在stm32f10x_it.c中)\n<ul>\n<li>stm32f10x_it.c</li>\n<li>stm32f10x_it.h</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"新建固件库版本工程\">新建固件库版本工程</h3>\n<p>项目地址: <strong>Fwlib-Template</strong></p>\n<ul>\n<li>Doc: 用来存放程序说明的文件，由写程序的人添加</li>\n<li>Libraries: 存放库文件</li>\n<li>Project: 存放工程</li>\n<li>User: 用户编写的驱动文件</li>\n</ul>\n<p>其余按照视频配置，P18, 视频链接: <a href=\"https://www.bilibili.com/video/BV1yW411Y7Gw/?p=18&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4\">按照P18进行库移植</a></p>\n<h3 id=\"gpio输出-使用固件库点亮led\">GPIO输出-使用固件库点亮LED</h3>\n<p>项目地址: <strong>12-GPIO输出-使用固件库点亮LED</strong></p>\n<p>在User目录下新建led文件夹，添加bsp_led.c和bsp_led.h</p>\n<h4 id=\"在bsp_ledh中添加所使用的宏定义和函数声明\">在bsp_led.h中添加所使用的宏定义和函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_LED_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_LED_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PIN GPIO_Pin_1 <span class=\"comment\">// stm32f10x_gpio.h中定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_PORT GPIOB <span class=\"comment\">// stm32f10x.h中定义 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_GPIO_CLK RCC_APB2Periph_GPIOB</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_LED_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledc中添加初始化函数\">在bsp_led.c中添加初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bsp: board support package 板级支持包</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(LED_B_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = LED_B_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(LED_B_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用初始化函数，并进行软件延时，实现led闪烁\">在main.c中调用初始化函数，并进行软件延时，实现LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; count != <span class=\"number\">0</span>; count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> current;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(current = count; current != <span class=\"number\">0</span>; current--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LED_GPIO_Config();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">        GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledh中增加函数宏定义\">在bsp_led.h中增加函数宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ON 1 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFF 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B(a) <span class=\"keyword\">if</span> (a)\\</span></span><br><span class=\"line\"><span class=\"meta\">                     GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); \\</span></span><br><span class=\"line\"><span class=\"meta\">                     <span class=\"keyword\">else</span>\\</span></span><br><span class=\"line\"><span class=\"meta\">                     GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span></span><br><span class=\"line\"><span class=\"comment\">// 使用\\可以进行换行，其后不能跟空格，\\后应该直接回车</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用宏定义的函数\">在main.c中使用宏定义的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LED_B(OFF);</span><br><span class=\"line\">Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">LED_B(ON);</span><br><span class=\"line\">Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-c语言反斜杠\\换行\">补充: C语言反斜杠\\换行</h4>\n<p>在C语言中使用反斜杠 \\ 进行换行时，确实有一些需要注意的事项。这种用法通常出现在宏定义或是将长代码行分割为多行以提高代码的可读性。正确使用时，\\ 应该放在行尾，紧接着是换行符。</p>\n<h5 id=\"c语言反斜杠\\换行的注意事项\">C语言反斜杠\\换行的注意事项</h5>\n<ul>\n<li><strong>无空格</strong>：在行尾使用 \\ 时，它之后直到行末不能有任何字符，包括空格或制表符。任何在 \\ 之后的空格都会使得换行转义失效，导致编译错误。</li>\n<li><strong>紧跟换行符</strong>：\\ 应该直接紧跟换行符。这告诉编译器忽略换行符，将下一行视为当前行的延续。</li>\n<li><strong>可读性</strong>：虽然使用 \\ 可以将长代码行分割为多行，但过度使用可能会降低代码的可读性。适当使用，以保持代码整洁和可维护。</li>\n<li><strong>宏定义中的使用</strong>：在宏定义中使用 \\ 进行换行是常见的做法，<strong>因为宏定义必须是单行的</strong>。在这种情况下，确保每一行（除了最后一行）都以 \\ 结尾。</li>\n</ul>\n<h5 id=\"c语言反斜杠\\换行的示例\">C语言反斜杠\\换行的示例</h5>\n<p>正确的使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MY_MACRO(a, b) \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">        a = 2; \\</span></span><br><span class=\"line\"><span class=\"meta\">        b = 3; \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; while(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    MY_MACRO(x, y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，宏 MY_MACRO 被分成了多行，每行的末尾都使用了 \\ 来实现。</p>\n<p>错误的使用（如果 \\ 后有空格）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MY_MACRO(a, b) \\ </span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">        a = <span class=\"number\">2</span>; \\</span><br><span class=\"line\">        b = <span class=\"number\">3</span>; \\</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>在这个错误的例子中，<strong>第一行的 \\ 后面如果有空格，将导致编译错误</strong>。</p>\n<p>总之，当在C语言中使用 \\ 进行换行时，<strong>确保 \\ 是每行的最后一个字符，并且紧接着换行符</strong>，以避免编译错误并保持代码的清晰</p>\n<h3 id=\"gpio输入\">GPIO输入</h3>\n<p>项目地址: <strong>13-GPIO输入-按键检测</strong></p>\n<p>通过原理图可知<strong>KEY1接PA0口, 按键按下后为高电平</strong>, 原理图如下</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401011723631.png\" alt=\"KEY1原理图\"></p>\n<p>实现<strong>按下KEY1后蓝灯状态翻转</strong></p>\n<h4 id=\"在bsp_ledh中宏定义电平翻转函数\">在bsp_led.h中宏定义电平翻转函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_TOGGLE &#123;LED_B_GPIO_PORT-&gt;ODR ^= LED_B_GPIO_PIN;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">^= 异或运算 (a ^ b) 则ab不同为1，相同则为0</span></span><br><span class=\"line\"><span class=\"comment\">ODR低16位和GPIO_Pin_1作异或并重新赋值给ODR可实现ODR的Bit0翻转</span></span><br><span class=\"line\"><span class=\"comment\">若Bit0=1则Bit0 = 1 ^ 1 = 0, 下一次运算时, Bit0=0则Bit0 = 0^1 = 1</span></span><br><span class=\"line\"><span class=\"comment\">实际上是ODR的Bit0在和1进行异或操作</span></span><br><span class=\"line\"><span class=\"comment\">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_keyh中进行宏定义和函数声明\">在bsp_key.h中进行宏定义和函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_KEY_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_KEY_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY_ON 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY_OFF 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY1_GPIO_PIN GPIO_Pin_0 <span class=\"comment\">// stm32f10x_gpio.h中定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY1_GPIO_PORT GPIOA <span class=\"comment\">// stm32f10x.h中定义 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY1_GPIO_CLK RCC_APB2Periph_GPIOA</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">KEY_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">Key_Scan</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_KEY_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_keyc中写初始化函数和端口扫描函数\">在bsp_key.c中写初始化函数和端口扫描函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_key.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">KEY_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 端口扫面函数 检测按下返回1，否则返回0</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">Key_Scan</span><span class=\"params\">(GPIO_TypeDef* GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> KEY_ON;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KEY_OFF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中进行调用\">在main.c中进行调用</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LED_GPIO_Config();</span><br><span class=\"line\">    KEY_GPIO_Config();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            LED_B_TOGGLE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"补充:-c语言中的异或操作\">补充: C语言中的异或操作</h4>\n<p>在C语言中，异或运算是一种基本的位运算，使用符号 ^ 表示。<strong>异或运算符对两个操作数的对应位进行比较，如果两个相应的位不同，则结果为1，如果相同，则结果为0</strong>换句话说，它在以下情况下返回1：</p>\n<ul>\n<li>第一个操作数的位是0，第二个操作数的位是1。</li>\n<li>第一个操作数的位是1，第二个操作数的位是0。</li>\n</ul>\n<h5 id=\"c语言异或运算的特性\">C语言异或运算的特性</h5>\n<ul>\n<li>交换律：a ^ b 等于 b ^ a。</li>\n<li>结合律：(a ^ b) ^ c 等于 a ^ (b ^ c)。</li>\n<li>自反性：任何数与自身异或的结果都是0，即 a ^ a 等于 0。</li>\n<li>与0的异或：任何数与0异或都等于它本身，即 a ^ 0 等于 a。</li>\n</ul>\n<h5 id=\"c语言异或操作的应用\">C语言异或操作的应用</h5>\n<p>异或运算在C语言编程中有多种应用：</p>\n<p><strong>值交换</strong>：不使用临时变量交换两个变量的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a ^ b;</span><br><span class=\"line\">b = a ^ b;</span><br><span class=\"line\">a = a ^ b;</span><br></pre></td></tr></table></figure>\n<p>这种方法虽然巧妙，但<strong>在实际编程中不常用</strong>，因为如果 a 和 b 指向同一内存位置，这会导致结果为0。</p>\n<p><strong>反转特定位</strong>：可以使用异或运算来反转数值中的特定位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = x ^ (<span class=\"number\">1</span> &lt;&lt; n);  <span class=\"comment\">// 反转x的第n位</span></span><br></pre></td></tr></table></figure>\n<p><strong>检查奇偶性</strong>：通过检查数的最低位是否为1，可以使用异或运算来快速检查一个数是奇数还是偶数。</p>\n<p><strong>加密和解密</strong>：由于异或运算的自反性，它可以用于简单的加密和解密操作。</p>\n<h5 id=\"c语言异或操作的示例\">C语言异或操作的示例</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">5</span>;  <span class=\"comment\">// 二进制: 0101</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">3</span>;  <span class=\"comment\">// 二进制: 0011</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行异或运算</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> result = a ^ b;  <span class=\"comment\">// 结果是 6，二进制: 0110</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result = %d\\n&quot;</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，5（二进制0101）和3（二进制0011）进行异或运算的结果是6（二进制0110），因为每一位都被相应地比较并计算出结果。</p>\n<h2 id=\"位带操作\">位带操作</h2>\n<h3 id=\"位带简介\">位带简介</h3>\n<p>Cortex-M3微控制器，作为ARM的Cortex-M系列的一部分，提供了位带（Bit-banding）功能，<strong>这是一种允许对单个位进行原子读写操作的机制</strong>。这种功能在需要精确控制或原子性操作单个位的场合非常有用，例如在多任务环境中操作共享资源。</p>\n<p>在 CM3 中，有两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，<strong>它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个 32 位的字</strong>。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021935413.png\" alt=\"位带地址\"></p>\n<p>在CM3权威指南CnR2中<strong>支持位带操作的两个内存区的范围</strong>如下</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021941642.png\" alt=\"内存区范围\"></p>\n<h3 id=\"位带操作的原理\">位带操作的原理</h3>\n<p>位带操作在Cortex-M3中是<strong>通过将一个较大的地址空间（位带区域）映射到一个较小的地址空间（位带别名区域）来实现的</strong>。在Cortex-M3中，有两个主要的位带区域：</p>\n<ol>\n<li>SRAM位带区域：通常用于内存中的变量。</li>\n<li>外设位带区域：用于外设寄存器。</li>\n</ol>\n<p>每个位带区域的一个字（32位）对应主存储区的一个位。这意味着，通过写入位带区域的地址，你可以设置或清除主存储区相应位的值。</p>\n<h3 id=\"位带操作的地址映射\">位带操作的地址映射</h3>\n<p>位带操作的地址映射通常遵循以下规则：</p>\n<p>位带别名地址 = 位带基地址 + (字节偏移量 x 32) + (位编号 x 4)</p>\n<p>其中，<strong>字节偏移量是目标地址相对于位带区域基地址的偏移量</strong>，<strong>位编号是要操作的位</strong>。</p>\n<h3 id=\"位带操作的示例\">位带操作的示例</h3>\n<p>假设有一个外设寄存器的地址为 0x40000000，我们要设置这个寄存器的第2位。首先，我们需要计算这个位在位带别名区域中的地址。</p>\n<p>假设外设位带区域的基地址是 0x42000000，那么：</p>\n<ul>\n<li>字节偏移量 = 0x40000000 - 0x40000000 = 0x00000000</li>\n<li>位编号 = 2</li>\n<li>位带别名地址 = 0x42000000 + (0x00000000 x 32) + (2 x 4) = 0x42000008</li>\n</ul>\n<p>然后，你可以直接写入这个位带别名地址来设置或清除该位：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BITBAND_PERIPH(address, bit) ((void*)(0x42000000 + ((address) - 0x40000000) * 32 + (bit) * 4))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> *alias_address = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)BITBAND_PERIPH(<span class=\"number\">0x40000000</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">*alias_address = <span class=\"number\">1</span>;  <span class=\"comment\">// 设置第2位, 将第二位值设置为1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"位带操作的注意事项\">位带操作的注意事项</h3>\n<ul>\n<li>硬件支持：确保你的Cortex-M3微控制器支持位带操作。</li>\n<li>地址计算：正确的地址计算对于位带操作至关重要。</li>\n<li>原子操作：位带操作是原子的，这意味着在多任务或中断驱动的环境中，它们是安全的。</li>\n</ul>\n<h3 id=\"使用位带操作实现gpio的输出和输入\">使用位带操作实现GPIO的输出和输入</h3>\n<p>项目地址: <strong>14-位带操作-GPIO的输出和输入</strong></p>\n<p>使用位带操作实现GPIO输出: LED_B的闪烁</p>\n<h4 id=\"在mainc中添加位带操作的宏定义\">在main.c中添加位带操作的宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOB_ODR_Addr (GPIOB_BASE+0x0C)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PBout(n) *(unsigned int*)((GPIOB_ODR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOB_ODR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中使用位带操作点灯\">在main.c中使用位带操作点灯</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    PBout(<span class=\"number\">1</span>) = <span class=\"number\">1</span>;</span><br><span class=\"line\">    Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">    PBout(<span class=\"number\">1</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用位带操作实现GPIO输入: KEY1和KEY2控制LED_B状态翻转</p>\n<h4 id=\"在bsp_keyh中添加key2的宏定义\">在bsp_key.h中添加KEY2的宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY2_GPIO_PIN GPIO_Pin_13 <span class=\"comment\">// stm32f10x_gpio.h中定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY2_GPIO_PORT GPIOC <span class=\"comment\">// stm32f10x.h中定义 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> KEY2_GPIO_CLK RCC_APB2Periph_GPIOC</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bspc中增加key2的gpio初始化\">在bsp.c中增加KEY2的GPIO初始化</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">KEY_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// KEY1 初始化</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// KEY2 初始化</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(KEY2_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中添加gpio输入位带操作的宏定义\">在main.c中添加GPIO输入位带操作的宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOA_IDR_Addr (GPIOA_BASE+0x08)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GPIOC_IDR_Addr (GPIOC_BASE+0x08)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PAin(n) *(unsigned int*)((GPIOA_IDR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOA_IDR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PCin(n) *(unsigned int*)((GPIOC_IDR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOC_IDR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中测试led闪烁\">在main.c中测试LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(PAin(<span class=\"number\">0</span>) == KEY_ON)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 加入软件消抖后可正常运行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(PAin(<span class=\"number\">0</span>) == KEY_ON) <span class=\"comment\">// 等待按键释放</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LED_B_TOGGLE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(PCin(<span class=\"number\">13</span>) == KEY_ON)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Delay(<span class=\"number\">0xFFF</span>); <span class=\"comment\">// 加入软件消抖后可正常运行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(PCin(<span class=\"number\">13</span>) == KEY_ON) <span class=\"comment\">// 等待按键释放</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LED_B_TOGGLE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动文件详解\">启动文件详解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************</span><br><span class=\"line\">;* File Name          : startup_stm32f10x_hd.s</span><br><span class=\"line\">;* Author             : MCD Application Team</span><br><span class=\"line\">;* Version            : V3.5.0</span><br><span class=\"line\">;* Date               : 11-March-2011</span><br><span class=\"line\">;* Description        : STM32F10x High Density Devices vector table for MDK-ARM </span><br><span class=\"line\">;*                      toolchain. </span><br><span class=\"line\">;*                      This module performs:</span><br><span class=\"line\">;*                      - Set the initial SP </span><br><span class=\"line\">;                       初始化堆栈指针</span><br><span class=\"line\">;*                      - Set the initial PC == Reset_Handler </span><br><span class=\"line\">;                       初始化PC指针 == Reset_Handler程序</span><br><span class=\"line\">;*                      - Set the vector table entries with the exceptions ISR address </span><br><span class=\"line\">;                       初始化中断向量表</span><br><span class=\"line\">;*                      - Configure the clock system and also configure the external </span><br><span class=\"line\">;*                        SRAM mounted on STM3210E-EVAL board to be used as data </span><br><span class=\"line\">;*                        memory (optional, to be enabled by user) </span><br><span class=\"line\">;                       配置系统时钟</span><br><span class=\"line\">;*                      - Branches to __main in the C library (which eventually</span><br><span class=\"line\">;*                        calls main()). </span><br><span class=\"line\">;                       调用C库函数, 最终去到C的世界</span><br><span class=\"line\">;*                      After Reset the CortexM3 processor is in Thread mode,</span><br><span class=\"line\">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class=\"line\">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\">; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS</span><br><span class=\"line\">; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.</span><br><span class=\"line\">; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,</span><br><span class=\"line\">; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE</span><br><span class=\"line\">; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING</span><br><span class=\"line\">; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">;****************************************************************************</span><br><span class=\"line\">;* 1- 栈的配置</span><br><span class=\"line\">;****************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Amount of memory (in bytes) allocated for Stack</span><br><span class=\"line\">; Tailor this value to your application needs</span><br><span class=\"line\">; &lt;h&gt; Stack Configuration </span><br><span class=\"line\">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class=\"line\">; &lt;/h&gt;</span><br><span class=\"line\">; 配置栈: 用于变量存储(局部/全局), 函数调用</span><br><span class=\"line\"></span><br><span class=\"line\">Stack_Size      EQU     0x00000400 </span><br><span class=\"line\">; 宏定义的伪指令，相当于等于，类似与 C 中的 define。</span><br><span class=\"line\">; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小</span><br><span class=\"line\"></span><br><span class=\"line\">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class=\"line\">                ; 告诉汇编器汇编一个新的代码段或者数据段。</span><br><span class=\"line\">                ; STACK 表示段名，这个可以任意命名</span><br><span class=\"line\">                ; NOINIT 表示不初始化</span><br><span class=\"line\">                ; READWRITE 表示可读可写</span><br><span class=\"line\">                ; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐</span><br><span class=\"line\">Stack_Mem       SPACE   Stack_Size</span><br><span class=\"line\">__initial_sp</span><br><span class=\"line\">; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</span><br><span class=\"line\">; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</span><br><span class=\"line\">的。 </span><br><span class=\"line\">                                                  </span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 2-堆的配置</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;h&gt; Heap Configuration</span><br><span class=\"line\">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class=\"line\">; &lt;/h&gt;</span><br><span class=\"line\">; 配置堆: 主要用于动态内存的分配, 如malloc()函数</span><br><span class=\"line\"></span><br><span class=\"line\">Heap_Size       EQU     0x00000200</span><br><span class=\"line\">; 将0x00000200命名为Heap_Size, 0x00000200为512Type</span><br><span class=\"line\"></span><br><span class=\"line\">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class=\"line\">                ; 汇编数据段</span><br><span class=\"line\">                ; 名字叫HEAP</span><br><span class=\"line\">                ; 不初始化</span><br><span class=\"line\">                ; 可读可写</span><br><span class=\"line\">                ; 2^3即8字节对齐</span><br><span class=\"line\">__heap_base</span><br><span class=\"line\">Heap_Mem        SPACE   Heap_Size</span><br><span class=\"line\">__heap_limit</span><br><span class=\"line\">; __heap_base 表示对的起始地址</span><br><span class=\"line\">; SPACE 分配大小为Heap_Size即512字节的内存空间</span><br><span class=\"line\">; __heap_limit 表示堆的结束地址</span><br><span class=\"line\">; 堆是由低向高生长的，跟栈的生长方向相反。</span><br><span class=\"line\"></span><br><span class=\"line\">                PRESERVE8</span><br><span class=\"line\">                ; 指定当前文件的堆栈按照 8 字节对齐</span><br><span class=\"line\">                THUMB</span><br><span class=\"line\">                ; 表示后面指令兼容 THUMB 指令</span><br><span class=\"line\"></span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 3-初始化中断向量表</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Vector Table Mapped to Address 0 at Reset</span><br><span class=\"line\">                AREA    RESET, DATA, READONLY</span><br><span class=\"line\">                ; 区域名称为RESET</span><br><span class=\"line\">                ; 区域类型为DATA, 与CODE相对,后者用于包含可执行指令</span><br><span class=\"line\">                ; 区域属性为只读</span><br><span class=\"line\">                EXPORT  __Vectors</span><br><span class=\"line\">                EXPORT  __Vectors_End</span><br><span class=\"line\">                EXPORT  __Vectors_Size</span><br><span class=\"line\">                ; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用</span><br><span class=\"line\"></span><br><span class=\"line\">__Vectors       DCD     __initial_sp               ; Top of Stack ; 栈顶地址</span><br><span class=\"line\">                DCD     Reset_Handler              ; Reset Handler ; 复位程序地址</span><br><span class=\"line\">                DCD     NMI_Handler                ; NMI Handler</span><br><span class=\"line\">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class=\"line\">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class=\"line\">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class=\"line\">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class=\"line\">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class=\"line\">                DCD     0                          ; Reserved</span><br><span class=\"line\">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class=\"line\">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class=\"line\"></span><br><span class=\"line\">                ; External Interrupts</span><br><span class=\"line\">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class=\"line\">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect</span><br><span class=\"line\">                DCD     TAMPER_IRQHandler          ; Tamper</span><br><span class=\"line\">                DCD     RTC_IRQHandler             ; RTC</span><br><span class=\"line\">                DCD     FLASH_IRQHandler           ; Flash</span><br><span class=\"line\">                DCD     RCC_IRQHandler             ; RCC</span><br><span class=\"line\">                DCD     EXTI0_IRQHandler           ; EXTI Line 0</span><br><span class=\"line\">                DCD     EXTI1_IRQHandler           ; EXTI Line 1</span><br><span class=\"line\">                DCD     EXTI2_IRQHandler           ; EXTI Line 2</span><br><span class=\"line\">                DCD     EXTI3_IRQHandler           ; EXTI Line 3</span><br><span class=\"line\">                DCD     EXTI4_IRQHandler           ; EXTI Line 4</span><br><span class=\"line\">                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1</span><br><span class=\"line\">                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2</span><br><span class=\"line\">                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3</span><br><span class=\"line\">                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4</span><br><span class=\"line\">                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5</span><br><span class=\"line\">                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6</span><br><span class=\"line\">                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7</span><br><span class=\"line\">                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2</span><br><span class=\"line\">                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX</span><br><span class=\"line\">                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0</span><br><span class=\"line\">                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1</span><br><span class=\"line\">                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE</span><br><span class=\"line\">                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5</span><br><span class=\"line\">                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break</span><br><span class=\"line\">                DCD     TIM1_UP_IRQHandler         ; TIM1 Update</span><br><span class=\"line\">                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation</span><br><span class=\"line\">                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare</span><br><span class=\"line\">                DCD     TIM2_IRQHandler            ; TIM2</span><br><span class=\"line\">                DCD     TIM3_IRQHandler            ; TIM3</span><br><span class=\"line\">                DCD     TIM4_IRQHandler            ; TIM4</span><br><span class=\"line\">                DCD     I2C1_EV_IRQHandler         ; I2C1 Event</span><br><span class=\"line\">                DCD     I2C1_ER_IRQHandler         ; I2C1 Error</span><br><span class=\"line\">                DCD     I2C2_EV_IRQHandler         ; I2C2 Event</span><br><span class=\"line\">                DCD     I2C2_ER_IRQHandler         ; I2C2 Error</span><br><span class=\"line\">                DCD     SPI1_IRQHandler            ; SPI1</span><br><span class=\"line\">                DCD     SPI2_IRQHandler            ; SPI2</span><br><span class=\"line\">                DCD     USART1_IRQHandler          ; USART1</span><br><span class=\"line\">                DCD     USART2_IRQHandler          ; USART2</span><br><span class=\"line\">                DCD     USART3_IRQHandler          ; USART3</span><br><span class=\"line\">                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10</span><br><span class=\"line\">                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line</span><br><span class=\"line\">                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend</span><br><span class=\"line\">                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break</span><br><span class=\"line\">                DCD     TIM8_UP_IRQHandler         ; TIM8 Update</span><br><span class=\"line\">                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation</span><br><span class=\"line\">                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare</span><br><span class=\"line\">                DCD     ADC3_IRQHandler            ; ADC3</span><br><span class=\"line\">                DCD     FSMC_IRQHandler            ; FSMC</span><br><span class=\"line\">                DCD     SDIO_IRQHandler            ; SDIO</span><br><span class=\"line\">                DCD     TIM5_IRQHandler            ; TIM5</span><br><span class=\"line\">                DCD     SPI3_IRQHandler            ; SPI3</span><br><span class=\"line\">                DCD     UART4_IRQHandler           ; UART4</span><br><span class=\"line\">                DCD     UART5_IRQHandler           ; UART5</span><br><span class=\"line\">                DCD     TIM6_IRQHandler            ; TIM6</span><br><span class=\"line\">                DCD     TIM7_IRQHandler            ; TIM7</span><br><span class=\"line\">                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1</span><br><span class=\"line\">                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2</span><br><span class=\"line\">                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3</span><br><span class=\"line\">                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5</span><br><span class=\"line\">__Vectors_End</span><br><span class=\"line\">; _Vectors 为向量表起始地址，__Vectors_End 为向量表结束地址</span><br><span class=\"line\">; 向量表中，DCD 分配了一堆内存，并且以 ESR 的入口地址初始化它们 </span><br><span class=\"line\"></span><br><span class=\"line\">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class=\"line\">; 向量表的大小为结束地址减去起始地址</span><br><span class=\"line\"></span><br><span class=\"line\">                AREA    |.text|, CODE, READONLY</span><br><span class=\"line\">                ; 定义一个名称为.text 的代码段，只读</span><br><span class=\"line\">                </span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 4-复位程序</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Reset handler</span><br><span class=\"line\">Reset_Handler   PROC</span><br><span class=\"line\">                EXPORT  Reset_Handler             [WEAK]</span><br><span class=\"line\">                ; WEAK 表示弱定义, 如果在其他地方定义了Reset_Handler就使用其他地方的定义</span><br><span class=\"line\">                ; 可以理解为C++中的&quot;可以重载&quot;</span><br><span class=\"line\">                IMPORT  __main</span><br><span class=\"line\">                IMPORT  SystemInit</span><br><span class=\"line\">                ;表示 SystemInit和 __main 这两个函数均来自外部的文件</span><br><span class=\"line\"></span><br><span class=\"line\">                LDR     R0, =SystemInit</span><br><span class=\"line\">                ; 把SystemInit的地址加载到R0中</span><br><span class=\"line\">                BLX     R0               </span><br><span class=\"line\">                ; 跳转到R0执行, 执行完毕后返回</span><br><span class=\"line\">                LDR     R0, =__main</span><br><span class=\"line\">                ; 把__main的地址加载到R0中</span><br><span class=\"line\">                BX      R0</span><br><span class=\"line\">                ; 跳转到R0执行, 执行完毕后不返回</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">                </span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 5-中断服务函数</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class=\"line\">; 中断服务函数均跳转到无限循环</span><br><span class=\"line\">; 目的是用户在未定义中断服务函数的情况下调用可进入无限循环状态中(兜底作用)</span><br><span class=\"line\"></span><br><span class=\"line\">NMI_Handler     PROC</span><br><span class=\"line\">                EXPORT  NMI_Handler                [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ; B 表示跳转指令</span><br><span class=\"line\">                ; . 表示无限循环</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">HardFault_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  HardFault_Handler          [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">MemManage_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  MemManage_Handler          [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">BusFault_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  BusFault_Handler           [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">UsageFault_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  UsageFault_Handler         [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">SVC_Handler     PROC</span><br><span class=\"line\">                EXPORT  SVC_Handler                [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">DebugMon_Handler\\</span><br><span class=\"line\">                PROC</span><br><span class=\"line\">                EXPORT  DebugMon_Handler           [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">PendSV_Handler  PROC</span><br><span class=\"line\">                EXPORT  PendSV_Handler             [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\">SysTick_Handler PROC</span><br><span class=\"line\">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class=\"line\">                B       .</span><br><span class=\"line\">                ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">Default_Handler PROC</span><br><span class=\"line\"></span><br><span class=\"line\">                EXPORT  WWDG_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  PVD_IRQHandler             [WEAK]</span><br><span class=\"line\">                EXPORT  TAMPER_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  RTC_IRQHandler             [WEAK]</span><br><span class=\"line\">                EXPORT  FLASH_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  RCC_IRQHandler             [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI0_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI1_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI2_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI3_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI4_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  ADC1_2_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]</span><br><span class=\"line\">                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]</span><br><span class=\"line\">                EXPORT  CAN1_RX1_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  CAN1_SCE_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI9_5_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_BRK_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_UP_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]</span><br><span class=\"line\">                EXPORT  TIM1_CC_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM2_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM3_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM4_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  I2C1_EV_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  I2C1_ER_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  I2C2_EV_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  I2C2_ER_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  SPI1_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  SPI2_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  USART1_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  USART2_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  USART3_IRQHandler          [WEAK]</span><br><span class=\"line\">                EXPORT  EXTI15_10_IRQHandler       [WEAK]</span><br><span class=\"line\">                EXPORT  RTCAlarm_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  USBWakeUp_IRQHandler       [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_BRK_IRQHandler        [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_UP_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]</span><br><span class=\"line\">                EXPORT  TIM8_CC_IRQHandler         [WEAK]</span><br><span class=\"line\">                EXPORT  ADC3_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  FSMC_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  SDIO_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM5_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  SPI3_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  UART4_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  UART5_IRQHandler           [WEAK]</span><br><span class=\"line\">                EXPORT  TIM6_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  TIM7_IRQHandler            [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]</span><br><span class=\"line\">                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]</span><br><span class=\"line\"></span><br><span class=\"line\">WWDG_IRQHandler</span><br><span class=\"line\">PVD_IRQHandler</span><br><span class=\"line\">TAMPER_IRQHandler</span><br><span class=\"line\">RTC_IRQHandler</span><br><span class=\"line\">FLASH_IRQHandler</span><br><span class=\"line\">RCC_IRQHandler</span><br><span class=\"line\">EXTI0_IRQHandler</span><br><span class=\"line\">EXTI1_IRQHandler</span><br><span class=\"line\">EXTI2_IRQHandler</span><br><span class=\"line\">EXTI3_IRQHandler</span><br><span class=\"line\">EXTI4_IRQHandler</span><br><span class=\"line\">DMA1_Channel1_IRQHandler</span><br><span class=\"line\">DMA1_Channel2_IRQHandler</span><br><span class=\"line\">DMA1_Channel3_IRQHandler</span><br><span class=\"line\">DMA1_Channel4_IRQHandler</span><br><span class=\"line\">DMA1_Channel5_IRQHandler</span><br><span class=\"line\">DMA1_Channel6_IRQHandler</span><br><span class=\"line\">DMA1_Channel7_IRQHandler</span><br><span class=\"line\">ADC1_2_IRQHandler</span><br><span class=\"line\">USB_HP_CAN1_TX_IRQHandler</span><br><span class=\"line\">USB_LP_CAN1_RX0_IRQHandler</span><br><span class=\"line\">CAN1_RX1_IRQHandler</span><br><span class=\"line\">CAN1_SCE_IRQHandler</span><br><span class=\"line\">EXTI9_5_IRQHandler</span><br><span class=\"line\">TIM1_BRK_IRQHandler</span><br><span class=\"line\">TIM1_UP_IRQHandler</span><br><span class=\"line\">TIM1_TRG_COM_IRQHandler</span><br><span class=\"line\">TIM1_CC_IRQHandler</span><br><span class=\"line\">TIM2_IRQHandler</span><br><span class=\"line\">TIM3_IRQHandler</span><br><span class=\"line\">TIM4_IRQHandler</span><br><span class=\"line\">I2C1_EV_IRQHandler</span><br><span class=\"line\">I2C1_ER_IRQHandler</span><br><span class=\"line\">I2C2_EV_IRQHandler</span><br><span class=\"line\">I2C2_ER_IRQHandler</span><br><span class=\"line\">SPI1_IRQHandler</span><br><span class=\"line\">SPI2_IRQHandler</span><br><span class=\"line\">USART1_IRQHandler</span><br><span class=\"line\">USART2_IRQHandler</span><br><span class=\"line\">USART3_IRQHandler</span><br><span class=\"line\">EXTI15_10_IRQHandler</span><br><span class=\"line\">RTCAlarm_IRQHandler</span><br><span class=\"line\">USBWakeUp_IRQHandler</span><br><span class=\"line\">TIM8_BRK_IRQHandler</span><br><span class=\"line\">TIM8_UP_IRQHandler</span><br><span class=\"line\">TIM8_TRG_COM_IRQHandler</span><br><span class=\"line\">TIM8_CC_IRQHandler</span><br><span class=\"line\">ADC3_IRQHandler</span><br><span class=\"line\">FSMC_IRQHandler</span><br><span class=\"line\">SDIO_IRQHandler</span><br><span class=\"line\">TIM5_IRQHandler</span><br><span class=\"line\">SPI3_IRQHandler</span><br><span class=\"line\">UART4_IRQHandler</span><br><span class=\"line\">UART5_IRQHandler</span><br><span class=\"line\">TIM6_IRQHandler</span><br><span class=\"line\">TIM7_IRQHandler</span><br><span class=\"line\">DMA2_Channel1_IRQHandler</span><br><span class=\"line\">DMA2_Channel2_IRQHandler</span><br><span class=\"line\">DMA2_Channel3_IRQHandler</span><br><span class=\"line\">DMA2_Channel4_5_IRQHandler</span><br><span class=\"line\">                B       .</span><br><span class=\"line\"></span><br><span class=\"line\">                ENDP</span><br><span class=\"line\"></span><br><span class=\"line\">                ALIGN</span><br><span class=\"line\">                ; ALIGN 表示4字节对齐(参数缺省时)</span><br><span class=\"line\"></span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\">;* 6-堆栈的初始化, 由C库函数__main实现</span><br><span class=\"line\">;****************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\">; User Stack and Heap initialization</span><br><span class=\"line\">;*******************************************************************************</span><br><span class=\"line\">                 IF      :DEF:__MICROLIB ; __MICROLIB在ide里定义, 在Keil5 MDK中勾选Use MicroLIB选项</span><br><span class=\"line\">                </span><br><span class=\"line\">                 EXPORT  __initial_sp</span><br><span class=\"line\">                 EXPORT  __heap_base</span><br><span class=\"line\">                 EXPORT  __heap_limit</span><br><span class=\"line\">                </span><br><span class=\"line\">                 ELSE</span><br><span class=\"line\">                </span><br><span class=\"line\">                 IMPORT  __use_two_region_memory ; 如果__MICROLIB未定义, 则由用户自己实现</span><br><span class=\"line\">                 EXPORT  __user_initial_stackheap</span><br><span class=\"line\">                 </span><br><span class=\"line\">__user_initial_stackheap</span><br><span class=\"line\"></span><br><span class=\"line\">                 LDR     R0, =  Heap_Mem</span><br><span class=\"line\">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class=\"line\">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class=\"line\">                 LDR     R3, = Stack_Mem</span><br><span class=\"line\">                 BX      LR</span><br><span class=\"line\"></span><br><span class=\"line\">                 ALIGN</span><br><span class=\"line\"></span><br><span class=\"line\">                 ENDIF</span><br><span class=\"line\"></span><br><span class=\"line\">                 END</span><br><span class=\"line\"></span><br><span class=\"line\">;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"equ指令\">EQU指令</h3>\n<p>作用: The EQU directive is a register-relative address, a PC-relative address, an absolute address, or a 32-bit integer constant. // 为数值常量、寄存器相对值或 PC 相对值提供符号名称。(<em>可以理解为重命名</em>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack_Size      EQU     0x00000400 </span><br><span class=\"line\">; 宏定义的伪指令，相当于等于，类似与 C 中的 define。</span><br><span class=\"line\">; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小</span><br></pre></td></tr></table></figure>\n<h4 id=\"equ手册说明\">EQU手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031428875.png\" alt=\"EQU指令\"></p>\n<h3 id=\"area指令\">AREA指令</h3>\n<p>AREA: 汇编一个新的代码段或数据段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class=\"line\">; 告诉汇编器汇编一个新的代码段或者数据段。</span><br><span class=\"line\">; STACK 表示段名，这个可以任意命名</span><br><span class=\"line\">; NOINIT 表示不初始化</span><br><span class=\"line\">; READWRITE 表示可读可写</span><br><span class=\"line\">; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐</span><br></pre></td></tr></table></figure>\n<h4 id=\"area手册说明\">AREA手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031529274.png\" alt=\"AREA\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530123.png\" alt=\"AREA\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530696.png\" alt=\"AREA\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031531689.png\" alt=\"AREA\"></p>\n<h3 id=\"space指令\">SPACE指令</h3>\n<p>SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size, 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack_Mem       SPACE   Stack_Size</span><br><span class=\"line\">; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</span><br><span class=\"line\">__initial_sp</span><br><span class=\"line\">; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</span><br></pre></td></tr></table></figure>\n<h4 id=\"space手册说明\">SPACE手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031539781.png\" alt=\"SPACE\"></p>\n<h3 id=\"preserve8指令\">PRESERVE8指令</h3>\n<p>PRESERVE8：指定当前文件的堆栈按照 8 字节对齐</p>\n<h4 id=\"preserve8手册说明\">PRESERVE8手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031556307.png\" alt=\"PRESERVE8\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031557775.png\" alt=\"PRESERVE8\"></p>\n<h3 id=\"thumb指令\">THUMB指令</h3>\n<p>野火的解释: <strong>THUMB：表示后面指令兼容 THUMB 指令。THUBM 是 ARM 以前的指令集，16bit，现在 Cortex-M系列的都使用 THUMB-2 指令集，THUMB-2 是 32 位的，兼容 16 位和 32 位的指令，是 THUMB的超集</strong></p>\n<h4 id=\"thumb手册说明\">THUMB手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031600256.png\" alt=\"THUMB\"></p>\n<h3 id=\"export指令\">EXPORT指令</h3>\n<p>EXPORT：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 IAR 编译器，则使用的是 GLOBAL 这个指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPORT  __Vectors</span><br><span class=\"line\">EXPORT  __Vectors_End</span><br><span class=\"line\">EXPORT  __Vectors_Size</span><br><span class=\"line\">; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用</span><br></pre></td></tr></table></figure>\n<h4 id=\"export手册说明\">EXPORT手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031623174.png\" alt=\"EXPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624509.png\" alt=\"EXPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624882.png\" alt=\"EXPORT\"></p>\n<h3 id=\"dcd指令\">DCD指令</h3>\n<p>DCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存</p>\n<h4 id=\"dcd手册说明\">DCD手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032016385.png\" alt=\"DCD\"></p>\n<h3 id=\"proc指令\">PROC指令</h3>\n<p>PROC: 定义子程序, 与ENDP成对使用, 表示子程序结束</p>\n<h4 id=\"proc手册说明\">PROC手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032025440.png\" alt=\"PROC\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032026200.png\" alt=\"PROC\"></p>\n<h3 id=\"import指令\">IMPORT指令</h3>\n<p>IMPORT：表示该标号来自外部文件，跟 C 语言中的 EXTERN 关键字类似</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IMPORT  __main</span><br><span class=\"line\">IMPORT  SystemInit</span><br><span class=\"line\">;表示 SystemInit和 __main 这两个函数均来自外部的文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"import手册说明\">IMPORT手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034894.png\" alt=\"IMPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034604.png\" alt=\"IMPORT\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032035341.png\" alt=\"IMPORT\"></p>\n<h3 id=\"ldr指令\">LDR指令</h3>\n<p>LDR: 从存储器中加载字到一个寄存器中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDR     R0, =SystemInit</span><br><span class=\"line\">; 把SystemInit的地址加载到R0中</span><br><span class=\"line\">BLX     R0               </span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后返回</span><br><span class=\"line\">LDR     R0, =__main</span><br><span class=\"line\">; 把__main的地址加载到R0中</span><br><span class=\"line\">BX      R0</span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后不返回</span><br></pre></td></tr></table></figure>\n<h4 id=\"ldr手册说明\">LDR手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046548.png\" alt=\"LDR\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046349.png\" alt=\"LDR\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032047305.png\" alt=\"LDR\"></p>\n<h3 id=\"blx指令\">BLX指令</h3>\n<p>BLX: 跳转到由寄存器给出的地址, 并根据寄存器的LSE确定处理器的状态, 还要把跳转前的下条指令地址保存到LR</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BLX     R0               </span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后返回</span><br></pre></td></tr></table></figure>\n<h3 id=\"bx指令\">BX指令</h3>\n<p>BX: 跳转到由寄存器/标号给出的地址, 不用返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BX      R0</span><br><span class=\"line\">; 跳转到R0执行, 执行完毕后不返回</span><br></pre></td></tr></table></figure>\n<h3 id=\"align指令\">ALIGN指令</h3>\n<p>ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐</p>\n<h4 id=\"align手册说明\">ALIGN手册说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103293.png\" alt=\"ALIGN\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103739.png\" alt=\"ALIGN\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103256.png\" alt=\"ALIGN\"></p>\n<h2 id=\"时钟\">时钟</h2>\n<h3 id=\"时钟系统框图\">时钟系统框图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2009.47.02.png\" alt=\"时钟系统框图\"></p>\n<h4 id=\"sysclk系统时钟源选择\">SYSCLK系统时钟源选择</h4>\n<ul>\n<li>HSI_RC: 高速内部时钟, RC 震荡产生(频率约为 8MHz)</li>\n<li>HSE: 高速外部时钟,通过外接晶振产生(频率范围: 4-16MHz)</li>\n<li>PLL: 锁相环,倍频到72MHz</li>\n</ul>\n<h5 id=\"sysclk-系统时钟的选择\">SYSCLK 系统时钟的选择</h5>\n<ol>\n<li>HSI_RC 约 8MHz</li>\n<li>PLLCLK 倍频至72MHz</li>\n<li>HSE_Osc直接使用</li>\n</ol>\n<h5 id=\"pll锁相环的选择\">PLL锁相环的选择</h5>\n<ol>\n<li>HSI_RC 两分频后</li>\n<li>HSE_Osc or HSE_Osc二分频后</li>\n</ol>\n<p>CSS: 时钟监视系统, 监视 HSE_Osc 是否正常工作,若 外部时钟源异常则将 SYSCLK 切换为 HSI_RC</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.03.07.png\" alt=\"时钟系统框图\"></p>\n<h4 id=\"rtcclk时钟源选择\">RTCCLK时钟源选择</h4>\n<ul>\n<li>LSE_Osc: 低速外部时钟源, 频率为36.768KHz</li>\n<li>LSI_RC: 低速内部时钟源, 频率约为40KHz, 由 RC 震荡产生</li>\n</ul>\n<h5 id=\"rtc_clk(rtc-时钟)的选择\">RTC_CLK(RTC 时钟)的选择</h5>\n<ol>\n<li>HSE_Osc 128 分频后</li>\n<li>LSE_Osc</li>\n<li>LSI_RC</li>\n</ol>\n<h4 id=\"iwdgclk独立看门狗时钟源\">IWDGCLK独立看门狗时钟源</h4>\n<p>IWDGCLK独立看门狗时钟源由LSI_RC 提供</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401291156077.png\" alt=\"IWDGCLK独立看门狗时钟源\"></p>\n<h4 id=\"mco-的选择\">MCO 的选择</h4>\n<p>MCO是一个引脚来输出内部时钟</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.13.53.png\" alt=\"系统时钟框图\"></p>\n<ol>\n<li>SYSCLK</li>\n<li>HSI</li>\n<li>HSE</li>\n<li>PLLCLK 二分频</li>\n</ol>\n<h4 id=\"各类总线时钟\">各类总线时钟</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.26.21.png\" alt=\"时钟系统框图\"></p>\n<ol>\n<li>USBCLK_48MHz (USB 时钟): 由 PLLCLK经USB_Prescaler预分频至 48MHz</li>\n<li>HCLK: SYSCLK-&gt;AHB_Prescaler 最高 72MHz</li>\n<li>PCLK1: SYSCLK-&gt;AHB_Prescaler-&gt;APB1_Prescaler 最高36MHz</li>\n<li>TIMxCLK(通用定时器时钟): SYSCLK-&gt;AHB_Prescaler-&gt;APB1_Prescaler-&gt;TIM2,3,4_Multiplier</li>\n<li>PCKL2: SYSCLK-&gt;AHB_Prescaler-&gt;APB2_Prescaler 最高72MHz</li>\n<li>TIM1CLK(TIM1 时钟): SYSCLK-&gt;AHB_Prescal-&gt;APB2_Prescaler-&gt;TIM1_Multiplier</li>\n<li>ADCCLK(ADC 时钟): SYSCLK-&gt;AHB_Prescaler-&gt;APB2_Prescaler-&gt;ADC_Prescaler</li>\n</ol>\n<h4 id=\"总结\">总结</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2011.09.39.png\" alt=\"知识总结\"></p>\n<h3 id=\"系统时钟配置函数-setsysclockto72()分析\">系统时钟配置函数 SetSysClockTo72()分析</h3>\n<p>在启动文件startup_stm32f10x_hd.s中执行SystemInit函数, 如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; Reset handler</span><br><span class=\"line\">Reset_Handler   PROC</span><br><span class=\"line\">                EXPORT  Reset_Handler             [WEAK]</span><br><span class=\"line\">                IMPORT  __main</span><br><span class=\"line\">                IMPORT  SystemInit</span><br><span class=\"line\">                LDR     R0, =SystemInit</span><br><span class=\"line\">                BLX     R0               </span><br><span class=\"line\">                LDR     R0, =__main</span><br><span class=\"line\">                BX      R0</span><br><span class=\"line\">                ENDP</span><br></pre></td></tr></table></figure>\n<p>在system_stm32f10x.c文件中调用SystemInit函数, SystemInit函数在末尾调用SetSysClock()函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SystemInit</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Reset the RCC clock configuration to the default reset state(for debug purpose) */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Set HSION bit */</span></span><br><span class=\"line\">  RCC-&gt;CR |= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x00000001</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> STM32F10X_CL</span></span><br><span class=\"line\">  RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xF8FF0000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xF0FF0000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* STM32F10X_CL */</span>   </span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Reset HSEON, CSSON and PLLON bits */</span></span><br><span class=\"line\">  RCC-&gt;CR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xFEF6FFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset HSEBYP bit */</span></span><br><span class=\"line\">  RCC-&gt;CR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xFFFBFFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span></span><br><span class=\"line\">  RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xFF80FFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> STM32F10X_CL</span></span><br><span class=\"line\">  <span class=\"comment\">/* Reset PLL2ON and PLL3ON bits */</span></span><br><span class=\"line\">  RCC-&gt;CR &amp;= (<span class=\"type\">uint32_t</span>)<span class=\"number\">0xEBFFFFFF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Disable all interrupts and clear pending bits  */</span></span><br><span class=\"line\">  RCC-&gt;CIR = <span class=\"number\">0x00FF0000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset CFGR2 register */</span></span><br><span class=\"line\">  RCC-&gt;CFGR2 = <span class=\"number\">0x00000000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class=\"line\">  <span class=\"comment\">/* Disable all interrupts and clear pending bits  */</span></span><br><span class=\"line\">  RCC-&gt;CIR = <span class=\"number\">0x009F0000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Reset CFGR2 register */</span></span><br><span class=\"line\">  RCC-&gt;CFGR2 = <span class=\"number\">0x00000000</span>;      </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"comment\">/* Disable all interrupts and clear pending bits  */</span></span><br><span class=\"line\">  RCC-&gt;CIR = <span class=\"number\">0x009F0000</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* STM32F10X_CL */</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)</span></span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> DATA_IN_ExtSRAM</span></span><br><span class=\"line\">    SystemInit_ExtMemCtl(); </span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* DATA_IN_ExtSRAM */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Configure the Flash Latency cycles and enable prefetch buffer */</span></span><br><span class=\"line\">  SetSysClock(); <span class=\"comment\">// 末尾调用SetSysClock()函数 </span></span><br></pre></td></tr></table></figure>\n<p>调用system_stm32f10x.c中SetSysClock()</p>\n<p>默认情况下定义SYSCLK_FREQ_72MHz宏, 调用SetSysClockTo72()函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  None</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">SetSysClock</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SYSCLK_FREQ_HSE</span></span><br><span class=\"line\">  SetSysClockToHSE();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_24MHz</span></span><br><span class=\"line\">  SetSysClockTo24();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_36MHz</span></span><br><span class=\"line\">  SetSysClockTo36();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_48MHz</span></span><br><span class=\"line\">  SetSysClockTo48();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_56MHz</span></span><br><span class=\"line\">  SetSysClockTo56();  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class=\"line\">  SetSysClockTo72();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/* If none of the define above is enabled, the HSI is used as System clock</span></span><br><span class=\"line\"><span class=\"comment\">    source (default after reset) */</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在system_stm32f10x.c中宏定义, 默认宏定义SYSTEMCLK_FREQ_72MHz</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_HSE    HSE_VALUE */</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> SYSCLK_FREQ_24MHz  24000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_HSE    HSE_VALUE */</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_24MHz  24000000 */</span> </span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_36MHz  36000000 */</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_48MHz  48000000 */</span></span><br><span class=\"line\"><span class=\"comment\">/* #define SYSCLK_FREQ_56MHz  56000000 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SYSCLK_FREQ_72MHz  72000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>在system_stem32f10x.c中定义SetSysClockTo72()函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 </span></span><br><span class=\"line\"><span class=\"comment\">  *         and PCLK1 prescalers. </span></span><br><span class=\"line\"><span class=\"comment\">  * @note   This function should be used only after reset.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  None</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">SetSysClockTo72</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> StartUpCounter = <span class=\"number\">0</span>, HSEStatus = <span class=\"number\">0</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/</span>    </span><br><span class=\"line\">  <span class=\"comment\">/* Enable HSE */</span>    </span><br><span class=\"line\">  <span class=\"comment\">// 使能HSE</span></span><br><span class=\"line\">  RCC-&gt;CR |= ((<span class=\"type\">uint32_t</span>)RCC_CR_HSEON);</span><br><span class=\"line\">  </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class=\"line\">  <span class=\"comment\">// 等待 HSE 就绪并作超时处理</span></span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class=\"line\">    StartUpCounter++;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span>((HSEStatus == <span class=\"number\">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    HSEStatus = (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    HSEStatus = (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x00</span>;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果 HSE启动成功, 程序则继续往下执行</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (HSEStatus == (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x01</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Enable Prefetch Buffer */</span></span><br><span class=\"line\">    <span class=\"comment\">// 启用 Flsh  预取缓冲区</span></span><br><span class=\"line\">    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Flash 2 wait state */</span></span><br><span class=\"line\">    <span class=\"comment\">// flash 时延两个等待状态</span></span><br><span class=\"line\">    FLASH-&gt;ACR &amp;= (<span class=\"type\">uint32_t</span>)((<span class=\"type\">uint32_t</span>)~FLASH_ACR_LATENCY);</span><br><span class=\"line\">    FLASH-&gt;ACR |= (<span class=\"type\">uint32_t</span>)FLASH_ACR_LATENCY_2;    </span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/* HCLK = SYSCLK */</span></span><br><span class=\"line\">    <span class=\"comment\">// 72MHz</span></span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_HPRE_DIV1;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/* PCLK2 = HCLK */</span></span><br><span class=\"line\">    <span class=\"comment\">// 72MHz</span></span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_PPRE2_DIV1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* PCLK1 = HCLK */</span></span><br><span class=\"line\">    <span class=\"comment\">// 36MHz</span></span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 互联型芯片 F105, F107 以下代码不进行分析</span></span><br><span class=\"line\"><span class=\"comment\"> *---------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**********************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> STM32F10X_CL</span></span><br><span class=\"line\">    <span class=\"comment\">/* Configure PLLs ------------------------------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */</span></span><br><span class=\"line\">    <span class=\"comment\">/* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    RCC-&gt;CFGR2 &amp;= (<span class=\"type\">uint32_t</span>)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |</span><br><span class=\"line\">                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);</span><br><span class=\"line\">    RCC-&gt;CFGR2 |= (<span class=\"type\">uint32_t</span>)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |</span><br><span class=\"line\">                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* Enable PLL2 */</span></span><br><span class=\"line\">    RCC-&gt;CR |= RCC_CR_PLL2ON;</span><br><span class=\"line\">    <span class=\"comment\">/* Wait till PLL2 is ready */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */</span> </span><br><span class=\"line\">    <span class=\"comment\">// 锁相环配置</span></span><br><span class=\"line\">    RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);</span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | </span><br><span class=\"line\">                            RCC_CFGR_PLLMULL9); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span>    </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Enable PLL */</span></span><br><span class=\"line\">    <span class=\"comment\">// 使能 PLL</span></span><br><span class=\"line\">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Wait till PLL is ready */</span></span><br><span class=\"line\">    <span class=\"comment\">//  等待 PLL 稳定</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* Select PLL as system clock source */</span></span><br><span class=\"line\">    <span class=\"comment\">// 选择 PLLCLK 作为系统时钟</span></span><br><span class=\"line\">    RCC-&gt;CFGR &amp;= (<span class=\"type\">uint32_t</span>)((<span class=\"type\">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class=\"line\">    RCC-&gt;CFGR |= (<span class=\"type\">uint32_t</span>)RCC_CFGR_SW_PLL;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Wait till PLL is used as system clock source */</span></span><br><span class=\"line\">    <span class=\"comment\">// 等待 PLLCLK 切换为系统时钟</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((RCC-&gt;CFGR &amp; (<span class=\"type\">uint32_t</span>)RCC_CFGR_SWS) != (<span class=\"type\">uint32_t</span>)<span class=\"number\">0x08</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123; <span class=\"comment\">/* If HSE fails to start-up, the application will have wrong clock </span></span><br><span class=\"line\"><span class=\"comment\">         configuration. User can add here some code to deal with this error */</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 HSE 启动失败,用户可以在这里添加处理错误的代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hse配置系统时钟\">HSE配置系统时钟</h3>\n<p>项目地址: <strong>16-使用HSE配置系统时钟并使用MCO输出监控系统时钟</strong></p>\n<h4 id=\"在bsp_rccclkconfigc中写入hse的配置函数\">在bsp_rccclkconfig.c中写入HSE的配置函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 设置系统时钟为外部高速晶振（HSE）时钟，并配置PLL倍频系数。</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param RCC_PLLMul_x PLL倍频系数，范围为2-16。</span></span><br><span class=\"line\"><span class=\"comment\"> * @note 该函数会将RCC模块复位，并使能HSE。如果HSE启动成功，则设置FLASH预取指令使能、FLASH等待周期、AHB总线时钟、APB1总线时钟、APB2总线时钟、PLL倍频系数，并等待PLL稳定后将系统时钟设置为PLL时钟。</span></span><br><span class=\"line\"><span class=\"comment\"> *       如果HSE启动失败，则用户可以在函数中添加处理错误的代码。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSE_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RCC_DeInit(); <span class=\"comment\">// RCC复位</span></span><br><span class=\"line\">    ErrorStatus HSEStatus;</span><br><span class=\"line\">    RCC_HSEConfig(RCC_HSE_ON); <span class=\"comment\">// 使能HSE</span></span><br><span class=\"line\">    HSEStatus = RCC_WaitForHSEStartUp(); <span class=\"comment\">// 获取HSE启动状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(HSEStatus == SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class=\"comment\">// 使能预取指</span></span><br><span class=\"line\">        FLASH_SetLatency(FLASH_ACR_LATENCY_2); <span class=\"comment\">// 设置等待</span></span><br><span class=\"line\">        RCC_HCLKConfig(RCC_SYSCLK_Div1); <span class=\"comment\">//HCLK = SYSCLK = 72MHz</span></span><br><span class=\"line\">        RCC_PCLK1Config(RCC_SYSCLK_Div2); <span class=\"comment\">//PCLK1 = HCLK / 2 = 36MHz</span></span><br><span class=\"line\">        RCC_PCLK2Config(RCC_SYSCLK_Div1); <span class=\"comment\">//PCLK2 = HCLK / 1 = 72MHz</span></span><br><span class=\"line\">        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_x); <span class=\"comment\">// RCC_RLLMul_x 用来超频 频率:(8*x)MHz</span></span><br><span class=\"line\">        RCC_PLLCmd(ENABLE); <span class=\"comment\">// 使能PLL</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待PLL稳定</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); <span class=\"comment\">// 设置系统时钟为PLL时钟</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetSYSCLKSource() != <span class=\"number\">0x08</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待设置系统时钟</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果HSE启动失败, 用户在此添加处理错误代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_rccclkconfigc中编写mco的gpio初始化函数\">在bsp_rccclkconfig.c中编写MCO的GPIO初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Configures the GPIO for MCO (Microcontroller Clock Output).</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This function initializes the GPIO pin for MCO and configures it as an alternate function push-pull output.</span></span><br><span class=\"line\"><span class=\"comment\"> * The GPIO pin used for MCO is GPIOA Pin 8.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @return None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MCO_GPIO_Config</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// MCO的GPIO初始化</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_rccclkconfigh中添加函数声明\">在bsp_rccclkconfig.h中添加函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_RCCCLKCONFIG_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_RCCCLKCONFIG_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSE_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MCO_GPIO_Config</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_RCCCLKCONFIG_H</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用hse配置系统时钟函数和mco的gpio初始化函数\">在main.c中调用HSE配置系统时钟函数和MCO的GPIO初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_rccclkconfig.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延时函数Delay()</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay</span><span class=\"params\">(<span class=\"type\">uint32_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; count != <span class=\"number\">0</span>; count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">0x2AFF</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HSE_SetSysClk(RCC_PLLMul_9); <span class=\"comment\">// 72MHz</span></span><br><span class=\"line\">    <span class=\"comment\">// HSE_SetSysClk(RCC_PLLMul_16); // 128MHz</span></span><br><span class=\"line\">    MCO_GPIO_Config();</span><br><span class=\"line\">    RCC_MCOConfig(RCC_MCO_SYSCLK); <span class=\"comment\">// 配置MCO选择系统时钟</span></span><br><span class=\"line\">    LED_GPIO_Config();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_B(OFF);</span><br><span class=\"line\">        Delay(<span class=\"number\">50</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">        LED_B(ON);</span><br><span class=\"line\">        Delay(<span class=\"number\">50</span>); <span class=\"comment\">// 延时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用hsi配置系统时钟并用mco监控系统时钟\">使用HSI配置系统时钟并用MCO监控系统时钟</h3>\n<p>项目地址: <strong>16-使用HSI配置系统时钟并用MCO监控系统时钟</strong></p>\n<h4 id=\"在bsp_rccclkconfigc中编写hsi配置系统时钟函数\">在bsp_rccclkconfig.c中编写HSI配置系统时钟函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 设置系统时钟为HSI，并配置PLL倍频系数</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param RCC_PLLMul_x PLL倍频系数，范围为2-16</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @note 该函数将系统时钟设置为HSI，并根据传入的PLL倍频系数配置PLL，以实现超频功能。</span></span><br><span class=\"line\"><span class=\"comment\"> *       如果HSI启动失败，用户可以在函数的else分支中添加处理错误的代码。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSI_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Function implementation</span></span><br><span class=\"line\">    __IO <span class=\"type\">uint32_t</span> HSIStatus = <span class=\"number\">0</span>; <span class=\"comment\">// 参考固件库源码</span></span><br><span class=\"line\">    RCC_DeInit(); <span class=\"comment\">// RCC复位</span></span><br><span class=\"line\">    RCC_HSICmd(ENABLE); <span class=\"comment\">// 使能HSI</span></span><br><span class=\"line\">    HSIStatus = RCC-&gt;CR &amp; RCC_CR_HSIRDY; <span class=\"comment\">// 获取HSI启动状态, 参考固件库源码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(HSIStatus == RCC_CR_HSIRDY)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class=\"comment\">// 使能预取指</span></span><br><span class=\"line\">        FLASH_SetLatency(FLASH_ACR_LATENCY_2); <span class=\"comment\">// 设置等待</span></span><br><span class=\"line\">        RCC_HCLKConfig(RCC_SYSCLK_Div1); <span class=\"comment\">//HCLK = SYSCLK = 72MHz</span></span><br><span class=\"line\">        RCC_PCLK1Config(RCC_SYSCLK_Div2); <span class=\"comment\">//PCLK1 = HCLK / 2 = 36MHz</span></span><br><span class=\"line\">        RCC_PCLK2Config(RCC_SYSCLK_Div1); <span class=\"comment\">//PCLK2 = HCLK / 1 = 72MHz</span></span><br><span class=\"line\">        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_x); <span class=\"comment\">// RCC_RLLMul_x 用来超频 频率:(8*x)MHz</span></span><br><span class=\"line\">        RCC_PLLCmd(ENABLE); <span class=\"comment\">// 使能PLL</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待PLL稳定</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); <span class=\"comment\">// 设置系统时钟为PLL时钟</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(RCC_GetSYSCLKSource() != <span class=\"number\">0x08</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待设置系统时钟</span></span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果HSI启动失败, 用户在此添加处理错误代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_rccclkconfigh中加入函数声明\">在bsp_rccclkconfig.h中加入函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HSI_SetSysClk</span><span class=\"params\">(<span class=\"type\">uint32_t</span> RCC_PLLMul_x)</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用hsi配置系统时钟函数\">在main.c中调用HSI配置系统时钟函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSI_SetSysClk(RCC_PLLMul_12); <span class=\"comment\">// 4*12=48MHz</span></span><br><span class=\"line\">MCO_GPIO_Config();</span><br><span class=\"line\">RCC_MCOConfig(RCC_MCO_SYSCLK); <span class=\"comment\">// 配置MCO选择系统时钟</span></span><br><span class=\"line\">LED_GPIO_Config();</span><br></pre></td></tr></table></figure>\n<h2 id=\"中断\">中断</h2>\n<h3 id=\"stm32中断应用概览\">STM32中断应用概览</h3>\n<h4 id=\"中断类型\">中断类型</h4>\n<ul>\n<li>系统异常: 体现在内核水平</li>\n<li>外部中断: 体现在外设水平</li>\n</ul>\n<h4 id=\"nvic\">NVIC</h4>\n<p>NVIC负责管理中断</p>\n<p>在core_cm3.h中的定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC</span></span><br><span class=\"line\"><span class=\"comment\">  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)</span></span><br><span class=\"line\"><span class=\"comment\">  @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 中断使能寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ISER[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x000  Interrupt Set Enable Register           */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED0[<span class=\"number\">24</span>];                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断清除寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ICER[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x080  Interrupt Clear Enable Register         */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RSERVED1[<span class=\"number\">24</span>];                                    </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断使能悬起寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ISPR[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x100  Interrupt Set Pending Register          */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED2[<span class=\"number\">24</span>];                                   </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 中断清除悬起寄存器 </span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> ICPR[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x180  Interrupt Clear Pending Register        */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED3[<span class=\"number\">24</span>];                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断有效位寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> IABR[<span class=\"number\">8</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x200  Interrupt Active bit Register           */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED4[<span class=\"number\">56</span>];                                   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 中断优先级寄存器</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint8_t</span>  IP[<span class=\"number\">240</span>];                      <span class=\"comment\">/*!&lt; Offset: 0x300  Interrupt Priority Register (8Bit wide) */</span></span><br><span class=\"line\">       <span class=\"type\">uint32_t</span> RESERVED5[<span class=\"number\">644</span>];                                  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 软件触发中断寄存器</span></span><br><span class=\"line\">  __O  <span class=\"type\">uint32_t</span> STIR;                         <span class=\"comment\">/*!&lt; Offset: 0xE00  Software Trigger Interrupt Register     */</span></span><br><span class=\"line\">&#125;  NVIC_Type;                                               </span><br><span class=\"line\"><span class=\"comment\">/*@&#125;*/</span> <span class=\"comment\">/* end of group CMSIS_CM3_NVIC */</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"nvic的优先级分组\">NVIC的优先级分组</h5>\n<p>通过<strong>SCB-&gt;AIRCR寄存器的PRIGROUP部分(即bit[10:8])进行分组</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401140238595.png\" alt=\"NVIC优先级\"></p>\n<h3 id=\"中断编程的顺序\">中断编程的顺序</h3>\n<ol>\n<li>使能中断请求(<strong>使能外设中断, 使能 NVIC 中断</strong>)</li>\n<li>配置中断优先级分组(NVIC_PriorityGroupConfig)</li>\n<li>配置 NVIC 寄存器, 初始化NVIC_InitTypeDef</li>\n<li>编写中断服务函数</li>\n</ol>\n<h2 id=\"exti\">EXTI</h2>\n<h3 id=\"exti-输入线\">EXTI 输入线</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.13.32.png\" alt=\"EXTI 输入线\"></p>\n<p>通过寄存器 AFIO_EXTICR1, 2, 3, 4配置</p>\n<h3 id=\"exti-框图讲解\">EXTI 框图讲解</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.18.42.png\" alt=\"EXTI 框图\"></p>\n<h4 id=\"外部中断流程\">外部中断流程</h4>\n<ol>\n<li>通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1</li>\n<li>通过 EXTI_SWIER 来配置软件中断, 配置后为 1</li>\n<li>经过逻辑与门后, 进入请求挂起寄存器</li>\n<li>通过 EXTI_PR 配置挂起</li>\n<li>通过 EXTI_IMR 配置中断屏蔽</li>\n<li>请求挂起寄存器的逻辑值与中断屏蔽寄存器的逻辑值做逻辑与至 NVIC 中断控制器</li>\n</ol>\n<h4 id=\"外部事件流程\">外部事件流程</h4>\n<ol>\n<li>通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1</li>\n<li>通过 EXTI_SWIER 来配置软件中断, 配置后为 1</li>\n<li>经过逻辑与门后, 向下跟事件屏蔽寄存器相与</li>\n<li>通过 EXTI_EMR 配置事件屏蔽</li>\n<li>若为 1 产生脉冲</li>\n</ol>\n<h3 id=\"exti-结构体\">EXTI 结构体</h3>\n<p>EXTI_InitTypeDef</p>\n<ul>\n<li>EXTI_Line : 用于产生中断/事件线</li>\n<li>EXTI_Mode : EXTI 模式(中断/事件)</li>\n<li>EXTI_Trigger : 触发(上/下/上下)</li>\n<li>EXTI_LineCmd :  使能或者失能(IMR/EMR)</li>\n</ul>\n<h4 id=\"exti-的结构体定义\">EXTI 的结构体定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  EXTI Init Structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> EXTI_Line;               <span class=\"comment\">/*!&lt; Specifies the EXTI lines to be enabled or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be any combination of @ref EXTI_Lines */</span></span><br><span class=\"line\">   </span><br><span class=\"line\">  EXTIMode_TypeDef EXTI_Mode;       <span class=\"comment\">/*!&lt; Specifies the mode for the EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref EXTIMode_TypeDef */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  EXTITrigger_TypeDef EXTI_Trigger; <span class=\"comment\">/*!&lt; Specifies the trigger signal active edge for the EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref EXTIMode_TypeDef */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  FunctionalState EXTI_LineCmd;     <span class=\"comment\">/*!&lt; Specifies the new state of the selected EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be set either to ENABLE or DISABLE */</span> </span><br><span class=\"line\">&#125;EXTI_InitTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"exti_line-的定义\">EXTI_Line 的定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @defgroup EXTI_Lines </span></span><br><span class=\"line\"><span class=\"comment\">  * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line0       ((uint32_t)0x00001)  <span class=\"comment\">/*!&lt; External interrupt line 0 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line1       ((uint32_t)0x00002)  <span class=\"comment\">/*!&lt; External interrupt line 1 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line2       ((uint32_t)0x00004)  <span class=\"comment\">/*!&lt; External interrupt line 2 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line3       ((uint32_t)0x00008)  <span class=\"comment\">/*!&lt; External interrupt line 3 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line4       ((uint32_t)0x00010)  <span class=\"comment\">/*!&lt; External interrupt line 4 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line5       ((uint32_t)0x00020)  <span class=\"comment\">/*!&lt; External interrupt line 5 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line6       ((uint32_t)0x00040)  <span class=\"comment\">/*!&lt; External interrupt line 6 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line7       ((uint32_t)0x00080)  <span class=\"comment\">/*!&lt; External interrupt line 7 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line8       ((uint32_t)0x00100)  <span class=\"comment\">/*!&lt; External interrupt line 8 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line9       ((uint32_t)0x00200)  <span class=\"comment\">/*!&lt; External interrupt line 9 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line10      ((uint32_t)0x00400)  <span class=\"comment\">/*!&lt; External interrupt line 10 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line11      ((uint32_t)0x00800)  <span class=\"comment\">/*!&lt; External interrupt line 11 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line12      ((uint32_t)0x01000)  <span class=\"comment\">/*!&lt; External interrupt line 12 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line13      ((uint32_t)0x02000)  <span class=\"comment\">/*!&lt; External interrupt line 13 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line14      ((uint32_t)0x04000)  <span class=\"comment\">/*!&lt; External interrupt line 14 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line15      ((uint32_t)0x08000)  <span class=\"comment\">/*!&lt; External interrupt line 15 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line16      ((uint32_t)0x10000)  <span class=\"comment\">/*!&lt; External interrupt line 16 Connected to the PVD Output */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line17      ((uint32_t)0x20000)  <span class=\"comment\">/*!&lt; External interrupt line 17 Connected to the RTC Alarm event */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line18      ((uint32_t)0x40000)  <span class=\"comment\">/*!&lt; External interrupt line 18 Connected to the USB Device/USB OTG FS</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"meta\">                                                   Wakeup from suspend event */</span>                                    </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EXTI_Line19      ((uint32_t)0x80000)  <span class=\"comment\">/*!&lt; External interrupt line 19 Connected to the Ethernet Wakeup event */</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"exti_mode-的定义\">EXTI_Mode 的定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  EXTI mode enumeration  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  EXTI_Mode_Interrupt = <span class=\"number\">0x00</span>,</span><br><span class=\"line\">  EXTI_Mode_Event = <span class=\"number\">0x04</span></span><br><span class=\"line\">&#125;EXTIMode_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"exti_trigger-的定义\">EXTI_Trigger 的定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  EXTI Trigger enumeration  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  EXTI_Trigger_Rising = <span class=\"number\">0x08</span>,</span><br><span class=\"line\">  EXTI_Trigger_Falling = <span class=\"number\">0x0C</span>,  </span><br><span class=\"line\">  EXTI_Trigger_Rising_Falling = <span class=\"number\">0x10</span></span><br><span class=\"line\">&#125;EXTITrigger_TypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \\</span></span><br><span class=\"line\"><span class=\"meta\">                                  ((TRIGGER) == EXTI_Trigger_Falling) || \\</span></span><br><span class=\"line\"><span class=\"meta\">                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"gpio-作为 exti 输入线的配置\">GPIO 作为 EXTI 输入线的配置</h3>\n<p>在 stm32f10x_gpio.c 中, 使用 GPIO_EXTILineConfig 函数进行配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Selects the GPIO pin used as EXTI Line.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.</span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  GPIO_PinSource: specifies the EXTI line to be configured.</span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be GPIO_PinSourcex where x can be (0..15).</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">GPIO_EXTILineConfig</span><span class=\"params\">(<span class=\"type\">uint8_t</span> GPIO_PortSource, <span class=\"type\">uint8_t</span> GPIO_PinSource)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> tmp = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* Check the parameters */</span></span><br><span class=\"line\">  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));</span><br><span class=\"line\">  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));</span><br><span class=\"line\">  </span><br><span class=\"line\">  tmp = ((<span class=\"type\">uint32_t</span>)<span class=\"number\">0x0F</span>) &lt;&lt; (<span class=\"number\">0x04</span> * (GPIO_PinSource &amp; (<span class=\"type\">uint8_t</span>)<span class=\"number\">0x03</span>));</span><br><span class=\"line\">  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; <span class=\"number\">0x02</span>] &amp;= ~tmp;</span><br><span class=\"line\">  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; <span class=\"number\">0x02</span>] |= (((<span class=\"type\">uint32_t</span>)GPIO_PortSource) &lt;&lt; (<span class=\"number\">0x04</span> * (GPIO_PinSource &amp; (<span class=\"type\">uint8_t</span>)<span class=\"number\">0x03</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"exti中断实验\">EXTI中断实验</h3>\n<p>项目地址: <strong>18-EXTI</strong></p>\n<p><strong>项目需求:</strong></p>\n<ol>\n<li>PA0 连接到 EXTI 用于产生中断, PA0 的电平变化通过按键来控制</li>\n<li>产生一次中断, LED 反转一次</li>\n</ol>\n<h4 id=\"在bsp_extic中初始化要连接到exti的gpio\">在bsp_exti.c中初始化要连接到EXTI的GPIO</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 Key1(PA0)</span></span><br><span class=\"line\">RCC_APB2PeriphClockCmd(KEY1_INT_GPIO_CLK, ENABLE);</span><br><span class=\"line\">GPIO_InitStruct.GPIO_Pin = KEY1_INT_GPIO_PIN;</span><br><span class=\"line\">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">GPIO_Init(KEY1_INT_GPIO_PORT, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_extic中初始化exti用于产生中断/事件\">在bsp_exti.c中初始化EXTI用于产生中断/事件</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class=\"line\">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); <span class=\"comment\">// 选择输入线</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_Line = EXTI_Line0;                     <span class=\"comment\">// 选择EXTI线路</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class=\"comment\">// 选择中断模式</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;         <span class=\"comment\">// 选择触发模式</span></span><br><span class=\"line\">EXTI_InitStruct.EXTI_LineCmd = ENABLE;                          <span class=\"comment\">// 使能EXTI线路</span></span><br><span class=\"line\">EXTI_Init(&amp;EXTI_InitStruct);</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_extic中初始化nvic,-用于处理中断\">在bsp_exti.c中初始化NVIC, 用于处理中断</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class=\"line\"></span><br><span class=\"line\">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); <span class=\"comment\">// 配置中断优先级分组</span></span><br><span class=\"line\"></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn; <span class=\"comment\">// 选择中断源</span></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">1</span>; <span class=\"comment\">// 抢占优先级</span></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class=\"number\">1</span>; <span class=\"comment\">// 子优先级</span></span><br><span class=\"line\">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; <span class=\"comment\">// 使能中断</span></span><br><span class=\"line\">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_itc中编写中断服务函数\">在stm32f10x_it.c中编写中断服务函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief EXTI0_IRQHandler: Interrupt handler for EXTI Line 0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This function is the interrupt handler for EXTI Line 0. It toggles the state of the blue LED.</span></span><br><span class=\"line\"><span class=\"comment\"> * It checks the interrupt status of EXTI Line 0 and clears the interrupt pending bit.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EXTI0_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(EXTI_GetITStatus(EXTI_Line0) != RESET) <span class=\"comment\">// 判断中断位</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    LED_B_TOGGLE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  EXTI_ClearITPendingBit(EXTI_Line0); <span class=\"comment\">// 清除中断标志位</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledh中编写电平反转函数\">在bsp_led.h中编写电平反转函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_B_TOGGLE &#123;LED_B_GPIO_PORT-&gt;ODR ^= LED_B_GPIO_PIN;&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"补充:-使能afio时钟\">补充: 使能AFIO时钟</h3>\n<p>在STM32微控制器系列中，使用外部中断（EXTI）时需要开启AFIO（Alternate Function IO）时钟的原因与STM32的硬件设计和引脚复用功能有关。</p>\n<h4 id=\"afio的作用\">AFIO的作用</h4>\n<ol>\n<li><strong>引脚复用</strong>：STM32的GPIO（通用输入输出）引脚具有多功能性。一个物理引脚可以用作普通的I/O，也可以被配置为特殊功能，如USART、SPI、I2C通信或外部中断（EXTI）等。AFIO（Alternate Function IO）模块负责管理这些引脚的复用功能。</li>\n<li><strong>EXTI配置</strong>：在STM32中，外部中断线（EXTI）可以映射到不同的GPIO引脚上。AFIO模块提供了这种映射功能。例如，如果你想将EXTI0配置为由PA0、PB0、PC0等其中一个引脚触发，就需要通过AFIO模块来设置这种映射。</li>\n</ol>\n<h4 id=\"开启afio时钟的原因\">开启AFIO时钟的原因</h4>\n<p><strong>由于AFIO模块负责处理引脚的复用功能，包括EXTI的引脚映射，因此在使用EXTI功能之前，必须确保AFIO模块的时钟是使能的</strong>如果没有使能AFIO时钟，对AFIO寄存器的任何配置操作都不会生效，这意味着EXTI线路无法正确地映射到相应的GPIO引脚上，从而导致外部中断功能无法正常工作。</p>\n<h4 id=\"afio的实际操作\">AFIO的实际操作</h4>\n<p>在STM32的标准固件库或HAL（硬件抽象层）库中，通常会看到类似以下的代码片段，用于使能AFIO时钟：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br></pre></td></tr></table></figure>\n<p>或在使用HAL库时：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__HAL_RCC_AFIO_CLK_ENABLE();</span><br></pre></td></tr></table></figure>\n<p>这些函数调用确保了AFIO模块的时钟被使能，从而使得外部中断的相关配置（如引脚映射）能够正确执行。</p>\n<h4 id=\"afio的总结\">AFIO的总结</h4>\n<p>开启AFIO时钟是使用STM32的EXTI功能的必要步骤，因为AFIO模块控制着GPIO引脚的复用功能，包括将外部中断线路映射到特定的GPIO引脚。未使能AFIO时钟可能导致外部中断配置无效，进而影响整个中断处理机制的正常工作。</p>\n<h2 id=\"systick\">SysTick</h2>\n<h3 id=\"systick简介\">SysTick简介</h3>\n<p>SysTick: 系统定时器, <strong>24位, 只能递减, 存在于内核中</strong>, 嵌套在NVIC中, 所有的Cotex-M内核的单片机都具有这个定时器.</p>\n<h3 id=\"systick-功能框图\">SysTick 功能框图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170017620.png\" alt=\"框图\"></p>\n<p>重装载寄存器把值写入递减计数器, 可通过STK_VAL实时查询其中的值, 递减计数器从reload值开始递减, 减为0后可产生中断并且置位COUNTFLAG标志位, 置位后从reload获取值重复以上操作</p>\n<h3 id=\"systick-寄存器描述\">SysTick 寄存器描述</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170023320.png\" alt=\"SysTick 寄存器描述\"></p>\n<h3 id=\"systick-定时时间计算\">SysTick 定时时间计算</h3>\n<p>需要计算的参数</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025237.png\" alt=\"计算参数\"></p>\n<p>计算过程</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025314.png\" alt=\"计算过程\"></p>\n<ul>\n<li>Clk = 72M时</li>\n<li>reload = 72, t = 1us</li>\n<li>reload = 72000, t = 1ms</li>\n</ul>\n<h3 id=\"补充:-systick 介绍\">补充: SysTick 介绍</h3>\n<p>SysTick（System Tick Timer）是ARM Cortex-M微控制器内核的一个内置组件，用于提供一个简单但高效的系统定时器。这个定时器通常用于实现操作系统的节拍（tick），也可以用于简单的延时功能。</p>\n<h4 id=\"systick的主要特点\">SysTick的主要特点</h4>\n<ol>\n<li>24位递减计数器：SysTick包含一个24位的递减计数器，当计数器值递减到零时，定时器溢出并触发一个中断。</li>\n<li>可编程重载值：可以设置计数器的重载值，这决定了定时器的溢出时间间隔。</li>\n<li>可配置的时钟源：SysTick定时器可以配置为使用内核时钟或外部时钟（通常是内核时钟的一半）。</li>\n<li>自动重载：在计数到零时，计数器会自动重新加载预设的重载值，从而实现周期性定时。</li>\n<li>中断功能：当计数器达到零时，SysTick定时器可以产生一个中断。这个中断可以用于各种定时任务，如操作系统的任务调度。</li>\n</ol>\n<h4 id=\"systick的应用场景\">SysTick的应用场景</h4>\n<ol>\n<li>操作系统节拍：在实时操作系统（RTOS）中，SysTick常用于生成操作系统的节拍，这对于任务调度和时间管理非常重要。</li>\n<li>延时功能：在不需要RTOS的简单应用中，SysTick可用于生成精确的延时，例如在两个事件之间等待固定的时间。</li>\n<li>时间基准：SysTick还可以作为程序中的时间基准，用于测量时间间隔或产生定时事件。</li>\n</ol>\n<h4 id=\"systick的配置和使用\">SysTick的配置和使用</h4>\n<p>在使用SysTick时，一般需要进行以下配置：</p>\n<ol>\n<li>设置重载值：根据所需的定时周期和时钟源频率设置重载值。</li>\n<li>选择时钟源：选择使用内核时钟还是外部时钟作为SysTick的时钟源。</li>\n<li>启用中断（可选）：如果需要在定时器溢出时执行特定操作，可以启<br>\n用SysTick中断。</li>\n<li>启动定时器：启用SysTick定时器开始计数</li>\n</ol>\n<h4 id=\"systick的编程示例\">SysTick的编程示例</h4>\n<p>在STM32等ARM Cortex-M微控制器上，SysTick的配置和使用通常涉及直接操作其控制和状态寄存器。以下是一个简单的示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SysTick_Config(SystemCoreClock / <span class=\"number\">1000</span>);  <span class=\"comment\">// 配置SysTick产生</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"systick-源码分析\">SysTick 源码分析</h3>\n<p>SysTick_Type定义在core_cm3.h中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick</span></span><br><span class=\"line\"><span class=\"comment\">  memory mapped structure for SysTick</span></span><br><span class=\"line\"><span class=\"comment\">  @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> CTRL;                         <span class=\"comment\">/*!&lt; Offset: 0x00  SysTick Control and Status Register */</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> LOAD;                         <span class=\"comment\">/*!&lt; Offset: 0x04  SysTick Reload Value Register       */</span></span><br><span class=\"line\">  __IO <span class=\"type\">uint32_t</span> VAL;                          <span class=\"comment\">/*!&lt; Offset: 0x08  SysTick Current Value Register      */</span></span><br><span class=\"line\">  __I  <span class=\"type\">uint32_t</span> CALIB;                        <span class=\"comment\">/*!&lt; Offset: 0x0C  SysTick Calibration Register        */</span></span><br><span class=\"line\">&#125; SysTick_Type;</span><br></pre></td></tr></table></figure>\n<p>SysTick_Config函数在core_cm3.h中定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief  Initialize and start the SysTick counter and its interrupt.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param   ticks   number of ticks between two interrupts</span></span><br><span class=\"line\"><span class=\"comment\"> * @return  1 = failed, 0 = successful</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialise the system tick timer and its interrupt and start the</span></span><br><span class=\"line\"><span class=\"comment\"> * system tick timer / counter in free running mode to generate </span></span><br><span class=\"line\"><span class=\"comment\"> * periodical interrupts.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> __INLINE <span class=\"type\">uint32_t</span> <span class=\"title function_\">SysTick_Config</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ticks)</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">  <span class=\"comment\">// 判断ticks的值是否大于2^24, 若大于则违法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class=\"keyword\">return</span> (<span class=\"number\">1</span>);            <span class=\"comment\">/* Reload value impossible */</span></span><br><span class=\"line\">                                                               </span><br><span class=\"line\">  <span class=\"comment\">// 初始化reaload寄存器的值</span></span><br><span class=\"line\">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class=\"number\">1</span>;      <span class=\"comment\">/* set reload register */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置中断优先级, 配置为15, 默认为最低的优先级</span></span><br><span class=\"line\">  <span class=\"comment\">/*-------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 注: </span></span><br><span class=\"line\"><span class=\"comment\">   * 内核优先级的判断方式:</span></span><br><span class=\"line\"><span class=\"comment\">   * 将内核外设的中断优先级的四个位按照外设的中断优先级进行分组</span></span><br><span class=\"line\"><span class=\"comment\">   * 分组后可判断内核的抢占优先级和响应优先级</span></span><br><span class=\"line\"><span class=\"comment\">   * 即人为分出抢占和响应优先级</span></span><br><span class=\"line\"><span class=\"comment\">   * </span></span><br><span class=\"line\"><span class=\"comment\">   * 例:</span></span><br><span class=\"line\"><span class=\"comment\">   * 这里SysTick的中断优先级为15, 二进制为1111</span></span><br><span class=\"line\"><span class=\"comment\">   * 若分组为2位抢占, 2位响应</span></span><br><span class=\"line\"><span class=\"comment\">   * 则SysTick的抢占优先级为11即3, 响应优先级为11即3</span></span><br><span class=\"line\"><span class=\"comment\">   * 若分组为1位抢占, 3位响应</span></span><br><span class=\"line\"><span class=\"comment\">   * 则SysTick的抢占优先级为1即1, 响应优先级为111即7</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过该方法可以比较内核优先级与外设的优先级谁更高</span></span><br><span class=\"line\"><span class=\"comment\">   * ----------------------------------------------------------*/</span></span><br><span class=\"line\">  NVIC_SetPriority (SysTick_IRQn, (<span class=\"number\">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class=\"number\">1</span>);  <span class=\"comment\">/* set Priority for Cortex-M0 System Interrupts */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化counter的值为0</span></span><br><span class=\"line\">  SysTick-&gt;VAL   = <span class=\"number\">0</span>;                                          <span class=\"comment\">/* Load the SysTick Counter Value */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置 SysTick的时钟为 72M</span></span><br><span class=\"line\">  <span class=\"comment\">// 使能中断</span></span><br><span class=\"line\">  <span class=\"comment\">// 使能 SysTick </span></span><br><span class=\"line\">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class=\"line\">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class=\"line\">                   SysTick_CTRL_ENABLE_Msk;                    <span class=\"comment\">/* Enable SysTick IRQ and SysTick Timer */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"number\">0</span>);                                                  <span class=\"comment\">/* Function successful */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"systick-实验\">SysTick 实验</h3>\n<p>项目地址: <strong>19-SysTick</strong></p>\n<p>实验要求:</p>\n<ol>\n<li>编写一个微妙延时函数</li>\n<li>编写一个毫秒延时函数</li>\n</ol>\n<h4 id=\"在bsp_systickc中编写微妙延时函数\">在bsp_systick.c中编写微妙延时函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 延时指定的微秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param us 延时的微秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_us</span><span class=\"params\">(<span class=\"type\">uint32_t</span> us)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SysTick_Config(SystemCoreClock / <span class=\"number\">1000000</span>); <span class=\"comment\">// reload 设置为 72, t = 1us</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; us; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!(SysTick-&gt;CTRL &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>)))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ; <span class=\"comment\">// 等待CTRL的Bit16置1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; <span class=\"comment\">// 状态位清除</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_systickc中编写毫秒延时函数\">在bsp_systick.c中编写毫秒延时函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 延时指定的毫秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ms 延时的毫秒数</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 无</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_ms</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SysTick_Config(SystemCoreClock / <span class=\"number\">1000</span>); <span class=\"comment\">// reload 设置为 72000, t = 1ms</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ms; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!(SysTick-&gt;CTRL &amp; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>)))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ; <span class=\"comment\">// 等待CTRL的Bit16置1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; <span class=\"comment\">// 状态位清除</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_systickh中引用库文件和进行函数声明\">在bsp_systick.h中引用库文件和进行函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __BSP_SYSTICK_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __BSP_SYSTICK_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;core_cm3.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_ms</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ms)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">SysTick_Delay_us</span><span class=\"params\">(<span class=\"type\">uint32_t</span> us)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// !__BSP_SYSTICK_H</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中调用延时函数,实现led闪烁\">在main.c中调用延时函数,实现LED闪烁</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Main function of the program.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This function initializes the LED GPIO and enters an infinite loop. </span></span><br><span class=\"line\"><span class=\"comment\"> * In each iteration of the loop, it turns off the blue LED, delays for 0.5 seconds,</span></span><br><span class=\"line\"><span class=\"comment\"> * turns on the blue LED, and delays for 0.5 seconds again.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @return int The exit status of the program.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// Initialize the LED GPIO</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_B(OFF); <span class=\"comment\">// Turn off the blue LED</span></span><br><span class=\"line\">        SysTick_Delay_ms(<span class=\"number\">500</span>); <span class=\"comment\">// Delay for 0.5 seconds</span></span><br><span class=\"line\">        LED_B(ON); <span class=\"comment\">// Turn on the blue LED</span></span><br><span class=\"line\">        SysTick_Delay_us(<span class=\"number\">500000</span>); <span class=\"comment\">// Delay for 0.5 seconds</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"通信的基本概念\">通信的基本概念</h2>\n<h3 id=\"串行和并行通信\">串行和并行通信</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171542012.png\" alt=\"串行和并行通信\"></p>\n<ul>\n<li>串行协议: USART, I2C, SPI, W500, CAN, LIN</li>\n<li>并行协议: FSMC, SDIO</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171546066.png\" alt=\"对比\"></p>\n<h3 id=\"全双工,-半双工和单工\">全双工, 半双工和单工</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171548657.png\" alt=\"全双工,半双工和单工\"></p>\n<h3 id=\"同步与异步\">同步与异步</h3>\n<p>同步传输通过时钟信号进行同步, 保证数据传输的准确性</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171550768.png\" alt=\"同步\"></p>\n<p>异步传输通过加入辅助的标识符, 保证数据传输的准确性</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171552733.png\" alt=\"异步\"></p>\n<h4 id=\"同步与异步的区别\">同步与异步的区别</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171554763.png\" alt=\"区别\"></p>\n<h3 id=\"通信的速率\">通信的速率</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171555519.png\" alt=\"通信的速率\"></p>\n<p>当用一个二进制位表示一个码元时, 比特率和波特率相等</p>\n<h2 id=\"usart-串口通信\">USART-串口通信</h2>\n<h3 id=\"串口通信协议简介\">串口通信协议简介</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610065.png\" alt=\"USART\"></p>\n<h4 id=\"物理层的常用标准\">物理层的常用标准</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610887.png\" alt=\"USART\"></p>\n<h5 id=\"232和ttl电平区别\">232和TTL电平区别</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171611637.png\" alt=\"USART\"></p>\n<ul>\n<li>TTL: 从芯片出来的基本是TTL电平</li>\n<li>232: 负逻辑, 压差大</li>\n</ul>\n<h6 id=\"232通信通讯结构图\">232通信通讯结构图</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171631235.png\" alt=\"232\"></p>\n<p>DB9接口图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171634288.png\" alt=\"DB9接口\"></p>\n<h6 id=\"usb转串口通讯结构图\">USB转串口通讯结构图</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171644660.png\" alt=\"USB转串口\"></p>\n<h5 id=\"串口到串口通讯结构图\">串口到串口通讯结构图</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171655718.png\" alt=\"串口到串口\"></p>\n<h4 id=\"串口数据包的组成\">串口数据包的组成</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171658813.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171659831.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171702232.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703446.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703050.png\" alt=\"串口数据包\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171704956.png\" alt=\"串口数据包\"></p>\n<h3 id=\"stm32串口功能框图讲解\">STM32串口功能框图讲解</h3>\n<h4 id=\"引脚部分讲解\">引脚部分讲解</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708669.png\" alt=\"STM32串口功能框图\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708578.png\" alt=\"STM32串口功能框图\"></p>\n<h5 id=\"引脚对应\">引脚对应</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171710068.png\" alt=\"引脚对应\"></p>\n<h4 id=\"数据寄存器部分\">数据寄存器部分</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171723621.png\" alt=\"数据寄存器部分\"></p>\n<h5 id=\"数据格式\">数据格式</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171725627.png\" alt=\"数据格式\"></p>\n<h6 id=\"usart_cr1的bit12-m控制字长\">USART_CR1的bit12 M控制字长</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727509.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_cr2的bit[13:12]-stop控制停止位的位数\">USART_CR2的bit[13:12] STOP控制停止位的位数</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727238.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_cr1的bit10(pse),-bit9(ps)来使能校验和选择校验模式\">USART_CR1的bit10(PSE), bit9(PS)来使能校验和选择校验模式</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171730822.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_cr1的bit8(peie)来使能中断\">USART_CR1的bit8(PEIE)来使能中断</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171731175.png\" alt=\"寄存器\"></p>\n<h6 id=\"usart_sr的bit0(pe)来检测校验错误\">USART_SR的bit0(PE)来检测校验错误</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171732400.png\" alt=\"寄存器\"></p>\n<h4 id=\"发送数据部分\">发送数据部分</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171739676.png\" alt=\"发送数据\"></p>\n<ol>\n<li>先将USART_CR1的UE位置1(<em>使能USART模块</em>), 再将USART_CR1的TE位置1(<em>使能发送</em>)</li>\n<li>数据从CPU或DMA中写入发送数据寄存器(TDR), TDR发送完毕后, USART_SR的TXE位置1(<em>数据已经被转移到移位寄存器中</em>)</li>\n<li>发送移位寄存器发送完毕后, USART_SR的TC位置1(<em>表示发送完成</em>)</li>\n</ol>\n<h4 id=\"接收数据部分\">接收数据部分</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171900970.png\" alt=\"接收数据部分\"></p>\n<ol>\n<li>先将USART_CR1的UE位置1(<em>使能USART模块</em>), 再将USART_CR1的RE位置1(<em>使能接收</em>)</li>\n<li>数据从RX到接收移位寄存器到接收数据寄存器(RDR), 接收完毕后, USART_SR的RXNE位置1(<em>收到数据, 可以读出</em>)</li>\n</ol>\n<h4 id=\"波特率设置\">波特率设置</h4>\n<h5 id=\"使用usart_brr进行配置\">使用USART_BRR进行配置</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171906798.png\" alt=\"USART_BRR\"></p>\n<h5 id=\"波特率的计算公式\">波特率的计算公式</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171909589.png\" alt=\"波特率的计算公式\"></p>\n<ul>\n<li>APB2时钟: 72MHz, 挂载USART1</li>\n<li>APB1时钟: 36MHz, 挂载USART2, 3, 4, 5</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171910703.png\" alt=\"波特率\"></p>\n<h3 id=\"串口初始化结构体和固件库讲解\">串口初始化结构体和固件库讲解</h3>\n<h4 id=\"串口初始化结构体\">串口初始化结构体</h4>\n<p>在stm32f10x_usart.h中定义串口初始化结构体(异步)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART Init Structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span> </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 设置波特率</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> USART_BaudRate;            <span class=\"comment\">/*!&lt; This member configures the USART communication baud rate.</span></span><br><span class=\"line\"><span class=\"comment\">                                           The baud rate is computed using the following formula:</span></span><br><span class=\"line\"><span class=\"comment\">                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))</span></span><br><span class=\"line\"><span class=\"comment\">                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置字长</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_WordLength_8b                  ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_WordLength_9b                  ((uint16_t)0x1000)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_WordLength;          <span class=\"comment\">/*!&lt; Specifies the number of data bits transmitted or received in a frame.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Word_Length */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置停止位</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_1                     ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_0_5                   ((uint16_t)0x1000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_2                     ((uint16_t)0x2000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_StopBits_1_5                   ((uint16_t)0x3000)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_StopBits;            <span class=\"comment\">/*!&lt; Specifies the number of stop bits transmitted.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Stop_Bits */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置校验</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Parity_No                      ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Parity_Even                    ((uint16_t)0x0400)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Parity_Odd                     ((uint16_t)0x0600)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_Parity;              <span class=\"comment\">/*!&lt; Specifies the parity mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Parity</span></span><br><span class=\"line\"><span class=\"comment\">                                           @note When parity is enabled, the computed parity is inserted</span></span><br><span class=\"line\"><span class=\"comment\">                                                 at the MSB position of the transmitted data (9th bit when</span></span><br><span class=\"line\"><span class=\"comment\">                                                 the word length is set to 9 data bits; 8th bit when the</span></span><br><span class=\"line\"><span class=\"comment\">                                                 word length is set to 8 data bits). */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 设置模式</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Mode_Rx                        ((uint16_t)0x0004)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Mode_Tx                        ((uint16_t)0x0008)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_Mode;                <span class=\"comment\">/*!&lt; Specifies wether the Receive or Transmit mode is enabled or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置硬件控制流</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_HardwareFlowControl; <span class=\"comment\">/*!&lt; Specifies wether the hardware flow control mode is enabled</span></span><br><span class=\"line\"><span class=\"comment\">                                           or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */</span></span><br><span class=\"line\">&#125; USART_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<p>在stm32f10x_usart.h中定义串口初始化结构体(同步)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART Clock Init Structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span> </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置使能时钟</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Clock_Disable                  ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_Clock_Enable                   ((uint16_t)0x0800)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_Clock;   <span class=\"comment\">/*!&lt; Specifies whether the USART clock is enabled or disabled.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Clock */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置时钟的极性, 即总线空闲时CK引脚保持低电平还是高电平</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPOL_Low                       ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPOL_High                      ((uint16_t)0x0400)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_CPOL;    <span class=\"comment\">/*!&lt; Specifies the steady state value of the serial clock.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Clock_Polarity */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置时钟的相位, 即数据采样的时机为第一个边沿还是第二个边沿</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPHA_1Edge                     ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_CPHA_2Edge                     ((uint16_t)0x0200)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_CPHA;    <span class=\"comment\">/*!&lt; Specifies the clock transition on which the bit capture is made.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Clock_Phase */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置时钟的最后一个数据位的时钟脉冲是否输出到SCLK引脚</span></span><br><span class=\"line\">  <span class=\"comment\">/*-----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 参数如下:</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_LastBit_Disable                ((uint16_t)0x0000)</span></span><br><span class=\"line\"><span class=\"comment\">   * #define USART_LastBit_Enable                 ((uint16_t)0x0100)</span></span><br><span class=\"line\"><span class=\"comment\">   * ---------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> USART_LastBit; <span class=\"comment\">/*!&lt; Specifies whether the clock pulse corresponding to the last transmitted</span></span><br><span class=\"line\"><span class=\"comment\">                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.</span></span><br><span class=\"line\"><span class=\"comment\">                               This parameter can be a value of @ref USART_Last_Bit */</span></span><br><span class=\"line\">&#125; USART_ClockInitTypeDef;</span><br></pre></td></tr></table></figure>\n<h4 id=\"串口库函数\">串口库函数</h4>\n<ul>\n<li><strong>串口初始化函数</strong>: void USART_Init(USART_TypeDef<em>USARTx, USART_InitTypeDef</em> USART_InitStruct);</li>\n<li><strong>中断配置函数</strong>: void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);</li>\n<li><strong>串口使能函数</strong>: void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);</li>\n<li><strong>数据发送函数</strong>: void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</li>\n<li><strong>数据接收函数</strong>: void USART_ReceiveData(USART_TypeDef* USARTx);</li>\n<li><strong>中断状态位获取函数</strong>: ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);</li>\n</ul>\n<h3 id=\"usb转串口的硬件原理图\">USB转串口的硬件原理图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401172002602.png\" alt=\"硬件原理图\"></p>\n<h3 id=\"串口gpio汇总\">串口GPIO汇总</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220859886.png\" alt=\"串口GPIO\"></p>\n<h3 id=\"补充:-外设的gpio配置\">补充: 外设的GPIO配置</h3>\n<p>在STM32F10x参考手册中的8.1.11节可找到外设的GPIO配置, 其中关于USART部分的GPIO配置如下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220904826.png\" alt=\"USART的GPIO配置\"></p>\n<h3 id=\"配置串口助手\">配置串口助手</h3>\n<p>本项目使用的串口助手: 野火多功能调试助手V1.0.2.9</p>\n<p>串口配置如下图(<em>串口配置参数与串口的初始化配置有关, 该配置符合下文代码的初始化</em>)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401250242370.png\" alt=\"串口助手配置\"></p>\n<h3 id=\"usart接收和发送实验\">USART接收和发送实验</h3>\n<p>项目地址: <strong>21-USART-接收和发送</strong></p>\n<p><strong>实验需求</strong>: 单片机给电脑发送数据, 电脑上位机把数据打印出来; 电脑上位机给单片机发数据, 单片机接收到数据之后立马发回给电脑, 并打印出来.</p>\n<h4 id=\"在bsp_usarth中进行串口的宏定义,-并使用条件编译来选择串口\">在bsp_usart.h中进行串口的宏定义, 并使用条件编译来选择串口</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏</span></span><br><span class=\"line\"><span class=\"comment\">  * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线</span></span><br><span class=\"line\"><span class=\"comment\">  * 2-修改GPIO的宏</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 通过条件编译选择串口, 使用的串口置1，其余置0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART1 1</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART2 0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART3 0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART4 0</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">define</span> DEBUG_USART5 0</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> DEBUG_USART1</span></span><br><span class=\"line\"><span class=\"comment\">// 串口1-USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB2Periph_USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                USART1_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         USART1_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_USART2</span></span><br><span class=\"line\"><span class=\"comment\">// 串口2-USART2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_USART2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                USART2_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         USART2_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_USART3</span></span><br><span class=\"line\"><span class=\"comment\">// 串口3-USART3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_USART3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOB   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOB</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                USART3_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         USART3_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_USART4</span></span><br><span class=\"line\"><span class=\"comment\">//串口4-UART4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   UART4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_UART4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOC   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOC</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                UART4_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         UART4_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">elif</span> DEBUG_UART5</span></span><br><span class=\"line\"><span class=\"comment\">// 串口5-UART5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   UART5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_UART5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOC   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOD</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQ                UART5_IRQn</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_IRQHandler         UART5_IRQHandler</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写usart的初始化函数\">在bsp_usart.c中编写usart的初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口GPIO的时钟</span></span><br><span class=\"line\">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开串口外设的时钟</span></span><br><span class=\"line\">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"comment\">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 配置串口的工作参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置波特率</span></span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">// 配置 针数据字长</span></span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    <span class=\"comment\">// 配置停止位</span></span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    <span class=\"comment\">// 配置校验位</span></span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class=\"line\">    <span class=\"comment\">// 配置硬件流控制</span></span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = </span><br><span class=\"line\">    USART_HardwareFlowControl_None;</span><br><span class=\"line\">    <span class=\"comment\">// 配置工作模式，收发一起</span></span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class=\"line\">    <span class=\"comment\">// 完成串口的初始化配置</span></span><br><span class=\"line\">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 串口中断优先级配置</span></span><br><span class=\"line\">    NVIC_Configuration();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使能串口接收中断</span></span><br><span class=\"line\">    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使能串口</span></span><br><span class=\"line\">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写串口中断优先级配置函数\">在bsp_usart.c中编写串口中断优先级配置函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  配置嵌套向量中断控制器NVIC</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">NVIC_Configuration</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* 嵌套向量中断控制器组选择 */</span></span><br><span class=\"line\">  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* 配置USART为中断源 */</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;</span><br><span class=\"line\">  <span class=\"comment\">/* 抢断优先级*/</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* 子优先级 */</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* 使能中断 */</span></span><br><span class=\"line\">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class=\"line\">  <span class=\"comment\">/* 初始化配置NVIC */</span></span><br><span class=\"line\">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送一个字节到串口的函数\">在bsp_usart.c中编写发送一个字节到串口的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 发送一个字节到指定的USART外设</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx USART外设指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ch 要发送的字节</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendByte</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint8_t</span> ch)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发送一个字节</span></span><br><span class=\"line\">    USART_SendData(pUSARTx, ch);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 等待发送数据寄存器为空</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送两个字节到串口的函数\">在bsp_usart.c中编写发送两个字节到串口的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 发送两个字节的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx USART外设指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ch 要发送的16位数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendHalfWord</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint16_t</span> ch)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> tmp_h, tmp_l;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp_h = (ch &amp; <span class=\"number\">0xFF00</span>) &gt;&gt; <span class=\"number\">8</span>; <span class=\"comment\">// 取出高八位</span></span><br><span class=\"line\">    tmp_l = (ch &amp; <span class=\"number\">0xFF</span>) &gt;&gt; <span class=\"number\">0</span>; <span class=\"comment\">// 取出低八位</span></span><br><span class=\"line\"></span><br><span class=\"line\">    USART_SendData(pUSARTx, tmp_h); <span class=\"comment\">// 发送高八位</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    USART_SendData(pUSARTx, tmp_l); <span class=\"comment\">// 发送低八位</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送数组的函数\">在bsp_usart.c中编写发送数组的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Sends an array of bytes over USART.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * This function sends an array of bytes over the specified USART peripheral.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx The USART peripheral to use.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param array Pointer to the array of bytes to send.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param num The number of bytes to send.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendArray</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint8_t</span>* <span class=\"built_in\">array</span>, <span class=\"type\">uint16_t</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; num; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     Usart_SendByte(pUSARTx, <span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写发送字符串的函数\">在bsp_usart.c中编写发送字符串的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 发送字符串到USART外设</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pUSARTx USART外设指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param str 要发送的字符串</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Usart_SendString</span><span class=\"params\">(USART_TypeDef* pUSARTx, <span class=\"type\">uint8_t</span>* str)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     Usart_SendByte(pUSARTx, *(str + i));</span><br><span class=\"line\">     i++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (*(str + i) != <span class=\"string\">&#x27;\\0&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待发送完成</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中编写重定向标准输出输入函数,-使得串口可使用scanf printf等函数\">在bsp_usart.c中编写重定向标准输出输入函数, 使得串口可使用scanf printf等函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重定向c库函数printf, putchar到串口，重定向后可使用printf, putchar函数</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 重定向标准输出函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ch 要发送的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * @param f 文件指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval 发送的字符</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE* f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    USART_SendData(DEBUG_USARTx, (<span class=\"type\">uint8_t</span>)ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">     ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param f 文件指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @return int 从串口接收到的数据</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fgetc</span><span class=\"params\">(FILE *f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 等待串口输入数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)USART_ReceiveData(DEBUG_USARTx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc函数中进行测试\">在main.c函数中进行测试</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_usart.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    USART_Config(); <span class=\"comment\">// 初始化USART</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送1字节数据</span></span><br><span class=\"line\">    Usart_SendByte(DEBUG_USARTx, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    Usart_SendByte(DEBUG_USARTx, <span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送2字节数据</span></span><br><span class=\"line\">    Usart_SendHalfWord(DEBUG_USARTx, <span class=\"number\">0xFF56</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送数组</span></span><br><span class=\"line\">    Usart_SendArray(DEBUG_USARTx, (<span class=\"type\">uint8_t</span>*)<span class=\"string\">&quot;Hello World!&quot;</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> <span class=\"built_in\">array</span>[<span class=\"number\">11</span>] = &#123;<span class=\"string\">&quot;Hello World!&quot;</span>&#125;;</span><br><span class=\"line\">    Usart_SendArray(DEBUG_USARTx, <span class=\"built_in\">array</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送字符串</span></span><br><span class=\"line\">    Usart_SendString(DEBUG_USARTx, <span class=\"string\">&quot;\\nString: Hello World\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重定向printf函数</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;printf: Hello World\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重定向putchar函数</span></span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;u&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;t&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;c&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;h&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;r&#x27;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在stm32f10x_itc中编写中断服务函数实现串口数据的接收并发送\">在stm32f10x_it.c中编写中断服务函数实现串口数据的接收并发送</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Interrupt handler for the DEBUG_USART.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This function is called when there is a receive interrupt from the DEBUG_USART.</span></span><br><span class=\"line\"><span class=\"comment\"> * It receives data from the DEBUG_USART and sends it back.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DEBUG_USART_IRQHandler</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> ucTemp;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(USART_GetITStatus(DEBUG_USARTx, USART_IT_RXNE) != RESET)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ucTemp = USART_ReceiveData(DEBUG_USARTx); <span class=\"comment\">// Receive data into ucTemp</span></span><br><span class=\"line\">    USART_SendData(DEBUG_USARTx, ucTemp); <span class=\"comment\">// Send data</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充:-通过重写fputc函数重定向c库函数printf到串口\">补充: 通过重写fputc函数重定向C库函数printf到串口</h3>\n<p>通过重写 fputc 函数可以实现重定向 printf 到串口的效果。这是因为 printf 函数实际上是通过 C 标准库中的输出函数 fputc 来将字符一个个地发送到输出设备的。当你重写了 fputc 函数，实际上就改变了字符的输出方式，使得字符被发送到你所定义的输出设备，比如串口。</p>\n<p>下面是一个简单的示例，演示了如何通过重写 fputc 函数来重定向 printf 到串口。这里假设你已经在系统中初始化了串口的硬件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 串口初始化函数，假设已经在系统中实现</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">initSerialPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 串口初始化的相关代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重定向标准输出函数</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE *f)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将字符发送到串口</span></span><br><span class=\"line\">    <span class=\"comment\">// 你需要在这里添加实际的串口发送代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如：sendCharacterToSerialPort(ch);</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化串口</span></span><br><span class=\"line\">    initSerialPort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在这之后，调用printf将输出信息发送到串口</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello, Serial Port!\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他代码...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们重写了 fputc 函数，使其将字符发送到串口。当 printf 调用 fputc 函数时，字符就会被发送到串口。这样就实现了将 printf 输出重定向到串口的效果。</p>\n<p>需要注意的是，具体的串口发送函数实现（比如 sendCharacterToSerialPort）需要根据你的具体硬件和系统来编写。这个示例只是演示了重定向的基本原理。</p>\n<h3 id=\"usart控制rgb灯实验\">USART控制RGB灯实验</h3>\n<p>项目地址: <strong>21-USART-控制RGB灯</strong></p>\n<p><strong>实验需求</strong>: 电脑给单片机发命令, 用于控制开发板上的RGB灯.</p>\n<h4 id=\"在bsp_ledh中定义rgb灯的宏\">在bsp_led.h中定义RGB灯的宏</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __LED_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __LED_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */</span></span><br><span class=\"line\"><span class=\"comment\">// R-红色</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_GPIO_PORT     GPIOB                 <span class=\"comment\">/* GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class=\"comment\">/* GPIO端口时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_GPIO_PIN  GPIO_Pin_5           <span class=\"comment\">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// G-绿色</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_GPIO_PORT     GPIOB                 <span class=\"comment\">/* GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class=\"comment\">/* GPIO端口时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_GPIO_PIN  GPIO_Pin_0           <span class=\"comment\">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B-蓝色</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_GPIO_PORT     GPIOB                 <span class=\"comment\">/* GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class=\"comment\">/* GPIO端口时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_GPIO_PIN  GPIO_Pin_1           <span class=\"comment\">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** the macro definition to trigger the led on or off </span></span><br><span class=\"line\"><span class=\"comment\">  * 1 - off</span></span><br><span class=\"line\"><span class=\"comment\">  *0 - on</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ON  0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OFF 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用标准的固件库控制IO*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1(a) <span class=\"keyword\">if</span> (a) \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\\</span></span><br><span class=\"line\"><span class=\"meta\">     <span class=\"keyword\">else</span>  \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2(a) <span class=\"keyword\">if</span> (a) \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\\</span></span><br><span class=\"line\"><span class=\"meta\">     <span class=\"keyword\">else</span>  \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3(a) <span class=\"keyword\">if</span> (a) \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);\\</span></span><br><span class=\"line\"><span class=\"meta\">     <span class=\"keyword\">else</span>  \\</span></span><br><span class=\"line\"><span class=\"meta\">     GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 直接操作寄存器的方法控制IO */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> digitalHi(p,i)   &#123;p-&gt;BSRR=i;&#125;  <span class=\"comment\">//输出为高电平  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> digitalLo(p,i)   &#123;p-&gt;BRR=i;&#125;  <span class=\"comment\">//输出低电平</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> digitalToggle(p,i) &#123;p-&gt;ODR ^=i;&#125; <span class=\"comment\">//输出反转状态</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 定义控制IO的宏 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_TOGGLE   digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_OFF     digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED1_ON      digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_TOGGLE   digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_OFF     digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED2_ON      digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_TOGGLE   digitalToggle(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_OFF     digitalHi(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED3_ON      digitalLo(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//红</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_RED  \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//绿</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_GREEN  \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//蓝</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_BLUE \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\"></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">//黄(红+绿)     </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_YELLOW \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"><span class=\"comment\">//紫(红+蓝)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_PURPLE \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//青(绿+蓝)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_CYAN \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">//白(红+绿+蓝)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_WHITE \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_ON;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_ON\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_ON</span></span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">//黑(全部关闭)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_RGBOFF \\</span></span><br><span class=\"line\"><span class=\"meta\">     LED1_OFF;\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED2_OFF\\</span></span><br><span class=\"line\"><span class=\"meta\">     LED3_OFF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __LED_H */</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_ledc中编写led初始化函数\">在bsp_led.c中编写led初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @file    bsp_led.c</span></span><br><span class=\"line\"><span class=\"comment\">  * @author  fire</span></span><br><span class=\"line\"><span class=\"comment\">  * @version V1.0</span></span><br><span class=\"line\"><span class=\"comment\">  * @date    2013-xx-xx</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   led应用函数接口</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @attention</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * 实验平台:野火 F103-霸道 STM32 开发板 </span></span><br><span class=\"line\"><span class=\"comment\">  * 论坛    :http://www.firebbs.cn</span></span><br><span class=\"line\"><span class=\"comment\">  * 淘宝    :https://fire-stm32.taobao.com</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;./led/bsp_led.h&quot;</span>   </span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  初始化控制LED的IO</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LED_GPIO_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/*定义一个GPIO_InitTypeDef类型的结构体*/</span></span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*开启LED相关的GPIO外设时钟*/</span></span><br><span class=\"line\">    RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK | LED3_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/*选择要控制的GPIO引脚*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*设置引脚模式为通用推挽输出*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*设置引脚速率为50MHz */</span>   </span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用库函数，初始化GPIO*/</span></span><br><span class=\"line\">    GPIO_Init(LED1_GPIO_PORT, &amp;GPIO_InitStructure); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*选择要控制的GPIO引脚*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用库函数，初始化GPIO*/</span></span><br><span class=\"line\">    GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*选择要控制的GPIO引脚*/</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = LED3_GPIO_PIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用库函数，初始化GPIOF*/</span></span><br><span class=\"line\">    GPIO_Init(LED3_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 关闭所有led灯 */</span></span><br><span class=\"line\">    GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 关闭所有led灯 */</span></span><br><span class=\"line\">    GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);  </span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">/* 关闭所有led灯 */</span></span><br><span class=\"line\">    GPIO_SetBits(LED3_GPIO_PORT, LED3_GPIO_PIN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">assert_failed</span><span class=\"params\">(<span class=\"type\">uint8_t</span>* file, <span class=\"type\">uint32_t</span> line)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 断言错误时执行的代码</span></span><br><span class=\"line\">    LED1_ON;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*********************************************END OF FILE**********************/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_usartc中关闭串口中断\">在bsp_usart.c中关闭串口中断</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口GPIO的时钟</span></span><br><span class=\"line\">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打开串口外设的时钟</span></span><br><span class=\"line\">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 配置串口的工作参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置波特率</span></span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">// 配置 针数据字长</span></span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    <span class=\"comment\">// 配置停止位</span></span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    <span class=\"comment\">// 配置校验位</span></span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class=\"line\">    <span class=\"comment\">// 配置硬件流控制</span></span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = </span><br><span class=\"line\">    USART_HardwareFlowControl_None;</span><br><span class=\"line\">    <span class=\"comment\">// 配置工作模式，收发一起</span></span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class=\"line\">    <span class=\"comment\">// 完成串口的初始化配置</span></span><br><span class=\"line\">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将中断失能</span></span><br><span class=\"line\">    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, DISABLE); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使能串口</span></span><br><span class=\"line\">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中编写测试程序\">在main.c中编写测试程序</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> ch = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    USART_Config(); <span class=\"comment\">// 初始化USART</span></span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// 初始化LED</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;USART-RGB\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;1:RED, 2:GREEN, 3:BLUE, 4:YELLOW, 5:PURPLE, 6:CYAN, 7:WHITE\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Others: BLACK\\n&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ch = getchar();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ch = %c\\n&quot;</span>, ch);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(ch)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;1&#x27;</span>: LED_RED;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;2&#x27;</span>: LED_GREEN;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;3&#x27;</span>: LED_BLUE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;4&#x27;</span>: LED_YELLOW;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;5&#x27;</span>: LED_PURPLE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;6&#x27;</span>: LED_CYAN;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;7&#x27;</span>: LED_WHITE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">default</span>: LED_RGBOFF;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"dma\">DMA</h2>\n<p>DMA: Direct Memory Access, 直接寄存器访问. 主要功能是可以把数据从一个地方搬到另一个地方, 而且不占用CPU</p>\n<ul>\n<li>DMA1: 有7个通道, 可实现P-&gt;M, M-&gt;P, M-&gt;M</li>\n<li>DMA2: 有5个通道, 可实现P-&gt;M, M-&gt;P, M-&gt;M(<em>只存在于大容量和互联型产品中</em>)</li>\n</ul>\n<h3 id=\"补充:-dma介绍\">补充: DMA介绍</h3>\n<p>DMA（Direct Memory Access，直接内存访问）是计算机系统中的一种技术，<strong>它允许外设或内存模块通过绕过中央处理器（CPU）直接与系统内存进行数据传输</strong>。DMA的目标是提高数据传输效率，减轻CPU的负担，使CPU能够专注于执行其他任务。</p>\n<p>以下是关于DMA的一些重要概念和特性：</p>\n<h4 id=\"dma的工作原理\">DMA的工作原理</h4>\n<p>DMA通过在系统总线上控制数据传输而不涉及CPU来工作。它可以在CPU不介入的情况下，直接将数据从一个位置传输到另一个位置。</p>\n<ol>\n<li>配置： CPU负责配置DMA，确定源地址、目标地址、传输方向、传输大小等参数。</li>\n<li>启动： 一旦DMA被配置，CPU就可以启动DMA控制器，它将负责管理数据传输。</li>\n<li>传输： DMA控制器在总线上控制数据传输，无需CPU的干预。数据在源和目标之间直接传输。</li>\n<li>中断通知： DMA传输完成后，通常会发出一个中断信号，以通知CPU或其他系统组件。</li>\n</ol>\n<h4 id=\"dma的优点\">DMA的优点</h4>\n<ol>\n<li>提高性能： 通过绕过CPU，减轻了CPU的负担，使其能够执行其他任务，提高了整体系统性能。</li>\n<li>实时数据传输： 特别适用于实时数据传输，如音频、视频流等。</li>\n<li>高效处理大量数据： 对于大量数据的块传输，DMA比CPU执行这样的传输更为高效。</li>\n</ol>\n<h4 id=\"dma的应用领域\">DMA的应用领域</h4>\n<p>DMA在多种应用场景中都得到了广泛应用，包括但不限于：</p>\n<ol>\n<li>嵌入式系统： 用于处理外设和内存之间的数据传输，例如，处理音频、图像等。</li>\n<li>网络通信： 在网络接口控制器和系统内存之间快速传输数据。</li>\n<li>存储系统： 用于在磁盘、固态硬盘等存储设备和系统内存之间进行数据传输。</li>\n<li>图形处理： 在图形卡和系统内存之间进行大规模图形数据的传输。</li>\n</ol>\n<h4 id=\"dma控制器\">DMA控制器</h4>\n<p>DMA通常由专门的硬件单元，称为DMA控制器，来管理。DMA控制器的设计和功能因芯片架构而异，但通常包括寄存器用于配置、启动和监视传输。</p>\n<p>总的来说，DMA是一项重要的技术，对于需要高效数据传输的系统是至关重要的。通过减轻CPU的负担，DMA提高了系统的整体性能和响应速度。</p>\n<h3 id=\"dma功能框图讲解\">DMA功能框图讲解</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261122722.png\" alt=\"DMA功能框图讲解\"></p>\n<h4 id=\"dma请求映射\">DMA请求映射</h4>\n<p>DMA1请求映射</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261126729.png\" alt=\"DMA1请求映射\"></p>\n<p>DMA2请求映射</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261127579.png\" alt=\"DMA2请求映射\"></p>\n<h4 id=\"dma仲裁器\">DMA仲裁器</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261128690.png\" alt=\"DMA仲裁器\"></p>\n<p>软件配置在寄存器DMA_CCRx:PL[1:0]进行通道优先级配置</p>\n<h3 id=\"dma固件库-初始化结构体\">DMA固件库-初始化结构体</h3>\n<p>初始化结构体在stm32f10x_dma.h文件中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  DMA Init structure definition</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 外设地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CPARx 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *---------------------------------------------------------------------------- */</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralBaseAddr; <span class=\"comment\">/*!&lt; Specifies the peripheral base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CMARx 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *---------------------------------------------------------------------------- */</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryBaseAddr;     <span class=\"comment\">/*!&lt; Specifies the memory base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 传输方向</span></span><br><span class=\"line\"><span class=\"comment\">   * P-&gt;M 和 M-&gt;P 由寄存器 DMA_CCRx:DIR[4] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   * M-&gt;M 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_DIR;                <span class=\"comment\">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 缓冲区大小, 传输数目</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CNDTRx 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_BufferSize;         <span class=\"comment\">/*!&lt; Specifies the buffer size, in data unit, of the specified Channel. </span></span><br><span class=\"line\"><span class=\"comment\">                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize</span></span><br><span class=\"line\"><span class=\"comment\">                                        or DMA_MemoryDataSize members depending in the transfer direction. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 外设增量模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:PINC[6] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralInc;      <span class=\"comment\">/*!&lt; Specifies whether the Peripheral address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器增量模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:MINC[7] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryInc;          <span class=\"comment\">/*!&lt; Specifies whether the memory address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 外设数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:PSIZE[9:8] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralDataSize; <span class=\"comment\">/*!&lt; Specifies the Peripheral data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:MSIZE[11:10] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryDataSize;     <span class=\"comment\">/*!&lt; Specifies the Memory data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 传输模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:CIRC[5] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   * 通过 DMA_ISR 判断传输状态来判断传输完成, 传输一半, 传输错误</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Mode;               <span class=\"comment\">/*!&lt; Specifies the operation mode of the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_circular_normal_mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                        @note: The circular buffer mode cannot be used if the memory-to-memory</span></span><br><span class=\"line\"><span class=\"comment\">                                              data transfer is configured on the selected Channel */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 优先级</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:PL[1:0] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Priority;           <span class=\"comment\">/*!&lt; Specifies the software priority for the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_priority_level */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*--------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 存储器到存储器模式</span></span><br><span class=\"line\"><span class=\"comment\">   * 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置</span></span><br><span class=\"line\"><span class=\"comment\">   *--------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_M2M;                <span class=\"comment\">/*!&lt; Specifies if the DMAy Channelx will be used in memory-to-memory transfer.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_to_memory */</span></span><br><span class=\"line\">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dma固件库-固件库函数\">DMA固件库-固件库函数</h3>\n<p>在stm32f10x_dma.h文件中可以找到DMA固件库函数的声明, 以下是常用的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DMA_Init</span><span class=\"params\">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>; <span class=\"comment\">// 初始化函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DMA_Cmd</span><span class=\"params\">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>; <span class=\"comment\">// 使能DMA</span></span><br><span class=\"line\">FlagStatus <span class=\"title function_\">DMA_GetFlagStatus</span><span class=\"params\">(<span class=\"type\">uint32_t</span> DMAy_FLAG)</span>; <span class=\"comment\">// 判断标志位</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"dma实验1:-m to m\">DMA实验1: M to M</h3>\n<p>项目地址: <strong>22-DMA-MtoM</strong></p>\n<p><strong>实验需求</strong>: FLASH to SRAM, 把内部FLASH的数据传输到内部的SRAM</p>\n<h4 id=\"在bsp_dma_m2mh增加宏定义\">在bsp_dma_m2m.h增加宏定义</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当使用存储器到存储器模式时候，通道可以随便选，没有硬性的规定</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> M2M_DMA_CHANNEL     DMA1_Channel6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> M2M_DMA_CLOCK       RCC_AHBPeriph_DMA1</span></span><br><span class=\"line\"><span class=\"comment\">// 传输完成标志</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> M2M_DMA_FLAG_TC     DMA1_FLAG_TC6</span></span><br><span class=\"line\"><span class=\"comment\">// 要发送的数据大小</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> BUFFER_SIZE     32</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2mc中定义源和目标变量\">在bsp_dma_m2m.c中定义源和目标变量</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 定义aSRC_Const_Buffer数组作为DMA传输数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * const关键字将aSRC_Const_Buffer数组变量定义为常量类型</span></span><br><span class=\"line\"><span class=\"comment\"> * 表示数据存储在内部的FLASH中</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE]= &#123;</span><br><span class=\"line\">                                    <span class=\"number\">0x01020304</span>,<span class=\"number\">0x05060708</span>,<span class=\"number\">0x090A0B0C</span>,<span class=\"number\">0x0D0E0F10</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x11121314</span>,<span class=\"number\">0x15161718</span>,<span class=\"number\">0x191A1B1C</span>,<span class=\"number\">0x1D1E1F20</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x21222324</span>,<span class=\"number\">0x25262728</span>,<span class=\"number\">0x292A2B2C</span>,<span class=\"number\">0x2D2E2F30</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x31323334</span>,<span class=\"number\">0x35363738</span>,<span class=\"number\">0x393A3B3C</span>,<span class=\"number\">0x3D3E3F40</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x41424344</span>,<span class=\"number\">0x45464748</span>,<span class=\"number\">0x494A4B4C</span>,<span class=\"number\">0x4D4E4F50</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x51525354</span>,<span class=\"number\">0x55565758</span>,<span class=\"number\">0x595A5B5C</span>,<span class=\"number\">0x5D5E5F60</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x61626364</span>,<span class=\"number\">0x65666768</span>,<span class=\"number\">0x696A6B6C</span>,<span class=\"number\">0x6D6E6F70</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0x71727374</span>,<span class=\"number\">0x75767778</span>,<span class=\"number\">0x797A7B7C</span>,<span class=\"number\">0x7D7E7F80</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义DMA传输目标存储器</span></span><br><span class=\"line\"><span class=\"comment\"> * 存储在内部的SRAM中                  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2mc中增加dma初始化函数\">在bsp_dma_m2m.c中增加DMA初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 配置存储器到存储器的DMA传输</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @return None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">M2M_DMA_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DMA_InitTypeDef DMA_InitStructure; <span class=\"comment\">// 定义DMA初始化结构体变量</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    RCC_AHBPeriphClockCmd(M2M_DMA_CLOCK, ENABLE); <span class=\"comment\">// 打开DMA时钟</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class=\"type\">uint32_t</span>)aSRC_Const_Buffer; <span class=\"comment\">// 配置外设地址, 实际将FLASH的数据配置成了外设</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryBaseAddr = (<span class=\"type\">uint32_t</span>)aDST_Buffer; <span class=\"comment\">// 配置存储器地址</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; <span class=\"comment\">// 配置传输方向，从外设读取数据发送到存储器</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE; <span class=\"comment\">// 配置传输数据大小</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable; <span class=\"comment\">// 配置外设地址自增</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; <span class=\"comment\">// 配置存储器地址自增</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; <span class=\"comment\">// 配置外设数据大小</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; <span class=\"comment\">// 配置存储器数据大小</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; <span class=\"comment\">// 配置传输模式，非循环模式</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Priority = DMA_Priority_High; <span class=\"comment\">// 配置传输通道优先级</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; <span class=\"comment\">// 配置存储器到存储器模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DMA_Init(M2M_DMA_CHANNEL, &amp;DMA_InitStructure); <span class=\"comment\">// 初始化DMA通道</span></span><br><span class=\"line\">    DMA_ClearFlag(M2M_DMA_FLAG_TC); <span class=\"comment\">// 清除DMA通道传输完成标志位</span></span><br><span class=\"line\">    DMA_Cmd(M2M_DMA_CHANNEL, ENABLE); <span class=\"comment\">// 使能DMA通道</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2mc中增加判断数据相等的函数\">在bsp_dma_m2m.c中增加判断数据相等的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 比较两个缓冲区的数据是否相等</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @param pBuffer 指向第一个缓冲区的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pBuffer1 指向第二个缓冲区的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param BufferLength 缓冲区的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return uint8_t 如果两个缓冲区的数据相等，则返回1；否则返回0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">Buffercmp</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uint32_t</span>* pBuffer, <span class=\"type\">uint32_t</span>* pBuffer1, <span class=\"type\">uint16_t</span> BufferLength)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 数据长度递减 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(BufferLength--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 判断两个数据源是否对应相等 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*pBuffer != *pBuffer1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 对应数据源不相等马上退出函数，并返回0 */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 递增两个数据源的地址指针 */</span></span><br><span class=\"line\">        pBuffer++;</span><br><span class=\"line\">        pBuffer1++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 完成判断并且对应数据相对 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc函数中进行dma测试\">在main.c函数中进行DMA测试</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明以下变量来自外部文件</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> <span class=\"type\">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE];</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Delays the execution for a specified number of milliseconds.(Not Sure)</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ms The number of milliseconds to delay.</span></span><br><span class=\"line\"><span class=\"comment\"> * @return None.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay_ms</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; ms; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">uint16_t</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> status = <span class=\"number\">0</span>; <span class=\"comment\">// 接收比较的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// 初始化LED</span></span><br><span class=\"line\">    M2M_DMA_Config(); <span class=\"comment\">// 初始化DMA</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">// 等待DMA1传送完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(DMA_GetFlagStatus(M2M_DMA_FLAG_TC) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LED_YELLOW;</span><br><span class=\"line\">    Delay_ms(<span class=\"number\">10000</span>); <span class=\"comment\">// DMA初始化完成后亮黄灯</span></span><br><span class=\"line\"></span><br><span class=\"line\">    status = Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE); <span class=\"comment\">// 比较两个数组的数据是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(status == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_RED; <span class=\"comment\">// 数据不相等亮红灯</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED_GREEN; <span class=\"comment\">// 数据相等亮绿灯</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dma实验2:-m to p\">DMA实验2: M to P</h3>\n<p>项目地址: <strong>22-DMA-MtoP</strong></p>\n<p><strong>实验需求</strong>: SRAM to 串口, 同时LED灯闪烁, 演示DMA数据不需占用CPU</p>\n<h3 id=\"在bsp_dma_m2ph中加入宏定义\">在bsp_dma_m2p.h中加入宏定义</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 串口工作参数宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USARTx                   USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_CLK                RCC_APB2Periph_USART1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// USART GPIO 引脚宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USART_TX_DMA_CLK RCC_AHBPeriph_DMA1 <span class=\"comment\">// 串口DMA时钟</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  USART_TX_DMA_CHANNEL     DMA1_Channel4 <span class=\"comment\">// 串口对应的DMA请求通道</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  USART_DR_ADDRESS        (USART1_BASE+0x04) <span class=\"comment\">// 外设寄存器地址</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  SENDBUFF_SIZE            5000 <span class=\"comment\">// 一次发送的数据量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  USART_TX_DMA_FLAG_TC DMA1_FLAG_TC4 <span class=\"comment\">// 标志位</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2pc中加入usart的初始化函数\">在bsp_dma_m2p.c中加入USART的初始化函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USART_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    USART_InitTypeDef USART_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口GPIO的时钟</span></span><br><span class=\"line\">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开串口外设的时钟</span></span><br><span class=\"line\">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class=\"line\">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 配置串口的工作参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 配置波特率</span></span><br><span class=\"line\">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">// 配置 针数据字长</span></span><br><span class=\"line\">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class=\"line\">    <span class=\"comment\">// 配置停止位</span></span><br><span class=\"line\">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class=\"line\">    <span class=\"comment\">// 配置校验位</span></span><br><span class=\"line\">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class=\"line\">    <span class=\"comment\">// 配置硬件流控制</span></span><br><span class=\"line\">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class=\"line\">    <span class=\"comment\">// 配置工作模式，收发一起</span></span><br><span class=\"line\">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class=\"line\">    <span class=\"comment\">// 完成串口的初始化配置</span></span><br><span class=\"line\">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使能串口</span></span><br><span class=\"line\">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2pc中加入usartx_tx-dma配置\">在bsp_dma_m2p.c中加入USARTx_TX DMA配置</h4>\n<p>实现内存到外设(USART1-&gt;DR)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  USARTx TX DMA 配置，内存到外设(USART1-&gt;DR)</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">USARTx_DMA_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 开启DMA时钟</span></span><br><span class=\"line\">    RCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">// 设置DMA源地址：串口数据寄存器地址*/</span></span><br><span class=\"line\">       DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;</span><br><span class=\"line\">    <span class=\"comment\">// 内存地址(要传输的变量的指针)</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff;</span><br><span class=\"line\">    <span class=\"comment\">// 方向：从内存到外设 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;</span><br><span class=\"line\">    <span class=\"comment\">// 传输大小 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;</span><br><span class=\"line\">    <span class=\"comment\">// 外设地址不增     </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class=\"line\">    <span class=\"comment\">// 内存地址自增</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class=\"line\">    <span class=\"comment\">// 外设数据单位 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class=\"line\">    <span class=\"comment\">// 内存数据单位</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  </span><br><span class=\"line\">    <span class=\"comment\">// DMA模式，一次或者循环模式</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;</span><br><span class=\"line\">    <span class=\"comment\">// DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; </span></span><br><span class=\"line\">    <span class=\"comment\">// 优先级：中 </span></span><br><span class=\"line\">    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; </span><br><span class=\"line\">    <span class=\"comment\">// 禁止内存到内存的传输</span></span><br><span class=\"line\">    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class=\"line\">    <span class=\"comment\">// 配置DMA通道     </span></span><br><span class=\"line\">    DMA_Init(USART_TX_DMA_CHANNEL, &amp;DMA_InitStructure);  </span><br><span class=\"line\">    <span class=\"comment\">// 清除TC标志位</span></span><br><span class=\"line\">    DMA_ClearFlag(USART_TX_DMA_FLAG_TC);</span><br><span class=\"line\">    <span class=\"comment\">// 使能DMA</span></span><br><span class=\"line\">    DMA_Cmd (USART_TX_DMA_CHANNEL, ENABLE);</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_dma_m2pc中声明在内存的变量\">在bsp_dma_m2p.c中声明在内存的变量</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中声明外部变量\">在main.c中声明外部变量</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中测试dma\">在main.c中测试DMA</h4>\n<p>实现DMA将储存器中的数据发送到USART-&gt;DR, 并实现LED1闪烁</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 实现DMA将储存器中的数据发送到USART-&gt;DR, 并实现LED1闪烁</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * @return int </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LED_GPIO_Config(); <span class=\"comment\">// 初始化LED</span></span><br><span class=\"line\">    USART_Config(); <span class=\"comment\">// 串口初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">uint16_t</span> i = <span class=\"number\">0</span>; i &lt; SENDBUFF_SIZE; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SendBuff[i] = <span class=\"string\">&#x27;P&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    USARTx_DMA_Config(); <span class=\"comment\">// 初始化DMA</span></span><br><span class=\"line\">    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); <span class=\"comment\">// 使能DMA发送</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LED1_TOGGLE;</span><br><span class=\"line\">        Delay_ms(<span class=\"number\">10000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用存储器\">常用存储器</h2>\n<h3 id=\"存储器的种类\">存储器的种类</h3>\n<p>易失性和非易失性区别在于<strong>掉电数据是否会丢失</strong>, 易失性存储器<strong>读写速度相对较快</strong></p>\n<ul>\n<li>易失性存储器(RAM)\n<ul>\n<li>DRAM(动态RAM, 常用于PC机)\n<ul>\n<li>SDRAM(STM32F429)</li>\n<li>DDR SDRAM</li>\n<li>DDRII SDRAM</li>\n<li>DDRIII SDRAM(常用于PC机)</li>\n</ul>\n</li>\n<li>SRAM(静态RAM, STM32F103)</li>\n</ul>\n</li>\n<li>非易失性存储器\n<ul>\n<li>ROM(半导体类)\n<ul>\n<li>MASK ROM(对于STM32可读不可写)</li>\n<li>PROM(可编程ROM)\n<ul>\n<li>OTPROM(可写一次的ROM)</li>\n<li>EPROM(可用高电压擦除的ROM)</li>\n<li>EEPROM(STM32F103, 可用较低电压3.3V擦除的ROM)</li>\n</ul>\n</li>\n<li>FLASH(半导体类)</li>\n<li>NOR FLASH(一般用来存储程序)</li>\n<li>NAND FLASH(一般用来存储数据)</li>\n<li>光盘</li>\n<li>软盘</li>\n<li>机械硬盘</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ram存储器(易失性存储器)\">RAM存储器(易失性存储器)</h3>\n<h4 id=\"ram介绍\">RAM介绍</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262322421.png\" alt=\"RAM介绍\"></p>\n<h4 id=\"dram的存储单元结构\">DRAM的存储单元结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262327533.png\" alt=\"DRAM的存储单元结构\"></p>\n<p><strong>DRAM通过电容充放电与MOS管配合产生高低电平</strong>, 需要配合电平检测阈值来减少电容漏电带来的影响</p>\n<h4 id=\"sram的存储单元结构\">SRAM的存储单元结构</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262328328.png\" alt=\"SRAM的存储单元结构\"></p>\n<p><strong>SRAM以锁存器结构来存储数据</strong>, 锁存器结构在没有输入的情况下会一直保持原来的状态</p>\n<h4 id=\"sram和dram的比较\">SRAM和DRAM的比较</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262336065.png\" alt=\"SRAM和DRAM的比较\"></p>\n<p>SDRAM使用同步通信方式</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262341860.png\" alt=\"SDRAM同步通信\"></p>\n<p>SRAM使用异步方式通信</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270000903.png\" alt=\"SRAM异步通信\"></p>\n<h3 id=\"非易失性存储器\">非易失性存储器</h3>\n<h4 id=\"rom简介\">ROM简介</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270001764.png\" alt=\"ROM简介\"></p>\n<h4 id=\"flash简介\">FLASH简介</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270007166.png\" alt=\"FLASH简介\"></p>\n<p>在嵌入式开发中选择 NOR FLASH 主要因为坏区较少, 基于字节读写可以支持XIP</p>\n<p>XIP(Execute In Place，就地执行)功能，它是一种特性，允许直接从 Flash 存储器中执行代码，而无需将代码首先复制到RAM中。XIP功能在嵌入式系统中很常见，它带来了一些优势，包括更少的RAM使用和更快的启动速度</p>\n<p>与ROM不同, FLASH必须先按块擦除数据后才能写入数据</p>\n<h2 id=\"i2c-读写eeprom\">I2C-读写EEPROM</h2>\n<h3 id=\"补充:-i2c简介\">补充: I2C简介</h3>\n<p>I2C（Inter-Integrated Circuit）是一种串行通信协议，<strong>用于在集成电路之间进行短距离通信</strong> I2C 由飞利浦公司（Philips）于1982年开发，并且现在由多家公司支持和采用。该协议通常用于连接芯片、传感器、存储器、外设等设备。</p>\n<p>以下是 I2C 协议的一些关键特点和基本概念：</p>\n<ol>\n<li>总线结构\n<ul>\n<li>主从结构： I2C 使用主从结构，其中一个设备充当主设备（通常是微控制器或处理器），而其他设备则充当从设备。主设备负责发起通信和生成时钟信号。</li>\n<li>双线制： I2C 使用两根线，一根是数据线（SDA），另一根是时钟线（SCL）。这两根线上都有上拉电阻，以便在设备不主动拉低时保持高电平。</li>\n</ul>\n</li>\n<li>数据传输：\n<ul>\n<li>起始和停止条件： 数据传输始于主设备发送起始条件（Start Condition），并以主设备发送停止条件（Stop Condition）结束。这两个条件都是由主设备在总线上生成的。</li>\n<li>地址帧： 每个数据传输都以地址帧开始，其中包含目标设备的地址和读写位。地址帧由主设备发送。</li>\n<li>数据帧： 在地址帧之后是一个或多个数据帧，其中包含实际的数据。数据帧的传输由主设备和从设备之间交替进行。</li>\n<li>应答（Acknowledge）： 在每个数据帧之后，接收方发送一个应答信号，通常是一个低电平，以确认数据的接收。</li>\n</ul>\n</li>\n<li>速率和模式：\n<ul>\n<li>速率： I2C 支持不同的传输速率，常见的有 100 kHz、400 kHz 和 1 MHz 等。</li>\n<li>模式： I2C 支持标准模式（100 kHz），快速模式（400 kHz），高速模式（1 MHz）等不同的工作模式。</li>\n</ul>\n</li>\n<li>多主设备和重复启动：\n<ul>\n<li>多主设备： I2C 支持多主设备共享同一总线。主设备之间通过仲裁（Arbitration）来确定哪个主设备能够继续发送。</li>\n<li>重复启动： 主设备可以在一个传输结束后发送重复启动条件，而无需先发送停止条件，从而在同一次通信中与另一个从设备建立连接。</li>\n</ul>\n</li>\n<li>I2C设备地址：\n<ul>\n<li>7位或10位地址： I2C 设备使用 7 位或 10 位地址来识别自己。大多数设备使用 7 位地址。</li>\n</ul>\n</li>\n</ol>\n<p>I2C 协议的简洁性和灵活性使得它在连接各种设备和传感器时非常有用，尤其是在嵌入式系统中。</p>\n<h3 id=\"补充:-高阻态\">补充: 高阻态</h3>\n<p>在嵌入式领域中，高阻态的概念同样非常重要，并涉及到数字电路设计和信号完整性的方面。以下是在嵌入式系统中高阻态的一些关键应用和概念：</p>\n<ol>\n<li>输入端口的高阻态： 很多嵌入式系统包括微控制器或微处理器，<strong>其输入端口通常具有高阻抗特性。这意味着当输入端口未连接到任何外部设备时，输入端口会处于高阻态状态。这有助于避免在未连接设备时引入不必要的电流，同时防止信号线上的悬空状态(floating)</strong>。</li>\n<li>悬空输入的高阻态： 在数字电路中，当一个输入端未连接时，它被称为悬空输入。在悬空输入的情况下，该输入端常常设计为高阻态，以减少对电路的干扰和功耗。</li>\n<li>总线冲突的高阻态： <strong>在多主设备共享总线的系统中，当多个主设备尝试在同一时刻传输数据时可能会发生总线冲突。为了避免冲突设备之间的干扰，某些设备在冲突时会将总线设置为高阻态，以允许其他设备继续操作</strong>。</li>\n<li>三态逻辑门： 一些数字逻辑门（如三态门）具有高阻态输出。这允许将多个门连接到同一总线上，当其中一个门处于高阻态时，其他门仍能够正常工作。</li>\n<li>输入缓冲器的高阻态： 在输入缓冲器中，当输入未被有效驱动时，输入缓冲器通常进入高阻态，以避免对电路产生负面影响。</li>\n</ol>\n<p>在这些情况下，高阻态的概念有助于确保电路在非活动状态时不引入不必要的电流，提高系统的稳定性和可靠性。这对于嵌入式系统中对功耗、信号完整性和总线冲突等方面的考虑非常重要。</p>\n<h3 id=\"i2c物理层\">I2C物理层</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270111246.png\" alt=\"I2C物理层\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270140896.png\" alt=\"I2C物理层\"></p>\n<h4 id=\"i2c物理层主要特点\">I2C物理层主要特点</h4>\n<ul>\n<li>I2C是支持多设备的总线, 可支持多个通讯主机和从机</li>\n<li>I2C使用两条线路, 一条SDA(双向串行数据线)来表示数据, 一条SCL(串行时钟线)来同步数据, 属于同步通信</li>\n<li>连接到总线的设备分配独立地址(7位或10位)</li>\n<li>总线接上拉电阻到电源(一般4.7KΩ, 具体看手册)\n<ol>\n<li>当设备空闲时输出高阻态<em>防止短路总线上的其他接地设备</em></li>\n<li>当所有设备都空闲时全部输出高阻态, 可通过上拉电阻把总线拉到高电平</li>\n<li>输出高阻态的特性需要GPIO的开漏输出</li>\n</ol>\n</li>\n<li>多设备占用总线会仲裁</li>\n<li>具有三种传输速度模式, <strong>实际开发中可使用低于最高速的速度, 协调总线设备速度一致即可</strong></li>\n<li>I2C可接入的设备数量受到最大电容负载的限制, 一般为400pF, <em>也就是说总线上的设备数量越多, 传输速度越慢</em></li>\n</ul>\n<h3 id=\"i2c协议层\">I2C协议层</h3>\n<p>I2C协议定义了<strong>通讯的起始和停止信号, 数据有效性, 响应, 仲裁, 时钟同步和地址广播等环节</strong></p>\n<h4 id=\"i2c基本读写过程\">I2C基本读写过程</h4>\n<h5 id=\"主机写数据到从机\">主机写数据到从机</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270157626.png\" alt=\"I2C基本读写过程\"></p>\n<ol>\n<li>S: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 主机传输需要通信的从机地址</li>\n<li>R/!W: 主机传输读或写信号, <em>若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据</em></li>\n<li>A: 从机传输响应</li>\n<li>DATA: 主机传输数据段</li>\n<li>A: 从机响应</li>\n<li>DATA: 主机继续发送数据段</li>\n<li>A/!A: 从机响应是否继续接收</li>\n<li>P: 若从机响应不继续接收, 则主机传输停止位</li>\n</ol>\n<h5 id=\"主机由从机读数据\">主机由从机读数据</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270207508.png\" alt=\"I2C基本读写过程\"></p>\n<ol>\n<li>S: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 主机传输需要通信的从机地址</li>\n<li>R/!W: 主机传输读或写信号, <em>若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据</em></li>\n<li>A: 从机传输响应</li>\n<li>DATA: 从机传输数据段</li>\n<li>A: 主机响应</li>\n<li>DATA: 从机继续发送数据段</li>\n<li>A/!A: 主机响应是否继续接收</li>\n<li>P: 若主机响应不继续接收, 则主机传输停止位</li>\n</ol>\n<p>注意:</p>\n<ul>\n<li>S: 开始信号只能由主机产生</li>\n<li>SLAVE ADDRESS: 进行通信的从机地址只能由主机产生</li>\n<li>R/!W: 读/写信号只能由主机产生</li>\n<li>P: 停止信号只能由主机产生</li>\n<li>DATA 和 A: 数据段和响应段由主机和从机交替产生, 具体由主机和从机的读写决定</li>\n</ul>\n<h5 id=\"通信复合格式\">通信复合格式</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270209992.png\" alt=\"通信复合格式\"></p>\n<p>常用的复合通信的方法, <strong>即先写入外设地址后将外设的寄存器地址返回进行读取</strong></p>\n<ul>\n<li>S: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 进行通信的从机地址(一般为外设)</li>\n<li>R/W!: 一般为写操作</li>\n<li>DATA: 写入的外设地址</li>\n<li>A/A!: 从机响应</li>\n<li>Sr: 主机传输开始信号</li>\n<li>SLAVE ADDRESS: 进行通信的从机地址(一般为同一个外设)</li>\n<li>R/W!: 一般为读操作</li>\n<li>DATA: 读取外设的寄存器的具体地址</li>\n<li>A/A!: 逐个字节进行读取外设每个寄存器的地址并做出响应</li>\n<li>P: 全部读取完毕后主机传输停止信号</li>\n</ul>\n<h4 id=\"通讯的起始和停止信号\">通讯的起始和停止信号</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270225648.png\" alt=\"通讯的起始和停止信号\"></p>\n<ul>\n<li>起始信号: <strong>SCL高电平, SDA由高电平向低电平转换</strong></li>\n<li>停止信号: <strong>SCL高电平, SDA由低电平向高电平转换</strong></li>\n</ul>\n<h4 id=\"数据的有效性\">数据的有效性</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270237788.png\" alt=\"数据有效性\"></p>\n<ul>\n<li>SDA: 负责传输数据</li>\n<li>SCL: 高电平时采集SDA上1bit数据, 低电平时SDA进行电平转换</li>\n</ul>\n<h4 id=\"地址及数据方向\">地址及数据方向</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270243764.png\" alt=\"地址及数据方向\"></p>\n<p>I2C采用高位先行, 由高位到低位进行传输</p>\n<p>一般使用7位表示I2C上的设备地址, 设备地址加上其后的读写位可以凑成8位即1字节方便传输</p>\n<p>例如, 某设备在I2C上的设备地址为7位的0x78(0b01111000), 可加入读写位凑到八位</p>\n<ul>\n<li>8位设备的读地址位为0xF1(0b11110001)</li>\n<li>8位设备的写地址位为0xF0(0b11110000)</li>\n</ul>\n<h4 id=\"响应\">响应</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270254565.png\" alt=\"响应\"></p>\n<ol>\n<li>1-8个时钟信号中: 数据发送端控制SDA传输7位设备地址和1位读写信号</li>\n<li>在第9个时钟信号时: 数据接收端获得SDA控制权, 发送应答信号(低电平表示应答)</li>\n</ol>\n<h3 id=\"stm32的i2c特性及架构\">STM32的I2C特性及架构</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270305500.png\" alt=\"STM32的I2C特性及架构\"></p>\n<ul>\n<li>软件模拟协议: 较为繁琐</li>\n<li>硬件模拟协议: 较为方便, 减轻CPU负担</li>\n</ul>\n<p>注: <em>STM32硬件的I2C逻辑可能会有问题</em></p>\n<h4 id=\"stm32的i2c架构分析\">STM32的I2C架构分析</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270315440.png\" alt=\"STM32的I2C架构分析\"></p>\n<h5 id=\"i2c的通讯引脚\">I2C的通讯引脚</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270346561.png\" alt=\"I2C的通讯引脚\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270316720.png\" alt=\"I2C的通讯引脚\"></p>\n<p>勘误: <em>I2C1_SCL默认映射到PB5, I2C1_SDA默认映射到PB7, 图片中有误</em></p>\n<p>STM32兼容smbus协议</p>\n<h5 id=\"时钟控制逻辑\">时钟控制逻辑</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347794.png\" alt=\"时钟控制逻辑\"><br>\n<img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270325594.png\" alt=\"时钟控制逻辑\"></p>\n<p>注: <em>Tpck1: 指的是APB1时钟周期(1/36MHz)</em></p>\n<h6 id=\"计算时钟频率的方法\">计算时钟频率的方法</h6>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270333989.png\" alt=\"计算时钟频率的方法\"></p>\n<p>实际就是解未知数CCR的一元一次方程</p>\n<h5 id=\"数据控制逻辑\">数据控制逻辑</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347332.png\" alt=\"数据控制逻辑\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270337311.png\" alt=\"数据控制逻辑\"></p>\n<ol>\n<li>将8位数据写入数据寄存器(DR)</li>\n<li>数据寄存器里面的数据会被发送到数据移位寄存器</li>\n</ol>\n<h5 id=\"整体控制逻辑\">整体控制逻辑</h5>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270348369.png\" alt=\"整体控制逻辑\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270355991.png\" alt=\"整体控制逻辑\"></p>\n<h3 id=\"stm32硬件i2c的通讯过程\">STM32硬件I2C的通讯过程</h3>\n<h4 id=\"stm32作为主发送器的通讯过程\">STM32作为主发送器的通讯过程</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270357886.png\" alt=\"STM32作为主发送器的通讯过程\"></p>\n<p>勘误: <em>EV8_2: TxE=1, BTF=1, 请求设置停止位. TxE和BTF位由硬件在产生停止条件时清除</em></p>\n<ul>\n<li>EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)</li>\n<li>EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)</li>\n<li>EV8: 在正常数据发送完毕后会产生EV8事件(I2C_SRx:TxE[7]置1表示数据寄存器空)</li>\n<li>EV8_2: 在从机发送结束应答后会产生EV8_2事件(I2C_SRx:TxE[7]置1表示数据寄存器空, I2C_SRx:BTF[2]置1表示字节发送结束, I2C_CRx:STOP[9]置1表示在当前字节传输或在当前起始条件发出后产生停止条件, 产生停止条件后由硬件清除TxE和BTF位)</li>\n</ul>\n<h4 id=\"stm32作为主接收器的通讯过程\">STM32作为主接收器的通讯过程</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270423471.png\" alt=\"STM32作为主接收器的通讯过程\"></p>\n<p>勘误: <em>EV7_1: RxNE=1, 读DR寄存器清除该事件. 设置ACK=0和STOP请求</em></p>\n<ul>\n<li>EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)</li>\n<li>EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)</li>\n<li>EV7: 在正常数据发送完毕后会产生EV7事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空)</li>\n<li>EV7_1: 在主机发送结束应答后会产生EV7_1事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空, I2C_CRx:ACK[10]置0表示设置为无应答返回, I2C_CRx:STOP[9]置1表示在当前字节传输或释放SCL和SDA线)</li>\n</ul>\n<p>每个状态标志位的清除方法各不相同, 使用库函数的方法可以较方便的清除寄存器的标志位</p>\n<h3 id=\"i2c初始化结构体\">I2C初始化结构体</h3>\n<p>在stm32f10x_i2c.h中定义I2C初始化结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  I2C Init structure definition  </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置时钟频率</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置I2C的传输速率, 函数根据该值经过运算后写入I2C_CCR寄存器</span></span><br><span class=\"line\"><span class=\"comment\">   * 不得高于400kHz, 即400 000</span></span><br><span class=\"line\"><span class=\"comment\">   * 由于I2C_CCR寄存器不能写入浮点数, 可能会导致实际速率小于设定的传输速率参数</span></span><br><span class=\"line\"><span class=\"comment\">   * 使得通讯稍慢, 但是并不会对I2C的通讯造成其他影响</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> I2C_ClockSpeed;          <span class=\"comment\">/*!&lt; Specifies the clock frequency.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter must be set to a value lower than 400kHz */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置I2C的模式</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Mode_I2C: 标准I2C模式</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Mode_SMBusDevice: SMBus设备模式</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Mode_SMBusHost: SMBus主机模式</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_Mode;                <span class=\"comment\">/*!&lt; Specifies the I2C mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 设置I2C的SCL时钟的占空比</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_DutyCycle_16_9: Tlow/Thigh = 16:9</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_DutyCycle_2: Tlow/Thigh = 2:1</span></span><br><span class=\"line\"><span class=\"comment\">   * 这两个选项差别不大, 开发中一般不会进行严格区分</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_DutyCycle;           <span class=\"comment\">/*!&lt; Specifies the I2C fast mode duty cycle.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 配置STM32的I2C设备自己的地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 此参数可以是 7 位或 10 位地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 第二个地址可以通过函数I2C_OwnAddress2Config进行配置, 只能是7位地址</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_OwnAddress1;         <span class=\"comment\">/*!&lt; Specifies the first device own address.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a 7-bit or 10-bit address. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 配置I2C应答是否使能</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Ack_Enable: 允许应答使能</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_Ack_Disable: 禁止应答使能</span></span><br><span class=\"line\"><span class=\"comment\">   * 一般配置为允许应答使能, 改为禁止应答使能往往会导致通讯错误</span></span><br><span class=\"line\"><span class=\"comment\">   *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_Ack;                 <span class=\"comment\">/*!&lt; Enables or disables the acknowledgement.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_acknowledgement */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*---------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">   * 配置I2C的寻址长度</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_AcknowledgedAddress_7bit: 7位地址</span></span><br><span class=\"line\"><span class=\"comment\">   * I2C_AcknowledgedAddress_10bit: 10位地址</span></span><br><span class=\"line\"><span class=\"comment\">   * 需要根据连接到I2C总线上的设备进行选择, 确保地址长度一致, 才能进行通信</span></span><br><span class=\"line\"><span class=\"comment\">   * 只有I2C_OwnAddress1才能配置10位地址, I2C_OwnAddress2只支持7位地址 *-------------------------------------------------------------------------------*/</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> I2C_AcknowledgedAddress; <span class=\"comment\">/*!&lt; Specifies if 7-bit or 10-bit address is acknowledged.</span></span><br><span class=\"line\"><span class=\"comment\">                                         This parameter can be a value of @ref I2C_acknowledged_address */</span></span><br><span class=\"line\">&#125;I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<h3 id=\"i2c库函数\">I2C库函数</h3>\n<h4 id=\"i2c_generatestart函数,-用于产生起始条件\">I2C_GenerateSTART函数, 用于产生起始条件</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271607885.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_getflagstatus函数,-用于获取状态位\">I2C_GetFlagStatus函数, 用于获取状态位</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271610721.png\" alt=\"I2C库函数\"></p>\n<p>I2C_FLAG参数列表对应I2C_SRx状态寄存器的各个位, 可通过查询手册查看其含义</p>\n<p>返回值说明</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271612900.png\" alt=\"返回值说明\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span>RESET = <span class=\"number\">0</span>, SET = !RESET&#125; FlagStatus, ITStatus;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>RESET: 0, 返回RESET表示该状态位为0</li>\n<li>SET: 1, 返回SET表示该状态位为1</li>\n</ul>\n<h4 id=\"i2c_send7bitaddress函数,-用于发送7位地址\">I2C_Send7bitAddress函数, 用于发送7位地址</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271616560.png\" alt=\"I2C库函数\"></p>\n<p>参数Address为八位读/写地址, 通过I2C_Direction实际配置读写方向, 最终方向以I2C_Direction配置为准, 参数Address的读写位失效</p>\n<h4 id=\"i2c_senddate函数,-通过i2cx外设发送数据字节\">I2C_SendDate函数, 通过I2Cx外设发送数据字节</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271618557.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_receivedata函数,-返回 i2cx 外设最近接收的数据\">I2C_ReceiveData函数, 返回 I2Cx 外设最近接收的数据</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271622473.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"acknowledgeconfig函数,-使能或禁用i2c的应答\">AcknowledgeConfig函数, 使能或禁用I2C的应答</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271623317.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_cmd函数,-使能或禁用i2cx外设\">I2C_Cmd函数, 使能或禁用I2Cx外设</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271625131.png\" alt=\"I2C库函数\"></p>\n<h4 id=\"i2c_checkevent函数,-i2c状态监测函数\">I2C_CheckEvent函数, I2C状态监测函数</h4>\n<p>监测的事件发生则返回SUCCESS</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280036252.png\" alt=\"I2C库函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037103.png\" alt=\"I2C_CheckEvent函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037758.png\" alt=\"I2C_CheckEvent函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038783.png\" alt=\"I2C_CheckEvent函数\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038105.png\" alt=\"I2C_CheckEvent函数\"></p>\n<h3 id=\"eeprom硬件结构\">EEPROM硬件结构</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271630443.png\" alt=\"EEPROM\"></p>\n<h4 id=\"引脚说明\">引脚说明</h4>\n<ul>\n<li>VCC: 电源引脚, 接3V3</li>\n<li>GND: 地引脚, 接地</li>\n<li>SCL: 时钟线, 经2.2K上拉电阻接3V3, 接PB6引脚(默认映射I2C1_SCL)</li>\n<li>SDA: 数据线, 经2,2K上拉电阻接3V3, 接PB7引脚(默认映射I2C1_SDA)</li>\n<li>HOLD: WP引脚, 接地, 不启用写保护(即可向AT24C02写数据)</li>\n<li>A0-A2: 地址引脚, 接地, A0:A2为000, 如需拓展EEPROM则可通过配置A0-A2的地址引脚来进行区分(如: 配置A0:A2为001, 则可对两EEPROM进行区分)</li>\n</ul>\n<h3 id=\"at24c02介绍\">AT24C02介绍</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271642465.png\" alt=\"AT24C02\"></p>\n<p>AT24C02可存储256字节数据</p>\n<h4 id=\"at24c02引脚说明\">AT24C02引脚说明</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271648925.png\" alt=\"AT24C02\"></p>\n<ul>\n<li>A0-A2: AT24C02用来区分不同AT24C0x芯片的设备地址</li>\n<li>SDA: 数据线</li>\n<li>SCL: 时钟线</li>\n<li>WP: 写保护, 置1启用写保护</li>\n<li>NC: 不连接</li>\n</ul>\n<h4 id=\"at24c02设备地址\">AT24C02设备地址</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702961.png\" alt=\"设备地址\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702718.png\" alt=\"设备地址\"></p>\n<p>AT24C02有256字节, 即属于2K(256*8)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271701248.png\" alt=\"设备地址\"></p>\n<p>根据原理图, 将A2-A0均接地, 则A2 = A1 = A0 = 0</p>\n<p>AT24C02的地址为0b1010000R/W, Bit0为R/!W位</p>\n<ul>\n<li>AT24C02在A2:A1[000]情况下读地址: 0b10100001(0xA1)</li>\n<li>AT24C02在A2:A1[000]情况下写地址: 0b10100000(0xA0)</li>\n</ul>\n<h4 id=\"at24c02的byte-write(以字节方式写数据)操作\">AT24C02的Byte Write(以字节方式写数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271719435.png\" alt=\"Byte Write\"></p>\n<p>第一个传输的数据段(DATA)为WORD ADDRESS(需要写入的字节所在的地址), 第二次传输数据段(DATA)才为真正需要写入的内容</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271723653.png\" alt=\"Byte Write\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Byte Write的工作流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. 在发送完SLAVE ADDRESS和W/!R后, 需要发送一个字节的数据地址(WORD ADDRESS)(即需要写入的字节所在的地址)</span><br><span class=\"line\">2. 收到地址(WORD ADDRESS)后, EEPROM会响应ACK, 然后接收一个字节的数据(DATA)(真正要写入的内容)</span><br><span class=\"line\">3. 接收到数据(DATA)后, EEPROM响应ACK, 单片机必须发送STOP信号, 不能继续传输第二段数据(给EEPROM预留写入时间)</span><br><span class=\"line\">4. 接收到停止信号后, EEPROM在tWR的周期时间内进行向内部写入数据</span><br><span class=\"line\">5. 在此写入周期中, 所有输入被禁用, EEPROM不进行响应</span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的page-write(以页方式写数据)操作\">AT24C02的Page Write(以页方式写数据)操作</h4>\n<p>又称突发写入(即仅发送一个地址可写入多个数据)</p>\n<p>Page Write解决了Byte Write不能连续写入的缺陷</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271734727.png\" alt=\"Page Write\"></p>\n<ul>\n<li>WORD ADDRESS(n): 数据的起始地址</li>\n<li>DATA(n): 写入到WORD ADDRESS(n)中</li>\n<li>DATA(n+1): 写入到WORD ADDRESS(n+1)中</li>\n<li>DATA(n+x): 写入到WORD ADDRESS(n+x)中</li>\n</ul>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271741445.png\" alt=\"Page Write\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Page Write工作流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. AT24C02能以8字节进行Page Write</span><br><span class=\"line\">2. 与Byte Write类似, 第一个字节是数据地址(WORD ADDRESS)(即需要写入的字节所在的地址), 在接受到第二个字节(DATA)后不会要求单片机发送STOP信号</span><br><span class=\"line\">3. 相反, EEPROM在接收到第一个DATA(真正要写入的数据)后, 对于AT24C02来说, 能再最多传输7个DATA</span><br><span class=\"line\">4. EEPROM每接收到一个数据位都会响应ACK, 单片机必须发送停止信号来结束Page Writting</span><br><span class=\"line\">5. 收到每个DATA后, 对于AT24C02来说, 数据地址(WORD ADDRESS)的低三位会递增(低三位的取值情况为2<span class=\"built_in\">^</span>3 = 8, 即8字节)</span><br><span class=\"line\">6. 高位地址不会递增, 从而保证原来的初始数据地址不发生改变(确保低三位正确递增)</span><br><span class=\"line\">7. 当递增的地址到达Page的界限后, 剩下的8位数据会覆盖Page的开头</span><br><span class=\"line\">8. 如果向EEPROM传输的DATA超过8个字节(对于AT24C02), 则数据会从头覆盖</span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的acknowledge-polling(确认轮询)\">AT24C02的ACKNOWLEDGE POLLING(确认轮询)</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280423663.png\" alt=\"ACKNOWLEDGE POLLING\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。</span><br><span class=\"line\">这涉及发送一个启动条件，后跟设备地址。读/写位是代表所需的操作。</span><br><span class=\"line\">仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列</span><br></pre></td></tr></table></figure>\n<p>需要在向AT24C02写入数据操作后, 进行确认询问, 主机需要发送启动条件, 设备地址, 读写位, 如果AT24C02准备完毕会响应0才能继续进行操作</p>\n<p>以I2C1为例, 软件编程实现如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认询问 </span></span><br><span class=\"line\"><span class=\"comment\"> *   STM32向EEPROM写入数据后, EEPROM需要时间向内部存储期间进行写入</span></span><br><span class=\"line\"><span class=\"comment\"> *   此时EEPROM不应答, 所以在发送下一次I2C请求之前,应等待EEPROM写入完成</span></span><br><span class=\"line\"><span class=\"comment\"> *   以上步骤称为ACKNOWLEDGE POLLING</span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_ACK_Polling</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); </span><br><span class=\"line\">    <span class=\"comment\">/* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* 结束询问 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的current-address read(从当前地址读数据)操作\">AT24C02的Current Address Read(从当前地址读数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271810617.png\" alt=\"Current Address Read\"></p>\n<p>一般不用, 因为在开发中不好确定当前地址的位置</p>\n<h4 id=\"at24c02的random-read(随机读数据)操作\">AT24C02的Random Read(随机读数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271813901.png\" alt=\"Random Read\"></p>\n<ol>\n<li>产生起始信号, 向EEPROM发送要读取数据的数据地址(写方向)</li>\n<li>再次产生起始信号, 从EEPROM中读取数据(读方向)</li>\n<li>EEPROM在被写入要读取数据的数据地址后会进行确认并输出该数据内容</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271821179.png\" alt=\"Random Read\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Random Read流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. Random Read需要&quot;dummy&quot;来写入要读取数据(DATA)的数据地址(WORD ADDRESS)</span><br><span class=\"line\">2. 一旦DEVICE ADDRESS和WORD ADDRESS被EEPROM响应, 单片机必须生成另一个START信号</span><br><span class=\"line\">3. 单片机发送读信号来读取当前地址(DEVICE ADDRESS)</span><br><span class=\"line\">4. EEPROM响应DEVICE ADDRESS并串行输出数据(DATA)</span><br><span class=\"line\">5. 单片机响应NO ACK并紧跟生成STOP信号</span><br></pre></td></tr></table></figure>\n<h4 id=\"at24c02的sequential-read(顺序读数据)操作\">AT24C02的Sequential Read(顺序读数据)操作</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271838678.png\" alt=\"Sequential Read\"></p>\n<p>与Page Write类似</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271841941.png\" alt=\"Sequential Read\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">翻译: Sequential Read流程</span><br><span class=\"line\"></span><br><span class=\"line\">1. Sequntial Read从当前地址读取或随机地址开始读取</span><br><span class=\"line\">2. 单片机收到DATA后，会响应ACK</span><br><span class=\"line\">3. 只要EEPROM收到ACK响应，它就会继续递增数据地址，并顺序串行输出DATA</span><br><span class=\"line\">4. 当达到内存地址限制时，数据地址将&quot;roll over&quot;，顺序读取将继续从头开始重新读取数据</span><br><span class=\"line\">5. 当单片机NO ACK响应并生成STOP，则终止Sequential Read</span><br></pre></td></tr></table></figure>\n<h3 id=\"i2c-读写eeprom实验\">I2C-读写EEPROM实验</h3>\n<p>项目地址: <strong>24-I2C-EEPROM</strong></p>\n<h4 id=\"操作流程\">操作流程</h4>\n<ol>\n<li>初始化I2C相关的GPIO</li>\n<li>配置I2C外设的工作模式</li>\n<li>编写I2C写入EEPROM的Byte Write函数</li>\n<li>编写I2C读取EEPROM的Random Read函数</li>\n<li>使用read函数和write函数进行读写校验</li>\n<li>编写Page Write和Sequential Read函数进行校验</li>\n</ol>\n<h4 id=\"在bsp_i2ch中定义相关宏\">在bsp_i2c.h中定义相关宏</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @defgroup I2C_EEPROM_Define </span></span><br><span class=\"line\"><span class=\"comment\"> * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief I2C的宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C I2C1 <span class=\"comment\">/*!&lt; EEPROM所使用的I2Cx */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_CLK RCC_APB1Periph_I2C1 <span class=\"comment\">/*!&lt; I2C的时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_APBxClkCmd RCC_APB1PeriphClockCmd <span class=\"comment\">/*!&lt; I2C时钟的使能函数 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_BAUDRATE 400000 <span class=\"comment\">/*!&lt; I2C的通信速率 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STM32_I2C_OWN_ADDR 0x5F <span class=\"comment\">/*!&lt; STM32在I2C总线上的自身地址, 可任意配置(只要在I2C总线上唯一即可) */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_WRITE_ADDRESS 0xA0 <span class=\"comment\">/*!&lt; EEPROM在I2C总线上的8位写地址 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_READ_ADDRESS 0xA1 <span class=\"comment\">/*!&lt; EEPROM在I2C总线上的8位读地址 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief I2C的GPIO引脚宏定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SCL_GPIO_CLK (RCC_APB2Periph_GPIOB) <span class=\"comment\">/*!&lt; I2C的SCL引脚的GPIO时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SDA_GPIO_CLK (RCC_APB2Periph_GPIOB) <span class=\"comment\">/*!&lt; I2C的SDA引脚的GPIO时钟 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd <span class=\"comment\">/*!&lt; I2C的GPIO时钟的使能函数 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SCL_GPIO_PORT GPIOB <span class=\"comment\">/*!&lt; I2C的SCL引脚的GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SCL_GPIO_Pin GPIO_Pin_6 <span class=\"comment\">/*!&lt; I2C的SCL引脚的GPIO引脚 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SDA_GPIO_PORT GPIOB <span class=\"comment\">/*!&lt; I2C的SDA引脚的GPIO端口 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_I2C_SDA_GPIO_Pin GPIO_Pin_7 <span class=\"comment\">/*!&lt; I2C的SDA引脚的GPIO引脚 */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2ch中进行函数声明\">在bsp_i2c.h中进行函数声明</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @defgroup EEPROM_I2C_Functions </span></span><br><span class=\"line\"><span class=\"comment\"> * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EEPROM_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Byte_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span> Data)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Page_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToWrite)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Random_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Sequential_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToRead)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_ACK_Polling</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写i2c_eeprom配置函数\">在bsp_i2c.c中编写I2C_EEPROM配置函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief I2C EEPROM配置函数 </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EEPROM_Config</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class=\"line\">    I2C_InitTypeDef I2C_InitStructure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- 时钟配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 使能I2C GPIO的时钟 */</span></span><br><span class=\"line\">    EEPROM_I2C_GPIO_APBxClkCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 使能I2C的时钟 */</span></span><br><span class=\"line\">    EEPROM_I2C_APBxClkCmd(EEPROM_I2C_CLK, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- I2C_SCL的GPIO配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 配置引脚为I2C的SCL */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_GPIO_Pin;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置输出速率为50MHz */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置模式开漏复用输出 */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C_SCL的GPIO配置 */</span> </span><br><span class=\"line\">    GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- I2C_SDA的GPIO配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 配置引脚为I2C的SDA */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_GPIO_Pin;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置输出速率为50MHz */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class=\"line\">    <span class=\"comment\">/* 配置模式开漏复用输出 */</span></span><br><span class=\"line\">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C_SDA的GPIO配置 */</span> </span><br><span class=\"line\">    GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------- I2C的工作模式配置 ------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 使能响应 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class=\"line\">    <span class=\"comment\">/* 使用7位地址 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class=\"line\">    <span class=\"comment\">/* 时钟频率 400kHz*/</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_ClockSpeed = EEPROM_I2C_BAUDRATE;</span><br><span class=\"line\">    <span class=\"comment\">/* 占空比 Tlow/Thigh = 2 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class=\"line\">    <span class=\"comment\">/* 模式 I2C */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32主机地址 */</span></span><br><span class=\"line\">    I2C_InitStructure.I2C_OwnAddress1 = STM32_I2C_OWN_ADDR;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C */</span></span><br><span class=\"line\">    I2C_Init(EEPROM_I2C, &amp;I2C_InitStructure); </span><br><span class=\"line\">    <span class=\"comment\">/* 使能I2C */</span></span><br><span class=\"line\">    I2C_Cmd(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写byte-writting方式的函数\">在bsp_i2c.c中编写Byte Writting方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现了STM32作为主发送器向EEPROM以Byte Writting的方式写数据 </span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 需要写入的字节所在的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 真正要写入的内容</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Byte_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span> Data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送Data */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, Data);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写page-writting方式的函数\">在bsp_i2c.c中编写Page Writting方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现了STM32作为主发送器向EEPROM以Page Writting的方式写数据(每次不超过8字节) </span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 需要写入的字节所在的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 真正要写入的数据的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param NumByteToWrite: 要写入数据的个数小于8</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Page_Writting</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToWrite)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* 循环写入数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(NumByteToWrite)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* STM32向EEPROM发送Data */</span></span><br><span class=\"line\">        I2C_SendData(EEPROM_I2C, *Data);</span><br><span class=\"line\">        <span class=\"comment\">/* 数据指针自增 */</span></span><br><span class=\"line\">        Data++;</span><br><span class=\"line\">        <span class=\"comment\">/* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        NumByteToWrite--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写random-read方式的函数\">在bsp_i2c.c中编写Random Read方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现STM32从EEPROM以Random Read方式读取数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 要读取数据的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 读取数据要写入到的变量</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Random_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32接收Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32另外产生一个START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的读地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    * 注意: </span></span><br><span class=\"line\"><span class=\"comment\">    * 该部分为STM32接收来自EEPROM的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作</span></span><br><span class=\"line\"><span class=\"comment\">    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 而不是进行数据接收</span></span><br><span class=\"line\"><span class=\"comment\">    *------------------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 监测到EV7事件发生, 说明接收到了新数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 将接收到的数据赋值给Data变量 */</span></span><br><span class=\"line\">    *Data = I2C_ReceiveData(EEPROM_I2C);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生NO ACK响应 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写sequential-read方式的函数\">在bsp_i2c.c中编写Sequential Read方式的函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 函数实现STM32从EEPROM以Sequential Read方式读取数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param WordAddress: 要读取数据的地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @param Data: 读取数据要写入到的变量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param NumByteToRead: 要读取数据的个数</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_Sequential_Read</span><span class=\"params\">(<span class=\"type\">uint8_t</span> WordAddress, <span class=\"type\">uint8_t</span>* Data, <span class=\"type\">uint8_t</span> NumByteToRead)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM发送WordAddress */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*---------------- STM32接收Data ----------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/* STM32另外产生一个START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的读地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    * 注意: </span></span><br><span class=\"line\"><span class=\"comment\">    * 该部分为STM32接收来自EEPROM的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作</span></span><br><span class=\"line\"><span class=\"comment\">    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据</span></span><br><span class=\"line\"><span class=\"comment\">    * 而不是进行数据接收</span></span><br><span class=\"line\"><span class=\"comment\">    *------------------------------------------------------------------------*/</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(NumByteToRead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (NumByteToRead == <span class=\"number\">1</span>) <span class=\"comment\">/* 如果为最后一个字节, 产生NO ACK响应 */</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* STM32产生NO ACK响应 */</span></span><br><span class=\"line\">            I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 监测到EV7事件发生, 说明接收到了新数据 */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* 将接收到的数据赋值给Data变量 */</span></span><br><span class=\"line\">        *Data = I2C_ReceiveData(EEPROM_I2C);</span><br><span class=\"line\">        <span class=\"comment\">/* Data 指针自增 */</span></span><br><span class=\"line\">        Data++;</span><br><span class=\"line\">        <span class=\"comment\">/* NumByteToRead递减 */</span></span><br><span class=\"line\">        NumByteToRead--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生STOP信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class=\"line\">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在bsp_i2cc中编写确认询问函数\">在bsp_i2c.c中编写确认询问函数</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认轮询</span></span><br><span class=\"line\"><span class=\"comment\"> *   一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。</span></span><br><span class=\"line\"><span class=\"comment\"> *   这涉及发送一个启动条件，后跟设备地址。</span></span><br><span class=\"line\"><span class=\"comment\"> *   读/写位是代表所需的操作。</span></span><br><span class=\"line\"><span class=\"comment\"> *   仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列</span></span><br><span class=\"line\"><span class=\"comment\"> *   以上步骤称为ACKNOWLEDGE POLLING</span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EEPROM_ACK_Polling</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32产生START信号 */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* STM32发送EEPROM的写地址 */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); </span><br><span class=\"line\">    <span class=\"comment\">/* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* 结束轮询 */</span></span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在mainc中进行读写测试\">在main.c中进行读写测试</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @file    main.c</span></span><br><span class=\"line\"><span class=\"comment\">  * @author  eric</span></span><br><span class=\"line\"><span class=\"comment\">  * @version V0.0.1</span></span><br><span class=\"line\"><span class=\"comment\">  * @date    27-January-2024</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   STM32与EEPROM通过I2C协议进行读写测试</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @attention</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * THE PRESENT FUNTIONS WHICH IS FOR GUIDANCE ONLY</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Includes ------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_conf.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_led.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_usart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;bsp_i2c.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"> * 操作流程:</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 初始化I2C相关的GPIO</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 配置I2C外设的工作模式</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. 编写I2C写入EEPROM的Byte Write函数 </span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 编写I2C读取EEPROM的Random Read函数</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 使用read函数和write函数进行读写校验</span></span><br><span class=\"line\"><span class=\"comment\"> * 6. 编写Page Write和Sequential Read函数进行校验</span></span><br><span class=\"line\"><span class=\"comment\"> *----------------------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @defgroup: Global_Values</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#123;  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> ReadData[<span class=\"number\">20</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">uint8_t</span> WriteData[<span class=\"number\">3</span>] = &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief STM32与EEPROM通过I2C协议进行读写测试 </span></span><br><span class=\"line\"><span class=\"comment\"> * @param None</span></span><br><span class=\"line\"><span class=\"comment\"> * @retval None </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化USART */</span></span><br><span class=\"line\">    USART_Config(); </span><br><span class=\"line\">    <span class=\"comment\">/* 串口打印 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;I2C-EEPROM\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 初始化I2C */</span></span><br><span class=\"line\">    I2C_EEPROM_Config();</span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM 地址1写入数据0x01 */</span></span><br><span class=\"line\">    EEPROM_Byte_Writting(<span class=\"number\">1</span>, <span class=\"number\">0x01</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class=\"line\">    EEPROM_ACK_Polling();</span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM 地址2写入数据0x02 */</span></span><br><span class=\"line\">    EEPROM_Byte_Writting(<span class=\"number\">2</span>, <span class=\"number\">0x02</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class=\"line\">    EEPROM_ACK_Polling();</span><br><span class=\"line\">    <span class=\"comment\">/*----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">     * Page Writting的地址对齐</span></span><br><span class=\"line\"><span class=\"comment\">     * 为保证数据无误需addr%8 == 0</span></span><br><span class=\"line\"><span class=\"comment\">     *----------------------------------------*/</span> </span><br><span class=\"line\">    <span class=\"comment\">/* STM32向EEPROM 地址3-5写入数据0x03-0x05 */</span></span><br><span class=\"line\">    EEPROM_Page_Writting(<span class=\"number\">0x03</span>, WriteData, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class=\"line\">    EEPROM_ACK_Polling();</span><br><span class=\"line\">    <span class=\"comment\">/* STM32从EEPROM以SequentialRead方式读取地址1-4的数据 */</span> </span><br><span class=\"line\">    EEPROM_Sequential_Read((<span class=\"type\">uint8_t</span>)<span class=\"number\">1</span>, ReadData, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* STM32从EEPROM以RandomRead方式读取地址5的数据 */</span> </span><br><span class=\"line\">    EEPROM_Random_Read((<span class=\"type\">uint8_t</span>)<span class=\"number\">5</span>, &amp;ReadData[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"comment\">/* 将读出的数据循环打印 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ReadData[%d] = 0x%x\\n&quot;</span>, i, ReadData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 空循环 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"串口实验现象\">串口实验现象</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280831099.png\" alt=\"实验现象\"></p>\n<h4 id=\"完善功能\">完善功能</h4>\n<p>以下函数是对实验中出现函数的进一步完善, 源文件不在工程中</p>\n<h5 id=\"增加的宏定义\">增加的宏定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* STM32 I2C 快速模式 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_Speed              400000  <span class=\"comment\">//*</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2Cx_OWN_ADDRESS7      0X0A   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* AT24C01/02每页有8个字节 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2C_PageSize           8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* AT24C04/08A/16A每页有16个字节 */</span></span><br><span class=\"line\"><span class=\"comment\">//#define I2C_PageSize           16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*等待超时时间*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT)</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"调试功能\">调试功能</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_DEBUG_ON         0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_INFO(fmt,arg...)           printf(<span class=\"string\">&quot;&lt;&lt;-EEPROM-INFO-&gt;&gt; &quot;</span>fmt<span class=\"string\">&quot;\\n&quot;</span>,##arg)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_ERROR(fmt,arg...)          printf(<span class=\"string\">&quot;&lt;&lt;-EEPROM-ERROR-&gt;&gt; &quot;</span>fmt<span class=\"string\">&quot;\\n&quot;</span>,##arg)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EEPROM_DEBUG(fmt,arg...)          do&#123;\\</span></span><br><span class=\"line\"><span class=\"meta\">                                          <span class=\"keyword\">if</span>(EEPROM_DEBUG_ON)\\</span></span><br><span class=\"line\"><span class=\"meta\">                                          printf(<span class=\"string\">&quot;&lt;&lt;-EEPROM-DEBUG-&gt;&gt; [%s][%d]&quot;</span>fmt<span class=\"string\">&quot;\\n&quot;</span>, __FILE__, __LINE__, ##arg);\\</span></span><br><span class=\"line\"><span class=\"meta\">                                          &#125;while(0)</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"超时处理函数\">超时处理函数</h5>\n<p>完善了对于超时的处理</p>\n<h6 id=\"超时处理相关宏定义\">超时处理相关宏定义</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*等待超时时间*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"超时处理相关变量声明\">超时处理相关变量声明</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __IO <span class=\"type\">uint32_t</span>  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_TIMEOUT_UserCallback</span><span class=\"params\">(<span class=\"type\">uint8_t</span> errorCode)</span>;</span><br></pre></td></tr></table></figure>\n<h6 id=\"超时状态函数\">超时状态函数</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Basic management of the timeout situation.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  errorCode：错误代码，可以用来定位是哪个环节出错.</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 返回0，表示IIC读取失败.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">static</span>  <span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_TIMEOUT_UserCallback</span><span class=\"params\">(<span class=\"type\">uint8_t</span> errorCode)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Block communication and all processes */</span></span><br><span class=\"line\">  EEPROM_ERROR(<span class=\"string\">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"多字节写入函数\">多字节写入函数</h5>\n<p>完善了在Page Write中字节对齐的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   将缓冲区中的数据写到I2C EEPROM中</span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  *  @arg pBuffer:缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  *  @arg WriteAddr:写地址</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg NumByteToWrite:写的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EE_BufferWrite</span><span class=\"params\">(u8* pBuffer, u8 WriteAddr, u16 NumByteToWrite)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  u8 NumOfPage = <span class=\"number\">0</span>, NumOfSingle = <span class=\"number\">0</span>, Addr = <span class=\"number\">0</span>, count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Addr = WriteAddr % I2C_PageSize;</span><br><span class=\"line\">  count = I2C_PageSize - Addr;</span><br><span class=\"line\">  NumOfPage =  NumByteToWrite / I2C_PageSize;</span><br><span class=\"line\">  NumOfSingle = NumByteToWrite % I2C_PageSize;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* If WriteAddr is I2C_PageSize aligned  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Addr == <span class=\"number\">0</span>) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &lt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(NumOfPage == <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class=\"line\">      I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &gt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(NumOfPage--)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); </span><br><span class=\"line\">     I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">        WriteAddr +=  I2C_PageSize;</span><br><span class=\"line\">        pBuffer += I2C_PageSize;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(NumOfSingle!=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* If WriteAddr is not I2C_PageSize aligned  */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &lt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(NumOfPage== <span class=\"number\">0</span>) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class=\"line\">      I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* If NumByteToWrite &gt; I2C_PageSize */</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      NumByteToWrite -= count;</span><br><span class=\"line\">      NumOfPage =  NumByteToWrite / I2C_PageSize;</span><br><span class=\"line\">      NumOfSingle = NumByteToWrite % I2C_PageSize; </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(count != <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, count);</span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">        WriteAddr += count;</span><br><span class=\"line\">        pBuffer += count;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span>(NumOfPage--)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);</span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">        WriteAddr +=  I2C_PageSize;</span><br><span class=\"line\">        pBuffer += I2C_PageSize;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(NumOfSingle != <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); </span><br><span class=\"line\">        I2C_EE_WaitEepromStandbyState();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"单字节写入函数\">单字节写入函数</h5>\n<p>增加超时处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   写一个字节到I2C EEPROM中</span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  * @arg pBuffer:缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  * @arg WriteAddr:写地址 </span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_EE_ByteWrite</span><span class=\"params\">(u8* pBuffer, u8 WriteAddr)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;  </span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"comment\">/* Send the EEPROM&#x27;s internal address to write to */</span></span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, WriteAddr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send the byte to be written */</span></span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, *pBuffer); </span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;  </span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">3</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send STOP condition */</span></span><br><span class=\"line\">  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"单页写入函数\">单页写入函数</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  *          不能超过EEPROM页的大小，AT24C02每页有8个字节</span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg pBuffer:缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg WriteAddr:写地址</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg NumByteToWrite:写的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_EE_PageWrite</span><span class=\"params\">(u8* pBuffer, u8 WriteAddr, u8 NumByteToWrite)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))   </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">5</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">6</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send the EEPROM&#x27;s internal address to write to */</span>    </span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, WriteAddr);  </span><br><span class=\"line\"></span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(! I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">7</span>);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* While there is data to be written */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(NumByteToWrite--)  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Send the current byte */</span></span><br><span class=\"line\">    I2C_SendData(EEPROM_I2Cx, *pBuffer); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Point to the next byte to be written */</span></span><br><span class=\"line\">    pBuffer++; </span><br><span class=\"line\">  </span><br><span class=\"line\">    I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">8</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Send STOP condition */</span></span><br><span class=\"line\">  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"读取数据函数\">读取数据函数</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   从EEPROM里面读取一块数据 </span></span><br><span class=\"line\"><span class=\"comment\">  * @param   </span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg pBuffer:存放从EEPROM读取的数据的缓冲区指针</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg WriteAddr:接收数据的EEPROM的地址</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg NumByteToWrite:要从EEPROM读取的字节数</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval  无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">I2C_EE_BufferRead</span><span class=\"params\">(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)</span></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//*((u8 *)0x4001080c) |=0x80; </span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">9</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  <span class=\"comment\">//*((u8 *)0x4001080c) &amp;=~0x80;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">10</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\"></span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">11</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Clear EV6 by setting again the PE bit */</span></span><br><span class=\"line\">  I2C_Cmd(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Send the EEPROM&#x27;s internal address to write to */</span></span><br><span class=\"line\">  I2C_SendData(EEPROM_I2Cx, ReadAddr);  </span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV8 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">12</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Send START condition a second time */</span>  </span><br><span class=\"line\">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV5 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">13</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">/* Send EEPROM address for read */</span></span><br><span class=\"line\">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver);</span><br><span class=\"line\">  </span><br><span class=\"line\">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class=\"line\">  <span class=\"comment\">/* Test on EV6 and clear it */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">14</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* While there is data to be read */</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(NumByteToRead)  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(NumByteToRead == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Disable Acknowledgement */</span></span><br><span class=\"line\">      I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* Send STOP Condition */</span></span><br><span class=\"line\">      I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Test on EV7 and clear it */</span>    </span><br><span class=\"line\">    I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==<span class=\"number\">0</span>)  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((I2CTimeout--) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> I2C_TIMEOUT_UserCallback(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    &#123;      </span><br><span class=\"line\">      <span class=\"comment\">/* Read a byte from the EEPROM */</span></span><br><span class=\"line\">      *pBuffer = I2C_ReceiveData(EEPROM_I2Cx);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* Point to the next location where the byte read will be saved */</span></span><br><span class=\"line\">      pBuffer++; </span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/* Decrement the read bytes counter */</span></span><br><span class=\"line\">      NumByteToRead--;        </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Enable Acknowledgement to be ready for another reception */</span></span><br><span class=\"line\">  I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"等待eeprom函数\">等待EEPROM函数</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Wait for EEPROM Standby state </span></span><br><span class=\"line\"><span class=\"comment\">  * @param  无</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval 无</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">I2C_EE_WaitEepromStandbyState</span><span class=\"params\">(<span class=\"type\">void</span>)</span>      </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  vu16 SR1_Tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Send START condition */</span></span><br><span class=\"line\">    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class=\"line\">    <span class=\"comment\">/* Read I2C1 SR1 register */</span></span><br><span class=\"line\">    SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1);</span><br><span class=\"line\">    <span class=\"comment\">/* Send EEPROM address for write */</span></span><br><span class=\"line\">    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">while</span>(!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) &amp; <span class=\"number\">0x0002</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Clear AF flag */</span></span><br><span class=\"line\">  I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF);</span><br><span class=\"line\">    <span class=\"comment\">/* STOP condition */</span>    </span><br><span class=\"line\">    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"波特率与比特率","date":"2024-01-17T08:00:52.000Z","_content":"\n## 波特率和比特率介绍\n\n\n波特率（Baud Rate）和比特率（Bit Rate）是数字通信中两个相关但不同的概念。它们经常被混淆，但它们表示的是不同的量。\n\n1. 波特率（Baud Rate）：\n - 定义： 波特率是指每秒传输的波特（符号、信号）的数量。一个波特可以表示一个电平变化，一个符号，或者一个脉冲。\n - 单位： 波特率的单位是波特（bps），表示每秒传输的符号或波特的数量。\n - 示例： 如果波特率为9600 bps，表示每秒传输9600个符号。\n2. 比特率（Bit Rate）：\n - 定义： 比特率是指每秒传输的比特（二进制位）的数量。每个符号可能携带多个比特，具体取决于使用的调制方式。\n - 单位： 比特率的单位是比特每秒（bps），表示每秒传输的二进制位的数量。\n - 示例： 如果比特率为9600 bps，表示每秒传输9600个二进制位。\n\n## 区别总结\n\n- 波特率：\n - 衡量的是每秒传输的波特（符号）的数量。\n - 波特率单位为波特每秒（bps）。\n - 通常用于描述调制解调器、串口通信等模拟信号的传输速率。\n- 比特率：\n - 衡量的是每秒传输的比特（二进制位）的数量。\n - 比特率单位为比特每秒（bps）。\n - 通常用于描述数字信号、数字通信中的传输速率。\n\n## 换算关系\n\n波特率和比特率的换算关系取决于每个符号（波特）携带的比特数。在一些通信系统中，一个波特可能携带一个比特，但在其他情况下，一个波特可以携带多个比特。以下是一些常见情况的换算关系：\n\n1. 每波特携带一个比特的情况：\n - 波特率（Baud Rate）= 比特率（Bit Rate）\n2. 每波特携带多个比特的情况：\n - **波特率（Baud Rate）= 比特率（Bit Rate） / 每波特携带的比特数**\n","source":"_posts/波特率与比特率.md","raw":"---\ntitle: 波特率与比特率\ndate: 2024-01-17 16:00:52\ntags: 通信\n---\n\n## 波特率和比特率介绍\n\n\n波特率（Baud Rate）和比特率（Bit Rate）是数字通信中两个相关但不同的概念。它们经常被混淆，但它们表示的是不同的量。\n\n1. 波特率（Baud Rate）：\n - 定义： 波特率是指每秒传输的波特（符号、信号）的数量。一个波特可以表示一个电平变化，一个符号，或者一个脉冲。\n - 单位： 波特率的单位是波特（bps），表示每秒传输的符号或波特的数量。\n - 示例： 如果波特率为9600 bps，表示每秒传输9600个符号。\n2. 比特率（Bit Rate）：\n - 定义： 比特率是指每秒传输的比特（二进制位）的数量。每个符号可能携带多个比特，具体取决于使用的调制方式。\n - 单位： 比特率的单位是比特每秒（bps），表示每秒传输的二进制位的数量。\n - 示例： 如果比特率为9600 bps，表示每秒传输9600个二进制位。\n\n## 区别总结\n\n- 波特率：\n - 衡量的是每秒传输的波特（符号）的数量。\n - 波特率单位为波特每秒（bps）。\n - 通常用于描述调制解调器、串口通信等模拟信号的传输速率。\n- 比特率：\n - 衡量的是每秒传输的比特（二进制位）的数量。\n - 比特率单位为比特每秒（bps）。\n - 通常用于描述数字信号、数字通信中的传输速率。\n\n## 换算关系\n\n波特率和比特率的换算关系取决于每个符号（波特）携带的比特数。在一些通信系统中，一个波特可能携带一个比特，但在其他情况下，一个波特可以携带多个比特。以下是一些常见情况的换算关系：\n\n1. 每波特携带一个比特的情况：\n - 波特率（Baud Rate）= 比特率（Bit Rate）\n2. 每波特携带多个比特的情况：\n - **波特率（Baud Rate）= 比特率（Bit Rate） / 每波特携带的比特数**\n","slug":"波特率与比特率","published":1,"updated":"2024-01-17T08:04:31.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrhhyxwb0000t497ecjy0118","content":"<h2 id=\"波特率和比特率介绍\">波特率和比特率介绍</h2>\n<p>波特率（Baud Rate）和比特率（Bit Rate）是数字通信中两个相关但不同的概念。它们经常被混淆，但它们表示的是不同的量。</p>\n<ol>\n<li>波特率（Baud Rate）：</li>\n</ol>\n<ul>\n<li>定义： 波特率是指每秒传输的波特（符号、信号）的数量。一个波特可以表示一个电平变化，一个符号，或者一个脉冲。</li>\n<li>单位： 波特率的单位是波特（bps），表示每秒传输的符号或波特的数量。</li>\n<li>示例： 如果波特率为9600 bps，表示每秒传输9600个符号。</li>\n</ul>\n<ol start=\"2\">\n<li>比特率（Bit Rate）：</li>\n</ol>\n<ul>\n<li>定义： 比特率是指每秒传输的比特（二进制位）的数量。每个符号可能携带多个比特，具体取决于使用的调制方式。</li>\n<li>单位： 比特率的单位是比特每秒（bps），表示每秒传输的二进制位的数量。</li>\n<li>示例： 如果比特率为9600 bps，表示每秒传输9600个二进制位。</li>\n</ul>\n<h2 id=\"区别总结\">区别总结</h2>\n<ul>\n<li>波特率：</li>\n<li>衡量的是每秒传输的波特（符号）的数量。</li>\n<li>波特率单位为波特每秒（bps）。</li>\n<li>通常用于描述调制解调器、串口通信等模拟信号的传输速率。</li>\n<li>比特率：</li>\n<li>衡量的是每秒传输的比特（二进制位）的数量。</li>\n<li>比特率单位为比特每秒（bps）。</li>\n<li>通常用于描述数字信号、数字通信中的传输速率。</li>\n</ul>\n<h2 id=\"换算关系\">换算关系</h2>\n<p>波特率和比特率的换算关系取决于每个符号（波特）携带的比特数。在一些通信系统中，一个波特可能携带一个比特，但在其他情况下，一个波特可以携带多个比特。以下是一些常见情况的换算关系：</p>\n<ol>\n<li>每波特携带一个比特的情况：</li>\n</ol>\n<ul>\n<li>波特率（Baud Rate）= 比特率（Bit Rate）</li>\n</ul>\n<ol start=\"2\">\n<li>每波特携带多个比特的情况：</li>\n</ol>\n<ul>\n<li><strong>波特率（Baud Rate）= 比特率（Bit Rate） / 每波特携带的比特数</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"波特率和比特率介绍\">波特率和比特率介绍</h2>\n<p>波特率（Baud Rate）和比特率（Bit Rate）是数字通信中两个相关但不同的概念。它们经常被混淆，但它们表示的是不同的量。</p>\n<ol>\n<li>波特率（Baud Rate）：</li>\n</ol>\n<ul>\n<li>定义： 波特率是指每秒传输的波特（符号、信号）的数量。一个波特可以表示一个电平变化，一个符号，或者一个脉冲。</li>\n<li>单位： 波特率的单位是波特（bps），表示每秒传输的符号或波特的数量。</li>\n<li>示例： 如果波特率为9600 bps，表示每秒传输9600个符号。</li>\n</ul>\n<ol start=\"2\">\n<li>比特率（Bit Rate）：</li>\n</ol>\n<ul>\n<li>定义： 比特率是指每秒传输的比特（二进制位）的数量。每个符号可能携带多个比特，具体取决于使用的调制方式。</li>\n<li>单位： 比特率的单位是比特每秒（bps），表示每秒传输的二进制位的数量。</li>\n<li>示例： 如果比特率为9600 bps，表示每秒传输9600个二进制位。</li>\n</ul>\n<h2 id=\"区别总结\">区别总结</h2>\n<ul>\n<li>波特率：</li>\n<li>衡量的是每秒传输的波特（符号）的数量。</li>\n<li>波特率单位为波特每秒（bps）。</li>\n<li>通常用于描述调制解调器、串口通信等模拟信号的传输速率。</li>\n<li>比特率：</li>\n<li>衡量的是每秒传输的比特（二进制位）的数量。</li>\n<li>比特率单位为比特每秒（bps）。</li>\n<li>通常用于描述数字信号、数字通信中的传输速率。</li>\n</ul>\n<h2 id=\"换算关系\">换算关系</h2>\n<p>波特率和比特率的换算关系取决于每个符号（波特）携带的比特数。在一些通信系统中，一个波特可能携带一个比特，但在其他情况下，一个波特可以携带多个比特。以下是一些常见情况的换算关系：</p>\n<ol>\n<li>每波特携带一个比特的情况：</li>\n</ol>\n<ul>\n<li>波特率（Baud Rate）= 比特率（Bit Rate）</li>\n</ul>\n<ol start=\"2\">\n<li>每波特携带多个比特的情况：</li>\n</ol>\n<ul>\n<li><strong>波特率（Baud Rate）= 比特率（Bit Rate） / 每波特携带的比特数</strong></li>\n</ul>\n"},{"title":"Doxygen常用注释语法","date":"2024-01-26T06:58:16.000Z","_content":"\n## 说明\n\n注释规范化参考文件为**STM32F103的库文件**, 即ST公司写的库函数底层代码\n\n## 文件头声明格式\n\n```c\n/**\n  ******************************************************************************\n  * @file    stm32f10x_dma.h\n  * @author  MCD Application Team\n  * @version V3.5.0\n  * @date    11-March-2011\n  * @brief   This file contains all the functions prototypes for the DMA firmware \n  *          library.\n  ******************************************************************************\n  * @attention\n  *\n  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\n  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\n  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\n  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\n  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n  *\n  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>\n  ******************************************************************************\n  */\n```\n\n通常包含以下部分\n\n- @file: 文件名\n- @author: 作者名\n- @version: 版本号\n- @date: 日期\n- @brief 文档简介\n- @attention: 注意信息\n\n## 函数注释格式\n\n```c\n/**\n  * @brief  Enables or disables the specified DMAy Channelx interrupts.\n  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and \n  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.\n  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled\n  *   or disabled. \n  *   This parameter can be any combination of the following values:\n  *     @arg DMA_IT_TC:  Transfer complete interrupt mask\n  *     @arg DMA_IT_HT:  Half transfer interrupt mask\n  *     @arg DMA_IT_TE:  Transfer error interrupt mask\n  * @param  NewState: new state of the specified DMA interrupts.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)\n{\n  /* Check the parameters */\n  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));\n  assert_param(IS_DMA_CONFIG_IT(DMA_IT));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected DMA interrupts */\n    DMAy_Channelx->CCR |= DMA_IT;\n  }\n  else\n  {\n    /* Disable the selected DMA interrupts */\n    DMAy_Channelx->CCR &= ~DMA_IT;\n  }\n}\n```\n\n通常包含以下部分:\n\n- @brief: 函数简介\n- @param: 参数说明\n- @arg: 可选的参数\n- @retval: 返回值说明\n\n## 结构体格式\n\n```c\n/** \n  * @brief  DMA Init structure definition\n  */\n\ntypedef struct\n{\n  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */\n\n  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */\n\n  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.\n                                        This parameter can be a value of @ref DMA_data_transfer_direction */\n\n  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. \n                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize\n                                        or DMA_MemoryDataSize members depending in the transfer direction. */\n\n  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */\n\n  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_memory_incremented_mode */\n\n  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.\n                                        This parameter can be a value of @ref DMA_peripheral_data_size */\n\n  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.\n                                        This parameter can be a value of @ref DMA_memory_data_size */\n\n  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_circular_normal_mode.\n                                        @note: The circular buffer mode cannot be used if the memory-to-memory\n                                              data transfer is configured on the selected Channel */\n\n  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_priority_level */\n\n  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.\n                                        This parameter can be a value of @ref DMA_memory_to_memory */\n}DMA_InitTypeDef;\n```\n\n通常包含以下部分\n\n- @brief: 结构体说明\n- @note 参数说明\n- @ref: 结构体成员取值选项\n\n### 结构体成员取值的注释格式\n\n以该结构体成员其后的注释为例, 可取值 @ref DMA_data_transfer_direction\n\n```c\nuint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.\n                                        This parameter can be a value of @ref DMA_data_transfer_direction */\n```\n\n则下文中需出现注释\n\n```c\n/** @defgroup DMA_data_transfer_direction \n  * @{\n  */\n\n#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)\n#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)\n#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \\\n                         ((DIR) == DMA_DIR_PeripheralSRC))\n/**\n  * @}\n  */\n```\n\n通常包含以下部分\n\n- @defgroup <NAME>: <NAME>为可取值组的名字需与@ref后的名字对应\n- @{ @}: 取值组前后需要用@大括号括起来, 中间为结构体成员可以取的变量\n- @ref <NAME>: 写在结构体成员之后, <NAME>需要与后文@defgroup的名字对应\n\n","source":"_posts/Doxygen常用注释语法.md","raw":"---\ntitle: Doxygen常用注释语法\ndate: 2024-01-26 14:58:16\ntags: Doxygen\n---\n\n## 说明\n\n注释规范化参考文件为**STM32F103的库文件**, 即ST公司写的库函数底层代码\n\n## 文件头声明格式\n\n```c\n/**\n  ******************************************************************************\n  * @file    stm32f10x_dma.h\n  * @author  MCD Application Team\n  * @version V3.5.0\n  * @date    11-March-2011\n  * @brief   This file contains all the functions prototypes for the DMA firmware \n  *          library.\n  ******************************************************************************\n  * @attention\n  *\n  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS\n  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE\n  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY\n  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING\n  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE\n  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.\n  *\n  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>\n  ******************************************************************************\n  */\n```\n\n通常包含以下部分\n\n- @file: 文件名\n- @author: 作者名\n- @version: 版本号\n- @date: 日期\n- @brief 文档简介\n- @attention: 注意信息\n\n## 函数注释格式\n\n```c\n/**\n  * @brief  Enables or disables the specified DMAy Channelx interrupts.\n  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and \n  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.\n  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled\n  *   or disabled. \n  *   This parameter can be any combination of the following values:\n  *     @arg DMA_IT_TC:  Transfer complete interrupt mask\n  *     @arg DMA_IT_HT:  Half transfer interrupt mask\n  *     @arg DMA_IT_TE:  Transfer error interrupt mask\n  * @param  NewState: new state of the specified DMA interrupts.\n  *   This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)\n{\n  /* Check the parameters */\n  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));\n  assert_param(IS_DMA_CONFIG_IT(DMA_IT));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected DMA interrupts */\n    DMAy_Channelx->CCR |= DMA_IT;\n  }\n  else\n  {\n    /* Disable the selected DMA interrupts */\n    DMAy_Channelx->CCR &= ~DMA_IT;\n  }\n}\n```\n\n通常包含以下部分:\n\n- @brief: 函数简介\n- @param: 参数说明\n- @arg: 可选的参数\n- @retval: 返回值说明\n\n## 结构体格式\n\n```c\n/** \n  * @brief  DMA Init structure definition\n  */\n\ntypedef struct\n{\n  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */\n\n  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */\n\n  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.\n                                        This parameter can be a value of @ref DMA_data_transfer_direction */\n\n  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. \n                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize\n                                        or DMA_MemoryDataSize members depending in the transfer direction. */\n\n  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */\n\n  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.\n                                        This parameter can be a value of @ref DMA_memory_incremented_mode */\n\n  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.\n                                        This parameter can be a value of @ref DMA_peripheral_data_size */\n\n  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.\n                                        This parameter can be a value of @ref DMA_memory_data_size */\n\n  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_circular_normal_mode.\n                                        @note: The circular buffer mode cannot be used if the memory-to-memory\n                                              data transfer is configured on the selected Channel */\n\n  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.\n                                        This parameter can be a value of @ref DMA_priority_level */\n\n  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.\n                                        This parameter can be a value of @ref DMA_memory_to_memory */\n}DMA_InitTypeDef;\n```\n\n通常包含以下部分\n\n- @brief: 结构体说明\n- @note 参数说明\n- @ref: 结构体成员取值选项\n\n### 结构体成员取值的注释格式\n\n以该结构体成员其后的注释为例, 可取值 @ref DMA_data_transfer_direction\n\n```c\nuint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.\n                                        This parameter can be a value of @ref DMA_data_transfer_direction */\n```\n\n则下文中需出现注释\n\n```c\n/** @defgroup DMA_data_transfer_direction \n  * @{\n  */\n\n#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)\n#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)\n#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \\\n                         ((DIR) == DMA_DIR_PeripheralSRC))\n/**\n  * @}\n  */\n```\n\n通常包含以下部分\n\n- @defgroup <NAME>: <NAME>为可取值组的名字需与@ref后的名字对应\n- @{ @}: 取值组前后需要用@大括号括起来, 中间为结构体成员可以取的变量\n- @ref <NAME>: 写在结构体成员之后, <NAME>需要与后文@defgroup的名字对应\n\n","slug":"Doxygen常用注释语法","published":1,"updated":"2024-01-26T07:20:55.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrubdkrb0000hs97hw5b7obx","content":"<h2 id=\"说明\">说明</h2>\n<p>注释规范化参考文件为<strong>STM32F103的库文件</strong>, 即ST公司写的库函数底层代码</p>\n<h2 id=\"文件头声明格式\">文件头声明格式</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @file    stm32f10x_dma.h</span></span><br><span class=\"line\"><span class=\"comment\">  * @author  MCD Application Team</span></span><br><span class=\"line\"><span class=\"comment\">  * @version V3.5.0</span></span><br><span class=\"line\"><span class=\"comment\">  * @date    11-March-2011</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   This file contains all the functions prototypes for the DMA firmware </span></span><br><span class=\"line\"><span class=\"comment\">  *          library.</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @attention</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS</span></span><br><span class=\"line\"><span class=\"comment\">  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE</span></span><br><span class=\"line\"><span class=\"comment\">  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY</span></span><br><span class=\"line\"><span class=\"comment\">  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING</span></span><br><span class=\"line\"><span class=\"comment\">  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE</span></span><br><span class=\"line\"><span class=\"comment\">  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分</p>\n<ul>\n<li>@file: 文件名</li>\n<li>@author: 作者名</li>\n<li>@version: 版本号</li>\n<li>@date: 日期</li>\n<li>@brief 文档简介</li>\n<li>@attention: 注意信息</li>\n</ul>\n<h2 id=\"函数注释格式\">函数注释格式</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Enables or disables the specified DMAy Channelx interrupts.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and </span></span><br><span class=\"line\"><span class=\"comment\">  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled</span></span><br><span class=\"line\"><span class=\"comment\">  *   or disabled. </span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be any combination of the following values:</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg DMA_IT_TC:  Transfer complete interrupt mask</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg DMA_IT_HT:  Half transfer interrupt mask</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg DMA_IT_TE:  Transfer error interrupt mask</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  NewState: new state of the specified DMA interrupts.</span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be: ENABLE or DISABLE.</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DMA_ITConfig</span><span class=\"params\">(DMA_Channel_TypeDef* DMAy_Channelx, <span class=\"type\">uint32_t</span> DMA_IT, FunctionalState NewState)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Check the parameters */</span></span><br><span class=\"line\">  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));</span><br><span class=\"line\">  assert_param(IS_DMA_CONFIG_IT(DMA_IT));</span><br><span class=\"line\">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (NewState != DISABLE)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Enable the selected DMA interrupts */</span></span><br><span class=\"line\">    DMAy_Channelx-&gt;CCR |= DMA_IT;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Disable the selected DMA interrupts */</span></span><br><span class=\"line\">    DMAy_Channelx-&gt;CCR &amp;= ~DMA_IT;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分:</p>\n<ul>\n<li>@brief: 函数简介</li>\n<li>@param: 参数说明</li>\n<li>@arg: 可选的参数</li>\n<li>@retval: 返回值说明</li>\n</ul>\n<h2 id=\"结构体格式\">结构体格式</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  DMA Init structure definition</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralBaseAddr; <span class=\"comment\">/*!&lt; Specifies the peripheral base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryBaseAddr;     <span class=\"comment\">/*!&lt; Specifies the memory base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_DIR;                <span class=\"comment\">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_BufferSize;         <span class=\"comment\">/*!&lt; Specifies the buffer size, in data unit, of the specified Channel. </span></span><br><span class=\"line\"><span class=\"comment\">                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize</span></span><br><span class=\"line\"><span class=\"comment\">                                        or DMA_MemoryDataSize members depending in the transfer direction. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralInc;      <span class=\"comment\">/*!&lt; Specifies whether the Peripheral address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryInc;          <span class=\"comment\">/*!&lt; Specifies whether the memory address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralDataSize; <span class=\"comment\">/*!&lt; Specifies the Peripheral data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryDataSize;     <span class=\"comment\">/*!&lt; Specifies the Memory data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Mode;               <span class=\"comment\">/*!&lt; Specifies the operation mode of the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_circular_normal_mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                        @note: The circular buffer mode cannot be used if the memory-to-memory</span></span><br><span class=\"line\"><span class=\"comment\">                                              data transfer is configured on the selected Channel */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Priority;           <span class=\"comment\">/*!&lt; Specifies the software priority for the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_priority_level */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_M2M;                <span class=\"comment\">/*!&lt; Specifies if the DMAy Channelx will be used in memory-to-memory transfer.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_to_memory */</span></span><br><span class=\"line\">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分</p>\n<ul>\n<li>@brief: 结构体说明</li>\n<li>@note 参数说明</li>\n<li>@ref: 结构体成员取值选项</li>\n</ul>\n<h3 id=\"结构体成员取值的注释格式\">结构体成员取值的注释格式</h3>\n<p>以该结构体成员其后的注释为例, 可取值 @ref DMA_data_transfer_direction</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint32_t</span> DMA_DIR;                <span class=\"comment\">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br></pre></td></tr></table></figure>\n<p>则下文中需出现注释</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @defgroup DMA_data_transfer_direction </span></span><br><span class=\"line\"><span class=\"comment\">  * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \\</span></span><br><span class=\"line\"><span class=\"meta\">                         ((DIR) == DMA_DIR_PeripheralSRC))</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分</p>\n<ul>\n<li>@defgroup <NAME>: <NAME>为可取值组的名字需与@ref后的名字对应</li>\n<li>@{ @}: 取值组前后需要用@大括号括起来, 中间为结构体成员可以取的变量</li>\n<li>@ref <NAME>: 写在结构体成员之后, <NAME>需要与后文@defgroup的名字对应</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\">说明</h2>\n<p>注释规范化参考文件为<strong>STM32F103的库文件</strong>, 即ST公司写的库函数底层代码</p>\n<h2 id=\"文件头声明格式\">文件头声明格式</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @file    stm32f10x_dma.h</span></span><br><span class=\"line\"><span class=\"comment\">  * @author  MCD Application Team</span></span><br><span class=\"line\"><span class=\"comment\">  * @version V3.5.0</span></span><br><span class=\"line\"><span class=\"comment\">  * @date    11-March-2011</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief   This file contains all the functions prototypes for the DMA firmware </span></span><br><span class=\"line\"><span class=\"comment\">  *          library.</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  * @attention</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS</span></span><br><span class=\"line\"><span class=\"comment\">  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE</span></span><br><span class=\"line\"><span class=\"comment\">  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY</span></span><br><span class=\"line\"><span class=\"comment\">  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING</span></span><br><span class=\"line\"><span class=\"comment\">  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE</span></span><br><span class=\"line\"><span class=\"comment\">  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2011 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  ******************************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分</p>\n<ul>\n<li>@file: 文件名</li>\n<li>@author: 作者名</li>\n<li>@version: 版本号</li>\n<li>@date: 日期</li>\n<li>@brief 文档简介</li>\n<li>@attention: 注意信息</li>\n</ul>\n<h2 id=\"函数注释格式\">函数注释格式</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  Enables or disables the specified DMAy Channelx interrupts.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and </span></span><br><span class=\"line\"><span class=\"comment\">  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled</span></span><br><span class=\"line\"><span class=\"comment\">  *   or disabled. </span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be any combination of the following values:</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg DMA_IT_TC:  Transfer complete interrupt mask</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg DMA_IT_HT:  Half transfer interrupt mask</span></span><br><span class=\"line\"><span class=\"comment\">  *     @arg DMA_IT_TE:  Transfer error interrupt mask</span></span><br><span class=\"line\"><span class=\"comment\">  * @param  NewState: new state of the specified DMA interrupts.</span></span><br><span class=\"line\"><span class=\"comment\">  *   This parameter can be: ENABLE or DISABLE.</span></span><br><span class=\"line\"><span class=\"comment\">  * @retval None</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">DMA_ITConfig</span><span class=\"params\">(DMA_Channel_TypeDef* DMAy_Channelx, <span class=\"type\">uint32_t</span> DMA_IT, FunctionalState NewState)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Check the parameters */</span></span><br><span class=\"line\">  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));</span><br><span class=\"line\">  assert_param(IS_DMA_CONFIG_IT(DMA_IT));</span><br><span class=\"line\">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (NewState != DISABLE)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Enable the selected DMA interrupts */</span></span><br><span class=\"line\">    DMAy_Channelx-&gt;CCR |= DMA_IT;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Disable the selected DMA interrupts */</span></span><br><span class=\"line\">    DMAy_Channelx-&gt;CCR &amp;= ~DMA_IT;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分:</p>\n<ul>\n<li>@brief: 函数简介</li>\n<li>@param: 参数说明</li>\n<li>@arg: 可选的参数</li>\n<li>@retval: 返回值说明</li>\n</ul>\n<h2 id=\"结构体格式\">结构体格式</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  * @brief  DMA Init structure definition</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralBaseAddr; <span class=\"comment\">/*!&lt; Specifies the peripheral base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryBaseAddr;     <span class=\"comment\">/*!&lt; Specifies the memory base address for DMAy Channelx. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_DIR;                <span class=\"comment\">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_BufferSize;         <span class=\"comment\">/*!&lt; Specifies the buffer size, in data unit, of the specified Channel. </span></span><br><span class=\"line\"><span class=\"comment\">                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize</span></span><br><span class=\"line\"><span class=\"comment\">                                        or DMA_MemoryDataSize members depending in the transfer direction. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralInc;      <span class=\"comment\">/*!&lt; Specifies whether the Peripheral address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryInc;          <span class=\"comment\">/*!&lt; Specifies whether the memory address register is incremented or not.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_incremented_mode */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_PeripheralDataSize; <span class=\"comment\">/*!&lt; Specifies the Peripheral data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_peripheral_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_MemoryDataSize;     <span class=\"comment\">/*!&lt; Specifies the Memory data width.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_data_size */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Mode;               <span class=\"comment\">/*!&lt; Specifies the operation mode of the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_circular_normal_mode.</span></span><br><span class=\"line\"><span class=\"comment\">                                        @note: The circular buffer mode cannot be used if the memory-to-memory</span></span><br><span class=\"line\"><span class=\"comment\">                                              data transfer is configured on the selected Channel */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_Priority;           <span class=\"comment\">/*!&lt; Specifies the software priority for the DMAy Channelx.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_priority_level */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> DMA_M2M;                <span class=\"comment\">/*!&lt; Specifies if the DMAy Channelx will be used in memory-to-memory transfer.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_memory_to_memory */</span></span><br><span class=\"line\">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分</p>\n<ul>\n<li>@brief: 结构体说明</li>\n<li>@note 参数说明</li>\n<li>@ref: 结构体成员取值选项</li>\n</ul>\n<h3 id=\"结构体成员取值的注释格式\">结构体成员取值的注释格式</h3>\n<p>以该结构体成员其后的注释为例, 可取值 @ref DMA_data_transfer_direction</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint32_t</span> DMA_DIR;                <span class=\"comment\">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class=\"line\"><span class=\"comment\">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br></pre></td></tr></table></figure>\n<p>则下文中需出现注释</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** @defgroup DMA_data_transfer_direction </span></span><br><span class=\"line\"><span class=\"comment\">  * @&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \\</span></span><br><span class=\"line\"><span class=\"meta\">                         ((DIR) == DMA_DIR_PeripheralSRC))</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * @&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<p>通常包含以下部分</p>\n<ul>\n<li>@defgroup <NAME>: <NAME>为可取值组的名字需与@ref后的名字对应</li>\n<li>@{ @}: 取值组前后需要用@大括号括起来, 中间为结构体成员可以取的变量</li>\n<li>@ref <NAME>: 写在结构体成员之后, <NAME>需要与后文@defgroup的名字对应</li>\n</ul>\n"},{"title":"取消Vscode在输入符号时自动补全","date":"2024-01-27T12:45:43.000Z","_content":"\n## 问题演示\n\n![问题演示](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272046475.png)\n\n在此状态下输入/会直接自动补全, 如下图\n\n![问题演示](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272047507.png)\n\n笔者想要达到的效果为可以正常输入/而不进行补全, 如下图\n\n![问题演示](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272048697.png)\n\n## 解决方法\n\n在设置->文本编辑器->建议, 取消勾选Accept Suggestion On Commit Character, 如下图所示\n\n![解决方法](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272051596.png)\n\n","source":"_posts/取消Vscode在输入符号时自动补全.md","raw":"---\ntitle: 取消Vscode在输入符号时自动补全\ndate: 2024-01-27 20:45:43\ntags: Vscode\n---\n\n## 问题演示\n\n![问题演示](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272046475.png)\n\n在此状态下输入/会直接自动补全, 如下图\n\n![问题演示](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272047507.png)\n\n笔者想要达到的效果为可以正常输入/而不进行补全, 如下图\n\n![问题演示](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272048697.png)\n\n## 解决方法\n\n在设置->文本编辑器->建议, 取消勾选Accept Suggestion On Commit Character, 如下图所示\n\n![解决方法](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272051596.png)\n\n","slug":"取消Vscode在输入符号时自动补全","published":1,"updated":"2024-01-27T12:51:50.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrw2n0f30000zo973lfk8h1u","content":"<h2 id=\"问题演示\">问题演示</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272046475.png\" alt=\"问题演示\"></p>\n<p>在此状态下输入/会直接自动补全, 如下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272047507.png\" alt=\"问题演示\"></p>\n<p>笔者想要达到的效果为可以正常输入/而不进行补全, 如下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272048697.png\" alt=\"问题演示\"></p>\n<h2 id=\"解决方法\">解决方法</h2>\n<p>在设置-&gt;文本编辑器-&gt;建议, 取消勾选Accept Suggestion On Commit Character, 如下图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272051596.png\" alt=\"解决方法\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题演示\">问题演示</h2>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272046475.png\" alt=\"问题演示\"></p>\n<p>在此状态下输入/会直接自动补全, 如下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272047507.png\" alt=\"问题演示\"></p>\n<p>笔者想要达到的效果为可以正常输入/而不进行补全, 如下图</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272048697.png\" alt=\"问题演示\"></p>\n<h2 id=\"解决方法\">解决方法</h2>\n<p>在设置-&gt;文本编辑器-&gt;建议, 取消勾选Accept Suggestion On Commit Character, 如下图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272051596.png\" alt=\"解决方法\"></p>\n"},{"title":"Vscode常用快捷键","date":"2024-01-27T13:51:54.000Z","_content":"\n## 说明\n\n仅供读者本人备忘使用, 不具备参考价值\n\n## 面板操作\n\n- 收起/打开左侧边栏: Ctrl+B\n- 切换标签页: Ctrl+Tab\n- 选择标签页: Alt+<NUMBER> (NUMBER为当前为第几个标签页)\n- 显示下方集成终端面板: Ctrl+`\n- 聚焦到资源管理器: Ctrl+Shift+E\n- 最大化终端面板: Ctrl+J\n\n## 编辑操作\n\n- 代码注释: Ctrl+/\n- 生成文档(基于Copilot): Ctrl+Shift+D\n- 智能修复(fix)报错(基于Copilot): Ctrl+Shift+F\n","source":"_posts/Vscode常用快捷键.md","raw":"---\ntitle: Vscode常用快捷键\ndate: 2024-01-27 21:51:54\ntags: Vscode\n---\n\n## 说明\n\n仅供读者本人备忘使用, 不具备参考价值\n\n## 面板操作\n\n- 收起/打开左侧边栏: Ctrl+B\n- 切换标签页: Ctrl+Tab\n- 选择标签页: Alt+<NUMBER> (NUMBER为当前为第几个标签页)\n- 显示下方集成终端面板: Ctrl+`\n- 聚焦到资源管理器: Ctrl+Shift+E\n- 最大化终端面板: Ctrl+J\n\n## 编辑操作\n\n- 代码注释: Ctrl+/\n- 生成文档(基于Copilot): Ctrl+Shift+D\n- 智能修复(fix)报错(基于Copilot): Ctrl+Shift+F\n","slug":"Vscode常用快捷键","published":1,"updated":"2024-02-01T06:13:26.840Z","_id":"clrw50tga0000t497bqnwctst","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\">说明</h2>\n<p>仅供读者本人备忘使用, 不具备参考价值</p>\n<h2 id=\"面板操作\">面板操作</h2>\n<ul>\n<li>收起/打开左侧边栏: Ctrl+B</li>\n<li>切换标签页: Ctrl+Tab</li>\n<li>选择标签页: Alt+<NUMBER> (NUMBER为当前为第几个标签页)</li>\n<li>显示下方集成终端面板: Ctrl+`</li>\n<li>聚焦到资源管理器: Ctrl+Shift+E</li>\n<li>最大化终端面板: Ctrl+J</li>\n</ul>\n<h2 id=\"编辑操作\">编辑操作</h2>\n<ul>\n<li>代码注释: Ctrl+/</li>\n<li>生成文档(基于Copilot): Ctrl+Shift+D</li>\n<li>智能修复(fix)报错(基于Copilot): Ctrl+Shift+F</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\">说明</h2>\n<p>仅供读者本人备忘使用, 不具备参考价值</p>\n<h2 id=\"面板操作\">面板操作</h2>\n<ul>\n<li>收起/打开左侧边栏: Ctrl+B</li>\n<li>切换标签页: Ctrl+Tab</li>\n<li>选择标签页: Alt+<NUMBER> (NUMBER为当前为第几个标签页)</li>\n<li>显示下方集成终端面板: Ctrl+`</li>\n<li>聚焦到资源管理器: Ctrl+Shift+E</li>\n<li>最大化终端面板: Ctrl+J</li>\n</ul>\n<h2 id=\"编辑操作\">编辑操作</h2>\n<ul>\n<li>代码注释: Ctrl+/</li>\n<li>生成文档(基于Copilot): Ctrl+Shift+D</li>\n<li>智能修复(fix)报错(基于Copilot): Ctrl+Shift+F</li>\n</ul>\n"},{"title":"增加Vscode引用路径","date":"2024-01-27T14:02:55.000Z","_content":"\n## 问题说明\n\n在嵌入式开发中需要经常用到库函数(SPL), Vscode需要配置引用路径才能对函数名或变量进行跳转\n\n## 解决思路1\n\n与Keil5 MDK类似, 在配置C/C++的json文件中添加所使用的头文件路径\n\n### 在Vscode中进行配置\n\n在vscode中按Ctrl+Shift+P 输入configuration, 如图选择C/C++编程配置(json)\n\n![Vscode配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272209160.png)\n\n在\"includePath\"后面增加所要使用的头文件的路径, 如下图所示\n\n![Vscode配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272342499.png)\n\n### 缺点\n\n配置起来较为繁琐, 且部分函数依然无法跳转\n\n## 解决思路2\n\n在思路1的基础上, 向编写的文件中包含\"stm32f10x_conf.h文件\"\n\n```c\n#include \"stm32f10x_conf.h\"\n```\n\n在stm32f10x_conf文件中有对于所有外设头文件的包含\n\n```c\n/* Includes ------------------------------------------------------------------*/\n/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */\n#include \"stm32f10x_adc.h\"\n#include \"stm32f10x_bkp.h\"\n#include \"stm32f10x_can.h\"\n#include \"stm32f10x_cec.h\"\n#include \"stm32f10x_crc.h\"\n#include \"stm32f10x_dac.h\"\n#include \"stm32f10x_dbgmcu.h\"\n#include \"stm32f10x_dma.h\"\n#include \"stm32f10x_exti.h\"\n#include \"stm32f10x_flash.h\"\n#include \"stm32f10x_fsmc.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_i2c.h\"\n#include \"stm32f10x_iwdg.h\"\n#include \"stm32f10x_pwr.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_rtc.h\"\n#include \"stm32f10x_sdio.h\"\n#include \"stm32f10x_spi.h\"\n#include \"stm32f10x_tim.h\"\n#include \"stm32f10x_usart.h\"\n#include \"stm32f10x_wwdg.h\"\n#include \"misc.h\" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */\n```\n\n所以在思路1的基础上加上思路2可以较好的解决该问题\n\n","source":"_posts/增加Vscode引用路径.md","raw":"---\ntitle: 增加Vscode引用路径\ndate: 2024-01-27 22:02:55\ntags: Vscode\n---\n\n## 问题说明\n\n在嵌入式开发中需要经常用到库函数(SPL), Vscode需要配置引用路径才能对函数名或变量进行跳转\n\n## 解决思路1\n\n与Keil5 MDK类似, 在配置C/C++的json文件中添加所使用的头文件路径\n\n### 在Vscode中进行配置\n\n在vscode中按Ctrl+Shift+P 输入configuration, 如图选择C/C++编程配置(json)\n\n![Vscode配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272209160.png)\n\n在\"includePath\"后面增加所要使用的头文件的路径, 如下图所示\n\n![Vscode配置](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272342499.png)\n\n### 缺点\n\n配置起来较为繁琐, 且部分函数依然无法跳转\n\n## 解决思路2\n\n在思路1的基础上, 向编写的文件中包含\"stm32f10x_conf.h文件\"\n\n```c\n#include \"stm32f10x_conf.h\"\n```\n\n在stm32f10x_conf文件中有对于所有外设头文件的包含\n\n```c\n/* Includes ------------------------------------------------------------------*/\n/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */\n#include \"stm32f10x_adc.h\"\n#include \"stm32f10x_bkp.h\"\n#include \"stm32f10x_can.h\"\n#include \"stm32f10x_cec.h\"\n#include \"stm32f10x_crc.h\"\n#include \"stm32f10x_dac.h\"\n#include \"stm32f10x_dbgmcu.h\"\n#include \"stm32f10x_dma.h\"\n#include \"stm32f10x_exti.h\"\n#include \"stm32f10x_flash.h\"\n#include \"stm32f10x_fsmc.h\"\n#include \"stm32f10x_gpio.h\"\n#include \"stm32f10x_i2c.h\"\n#include \"stm32f10x_iwdg.h\"\n#include \"stm32f10x_pwr.h\"\n#include \"stm32f10x_rcc.h\"\n#include \"stm32f10x_rtc.h\"\n#include \"stm32f10x_sdio.h\"\n#include \"stm32f10x_spi.h\"\n#include \"stm32f10x_tim.h\"\n#include \"stm32f10x_usart.h\"\n#include \"stm32f10x_wwdg.h\"\n#include \"misc.h\" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */\n```\n\n所以在思路1的基础上加上思路2可以较好的解决该问题\n\n","slug":"增加Vscode引用路径","published":1,"updated":"2024-01-27T16:10:50.086Z","_id":"clrw5sxen000000973e9ubvsy","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"问题说明\">问题说明</h2>\n<p>在嵌入式开发中需要经常用到库函数(SPL), Vscode需要配置引用路径才能对函数名或变量进行跳转</p>\n<h2 id=\"解决思路1\">解决思路1</h2>\n<p>与Keil5 MDK类似, 在配置C/C++的json文件中添加所使用的头文件路径</p>\n<h3 id=\"在vscode中进行配置\">在Vscode中进行配置</h3>\n<p>在vscode中按Ctrl+Shift+P 输入configuration, 如图选择C/C++编程配置(json)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272209160.png\" alt=\"Vscode配置\"></p>\n<p>在&quot;includePath&quot;后面增加所要使用的头文件的路径, 如下图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272342499.png\" alt=\"Vscode配置\"></p>\n<h3 id=\"缺点\">缺点</h3>\n<p>配置起来较为繁琐, 且部分函数依然无法跳转</p>\n<h2 id=\"解决思路2\">解决思路2</h2>\n<p>在思路1的基础上, 向编写的文件中包含&quot;stm32f10x_conf.h文件&quot;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_conf.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p>在stm32f10x_conf文件中有对于所有外设头文件的包含</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Includes ------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_adc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_bkp.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_can.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_cec.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_crc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_dac.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_dbgmcu.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_dma.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_exti.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_flash.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_fsmc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_i2c.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_iwdg.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_pwr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rtc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_sdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_spi.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_tim.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_wwdg.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;misc.h&quot;</span> <span class=\"comment\">/* High level functions for NVIC and SysTick (add-on to CMSIS functions) */</span></span></span><br></pre></td></tr></table></figure>\n<p>所以在思路1的基础上加上思路2可以较好的解决该问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题说明\">问题说明</h2>\n<p>在嵌入式开发中需要经常用到库函数(SPL), Vscode需要配置引用路径才能对函数名或变量进行跳转</p>\n<h2 id=\"解决思路1\">解决思路1</h2>\n<p>与Keil5 MDK类似, 在配置C/C++的json文件中添加所使用的头文件路径</p>\n<h3 id=\"在vscode中进行配置\">在Vscode中进行配置</h3>\n<p>在vscode中按Ctrl+Shift+P 输入configuration, 如图选择C/C++编程配置(json)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272209160.png\" alt=\"Vscode配置\"></p>\n<p>在&quot;includePath&quot;后面增加所要使用的头文件的路径, 如下图所示</p>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401272342499.png\" alt=\"Vscode配置\"></p>\n<h3 id=\"缺点\">缺点</h3>\n<p>配置起来较为繁琐, 且部分函数依然无法跳转</p>\n<h2 id=\"解决思路2\">解决思路2</h2>\n<p>在思路1的基础上, 向编写的文件中包含&quot;stm32f10x_conf.h文件&quot;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_conf.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p>在stm32f10x_conf文件中有对于所有外设头文件的包含</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Includes ------------------------------------------------------------------*/</span></span><br><span class=\"line\"><span class=\"comment\">/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_adc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_bkp.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_can.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_cec.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_crc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_dac.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_dbgmcu.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_dma.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_exti.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_flash.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_fsmc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_i2c.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_iwdg.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_pwr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rcc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_rtc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_sdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_spi.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_tim.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_usart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stm32f10x_wwdg.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;misc.h&quot;</span> <span class=\"comment\">/* High level functions for NVIC and SysTick (add-on to CMSIS functions) */</span></span></span><br></pre></td></tr></table></figure>\n<p>所以在思路1的基础上加上思路2可以较好的解决该问题</p>\n"},{"title":"配置Vscode与STM32串口连接","date":"2024-01-27T19:21:42.000Z","_content":"\n## 串口连接\n\n**插件: Serial Monitor**\n\n### 使用截图\n\n![](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280323798.png)\n\n","source":"_posts/配置Vscode与STM32串口连接.md","raw":"---\ntitle: 配置Vscode与STM32串口连接\ndate: 2024-01-28 03:21:42\ntags: Vscode\n---\n\n## 串口连接\n\n**插件: Serial Monitor**\n\n### 使用截图\n\n![](https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280323798.png)\n\n","slug":"配置Vscode与STM32串口连接","published":1,"updated":"2024-01-27T19:25:33.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrwgpaob0000go976ztxf212","content":"<h2 id=\"串口连接\">串口连接</h2>\n<p><strong>插件: Serial Monitor</strong></p>\n<h3 id=\"使用截图\">使用截图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280323798.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"串口连接\">串口连接</h2>\n<p><strong>插件: Serial Monitor</strong></p>\n<h3 id=\"使用截图\">使用截图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280323798.png\" alt=\"\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cli8bhb6a0000zs974go4f538","tag_id":"cli8bhb6f0001zs978c3v5bnx","_id":"cli8cd8os00003s972znxbczp"},{"post_id":"cli8unx910000r497b6ku1naw","tag_id":"cli8unx970002r497gtyyczuf","_id":"cli8unx990004r49778gkdt1q"},{"post_id":"cli8unx950001r4970x0uh6az","tag_id":"cli8unx970002r497gtyyczuf","_id":"cli8unx9a0005r497datbf812"},{"post_id":"cli8w3wnr00000g978six79iw","tag_id":"cli8w3wnx00010g97bwamfvhi","_id":"cli8w3wnz00020g976u9r4oup"},{"post_id":"clrcf4r5v00005s972uhxhlt1","tag_id":"clrcf4r5z00015s97cdlvegac","_id":"clrcf4r6100025s97cez85duq"},{"post_id":"clr20lqim0000b89714p11vpp","tag_id":"clrgn4wn90000cw972sacbdtd","_id":"clrgn4wnb0001cw97cmhscgra"},{"post_id":"clrgo9dgz0000hw9755wv2e89","tag_id":"clrcf4r5z00015s97cdlvegac","_id":"clrgo9dh40001hw974ndcauss"},{"post_id":"clrgok3h30000ck974lk05ny7","tag_id":"cli8bhb6f0001zs978c3v5bnx","_id":"clrgok3ha0001ck975uiz65zk"},{"post_id":"clrhhyxwb0000t497ecjy0118","tag_id":"clrhhyxwh0001t497eqs1h3ui","_id":"clrhhyxwk0002t4974ygf33dc"},{"post_id":"clrubdkrb0000hs97hw5b7obx","tag_id":"clrubdkrg0001hs970k3050d8","_id":"clrubdkrj0002hs977ynz53d2"},{"post_id":"clrw2n0f30000zo973lfk8h1u","tag_id":"clrw2n0f70001zo97e3wn2q7b","_id":"clrw2n0f90002zo97b0vg26ox"},{"post_id":"clrw50tga0000t497bqnwctst","tag_id":"clrw2n0f70001zo97e3wn2q7b","_id":"clrw50tge0001t497bfnq5f1h"},{"post_id":"clrw5sxen000000973e9ubvsy","tag_id":"clrw2n0f70001zo97e3wn2q7b","_id":"clrw5sxet00010097381c357f"},{"post_id":"clrwgpaob0000go976ztxf212","tag_id":"clrw2n0f70001zo97e3wn2q7b","_id":"clrwgpaof0001go97c3k8arjz"}],"Tag":[{"name":"嵌入式","_id":"cli8bhb6f0001zs978c3v5bnx"},{"name":"Embedded","_id":"cli8c3tk00000vk97eccghxyn"},{"name":"test","_id":"cli8c4yko0001m0976p4ecy0o"},{"name":"Windows","_id":"cli8unx970002r497gtyyczuf"},{"name":"博客","_id":"cli8w3wnx00010g97bwamfvhi"},{"name":"Git","_id":"clrcf4r5z00015s97cdlvegac"},{"name":"虚拟机","_id":"clrgn4wn90000cw972sacbdtd"},{"name":"通信","_id":"clrhhyxwh0001t497eqs1h3ui"},{"name":"Doxygen","_id":"clrubdkrg0001hs970k3050d8"},{"name":"Vscode","_id":"clrw2n0f70001zo97e3wn2q7b"}]}}