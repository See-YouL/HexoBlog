<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="STM32F103学习笔记 说明 本库仅供学习交流使用  开发板: 野火霸道V2开发板 编译器： ARM v5.06 C编译版本: C99 固件库版本: V3.5.0 MDK version: 538A 芯片包: Keil.STM32F1xx_DFP.2.4.1 芯片型号: STM32F103ZET6 参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道&#x2F;指南者&#x2F;MINI)【全】(刘">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32F103学习笔记">
<meta property="og:url" content="http://example.com/2024/01/17/STM32F103%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="过隙影">
<meta property="og:description" content="STM32F103学习笔记 说明 本库仅供学习交流使用  开发板: 野火霸道V2开发板 编译器： ARM v5.06 C编译版本: C99 固件库版本: V3.5.0 MDK version: 538A 芯片包: Keil.STM32F1xx_DFP.2.4.1 芯片型号: STM32F103ZET6 参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道&#x2F;指南者&#x2F;MINI)【全】(刘">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.41.14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.09.27.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.20.46.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.23.18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.18.55.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.24.03.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.29.40.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.33.21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.35.42.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202312301523539.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401011723631.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021935413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021941642.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031428875.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031529274.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530696.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031531689.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031539781.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031556307.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031557775.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031600256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031623174.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624509.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624882.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032016385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032025440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032026200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034894.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032035341.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046548.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046349.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032047305.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103293.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103739.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2009.47.02.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.03.07.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401291156077.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.13.53.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.26.21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2011.09.39.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401140238595.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.13.32.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.18.42.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170017620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170023320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025237.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025314.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171542012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171546066.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171548657.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171550768.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171552733.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171554763.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171555519.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610887.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171611637.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171631235.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171634288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171644660.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171655718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171658813.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171659831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171702232.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703050.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171704956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708669.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708578.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171710068.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171723621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171725627.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727509.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727238.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171730822.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171731175.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171732400.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171739676.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171900970.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171906798.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171909589.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171910703.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401172002602.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220859886.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220904826.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401250242370.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261122722.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261126729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261127579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261128690.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262322421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262327533.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262328328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262336065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262341860.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270000903.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270001764.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270007166.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270111246.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270140896.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270157626.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270207508.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270209992.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270225648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270237788.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270243764.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270254565.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270305500.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270315440.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270346561.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270316720.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347794.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270325594.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270333989.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347332.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270337311.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270348369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270355991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270357886.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270423471.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271607885.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271610721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271612900.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271616560.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271618557.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271622473.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271623317.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271625131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280036252.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037103.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038783.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038105.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271630443.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271642465.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271648925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702961.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271701248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271719435.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271723653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271734727.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271741445.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280423663.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271810617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271813901.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271821179.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271838678.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271841941.png">
<meta property="og:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280831099.png">
<meta property="article:published_time" content="2024-01-16T18:19:55.000Z">
<meta property="article:modified_time" content="2024-01-29T08:41:57.574Z">
<meta property="article:author" content="Eric Ellis">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png">

<link rel="canonical" href="http://example.com/2024/01/17/STM32F103%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STM32F103学习笔记 | 过隙影</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">过隙影</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/17/STM32F103%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eric Ellis">
      <meta itemprop="description" content="记录生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="过隙影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STM32F103学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 02:19:55" itemprop="dateCreated datePublished" datetime="2024-01-17T02:19:55+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-29 16:41:57" itemprop="dateModified" datetime="2024-01-29T16:41:57+08:00">2024-01-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="stm32f103学习笔记">STM32F103学习笔记</h1>
<h2 id="说明">说明</h2>
<p>本库仅供学习交流使用</p>
<ul>
<li>开发板: 野火霸道V2开发板</li>
<li>编译器： ARM v5.06</li>
<li>C编译版本: C99</li>
<li>固件库版本: V3.5.0</li>
<li>MDK version: 538A</li>
<li>芯片包: Keil.STM32F1xx_DFP.2.4.1</li>
<li>芯片型号: STM32F103ZET6</li>
<li>参考视频: 【【单片机】野火STM32F103教学视频 (配套霸道/指南者/MINI)【全】(刘火良老师出品) (无字幕)】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4">https://www.bilibili.com/video/BV1yW411Y7Gw/?p=9&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4</a></li>
<li>仓库地址: <a target="_blank" rel="noopener" href="https://github.com/See-YouL/Fire-Projects.git">https://github.com/See-YouL/Fire-Projects.git</a></li>
</ul>
<h2 id="基础配置">基础配置</h2>
<h3 id="配置keilmdk">配置KeilMDK</h3>
<p>看视频配置KeilMDK,P2</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yW411Y7Gw">看视频配置Keil MDK</a></p>
<h3 id="配置串口下载程序">配置串口下载程序</h3>
<p>看视频配置串口下载程序,P4</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yW411Y7Gw">看视频配置串口下载程序</a></p>
<h3 id="美化keil界面">美化Keil界面</h3>
<p><strong>非必须步骤</strong>, 用来美化界面</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uT411S7mB/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4">使用该方案的插件</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Df4y1k75Z/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4">使用该方案的主题配色</a></p>
<h3 id="配置vscode">配置VScode</h3>
<p><strong>非必须步骤</strong>, 用来使用VScode开发, <em>也可使用Keil MDK则不需要该步骤</em></p>
<p>方案一: 使用VScode + Keil5 MDK进行开发(主要插件<strong>Keil Assistant</strong>)</p>
<ul>
<li>优点: 不需要使用Keil进行编辑</li>
<li>缺点: 不具备Debug功能,只有编译和烧录</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19V411g7gD/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4">方案一参考视频</a></p>
<p>方案二: 使用Vscode + EIDE进行开发(主要插件<strong>EIDE</strong>)</p>
<ul>
<li>优点: 可在VScode中进行调试</li>
<li>缺点: 依赖Keil的编译环境</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nr4y1R7Jb/?share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4">方案二参考视频</a></p>
<h2 id="理论知识">理论知识</h2>
<h3 id="stm32命名方式">STM32命名方式</h3>
<ul>
<li>STM32: 32bit的MCU</li>
<li>F或L: F表示基础型(Foundation)或高性能型(High-Performance), L表示低功耗型(Ultra-low-power)</li>
<li>xxx: 芯片特性, 如性能级别、内存大小、特殊功能等</li>
<li>系列:
<ul>
<li>F0, F1, F2, F3, F4, F7：这些数字代表不同的性能级别，数字越大，性能通常越高。</li>
<li>L0, L1, L4, L5：这些是低功耗系列，数字越大，性能和功能通常越丰富。</li>
</ul>
</li>
<li>性能级别: 通常由一到两位数字表示，如STM32F103或STM32L152。这些数字表示不同的性能级别、内存大小和外设</li>
<li>包装类型: 通常由一个字母表示，如STM32F103C8T6中的C表示LQFP48封装</li>
<li>额外特性: 如STM32F103C8T6中的8表示该芯片有64KB闪存，T表示温度范围（-40°C 到 85°C），6表示批次号或版本</li>
</ul>
<h4 id="例子">例子</h4>
<p>以 STM32F103C8T6 为例：</p>
<ul>
<li>STM32：STMicroelectronics的32位微控制器。</li>
<li>F：Foundation系列。</li>
<li>103：该系列中的特定型号，具有特定的性能、内存和外设配置。</li>
<li>C：封装类型，这里是LQFP48。</li>
<li>8：闪存大小，这里是64KB。</li>
<li>T：温度范围，这里是-40°C 到 85°C。</li>
<li>6：批次号或版本。</li>
</ul>
<h2 id="置位与清零">置位与清零</h2>
<ul>
<li>&amp;= ~(1 &lt;&lt; n); <strong>将bit n清零,其他位保持不变</strong></li>
<li>|= (1 &lt;&lt; n); <strong>将bit n置1,其他位保持不变</strong></li>
</ul>
<h2 id="gpio">GPIO</h2>
<h3 id="gpio简介">GPIO简介</h3>
<p>GPIO(General purpose input output)通用输入输出端口的简称,<strong>软件可以控制的引脚,可输入可输出</strong></p>
<h4 id="gpio和引脚的区别">GPIO和引脚的区别</h4>
<p>引脚（Pin）</p>
<ul>
<li>定义：引脚是指微控制器、微处理器或其他电子组件上的物理接点。它们是硬件设备的一部分，用于连接电路板、传递信号或供电。</li>
<li>通用性：引脚可以有多种功能，包括但不限于传输数据、供电、接地或作为特殊功能的接口（如模拟输入、PWM输出等）。</li>
<li>物理特性：引脚是实体的、物理存在的，可以是金属的脚或焊盘。</li>
</ul>
<p>GPIO（General-Purpose Input/Output）</p>
<ul>
<li>定义：GPIO是指在微控制器或其他数字电路设备上的一种特定类型的引脚，可以通过编程设置为输入或输出模式。</li>
<li>功能：GPIO引脚的功能非常灵活，可以用于读取数字信号（如按钮的按压）或输出数字信号（如控制LED灯的开关）。</li>
<li>编程控制：GPIO引脚的主要特点是它们可以通过软件编程来控制其行为，这使得它们非常适合于各种通用的数字输入输出任务。</li>
</ul>
<p>区别</p>
<ul>
<li>功能范围：所有GPIO都是引脚，但并非所有引脚都是GPIO。引脚是一个更广泛的概念，包括GPIO以及其他专用功能的引脚。</li>
<li>灵活性和用途：GPIO引脚特别设计用于通用的数字输入输出任务，并且它们的行为可以通过软件编程来改变。而其他类型的引脚可能有固定的功能，如电源、接地或特定的通信功能。</li>
<li>编程控制：GPIO的关键特性是它们可以被编程来执行不同的任务（输入或输出），而其他类型的引脚可能不具备这种灵活性。</li>
</ul>
<p>总的来说，<strong>GPIO是引脚的一个子集，专门用于可编程的通用数字输入输出任务。而引脚是一个更广泛的概念，涵盖了电子设备上的所有物理接点。</strong></p>
<h4 id="引脚的分类">引脚的分类</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.37.46.png" alt="引脚的分类"></p>
<h3 id="gpio-框图讲解">GPIO 框图讲解</h3>
<h4 id="保护二极管">保护二极管</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2014.41.14.png" alt="保护二极管"></p>
<ul>
<li><strong>如果引脚电压大于VDD则上面的保护二极管导通</strong>,防止高电压进入芯片内部,如果电压过高则会烧坏二极管进而烧坏芯片</li>
<li><strong>如果引脚电压低于VSS则下面的保护二极管导通</strong>,保护芯片</li>
</ul>
<h4 id="推挽输出">推挽输出</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.09.27.png" alt="ODR=1时推挽输出原理图"></p>
<p>推挽输出部分的INT来自ODR寄存器</p>
<p>若ODR为1, 经过反相器后为0, 此时PMOS和NMOS的Ug=0V</p>
<p>对于PMOS, Us=3.3V &gt; Ug=0V, PMOS管导通, OUT=VDD</p>
<p>对于NMOS, Us=0V = Ug=0V, 简单认为, NMOS管截止</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.20.46.png" alt="ODR=0时推挽输出原理图"></p>
<p>若ODR为0,经过反相器后为1, 此时PMOS和NMOS的Ug=3.3V</p>
<p>对于PMOS, Us=3.3V = Ug=3.3V, 简单认为, PMOS管截止</p>
<p>对于NMOS, Us=0V &lt; Ug=3.3V, NMOS管导通, OUT=GND=0V</p>
<h5 id="推挽输出的含义">推挽输出的含义</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2015.23.18.png" alt="推挽输出含义图"></p>
<ul>
<li>PMOS导通时, OUT处电流向外称为<strong>推</strong>, 此时电流称为<strong>灌电流</strong></li>
<li>NMOS导通时, OUT处电流向里称为<strong>挽</strong>, 此时电流称为<strong>拉电流</strong></li>
</ul>
<p>推挽输出（Push-Pull Output）是一种常见的电子电路输出类型，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的<strong>主要特点是它使用两个晶体管（一个N型和一个P型）来控制输出引脚的电压状态。</strong></p>
<h5 id="推挽输出的原理">推挽输出的原理</h5>
<p>在推挽配置中，通常有两个晶体管：</p>
<ul>
<li>N型晶体管：当被激活（或导通）时，它将输出引脚连接到地（GND），从而产生低电平（0）输出。</li>
<li>P型晶体管：当被激活时，它将输出引脚连接到正电源（VCC），从而产生高电平（1）输出。</li>
</ul>
<p>这两个晶体管不会同时导通，以避免短路。在任何给定的时刻，要么N型晶体管导通将输出拉低，要么P型晶体管导通将输出拉高。</p>
<h5 id="推挽输出的特点">推挽输出的特点</h5>
<ul>
<li>强驱动能力：<strong>推挽输出可以提供较强的电流驱动能力</strong>，无论是向输出引脚提供电流（高电平）还是从引脚吸收电流（低电平）。</li>
<li>确定的逻辑状态：输出要么明确地是高电平，要么是低电平，<strong>不会处于悬空（高阻态）状态</strong>。</li>
<li>无需外部上拉或下拉电阻：由于<strong>推挽输出自身就可以明确地驱动高电平或低电平</strong>，因此不需要外部的上拉或下拉电阻来确保稳定的输出状态。</li>
</ul>
<h5 id="推挽输出的应用">推挽输出的应用</h5>
<p>推挽输出广泛应用于各种数字电路，特别是<strong>在需要驱动LED、继电器或其他需要较高电流的负载时</strong>。由于其<strong>强大的驱动能力和清晰的逻辑电平</strong>，推挽输出是实现<strong>数字信号传输</strong>的理想选择。</p>
<h5 id="推挽输出对比开漏/开集输出">推挽输出对比开漏/开集输出</h5>
<p>与推挽输出相对的是开漏（在MOSFET技术中）或开集（在双极晶体管技术中）输出，<strong>这种类型的输出只有一个晶体管，要么将输出拉低，要么让它悬空（高阻态）</strong>。开漏/开集输出<strong>需要外部上拉电阻来确保高电平状态</strong>，常用于需要多个设备共享同一输出线的应用，如I2C通信协议。</p>
<h4 id="开漏输出">开漏输出</h4>
<p>内部只能输出低电平,不能输出高电平</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png" alt="当ODR为1时开漏输出原理图"></p>
<p>该图片标注有误, 实际用的是ODR=0时的图, 但是结构相同, 不影响分析</p>
<p>ODR=1, 经反相器为0, Vg=0V=Vs=0V, NMOS管截止, 此时OUT为高阻态悬空, 加入外部上拉电阻后, OUT=1</p>
<p>如果外部需要高电平驱动可以通过更换外部上拉电路来进行更换</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2016.06.58.png" alt="当ODR为0时开漏输出原理图"></p>
<p>ODR=0, 经反相器为1, Vg=1 &gt; Vs=0, NMOS管导通, 此时OUT=0V</p>
<p>开漏输出（Open-Drain Output，在使用MOSFET技术的情况下称为开漏，而在使用双极性晶体管的情况下称为开集（Open-Collector）输出）是一种常见的电子电路设计，特别是在数字电路和微控制器的GPIO（通用输入/输出）引脚中。这种输出类型的<strong>主要特点是它使用单个晶体管来控制输出引脚的电压状态，而不是像推挽输出那样使用两个晶体管。</strong></p>
<h5 id="开漏输出的原理">开漏输出的原理</h5>
<p>在开漏配置中，只有一个N型晶体管：</p>
<ul>
<li>N型晶体管：当晶体管导通（激活）时，它将输出引脚连接到地（GND），产生低电平（0）输出。当晶体管关闭（非激活）时，输出引脚不连接到任何东西，处于悬空状态。</li>
<li>由于输出在晶体管关闭时处于悬空状态，因此通常需要一个外部的上拉电阻连接到正电源（VCC），以确保当晶体管关闭时输出能够达到高电平（1）。</li>
</ul>
<h5 id="开漏输出的特点">开漏输出的特点</h5>
<ul>
<li>单向驱动能力：开漏输出<strong>只能将输出拉低，不能主动驱动高电平</strong>。</li>
<li>需要外部上拉电阻：<strong>为了确保输出能够达到高电平，需要外部上拉电阻</strong>。</li>
<li>适合于总线和共享线路：开漏输出非常<strong>适合于多个设备共享同一输出线的应用</strong>，因为任何一个设备都可以将线路拉低，而不会对其他设备造成干扰。</li>
</ul>
<h5 id="开漏输出的应用">开漏输出的应用</h5>
<p>开漏输出<strong>常用于需要多个设备共享同一通信线路的场合</strong>，如I2C和1-Wire通信协议。在这些应用中，<strong>多个设备可以连接到同一条线路上，每个设备都可以通过将线路拉低来发送信号，而不会影响其他设备。</strong></p>
<h5 id="开漏输出对比推挽输出">开漏输出对比推挽输出</h5>
<p>与开漏输出相对的是推挽输出，后者使用两个晶体管（一个N型和一个P型）来分别驱动高电平和低电平。推挽输出可以主动驱动高电平和低电平，而<strong>开漏输出只能驱动低电平，需要外部上拉电阻来实现高电平状态。</strong></p>
<h4 id="补充:-高阻态与悬空">补充: 高阻态与悬空</h4>
<p><strong>高阻态（High-Impedance State），通常简称为Hi-Z</strong>，是电子电路中的一个术语，用来描述一个电路节点在特定条件下呈现出非常高电阻的状态。在这种状态下，<strong>电路节点既不明显地连接到电源（高电平），也不明显地连接到地（低电平）</strong>。换句话说，这个节点处于一种“断开”或“浮空”的状态，对电路中的其他部分几乎没有任何电气影响。</p>
<h5 id="高阻态的应用">高阻态的应用</h5>
<ul>
<li><strong>三态逻辑（Tri-state Logic）</strong>：在数字电路中，高阻态常用于三态逻辑，<strong>允许多个输出连接到同一个线路或总线上，而不会相互干扰</strong>只有被选中的设备会将其输出置于低电阻状态（高电平或低电平），其他设备的输出则处于高阻态。</li>
<li><strong>总线系统</strong>：在微处理器、微控制器和其他数字系统的总线（如数据总线、地址总线）上，高阻态用于控制哪个设备可以在特定时刻向总线发送数据。</li>
<li><strong>输入/输出端口</strong>：在可编程的微控制器的GPIO（通用输入/输出）端口中，<strong>高阻态可以用来防止未使用的或被配置为输入的端口对电路造成影响</strong>。</li>
</ul>
<h5 id="高阻态的重要性">高阻态的重要性</h5>
<ul>
<li><strong>避免冲突</strong>：在多个设备共享同一通信线路时，高阻态可以防止输出冲突。</li>
<li><strong>节能</strong>：当端口处于高阻态时，它几乎不消耗电流，有助于降低功耗。</li>
<li><strong>灵活性</strong>：高阻态提供了电路设计的灵活性，特别是在需要多个设备共享同一资源的情况下。</li>
</ul>
<h5 id="高阻态的注意事项">高阻态的注意事项</h5>
<ul>
<li><strong>浮动电压</strong>：当一个端口或线路处于高阻态时，它可能会因为电磁干扰或静电感应而捕获不确定的电压，<strong>有时可能需要通过上拉或下拉电阻来确保稳定的逻辑状态</strong>。</li>
<li><strong>设计考虑</strong>：在设计电路和编写程序时，需要考虑到高阻态的影响，确保在适当的时候启用或禁用高阻态。</li>
</ul>
<p>在电子电路中，<strong>“悬空”（Floating）是指一个电路节点没有被明确连接到电源（高电平）或地（低电平），也没有通过任何电阻或其他电子元件连接到其他电路节点的状态</strong>这种状态下的节点电压是不确定的，因为它既不是被固定在逻辑高也不是逻辑低，而是可以随外部电磁场或附近电路的状态变化而变化。</p>
<h5 id="悬空状态的特点">悬空状态的特点</h5>
<ul>
<li>不确定的电压：悬空的节点可能会随机地捕获周围环境的电磁干扰，导致其电压处于不确定的状态。</li>
<li>易受干扰：由于没有明确的电气连接，悬空的节点容易受到外部电磁干扰的影响。</li>
<li>可能导致问题：在数字电路中，悬空的输入引脚可能导致不稳定的逻辑状态，从而引发电路的不可预测行为。</li>
</ul>
<h5 id="高阻态与悬空的关系">高阻态与悬空的关系</h5>
<p>高阻态是一种特定的电路配置，<strong>其中一个节点（如微控制器的GPIO引脚）被设置为非常高的电阻状态。这意味着该节点对电路的其他部分几乎没有电气影响，类似于断开连接</strong>因此，<strong>当一个引脚被设置为高阻态时，它实际上是在悬空状态</strong>，因为它既不是明确地连接到高电平也不是低电平。</p>
<h5 id="高阻态与悬空区别和联系">高阻态与悬空区别和联系</h5>
<ul>
<li>联系：<strong>高阻态通常会导致节点悬空</strong>当一个节点处于高阻态时，由于其极高的电阻值，它实际上与电路的其他部分隔离，从而处于悬空状态。</li>
<li>区别：<strong>高阻态是一种有意设置的电路状态</strong>，用于特定的目的（如防止总线冲突）。而<strong>悬空可能是无意的</strong>，可能是由于设计不当或电路未完成造成的。</li>
</ul>
<h5 id="悬空的注意事项">悬空的注意事项</h5>
<ul>
<li>设计考虑：在设计电子电路和系统时，<strong>应避免输入引脚悬空，因为这可能导致不稳定的行为</strong>。通常<strong>使用上拉或下拉电阻来确保这些引脚有一个确定的逻辑状态。</strong></li>
<li>高阻态应用：在某些情况下，如<strong>多个设备共享一个通信总线，高阻态是必要的，以确保只有一个设备在任何时刻控制总线。</strong></li>
</ul>
<h4 id="复用功能输出">复用功能输出</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.18.55.png" alt="复用功能输出原理框图"></p>
<p>通过片上外设如EXTI到引脚输出</p>
<h4 id="输入模式">输入模式</h4>
<p>ISR读出</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.24.03.png" alt="普通模式的输入"></p>
<p>I/O引脚至上拉/下拉输入(通过BSRR寄存器软件配置), 经TTL肖特基触发器(&gt;2V &lt;1.2V), 至IDR寄存器读出</p>
<p>复用功能输入</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.29.40.png" alt="复用功能输入"></p>
<p>以EXTI为例,RX数据经由TTL肖特基触发器到DR寄存器</p>
<p>模拟输入</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.33.21.png" alt="模拟输入框图"></p>
<p>不经过TTL肖特基触发器直接被读出</p>
<h4 id="gpio框图对应寄存器">GPIO框图对应寄存器</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2023-12-28%2018.35.42.png" alt="GPIO框图"></p>
<ul>
<li>2部分: 推挽,开漏输出对应CRL,CRH寄存器</li>
<li>3部分: 输出数据寄存器对应ODR; 位设置/清除寄存器对应BSRR</li>
<li>上拉/下拉输入: 对应CRL,CRH,具体选择上拉还是下拉需要软件配置BSRR</li>
<li>5部分: 输入数据寄存器对应IDR</li>
</ul>
<h3 id="gpio输出初始化顺序">GPIO输出初始化顺序</h3>
<ol>
<li>时钟使能</li>
<li>选择具体的GPIO</li>
<li>配置GPIO的工作模式(CRL CRH)</li>
<li>控制GPIO输出高低电平(ODR,BRR和BSRR)</li>
</ol>
<h2 id="手写库">手写库</h2>
<h3 id="通过地址使用寄存器">通过地址使用寄存器</h3>
<p>项目地址: <strong>REG-LED</strong></p>
<h4 id="mainc中的主要代码">main.c中的主要代码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021018</span>) |= ((<span class="number">1</span>) &lt;&lt; <span class="number">3</span>); <span class="comment">// RCC_APB2ENR的bit3置1</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">开启GPIOB的时钟</span></span><br><span class="line"><span class="comment">GPIOB挂载在APB2总线</span></span><br><span class="line"><span class="comment">RCC_APB2ENR的偏移量为0x18</span></span><br><span class="line"><span class="comment">RCC的基地址为0x40021000</span></span><br><span class="line"><span class="comment">RCC_APB2ENR的bit3为IOPBEN(IO端口B时钟使能) 1开启</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40010C00</span>) |= ((<span class="number">1</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">0</span>)); <span class="comment">// GPIOB_CRL的bit4-0置0001</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">将GPIOB设置为推挽输出</span></span><br><span class="line"><span class="comment">GPIOB 基地址 0x40010C00</span></span><br><span class="line"><span class="comment">GPIOx_CRL 偏移量 00h </span></span><br><span class="line"><span class="comment">bit1-0: 01 输出模式，最大速度10MHz</span></span><br><span class="line"><span class="comment">bit4-3: 00 通用推挽输出模式</span></span><br><span class="line"><span class="comment">((1) &lt;&lt; (4*0)) // 若修改PB1则为(4*1)</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40010C0C</span>) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>); <span class="comment">// GPIOB_ODR的bit0置0</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">修改PB0为1</span></span><br><span class="line"><span class="comment">GPIOB 基地址 0x40010C00</span></span><br><span class="line"><span class="comment">GPIOx_ODR 偏移量 0Ch </span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br></pre></td></tr></table></figure>
<h3 id="通过头文件定义使用寄存器">通过头文件定义使用寄存器</h3>
<p>项目地址: <strong>REG-LED-Register</strong></p>
<p>确定总线基地址, 其中AHB的基地址是从DMA1开始的,即从0x40020000开始</p>
<h4 id="在stm32f10xh中增加宏定义">在stm32f10x.h中增加宏定义</h4>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放stm32寄存器映射的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外设 Peripheral</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE ((unsigned int)0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB1PERIPH_BASE (PERIPH_BASE) <span class="comment">// 从TIM2开始</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE (PERIPH_BASE + 0x10000) <span class="comment">// 从AFIO开始</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHBPERIPH_BASE (PERIPH_BASE + 0x20000) <span class="comment">// 从DMA1开始</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RCC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE (AHBPERIPH_BASE + 0x1000) <span class="comment">// RCC基地址 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (APB2PERIPH_BASE + 0x0C00) <span class="comment">// GPIOB基地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x18)) <span class="comment">// APB2外设时钟使能寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL (*(volatile unsigned int *)(GPIOB_BASE + 0x00))<span class="comment">// GPIOB_CRL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH (*(volatile unsigned int *)(GPIOB_BASE + 0x04)) <span class="comment">// GPIOB_CRH</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C)) <span class="comment">// GPIOB_CRH</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中的主函数代码改为">在main.c中的主函数代码改为</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2ENR |= ((<span class="number">1</span>) &lt;&lt; <span class="number">3</span>); <span class="comment">// 开启GPIOB的时钟</span></span><br><span class="line">GPIOB_CRL &amp;= ~((<span class="number">0x0F</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">0</span>)); <span class="comment">// 将GPIOB状态清零</span></span><br><span class="line">GPIOB_CRL |= ((<span class="number">1</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">0</span>)); <span class="comment">// 将GPIOB设置为推挽输出</span></span><br><span class="line">GPIOB_ODR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>); <span class="comment">// PB0置0</span></span><br></pre></td></tr></table></figure>
<h4 id="补充:-关键字volatile的作用">补充: 关键字volatile的作用</h4>
<p>在C语言中，尤其是在嵌入式领域，volatile 关键字用于告诉编译器，<strong>定义为 volatile 的变量可能会以编译器不可预知的方式被改变</strong>。这意味着编译器在处理这些变量时，<strong>应避免进行某些优化，确保每次访问都直接从内存中读取变量的值</strong>。</p>
<h4 id="关键字volatile含义">关键字volatile含义</h4>
<p>当一个变量被声明为 volatile 时，编译器会对该变量的处理方式做出以下调整：</p>
<ul>
<li><strong>防止优化</strong>：编译器不会对这些变量进行优化，这可能包括消除看似多余的读取或写入操作。</li>
<li><strong>直接访问</strong>：每次访问 volatile 变量时，都会直接从其内存地址读取数据，而不是使用可能存储在寄存器中的副本。</li>
</ul>
<h4 id="关键字volatile的应用场景">关键字volatile的应用场景</h4>
<p>在嵌入式编程中，volatile 关键字的使用场景主要包括：</p>
<ul>
<li><strong>硬件寄存器访问</strong>：当编程与硬件寄存器交互时，如读取一个传感器的数据寄存器或写入一个控制寄存器。这些寄存器的值可能会在任何时候改变，因此需要使用 volatile 来确保每次读取或写入都是最新的值。</li>
<li><strong>中断服务例程</strong>：在中断服务例程（ISR）中使用的变量，这些变量可能在ISR中被改变，并在程序的其他部分被访问。使用 volatile 可以确保主程序中的代码能够看到在ISR中对这些变量所做的更改。</li>
<li><strong>多线程和并发</strong>：在多线程或并发环境中，一个线程可能修改另一个线程正在访问的变量。volatile 确保每个线程都能访问到最新的值。</li>
</ul>
<h4 id="关键字volative的注意事项">关键字volative的注意事项</h4>
<ul>
<li><strong>不是并发解决方案</strong>：volatile 关键字不能替代互斥锁或其他并发控制机制。它不保证操作的原子性或内存可见性。</li>
<li><strong>性能影响</strong>：由于 volatile 防止了某些优化，过度使用它可能会降低程序的性能。</li>
<li><strong>正确使用</strong>：只有在上述特定场景中才应使用 volatile。错误地使用 volatile 可能会导致难以发现的错误。</li>
</ul>
<h3 id="通过结构体操作寄存器">通过结构体操作寄存器</h3>
<p>项目地址: <strong>FWlib-LED</strong></p>
<h4 id="在stm32f10xh中添加结构体定义">在stm32f10x.h中添加结构体定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> CRL;</span><br><span class="line">    <span class="type">uint32_t</span> CRH;</span><br><span class="line">    <span class="type">uint32_t</span> IDR;</span><br><span class="line">    <span class="type">uint32_t</span> ODR;</span><br><span class="line">    <span class="type">uint32_t</span> BSRR;</span><br><span class="line">    <span class="type">uint32_t</span> BRR;</span><br><span class="line">    <span class="type">uint32_t</span> LCKR;</span><br><span class="line">&#125;GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *)GPIOB_BASE) <span class="comment">// 使用GPIOB-&gt;访问成员变量</span></span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">若定义为 #define GPIOB (*(GPIO_TypeDef *)(GPIOB_BASE))</span></span><br><span class="line"><span class="comment">则使用GPIOB.XXX来访问成员变量</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>在main.c中使用GPIOB-&gt;XXX的方式来访问结构体成员(即寄存器), 主要代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIOB-&gt;CRL &amp;= ~((<span class="number">0x0F</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">1</span>)); <span class="comment">// 将GPIOB状态复位</span></span><br><span class="line">GPIOB-&gt;CRL |= ((<span class="number">1</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">1</span>)); <span class="comment">// 将GPIOB设置为推挽输出</span></span><br><span class="line">GPIOB-&gt;ODR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>); <span class="comment">// PB0置0</span></span><br></pre></td></tr></table></figure>
<h4 id="在stm32f10xh中增加rcc的结构体定义,如下">在stm32f10x.h中增加RCC的结构体定义,如下</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> CR;</span><br><span class="line">    <span class="type">uint32_t</span> CFGR;</span><br><span class="line">    <span class="type">uint32_t</span> CIR;</span><br><span class="line">    <span class="type">uint32_t</span> APB2RSTR;</span><br><span class="line">    <span class="type">uint32_t</span> APB1RSTR;</span><br><span class="line">    <span class="type">uint32_t</span> AHBENR;</span><br><span class="line">    <span class="type">uint32_t</span> APB2ENR;</span><br><span class="line">    <span class="type">uint32_t</span> APB1ENR;</span><br><span class="line">    <span class="type">uint32_t</span> BDCR;</span><br><span class="line">    <span class="type">uint32_t</span> CSR;</span><br><span class="line">    <span class="type">uint32_t</span> AHBRSTR;</span><br><span class="line">    <span class="type">uint32_t</span> CFGR2;</span><br><span class="line">&#125;RCC_Typedef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC ((RCC_Typedef*)RCC_BASE) <span class="comment">// 使用RCC-&gt;访问成员变量</span></span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">若定义为 #define RCC (*(RCC_Typedef*)RCC_Base)</span></span><br><span class="line"><span class="comment">则使用RCC.XXX来访问成员变量</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中通过结构体访问rcc寄存器,代码如下">在main.c中通过结构体访问RCC寄存器,代码如下</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC-&gt;APB2ENR |= ((<span class="number">1</span>) &lt;&lt; <span class="number">3</span>); <span class="comment">// 开启GPIOB的时钟</span></span><br></pre></td></tr></table></figure>
<h4 id="更换led说明">更换LED说明</h4>
<p>由于我的开发板，PB0总是点亮蓝灯(本应该是绿灯), 以后的测试换为测试蓝灯，<strong>PB0换为PB1进行测试</strong></p>
<h3 id="增加端口置位/复位函数">增加端口置位/复位函数</h3>
<p>项目地址: <strong>FWlib-LED</strong></p>
<p>增加stm32f10x_gpio.c和stm32f10x_gpio.h文件</p>
<h4 id="在stm32f10x_gpioc中增加置位/复位函数">在stm32f10x_gpio.c中增加置位/复位函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x_gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口置位函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOx-&gt;BSRR |= Pin;</span><br><span class="line">    <span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    BSRR寄存器:</span></span><br><span class="line"><span class="comment">    低16位写1置1，写0不改变</span></span><br><span class="line"><span class="comment">    高16位写1置0，写0不改变</span></span><br><span class="line"><span class="comment">    *----------------------------------------------------------------*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口复位函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOx-&gt;BRR |= Pin;</span><br><span class="line">    <span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    BRR寄存器:</span></span><br><span class="line"><span class="comment">    低16位写1置0，写0不改变</span></span><br><span class="line"><span class="comment">    高16位保留</span></span><br><span class="line"><span class="comment">    ----------------------------------------------------------------*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在stm32f10x_gpioh中添加16位pin置1的宏定义与函数声明">在stm32f10x_gpio.h中添加16位PIN置1的宏定义与函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F10X_GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_0    ((uint16_t)0x0001)  <span class="comment">/*!&lt; 选择Pin0 */</span>    <span class="comment">//(00000000 00000001)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_1    ((uint16_t)0x0002)  <span class="comment">/*!&lt; 选择Pin1 */</span>    <span class="comment">//(00000000 00000010)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_2    ((uint16_t)0x0004)  <span class="comment">/*!&lt; 选择Pin2 */</span>    <span class="comment">//(00000000 00000100)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_3    ((uint16_t)0x0008)  <span class="comment">/*!&lt; 选择Pin3 */</span>    <span class="comment">//(00000000 00001000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_4    ((uint16_t)0x0010)  <span class="comment">/*!&lt; 选择Pin4 */</span>    <span class="comment">//(00000000 00010000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_5    ((uint16_t)0x0020)  <span class="comment">/*!&lt; 选择Pin5 */</span>    <span class="comment">//(00000000 00100000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6    ((uint16_t)0x0040)  <span class="comment">/*!&lt; 选择Pin6 */</span>    <span class="comment">//(00000000 01000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7    ((uint16_t)0x0080)  <span class="comment">/*!&lt; 选择Pin7 */</span>    <span class="comment">//(00000000 10000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8    ((uint16_t)0x0100)  <span class="comment">/*!&lt; 选择Pin8 */</span>    <span class="comment">//(00000001 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_9    ((uint16_t)0x0200)  <span class="comment">/*!&lt; 选择Pin9 */</span>    <span class="comment">//(00000010 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_10   ((uint16_t)0x0400)  <span class="comment">/*!&lt; 选择Pin10 */</span>   <span class="comment">//(00000100 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_11   ((uint16_t)0x0800)  <span class="comment">/*!&lt; 选择Pin11 */</span>   <span class="comment">//(00001000 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_12   ((uint16_t)0x1000)  <span class="comment">/*!&lt; 选择Pin12 */</span>   <span class="comment">//(00010000 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_13   ((uint16_t)0x2000)  <span class="comment">/*!&lt; 选择Pin13 */</span>   <span class="comment">//(00100000 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_14   ((uint16_t)0x4000)  <span class="comment">/*!&lt; 选择Pin14 */</span>   <span class="comment">//(01000000 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_15   ((uint16_t)0x8000)  <span class="comment">/*!&lt; 选择Pin15 */</span>   <span class="comment">//(10000000 00000000)b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_All  ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; 选择全部引脚*/</span> <span class="comment">//(11111111 11111111)b</span></span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">对于类似于GPIOx_BSRR, GPIOx_BRR寄存器通过写1来进行置位/复位操作的寄存器来说</span></span><br><span class="line"><span class="comment">宏定义16位端口的1值很有必要</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__STM32F10X_GPIO</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc函数中使用置位/复位函数">在main.c函数中使用置位/复位函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 增加复位/置位函数</span></span><br><span class="line">RCC-&gt;APB2ENR  |=  ( (<span class="number">1</span>) &lt;&lt; <span class="number">3</span> );</span><br><span class="line">GPIOB-&gt;CRL &amp;=  ~( (<span class="number">0x0f</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">0</span>) );</span><br><span class="line">GPIOB-&gt;CRL |=  ( (<span class="number">1</span>) &lt;&lt; (<span class="number">4</span>*<span class="number">0</span>) );</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_1);</span><br><span class="line">GPIO_ResetBits( GPIOB,GPIO_Pin_1 );</span><br></pre></td></tr></table></figure>
<h4 id="在stm32f10xh中增加#ifndef">在stm32f10x.h中增加#ifndef</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F10X_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F10X_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__STM32F10X_H</span></span></span><br></pre></td></tr></table></figure>
<h4 id="补充:-在c语言中#ifndef的作用">补充: 在C语言中#ifndef的作用</h4>
<p>在C语言中，#ifndef 是一种预处理指令，用于条件编译。它的全称是 “if not defined”，意思是“如果没有定义”。#ifndef 通常与 #define 和 #endif 一起使用，<strong>用于防止头文件的内容被多次包含（重复包含）</strong>。</p>
<h5 id="ifndef的作用">ifndef的作用</h5>
<p>&quot;#ifndef&quot;的主要作用是<strong>确保一个头文件中的内容只被包含一次，防止因重复包含同一头文件而导致的编译错误</strong>这种技术被称为“包含卫士”（Include Guards）或“头文件卫士”（Header Guards）。</p>
<h5 id="ifndef的使用方式">ifndef的使用方式</h5>
<p>一个典型的使用 #ifndef 的例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是一个头文件 example.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H    <span class="comment">// 如果没有定义 EXAMPLE_H</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H    <span class="comment">// 定义 EXAMPLE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">someFunction</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 更多的声明...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// 结束 #ifndef</span></span></span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ol>
<li>当编译器首次遇到 example.h 时，EXAMPLE_H 还没有被定义，所以编译器会处理 #define EXAMPLE_H 和随后的头文件内容。</li>
<li>如果同一源文件或其他包含了 example.h 的文件再次尝试包含 example.h，EXAMPLE_H 已经被定义了，因此 #ifndef EXAMPLE_H 条件失败，编译器将跳过文件的其余部分，防止重复包含。</li>
</ol>
<h5 id="ifndef的重要性">ifndef的重要性</h5>
<p>在C语言项目中，特别是在大型项目中，头文件经常被多个源文件包含，或者一个头文件包含其他头文件。如果没有包含卫士，头文件中的定义（如函数声明、宏定义、类型定义等）可能会被重复包含，导致编译错误（如重复定义错误）。使用 #ifndef 可以有效地避免这种情况。</p>
<h4 id="补充:-使用#ifndef命名使用双下划线说明">补充: 使用#ifndef命名使用双下划线说明</h4>
<p>在C语言中，当使用 #ifndef（和 #define、#endif）作为头文件的包含卫士时，通常会在文件名前加上双下划线 __ 或其他类似的前缀/后缀，<strong>这是一种非正式的约定，用于减少命名冲突的风险</strong>然而，需要注意的是，<strong>使用双下划线作为前缀或后缀在某些情况下可能并不是最佳实践</strong>。</p>
<h5 id="使用双下划线的原因">使用双下划线的原因</h5>
<ul>
<li><strong>唯一性</strong>：在大型项目中，可能会有许多不同的头文件。使用文件名作为宏的一部分可以帮助确保每个包含卫士的宏是唯一的。</li>
<li><strong>减少冲突</strong>：添加额外的字符（如双下划线）可以进一步减少不同头文件之间宏名称冲突的可能性。</li>
</ul>
<h5 id="使用双下划线的注意事项">使用双下划线的注意事项</h5>
<p><strong>保留标识符</strong>：根据C和C++标准，<strong>以双下划线开头或以单下划线后跟大写字母开头的标识符是保留给实现（编译器和标准库）使用的</strong>。因此，使用这样的标识符作为宏名称<strong>可能会导致与标准库或编译器的内部标识符冲突</strong>。</p>
<p>建议的做法：更安全的做法是<strong>使用文件名的大写形式加上一个后缀（如 _H），而不是使用双下划线</strong>。例如，对于 example.h 头文件，可以使用 EXAMPLE_H 作为包含卫士的宏。</p>
<h5 id="示例">示例</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H    <span class="comment">// 更安全的做法</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure>
<p>总之，<strong>虽然在文件名前加上双下划线是一种常见做法，但为了避免与编译器或标准库的内部标识符冲突，建议使用其他方法来确保宏名称的唯一性和安全性</strong>。</p>
<h3 id="增加gpio初始化结构体">增加GPIO初始化结构体</h3>
<p>项目地址: <strong>FWlib-LED</strong></p>
<p>配置GPIO工作模式的宏定义(GPIOMode_TypeDef)参考下图</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202312301523539.png" alt="GPIO工作模式图"></p>
<p>实际写入寄存器的是bit3-0,bit7-4并不写入寄存器</p>
<p>勘误：上拉输入和下拉输入两行的bit3-2应该为10</p>
<ul>
<li>bit1-0: 置0, 配置输出速度，通过GPIOSpeed_TypeDef进行覆盖配置</li>
<li>bit3-2: 配置输入/输出模式</li>
<li>bi4: <strong>不写入寄存器</strong>, 用来标志是输入还是输出</li>
<li>bit6-5: <strong>不写入寄存器</strong>， 用来判断是上拉输入还是下拉输入</li>
<li>bit7: <strong>不写入寄存器</strong></li>
</ul>
<h4 id="在stm32f10x_gpioh中增加宏定义">在stm32f10x_gpio.h中增加宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过枚举 限定GPIO_Speed的选择</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Speed_10MHZ = <span class="number">1</span>, <span class="comment">// 01 输出模式，最大速度10MHz</span></span><br><span class="line">    GPIO_Speed_2MHZ, <span class="comment">// 10 输出模式，最大速度2MHz</span></span><br><span class="line">    GPIO_Speed_50MHZ <span class="comment">// 11 输出模式，最大速度50MHz</span></span><br><span class="line">&#125;GPIOSpeed_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过枚举限定GPIO_Mode的选择</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>,           <span class="comment">// 模拟输入     (0000 0000)b</span></span><br><span class="line">  GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,  <span class="comment">// 浮空输入     (0000 0100)b</span></span><br><span class="line">  GPIO_Mode_IPD = <span class="number">0x28</span>,          <span class="comment">// 下拉输入     (0010 1000)b</span></span><br><span class="line">  GPIO_Mode_IPU = <span class="number">0x48</span>,          <span class="comment">// 上拉输入     (0100 1000)b</span></span><br><span class="line">  </span><br><span class="line">  GPIO_Mode_Out_OD = <span class="number">0x14</span>,       <span class="comment">// 开漏输出     (0001 0100)b</span></span><br><span class="line">  GPIO_Mode_Out_PP = <span class="number">0x10</span>,       <span class="comment">// 推挽输出     (0001 0000)b</span></span><br><span class="line">  GPIO_Mode_AF_OD = <span class="number">0x1C</span>,        <span class="comment">// 复用开漏输出 (0001 1100)b</span></span><br><span class="line">  GPIO_Mode_AF_PP = <span class="number">0x18</span>         <span class="comment">// 复用推挽输出 (0001 1000)b</span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义GPIO初始化结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;</span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Speed;</span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Mode;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="在stm32f10x_gpioc中写入gpio初始化函数">在stm32f10x_gpio.c中写入GPIO初始化函数</h4>
<p>该函数是从库函数中复制得到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GPIO初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> currentmode = <span class="number">0x00</span>, currentpin = <span class="number">0x00</span>, pinpos = <span class="number">0x00</span>, pos = <span class="number">0x00</span>;</span><br><span class="line">  <span class="type">uint32_t</span> tmpreg = <span class="number">0x00</span>, pinmask = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*---------------------- GPIO 模式配置 --------------------------*/</span></span><br><span class="line">  <span class="comment">// 把输入参数GPIO_Mode的低四位暂存在currentmode</span></span><br><span class="line">  currentmode = ((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// bit4是1表示输出，bit4是0则是输入 </span></span><br><span class="line">  <span class="comment">// 判断bit4是1还是0，即首选判断是输入还是输出模式</span></span><br><span class="line">  <span class="keyword">if</span> ((((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class="type">uint32_t</span>)<span class="number">0x10</span>)) != <span class="number">0x00</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">// 输出模式则要设置输出速度</span></span><br><span class="line">    currentmode |= (<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*-------------GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- -------*/</span></span><br><span class="line">  <span class="comment">// 配置端口低8位，即Pin0~Pin7</span></span><br><span class="line">  <span class="keyword">if</span> (((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((<span class="type">uint32_t</span>)<span class="number">0x00FF</span>)) != <span class="number">0x00</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 先备份CRL寄存器的值</span></span><br><span class="line">    tmpreg = GPIOx-&gt;CRL;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 循环，从Pin0开始配对，找出具体的Pin</span></span><br><span class="line">    <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// pos的值为1左移pinpos位</span></span><br><span class="line">      pos = ((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 令pos与输入参数GPIO_PIN作位与运算，为下面的判断作准备</span></span><br><span class="line">      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">      <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚</span></span><br><span class="line">        pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">        pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">        tmpreg &amp;= ~pinmask;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">        tmpreg |= (currentmode &lt;&lt; pos);  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0</span></span><br><span class="line">          GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">          <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1</span></span><br><span class="line">            GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 把前面处理后的暂存值写入到CRL寄存器之中</span></span><br><span class="line">    GPIOx-&gt;CRL = tmpreg;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*-------------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----------*/</span></span><br><span class="line">  <span class="comment">// 配置端口高8位，即Pin8~Pin15</span></span><br><span class="line">  <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class="number">0x00FF</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 先备份CRH寄存器的值</span></span><br><span class="line">    tmpreg = GPIOx-&gt;CRH;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 循环，从Pin8开始配对，找出具体的Pin</span></span><br><span class="line">    <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">    &#123;</span><br><span class="line">      pos = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class="line">   </span><br><span class="line">      <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">      <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚</span></span><br><span class="line">        pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">        pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">        tmpreg &amp;= ~pinmask;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">        tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0</span></span><br><span class="line">          GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1</span></span><br><span class="line">          GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把前面处理后的暂存值写入到CRH寄存器之中</span></span><br><span class="line">    GPIOx-&gt;CRH = tmpreg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中使用gpio初始化函数">在main.c中使用GPIO初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>
<h3 id="增加宏定义来增强代码可移植性">增加宏定义来增强代码可移植性</h3>
<p>项目地址： <strong>FWlib-LED</strong></p>
<h4 id="在mainc中增加宏定义">在main.c中增加宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_GPIO_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_GPIO_CLK_ENABLE (RCC-&gt;APB2ENR |= ((1) &lt;&lt; 3)) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_GPIO_PIN GPIO_Pin_0</span></span><br></pre></td></tr></table></figure>
<p>在main.c中增加延时函数，实现LED闪烁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>( ; count != <span class="number">0</span>; count-- )</span><br><span class="line">  &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中使用宏定义后的代码实现led闪烁">在main.c中使用宏定义后的代码实现LED闪烁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加宏定义以增强代码可移植性</span></span><br><span class="line">LED_B_GPIO_CLK_ENABLE;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = LED_B_GPIO_PIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHZ;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); <span class="comment">// PB1置1 蓝灯灭</span></span><br><span class="line">  Delay(<span class="number">0xFFFF</span>);</span><br><span class="line">  GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); <span class="comment">// PB1置0 蓝灯亮</span></span><br><span class="line">  Delay(<span class="number">0xFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="固件库编程">固件库编程</h2>
<h3 id="stm32固件库文件分析">STM32固件库文件分析</h3>
<ol>
<li>汇编编写的启动文件 startup_stm32f10x_h.s: 设置堆栈指针,设置PC指针，初始化中断向量表，配置系统时钟，调用C库函数_main最终去C的世界</li>
<li>时钟配置文件 system_stm32f10x.c: 把外部时钟HSE=8M，经过PLL倍频成72M</li>
<li>外设相关
<ul>
<li>stm32f10x.h: 实现了内核之外的外设的寄存器映射</li>
<li>xx: GPIO, USART, I2C</li>
<li>stm32f10x_xx.c: 外设的驱动函数库文件</li>
<li>stm32f10x_xx.h: 存放外设的初始化结构体，外设初始化结构体成员的参数列表，外设固件库的头文件声明</li>
</ul>
</li>
<li>内核相关
<ul>
<li>CMSIS: Cortex微控制器软件接口标准</li>
<li>core_cm3.h: 实现了内核里面外设的寄存器映射</li>
<li>core_cm3.c: 内核外设的驱动固件库</li>
<li>NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器), misc.h, misc.c</li>
</ul>
</li>
<li>头文件的配置文件 stm32f10x_conf.h里面包含
<ul>
<li>stm32f10x_usar.c</li>
<li>stm32f10x_i2c.h</li>
<li>stm32f10x_spi.h</li>
<li>stm32f10x_adc.h</li>
<li>stm32f10x_fsmc.h</li>
</ul>
</li>
<li>专门存放终端服务函数的C文件(可以放在其他地方，不一定要放在stm32f10x_it.c中)
<ul>
<li>stm32f10x_it.c</li>
<li>stm32f10x_it.h</li>
</ul>
</li>
</ol>
<h3 id="新建固件库版本工程">新建固件库版本工程</h3>
<p>项目地址: <strong>Fwlib-Template</strong></p>
<ul>
<li>Doc: 用来存放程序说明的文件，由写程序的人添加</li>
<li>Libraries: 存放库文件</li>
<li>Project: 存放工程</li>
<li>User: 用户编写的驱动文件</li>
</ul>
<p>其余按照视频配置，P18, 视频链接: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yW411Y7Gw/?p=18&amp;share_source=copy_web&amp;vd_source=0db47c15b9f51dbaa4548ec2dc55dea4">按照P18进行库移植</a></p>
<h3 id="gpio输出-使用固件库点亮led">GPIO输出-使用固件库点亮LED</h3>
<p>项目地址: <strong>12-GPIO输出-使用固件库点亮LED</strong></p>
<p>在User目录下新建led文件夹，添加bsp_led.c和bsp_led.h</p>
<h4 id="在bsp_ledh中添加所使用的宏定义和函数声明">在bsp_led.h中添加所使用的宏定义和函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_GPIO_PIN GPIO_Pin_1 <span class="comment">// stm32f10x_gpio.h中定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_GPIO_PORT GPIOB <span class="comment">// stm32f10x.h中定义 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_GPIO_CLK RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__BSP_LED_H</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_ledc中添加初始化函数">在bsp_led.c中添加初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bsp: board support package 板级支持包</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(LED_B_GPIO_CLK, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = LED_B_GPIO_PIN;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(LED_B_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中调用初始化函数，并进行软件延时，实现led闪烁">在main.c中调用初始化函数，并进行软件延时，实现LED闪烁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; count != <span class="number">0</span>; count--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> current;</span><br><span class="line">        <span class="keyword">for</span>(current = count; current != <span class="number">0</span>; current--)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span><br><span class="line">        Delay(<span class="number">0xFFF</span>); <span class="comment">// 延时</span></span><br><span class="line">        GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span><br><span class="line">        Delay(<span class="number">0xFFF</span>); <span class="comment">// 延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_ledh中增加函数宏定义">在bsp_led.h中增加函数宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ON 1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B(a) <span class="keyword">if</span> (a)\</span></span><br><span class="line"><span class="meta">                     GPIO_ResetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN); \</span></span><br><span class="line"><span class="meta">                     <span class="keyword">else</span>\</span></span><br><span class="line"><span class="meta">                     GPIO_SetBits(LED_B_GPIO_PORT, LED_B_GPIO_PIN);</span></span><br><span class="line"><span class="comment">// 使用\可以进行换行，其后不能跟空格，\后应该直接回车</span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中使用宏定义的函数">在main.c中使用宏定义的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LED_B(OFF);</span><br><span class="line">Delay(<span class="number">0xFFF</span>); <span class="comment">// 延时</span></span><br><span class="line">LED_B(ON);</span><br><span class="line">Delay(<span class="number">0xFFF</span>); <span class="comment">// 延时</span></span><br></pre></td></tr></table></figure>
<h4 id="补充:-c语言反斜杠\换行">补充: C语言反斜杠\换行</h4>
<p>在C语言中使用反斜杠 \ 进行换行时，确实有一些需要注意的事项。这种用法通常出现在宏定义或是将长代码行分割为多行以提高代码的可读性。正确使用时，\ 应该放在行尾，紧接着是换行符。</p>
<h5 id="c语言反斜杠\换行的注意事项">C语言反斜杠\换行的注意事项</h5>
<ul>
<li><strong>无空格</strong>：在行尾使用 \ 时，它之后直到行末不能有任何字符，包括空格或制表符。任何在 \ 之后的空格都会使得换行转义失效，导致编译错误。</li>
<li><strong>紧跟换行符</strong>：\ 应该直接紧跟换行符。这告诉编译器忽略换行符，将下一行视为当前行的延续。</li>
<li><strong>可读性</strong>：虽然使用 \ 可以将长代码行分割为多行，但过度使用可能会降低代码的可读性。适当使用，以保持代码整洁和可维护。</li>
<li><strong>宏定义中的使用</strong>：在宏定义中使用 \ 进行换行是常见的做法，<strong>因为宏定义必须是单行的</strong>。在这种情况下，确保每一行（除了最后一行）都以 \ 结尾。</li>
</ul>
<h5 id="c语言反斜杠\换行的示例">C语言反斜杠\换行的示例</h5>
<p>正确的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO(a, b) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        a = 2; \</span></span><br><span class="line"><span class="meta">        b = 3; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    MY_MACRO(x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，宏 MY_MACRO 被分成了多行，每行的末尾都使用了 \ 来实现。</p>
<p>错误的使用（如果 \ 后有空格）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO(a, b) \ </span></span><br><span class="line">    <span class="keyword">do</span> &#123; \</span><br><span class="line">        a = <span class="number">2</span>; \</span><br><span class="line">        b = <span class="number">3</span>; \</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>在这个错误的例子中，<strong>第一行的 \ 后面如果有空格，将导致编译错误</strong>。</p>
<p>总之，当在C语言中使用 \ 进行换行时，<strong>确保 \ 是每行的最后一个字符，并且紧接着换行符</strong>，以避免编译错误并保持代码的清晰</p>
<h3 id="gpio输入">GPIO输入</h3>
<p>项目地址: <strong>13-GPIO输入-按键检测</strong></p>
<p>通过原理图可知<strong>KEY1接PA0口, 按键按下后为高电平</strong>, 原理图如下</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401011723631.png" alt="KEY1原理图"></p>
<p>实现<strong>按下KEY1后蓝灯状态翻转</strong></p>
<h4 id="在bsp_ledh中宏定义电平翻转函数">在bsp_led.h中宏定义电平翻转函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_TOGGLE &#123;LED_B_GPIO_PORT-&gt;ODR ^= LED_B_GPIO_PIN;&#125;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">^= 异或运算 (a ^ b) 则ab不同为1，相同则为0</span></span><br><span class="line"><span class="comment">ODR低16位和GPIO_Pin_1作异或并重新赋值给ODR可实现ODR的Bit0翻转</span></span><br><span class="line"><span class="comment">若Bit0=1则Bit0 = 1 ^ 1 = 0, 下一次运算时, Bit0=0则Bit0 = 0^1 = 1</span></span><br><span class="line"><span class="comment">实际上是ODR的Bit0在和1进行异或操作</span></span><br><span class="line"><span class="comment">----------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_keyh中进行宏定义和函数声明">在bsp_key.h中进行宏定义和函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ON 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_OFF 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_GPIO_PIN GPIO_Pin_0 <span class="comment">// stm32f10x_gpio.h中定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_GPIO_PORT GPIOA <span class="comment">// stm32f10x.h中定义 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_GPIO_CLK RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__BSP_KEY_H</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_keyc中写初始化函数和端口扫描函数">在bsp_key.c中写初始化函数和端口扫描函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">    GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口扫面函数 检测按下返回1，否则返回0</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> KEY_ON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> KEY_OFF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中进行调用">在main.c中进行调用</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    KEY_GPIO_Config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Key_Scan(KEY1_GPIO_PORT, KEY1_GPIO_PIN) == KEY_ON)</span><br><span class="line">        &#123;</span><br><span class="line">            LED_B_TOGGLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="补充:-c语言中的异或操作">补充: C语言中的异或操作</h4>
<p>在C语言中，异或运算是一种基本的位运算，使用符号 ^ 表示。<strong>异或运算符对两个操作数的对应位进行比较，如果两个相应的位不同，则结果为1，如果相同，则结果为0</strong>换句话说，它在以下情况下返回1：</p>
<ul>
<li>第一个操作数的位是0，第二个操作数的位是1。</li>
<li>第一个操作数的位是1，第二个操作数的位是0。</li>
</ul>
<h5 id="c语言异或运算的特性">C语言异或运算的特性</h5>
<ul>
<li>交换律：a ^ b 等于 b ^ a。</li>
<li>结合律：(a ^ b) ^ c 等于 a ^ (b ^ c)。</li>
<li>自反性：任何数与自身异或的结果都是0，即 a ^ a 等于 0。</li>
<li>与0的异或：任何数与0异或都等于它本身，即 a ^ 0 等于 a。</li>
</ul>
<h5 id="c语言异或操作的应用">C语言异或操作的应用</h5>
<p>异或运算在C语言编程中有多种应用：</p>
<p><strong>值交换</strong>：不使用临时变量交换两个变量的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p>这种方法虽然巧妙，但<strong>在实际编程中不常用</strong>，因为如果 a 和 b 指向同一内存位置，这会导致结果为0。</p>
<p><strong>反转特定位</strong>：可以使用异或运算来反转数值中的特定位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x ^ (<span class="number">1</span> &lt;&lt; n);  <span class="comment">// 反转x的第n位</span></span><br></pre></td></tr></table></figure>
<p><strong>检查奇偶性</strong>：通过检查数的最低位是否为1，可以使用异或运算来快速检查一个数是奇数还是偶数。</p>
<p><strong>加密和解密</strong>：由于异或运算的自反性，它可以用于简单的加密和解密操作。</p>
<h5 id="c语言异或操作的示例">C语言异或操作的示例</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">5</span>;  <span class="comment">// 二进制: 0101</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">3</span>;  <span class="comment">// 二进制: 0011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行异或运算</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> result = a ^ b;  <span class="comment">// 结果是 6，二进制: 0110</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result = %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，5（二进制0101）和3（二进制0011）进行异或运算的结果是6（二进制0110），因为每一位都被相应地比较并计算出结果。</p>
<h2 id="位带操作">位带操作</h2>
<h3 id="位带简介">位带简介</h3>
<p>Cortex-M3微控制器，作为ARM的Cortex-M系列的一部分，提供了位带（Bit-banding）功能，<strong>这是一种允许对单个位进行原子读写操作的机制</strong>。这种功能在需要精确控制或原子性操作单个位的场合非常有用，例如在多任务环境中操作共享资源。</p>
<p>在 CM3 中，有两个区中实现了位带。其中一个是 SRAM 区的最低 1MB 范围，第二个则是片内外设区的最低 1MB 范围。这两个位带中的地址除了可以像普通的 RAM 一样使用外，<strong>它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个 32 位的字</strong>。</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021935413.png" alt="位带地址"></p>
<p>在CM3权威指南CnR2中<strong>支持位带操作的两个内存区的范围</strong>如下</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401021941642.png" alt="内存区范围"></p>
<h3 id="位带操作的原理">位带操作的原理</h3>
<p>位带操作在Cortex-M3中是<strong>通过将一个较大的地址空间（位带区域）映射到一个较小的地址空间（位带别名区域）来实现的</strong>。在Cortex-M3中，有两个主要的位带区域：</p>
<ol>
<li>SRAM位带区域：通常用于内存中的变量。</li>
<li>外设位带区域：用于外设寄存器。</li>
</ol>
<p>每个位带区域的一个字（32位）对应主存储区的一个位。这意味着，通过写入位带区域的地址，你可以设置或清除主存储区相应位的值。</p>
<h3 id="位带操作的地址映射">位带操作的地址映射</h3>
<p>位带操作的地址映射通常遵循以下规则：</p>
<p>位带别名地址 = 位带基地址 + (字节偏移量 x 32) + (位编号 x 4)</p>
<p>其中，<strong>字节偏移量是目标地址相对于位带区域基地址的偏移量</strong>，<strong>位编号是要操作的位</strong>。</p>
<h3 id="位带操作的示例">位带操作的示例</h3>
<p>假设有一个外设寄存器的地址为 0x40000000，我们要设置这个寄存器的第2位。首先，我们需要计算这个位在位带别名区域中的地址。</p>
<p>假设外设位带区域的基地址是 0x42000000，那么：</p>
<ul>
<li>字节偏移量 = 0x40000000 - 0x40000000 = 0x00000000</li>
<li>位编号 = 2</li>
<li>位带别名地址 = 0x42000000 + (0x00000000 x 32) + (2 x 4) = 0x42000008</li>
</ul>
<p>然后，你可以直接写入这个位带别名地址来设置或清除该位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND_PERIPH(address, bit) ((void*)(0x42000000 + ((address) - 0x40000000) * 32 + (bit) * 4))</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *alias_address = (<span class="type">unsigned</span> <span class="type">int</span> *)BITBAND_PERIPH(<span class="number">0x40000000</span>, <span class="number">2</span>);</span><br><span class="line">*alias_address = <span class="number">1</span>;  <span class="comment">// 设置第2位, 将第二位值设置为1</span></span><br></pre></td></tr></table></figure>
<h3 id="位带操作的注意事项">位带操作的注意事项</h3>
<ul>
<li>硬件支持：确保你的Cortex-M3微控制器支持位带操作。</li>
<li>地址计算：正确的地址计算对于位带操作至关重要。</li>
<li>原子操作：位带操作是原子的，这意味着在多任务或中断驱动的环境中，它们是安全的。</li>
</ul>
<h3 id="使用位带操作实现gpio的输出和输入">使用位带操作实现GPIO的输出和输入</h3>
<p>项目地址: <strong>14-位带操作-GPIO的输出和输入</strong></p>
<p>使用位带操作实现GPIO输出: LED_B的闪烁</p>
<h4 id="在mainc中添加位带操作的宏定义">在main.c中添加位带操作的宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR_Addr (GPIOB_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n) *(unsigned int*)((GPIOB_ODR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOB_ODR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中使用位带操作点灯">在main.c中使用位带操作点灯</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PBout(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    Delay(<span class="number">0xFFF</span>); <span class="comment">// 延时</span></span><br><span class="line">    PBout(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">    Delay(<span class="number">0xFFF</span>); <span class="comment">// 延时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用位带操作实现GPIO输入: KEY1和KEY2控制LED_B状态翻转</p>
<h4 id="在bsp_keyh中添加key2的宏定义">在bsp_key.h中添加KEY2的宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_GPIO_PIN GPIO_Pin_13 <span class="comment">// stm32f10x_gpio.h中定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_GPIO_PORT GPIOC <span class="comment">// stm32f10x.h中定义 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_GPIO_CLK RCC_APB2Periph_GPIOC</span></span><br></pre></td></tr></table></figure>
<h4 id="在bspc中增加key2的gpio初始化">在bsp.c中增加KEY2的GPIO初始化</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">KEY_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1 初始化</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK, ENABLE);</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">    GPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2 初始化</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(KEY2_GPIO_CLK, ENABLE);</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">    GPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中添加gpio输入位带操作的宏定义">在main.c中添加GPIO输入位带操作的宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR_Addr (GPIOA_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_IDR_Addr (GPIOC_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n) *(unsigned int*)((GPIOA_IDR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOA_IDR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCin(n) *(unsigned int*)((GPIOC_IDR_Addr&amp;0xF0000000) + 0x02000000 + ((GPIOC_IDR_Addr&amp;0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中测试led闪烁">在main.c中测试LED闪烁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(PAin(<span class="number">0</span>) == KEY_ON)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay(<span class="number">0xFFF</span>); <span class="comment">// 加入软件消抖后可正常运行</span></span><br><span class="line">        <span class="keyword">while</span>(PAin(<span class="number">0</span>) == KEY_ON) <span class="comment">// 等待按键释放</span></span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        LED_B_TOGGLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(PCin(<span class="number">13</span>) == KEY_ON)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay(<span class="number">0xFFF</span>); <span class="comment">// 加入软件消抖后可正常运行</span></span><br><span class="line">        <span class="keyword">while</span>(PCin(<span class="number">13</span>) == KEY_ON) <span class="comment">// 等待按键释放</span></span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        LED_B_TOGGLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动文件详解">启动文件详解</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line">;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************</span><br><span class="line">;* File Name          : startup_stm32f10x_hd.s</span><br><span class="line">;* Author             : MCD Application Team</span><br><span class="line">;* Version            : V3.5.0</span><br><span class="line">;* Date               : 11-March-2011</span><br><span class="line">;* Description        : STM32F10x High Density Devices vector table for MDK-ARM </span><br><span class="line">;*                      toolchain. </span><br><span class="line">;*                      This module performs:</span><br><span class="line">;*                      - Set the initial SP </span><br><span class="line">;                       初始化堆栈指针</span><br><span class="line">;*                      - Set the initial PC == Reset_Handler </span><br><span class="line">;                       初始化PC指针 == Reset_Handler程序</span><br><span class="line">;*                      - Set the vector table entries with the exceptions ISR address </span><br><span class="line">;                       初始化中断向量表</span><br><span class="line">;*                      - Configure the clock system and also configure the external </span><br><span class="line">;*                        SRAM mounted on STM3210E-EVAL board to be used as data </span><br><span class="line">;*                        memory (optional, to be enabled by user) </span><br><span class="line">;                       配置系统时钟</span><br><span class="line">;*                      - Branches to __main in the C library (which eventually</span><br><span class="line">;*                        calls main()). </span><br><span class="line">;                       调用C库函数, 最终去到C的世界</span><br><span class="line">;*                      After Reset the CortexM3 processor is in Thread mode,</span><br><span class="line">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class="line">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class="line">;*******************************************************************************</span><br><span class="line">; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS</span><br><span class="line">; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.</span><br><span class="line">; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,</span><br><span class="line">; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE</span><br><span class="line">; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING</span><br><span class="line">; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</span><br><span class="line">;*******************************************************************************</span><br><span class="line"></span><br><span class="line">;****************************************************************************</span><br><span class="line">;* 1- 栈的配置</span><br><span class="line">;****************************************************************************</span><br><span class="line"></span><br><span class="line">; Amount of memory (in bytes) allocated for Stack</span><br><span class="line">; Tailor this value to your application needs</span><br><span class="line">; &lt;h&gt; Stack Configuration </span><br><span class="line">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line">; 配置栈: 用于变量存储(局部/全局), 函数调用</span><br><span class="line"></span><br><span class="line">Stack_Size      EQU     0x00000400 </span><br><span class="line">; 宏定义的伪指令，相当于等于，类似与 C 中的 define。</span><br><span class="line">; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">                ; 告诉汇编器汇编一个新的代码段或者数据段。</span><br><span class="line">                ; STACK 表示段名，这个可以任意命名</span><br><span class="line">                ; NOINIT 表示不初始化</span><br><span class="line">                ; READWRITE 表示可读可写</span><br><span class="line">                ; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line">; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</span><br><span class="line">; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</span><br><span class="line">的。 </span><br><span class="line">                                                  </span><br><span class="line">;****************************************************************</span><br><span class="line">;* 2-堆的配置</span><br><span class="line">;****************************************************************</span><br><span class="line"></span><br><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line">; 配置堆: 主要用于动态内存的分配, 如malloc()函数</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line">; 将0x00000200命名为Heap_Size, 0x00000200为512Type</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">                ; 汇编数据段</span><br><span class="line">                ; 名字叫HEAP</span><br><span class="line">                ; 不初始化</span><br><span class="line">                ; 可读可写</span><br><span class="line">                ; 2^3即8字节对齐</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line">; __heap_base 表示对的起始地址</span><br><span class="line">; SPACE 分配大小为Heap_Size即512字节的内存空间</span><br><span class="line">; __heap_limit 表示堆的结束地址</span><br><span class="line">; 堆是由低向高生长的，跟栈的生长方向相反。</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                ; 指定当前文件的堆栈按照 8 字节对齐</span><br><span class="line">                THUMB</span><br><span class="line">                ; 表示后面指令兼容 THUMB 指令</span><br><span class="line"></span><br><span class="line">;****************************************************************</span><br><span class="line">;* 3-初始化中断向量表</span><br><span class="line">;****************************************************************</span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                ; 区域名称为RESET</span><br><span class="line">                ; 区域类型为DATA, 与CODE相对,后者用于包含可执行指令</span><br><span class="line">                ; 区域属性为只读</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line">                ; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack ; 栈顶地址</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler ; 复位程序地址</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect</span><br><span class="line">                DCD     TAMPER_IRQHandler          ; Tamper</span><br><span class="line">                DCD     RTC_IRQHandler             ; RTC</span><br><span class="line">                DCD     FLASH_IRQHandler           ; Flash</span><br><span class="line">                DCD     RCC_IRQHandler             ; RCC</span><br><span class="line">                DCD     EXTI0_IRQHandler           ; EXTI Line 0</span><br><span class="line">                DCD     EXTI1_IRQHandler           ; EXTI Line 1</span><br><span class="line">                DCD     EXTI2_IRQHandler           ; EXTI Line 2</span><br><span class="line">                DCD     EXTI3_IRQHandler           ; EXTI Line 3</span><br><span class="line">                DCD     EXTI4_IRQHandler           ; EXTI Line 4</span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1</span><br><span class="line">                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2</span><br><span class="line">                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3</span><br><span class="line">                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4</span><br><span class="line">                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5</span><br><span class="line">                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6</span><br><span class="line">                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7</span><br><span class="line">                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2</span><br><span class="line">                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX</span><br><span class="line">                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0</span><br><span class="line">                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1</span><br><span class="line">                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE</span><br><span class="line">                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5</span><br><span class="line">                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break</span><br><span class="line">                DCD     TIM1_UP_IRQHandler         ; TIM1 Update</span><br><span class="line">                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare</span><br><span class="line">                DCD     TIM2_IRQHandler            ; TIM2</span><br><span class="line">                DCD     TIM3_IRQHandler            ; TIM3</span><br><span class="line">                DCD     TIM4_IRQHandler            ; TIM4</span><br><span class="line">                DCD     I2C1_EV_IRQHandler         ; I2C1 Event</span><br><span class="line">                DCD     I2C1_ER_IRQHandler         ; I2C1 Error</span><br><span class="line">                DCD     I2C2_EV_IRQHandler         ; I2C2 Event</span><br><span class="line">                DCD     I2C2_ER_IRQHandler         ; I2C2 Error</span><br><span class="line">                DCD     SPI1_IRQHandler            ; SPI1</span><br><span class="line">                DCD     SPI2_IRQHandler            ; SPI2</span><br><span class="line">                DCD     USART1_IRQHandler          ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler          ; USART2</span><br><span class="line">                DCD     USART3_IRQHandler          ; USART3</span><br><span class="line">                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10</span><br><span class="line">                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line</span><br><span class="line">                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend</span><br><span class="line">                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break</span><br><span class="line">                DCD     TIM8_UP_IRQHandler         ; TIM8 Update</span><br><span class="line">                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation</span><br><span class="line">                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare</span><br><span class="line">                DCD     ADC3_IRQHandler            ; ADC3</span><br><span class="line">                DCD     FSMC_IRQHandler            ; FSMC</span><br><span class="line">                DCD     SDIO_IRQHandler            ; SDIO</span><br><span class="line">                DCD     TIM5_IRQHandler            ; TIM5</span><br><span class="line">                DCD     SPI3_IRQHandler            ; SPI3</span><br><span class="line">                DCD     UART4_IRQHandler           ; UART4</span><br><span class="line">                DCD     UART5_IRQHandler           ; UART5</span><br><span class="line">                DCD     TIM6_IRQHandler            ; TIM6</span><br><span class="line">                DCD     TIM7_IRQHandler            ; TIM7</span><br><span class="line">                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1</span><br><span class="line">                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2</span><br><span class="line">                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3</span><br><span class="line">                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5</span><br><span class="line">__Vectors_End</span><br><span class="line">; _Vectors 为向量表起始地址，__Vectors_End 为向量表结束地址</span><br><span class="line">; 向量表中，DCD 分配了一堆内存，并且以 ESR 的入口地址初始化它们 </span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line">; 向量表的大小为结束地址减去起始地址</span><br><span class="line"></span><br><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line">                ; 定义一个名称为.text 的代码段，只读</span><br><span class="line">                </span><br><span class="line">;****************************************************************</span><br><span class="line">;* 4-复位程序</span><br><span class="line">;****************************************************************</span><br><span class="line"></span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">                ; WEAK 表示弱定义, 如果在其他地方定义了Reset_Handler就使用其他地方的定义</span><br><span class="line">                ; 可以理解为C++中的&quot;可以重载&quot;</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                ;表示 SystemInit和 __main 这两个函数均来自外部的文件</span><br><span class="line"></span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                ; 把SystemInit的地址加载到R0中</span><br><span class="line">                BLX     R0               </span><br><span class="line">                ; 跳转到R0执行, 执行完毕后返回</span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                ; 把__main的地址加载到R0中</span><br><span class="line">                BX      R0</span><br><span class="line">                ; 跳转到R0执行, 执行完毕后不返回</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">;****************************************************************</span><br><span class="line">;* 5-中断服务函数</span><br><span class="line">;****************************************************************</span><br><span class="line"></span><br><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line">; 中断服务函数均跳转到无限循环</span><br><span class="line">; 目的是用户在未定义中断服务函数的情况下调用可进入无限循环状态中(兜底作用)</span><br><span class="line"></span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ; B 表示跳转指令</span><br><span class="line">                ; . 表示无限循环</span><br><span class="line">                ENDP</span><br><span class="line">HardFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  HardFault_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">MemManage_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  MemManage_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">BusFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  BusFault_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">UsageFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  UsageFault_Handler         [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SVC_Handler     PROC</span><br><span class="line">                EXPORT  SVC_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">DebugMon_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  DebugMon_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">PendSV_Handler  PROC</span><br><span class="line">                EXPORT  PendSV_Handler             [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC</span><br><span class="line"></span><br><span class="line">                EXPORT  WWDG_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  PVD_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  TAMPER_IRQHandler          [WEAK]</span><br><span class="line">                EXPORT  RTC_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  FLASH_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  RCC_IRQHandler             [WEAK]</span><br><span class="line">                EXPORT  EXTI0_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  EXTI1_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  EXTI2_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  EXTI3_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  EXTI4_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  ADC1_2_IRQHandler          [WEAK]</span><br><span class="line">                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]</span><br><span class="line">                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]</span><br><span class="line">                EXPORT  CAN1_RX1_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  CAN1_SCE_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  EXTI9_5_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  TIM1_BRK_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  TIM1_UP_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]</span><br><span class="line">                EXPORT  TIM1_CC_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  TIM2_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  TIM3_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  TIM4_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  I2C1_EV_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  I2C1_ER_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  I2C2_EV_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  I2C2_ER_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  SPI1_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  SPI2_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  USART1_IRQHandler          [WEAK]</span><br><span class="line">                EXPORT  USART2_IRQHandler          [WEAK]</span><br><span class="line">                EXPORT  USART3_IRQHandler          [WEAK]</span><br><span class="line">                EXPORT  EXTI15_10_IRQHandler       [WEAK]</span><br><span class="line">                EXPORT  RTCAlarm_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  USBWakeUp_IRQHandler       [WEAK]</span><br><span class="line">                EXPORT  TIM8_BRK_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  TIM8_UP_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]</span><br><span class="line">                EXPORT  TIM8_CC_IRQHandler         [WEAK]</span><br><span class="line">                EXPORT  ADC3_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  FSMC_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  SDIO_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  TIM5_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  SPI3_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  UART4_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  UART5_IRQHandler           [WEAK]</span><br><span class="line">                EXPORT  TIM6_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  TIM7_IRQHandler            [WEAK]</span><br><span class="line">                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]</span><br><span class="line">                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]</span><br><span class="line"></span><br><span class="line">WWDG_IRQHandler</span><br><span class="line">PVD_IRQHandler</span><br><span class="line">TAMPER_IRQHandler</span><br><span class="line">RTC_IRQHandler</span><br><span class="line">FLASH_IRQHandler</span><br><span class="line">RCC_IRQHandler</span><br><span class="line">EXTI0_IRQHandler</span><br><span class="line">EXTI1_IRQHandler</span><br><span class="line">EXTI2_IRQHandler</span><br><span class="line">EXTI3_IRQHandler</span><br><span class="line">EXTI4_IRQHandler</span><br><span class="line">DMA1_Channel1_IRQHandler</span><br><span class="line">DMA1_Channel2_IRQHandler</span><br><span class="line">DMA1_Channel3_IRQHandler</span><br><span class="line">DMA1_Channel4_IRQHandler</span><br><span class="line">DMA1_Channel5_IRQHandler</span><br><span class="line">DMA1_Channel6_IRQHandler</span><br><span class="line">DMA1_Channel7_IRQHandler</span><br><span class="line">ADC1_2_IRQHandler</span><br><span class="line">USB_HP_CAN1_TX_IRQHandler</span><br><span class="line">USB_LP_CAN1_RX0_IRQHandler</span><br><span class="line">CAN1_RX1_IRQHandler</span><br><span class="line">CAN1_SCE_IRQHandler</span><br><span class="line">EXTI9_5_IRQHandler</span><br><span class="line">TIM1_BRK_IRQHandler</span><br><span class="line">TIM1_UP_IRQHandler</span><br><span class="line">TIM1_TRG_COM_IRQHandler</span><br><span class="line">TIM1_CC_IRQHandler</span><br><span class="line">TIM2_IRQHandler</span><br><span class="line">TIM3_IRQHandler</span><br><span class="line">TIM4_IRQHandler</span><br><span class="line">I2C1_EV_IRQHandler</span><br><span class="line">I2C1_ER_IRQHandler</span><br><span class="line">I2C2_EV_IRQHandler</span><br><span class="line">I2C2_ER_IRQHandler</span><br><span class="line">SPI1_IRQHandler</span><br><span class="line">SPI2_IRQHandler</span><br><span class="line">USART1_IRQHandler</span><br><span class="line">USART2_IRQHandler</span><br><span class="line">USART3_IRQHandler</span><br><span class="line">EXTI15_10_IRQHandler</span><br><span class="line">RTCAlarm_IRQHandler</span><br><span class="line">USBWakeUp_IRQHandler</span><br><span class="line">TIM8_BRK_IRQHandler</span><br><span class="line">TIM8_UP_IRQHandler</span><br><span class="line">TIM8_TRG_COM_IRQHandler</span><br><span class="line">TIM8_CC_IRQHandler</span><br><span class="line">ADC3_IRQHandler</span><br><span class="line">FSMC_IRQHandler</span><br><span class="line">SDIO_IRQHandler</span><br><span class="line">TIM5_IRQHandler</span><br><span class="line">SPI3_IRQHandler</span><br><span class="line">UART4_IRQHandler</span><br><span class="line">UART5_IRQHandler</span><br><span class="line">TIM6_IRQHandler</span><br><span class="line">TIM7_IRQHandler</span><br><span class="line">DMA2_Channel1_IRQHandler</span><br><span class="line">DMA2_Channel2_IRQHandler</span><br><span class="line">DMA2_Channel3_IRQHandler</span><br><span class="line">DMA2_Channel4_5_IRQHandler</span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line">                ; ALIGN 表示4字节对齐(参数缺省时)</span><br><span class="line"></span><br><span class="line">;****************************************************************</span><br><span class="line">;* 6-堆栈的初始化, 由C库函数__main实现</span><br><span class="line">;****************************************************************</span><br><span class="line"></span><br><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB ; __MICROLIB在ide里定义, 在Keil5 MDK中勾选Use MicroLIB选项</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory ; 如果__MICROLIB未定义, 则由用户自己实现</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line"></span><br><span class="line">;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="equ指令">EQU指令</h3>
<p>作用: The EQU directive is a register-relative address, a PC-relative address, an absolute address, or a 32-bit integer constant. // 为数值常量、寄存器相对值或 PC 相对值提供符号名称。(<em>可以理解为重命名</em>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400 </span><br><span class="line">; 宏定义的伪指令，相当于等于，类似与 C 中的 define。</span><br><span class="line">; 将0x00000400命名为Stack_Size, 0x00000400表示1Kb大小</span><br></pre></td></tr></table></figure>
<h4 id="equ手册说明">EQU手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031428875.png" alt="EQU指令"></p>
<h3 id="area指令">AREA指令</h3>
<p>AREA: 汇编一个新的代码段或数据段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">; 告诉汇编器汇编一个新的代码段或者数据段。</span><br><span class="line">; STACK 表示段名，这个可以任意命名</span><br><span class="line">; NOINIT 表示不初始化</span><br><span class="line">; READWRITE 表示可读可写</span><br><span class="line">; ALIGN=3，表示按照 2^3 对齐，即 8 字节对齐</span><br></pre></td></tr></table></figure>
<h4 id="area手册说明">AREA手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031529274.png" alt="AREA"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530123.png" alt="AREA"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031530696.png" alt="AREA"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031531689.png" alt="AREA"></p>
<h3 id="space指令">SPACE指令</h3>
<p>SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size, 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">; SPACE：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</span><br><span class="line">__initial_sp</span><br><span class="line">; 标号 __initial_sp 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长</span><br></pre></td></tr></table></figure>
<h4 id="space手册说明">SPACE手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031539781.png" alt="SPACE"></p>
<h3 id="preserve8指令">PRESERVE8指令</h3>
<p>PRESERVE8：指定当前文件的堆栈按照 8 字节对齐</p>
<h4 id="preserve8手册说明">PRESERVE8手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031556307.png" alt="PRESERVE8"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031557775.png" alt="PRESERVE8"></p>
<h3 id="thumb指令">THUMB指令</h3>
<p>野火的解释: <strong>THUMB：表示后面指令兼容 THUMB 指令。THUBM 是 ARM 以前的指令集，16bit，现在 Cortex-M系列的都使用 THUMB-2 指令集，THUMB-2 是 32 位的，兼容 16 位和 32 位的指令，是 THUMB的超集</strong></p>
<h4 id="thumb手册说明">THUMB手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031600256.png" alt="THUMB"></p>
<h3 id="export指令">EXPORT指令</h3>
<p>EXPORT：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 IAR 编译器，则使用的是 GLOBAL 这个指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPORT  __Vectors</span><br><span class="line">EXPORT  __Vectors_End</span><br><span class="line">EXPORT  __Vectors_Size</span><br><span class="line">; EXPORT声明标号__Vectors等具有全局属性, 可被外部的文件调用</span><br></pre></td></tr></table></figure>
<h4 id="export手册说明">EXPORT手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031623174.png" alt="EXPORT"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624509.png" alt="EXPORT"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401031624882.png" alt="EXPORT"></p>
<h3 id="dcd指令">DCD指令</h3>
<p>DCD：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存</p>
<h4 id="dcd手册说明">DCD手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032016385.png" alt="DCD"></p>
<h3 id="proc指令">PROC指令</h3>
<p>PROC: 定义子程序, 与ENDP成对使用, 表示子程序结束</p>
<h4 id="proc手册说明">PROC手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032025440.png" alt="PROC"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032026200.png" alt="PROC"></p>
<h3 id="import指令">IMPORT指令</h3>
<p>IMPORT：表示该标号来自外部文件，跟 C 语言中的 EXTERN 关键字类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMPORT  __main</span><br><span class="line">IMPORT  SystemInit</span><br><span class="line">;表示 SystemInit和 __main 这两个函数均来自外部的文件</span><br></pre></td></tr></table></figure>
<h4 id="import手册说明">IMPORT手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034894.png" alt="IMPORT"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032034604.png" alt="IMPORT"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032035341.png" alt="IMPORT"></p>
<h3 id="ldr指令">LDR指令</h3>
<p>LDR: 从存储器中加载字到一个寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR     R0, =SystemInit</span><br><span class="line">; 把SystemInit的地址加载到R0中</span><br><span class="line">BLX     R0               </span><br><span class="line">; 跳转到R0执行, 执行完毕后返回</span><br><span class="line">LDR     R0, =__main</span><br><span class="line">; 把__main的地址加载到R0中</span><br><span class="line">BX      R0</span><br><span class="line">; 跳转到R0执行, 执行完毕后不返回</span><br></pre></td></tr></table></figure>
<h4 id="ldr手册说明">LDR手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046548.png" alt="LDR"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032046349.png" alt="LDR"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032047305.png" alt="LDR"></p>
<h3 id="blx指令">BLX指令</h3>
<p>BLX: 跳转到由寄存器给出的地址, 并根据寄存器的LSE确定处理器的状态, 还要把跳转前的下条指令地址保存到LR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLX     R0               </span><br><span class="line">; 跳转到R0执行, 执行完毕后返回</span><br></pre></td></tr></table></figure>
<h3 id="bx指令">BX指令</h3>
<p>BX: 跳转到由寄存器/标号给出的地址, 不用返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BX      R0</span><br><span class="line">; 跳转到R0执行, 执行完毕后不返回</span><br></pre></td></tr></table></figure>
<h3 id="align指令">ALIGN指令</h3>
<p>ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐</p>
<h4 id="align手册说明">ALIGN手册说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103293.png" alt="ALIGN"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103739.png" alt="ALIGN"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401032103256.png" alt="ALIGN"></p>
<h2 id="时钟">时钟</h2>
<h3 id="时钟系统框图">时钟系统框图</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2009.47.02.png" alt="时钟系统框图"></p>
<h4 id="sysclk系统时钟源选择">SYSCLK系统时钟源选择</h4>
<ul>
<li>HSI_RC: 高速内部时钟, RC 震荡产生(频率约为 8MHz)</li>
<li>HSE: 高速外部时钟,通过外接晶振产生(频率范围: 4-16MHz)</li>
<li>PLL: 锁相环,倍频到72MHz</li>
</ul>
<h5 id="sysclk-系统时钟的选择">SYSCLK 系统时钟的选择</h5>
<ol>
<li>HSI_RC 约 8MHz</li>
<li>PLLCLK 倍频至72MHz</li>
<li>HSE_Osc直接使用</li>
</ol>
<h5 id="pll锁相环的选择">PLL锁相环的选择</h5>
<ol>
<li>HSI_RC 两分频后</li>
<li>HSE_Osc or HSE_Osc二分频后</li>
</ol>
<p>CSS: 时钟监视系统, 监视 HSE_Osc 是否正常工作,若 外部时钟源异常则将 SYSCLK 切换为 HSI_RC</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.03.07.png" alt="时钟系统框图"></p>
<h4 id="rtcclk时钟源选择">RTCCLK时钟源选择</h4>
<ul>
<li>LSE_Osc: 低速外部时钟源, 频率为36.768KHz</li>
<li>LSI_RC: 低速内部时钟源, 频率约为40KHz, 由 RC 震荡产生</li>
</ul>
<h5 id="rtc_clk(rtc-时钟)的选择">RTC_CLK(RTC 时钟)的选择</h5>
<ol>
<li>HSE_Osc 128 分频后</li>
<li>LSE_Osc</li>
<li>LSI_RC</li>
</ol>
<h4 id="iwdgclk独立看门狗时钟源">IWDGCLK独立看门狗时钟源</h4>
<p>IWDGCLK独立看门狗时钟源由LSI_RC 提供</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401291156077.png" alt="IWDGCLK独立看门狗时钟源"></p>
<h4 id="mco-的选择">MCO 的选择</h4>
<p>MCO是一个引脚来输出内部时钟</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.13.53.png" alt="系统时钟框图"></p>
<ol>
<li>SYSCLK</li>
<li>HSI</li>
<li>HSE</li>
<li>PLLCLK 二分频</li>
</ol>
<h4 id="各类总线时钟">各类总线时钟</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2010.26.21.png" alt="时钟系统框图"></p>
<ol>
<li>USBCLK_48MHz (USB 时钟): 由 PLLCLK经USB_Prescaler预分频至 48MHz</li>
<li>HCLK: SYSCLK-&gt;AHB_Prescaler 最高 72MHz</li>
<li>PCLK1: SYSCLK-&gt;AHB_Prescaler-&gt;APB1_Prescaler 最高36MHz</li>
<li>TIMxCLK(通用定时器时钟): SYSCLK-&gt;AHB_Prescaler-&gt;APB1_Prescaler-&gt;TIM2,3,4_Multiplier</li>
<li>PCKL2: SYSCLK-&gt;AHB_Prescaler-&gt;APB2_Prescaler 最高72MHz</li>
<li>TIM1CLK(TIM1 时钟): SYSCLK-&gt;AHB_Prescal-&gt;APB2_Prescaler-&gt;TIM1_Multiplier</li>
<li>ADCCLK(ADC 时钟): SYSCLK-&gt;AHB_Prescaler-&gt;APB2_Prescaler-&gt;ADC_Prescaler</li>
</ol>
<h4 id="总结">总结</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-04%2011.09.39.png" alt="知识总结"></p>
<h3 id="系统时钟配置函数-setsysclockto72()分析">系统时钟配置函数 SetSysClockTo72()分析</h3>
<p>在启动文件startup_stm32f10x_hd.s中执行SystemInit函数, 如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0               </span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>
<p>在system_stm32f10x.c文件中调用SystemInit函数, SystemInit函数在末尾调用SetSysClock()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Reset the RCC clock configuration to the default reset state(for debug purpose) */</span></span><br><span class="line">  <span class="comment">/* Set HSION bit */</span></span><br><span class="line">  RCC-&gt;CR |= (<span class="type">uint32_t</span>)<span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STM32F10X_CL</span></span><br><span class="line">  RCC-&gt;CFGR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xF8FF0000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  RCC-&gt;CFGR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xF0FF0000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F10X_CL */</span>   </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Reset HSEON, CSSON and PLLON bits */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFEF6FFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset HSEBYP bit */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFFFBFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span></span><br><span class="line">  RCC-&gt;CFGR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFF80FFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STM32F10X_CL</span></span><br><span class="line">  <span class="comment">/* Reset PLL2ON and PLL3ON bits */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xEBFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable all interrupts and clear pending bits  */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x00FF0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset CFGR2 register */</span></span><br><span class="line">  RCC-&gt;CFGR2 = <span class="number">0x00000000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class="line">  <span class="comment">/* Disable all interrupts and clear pending bits  */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x009F0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset CFGR2 register */</span></span><br><span class="line">  RCC-&gt;CFGR2 = <span class="number">0x00000000</span>;      </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Disable all interrupts and clear pending bits  */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x009F0000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* STM32F10X_CL */</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> DATA_IN_ExtSRAM</span></span><br><span class="line">    SystemInit_ExtMemCtl(); </span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* DATA_IN_ExtSRAM */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */</span></span><br><span class="line">  <span class="comment">/* Configure the Flash Latency cycles and enable prefetch buffer */</span></span><br><span class="line">  SetSysClock(); <span class="comment">// 末尾调用SetSysClock()函数 </span></span><br></pre></td></tr></table></figure>
<p>调用system_stm32f10x.c中SetSysClock()</p>
<p>默认情况下定义SYSCLK_FREQ_72MHz宏, 调用SetSysClockTo72()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SetSysClock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SYSCLK_FREQ_HSE</span></span><br><span class="line">  SetSysClockToHSE();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSCLK_FREQ_24MHz</span></span><br><span class="line">  SetSysClockTo24();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSCLK_FREQ_36MHz</span></span><br><span class="line">  SetSysClockTo36();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSCLK_FREQ_48MHz</span></span><br><span class="line">  SetSysClockTo48();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSCLK_FREQ_56MHz</span></span><br><span class="line">  SetSysClockTo56();  </span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class="line">  SetSysClockTo72();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* If none of the define above is enabled, the HSI is used as System clock</span></span><br><span class="line"><span class="comment">    source (default after reset) */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在system_stm32f10x.c中宏定义, 默认宏定义SYSTEMCLK_FREQ_72MHz</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class="line"><span class="comment">/* #define SYSCLK_FREQ_HSE    HSE_VALUE */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYSCLK_FREQ_24MHz  24000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* #define SYSCLK_FREQ_HSE    HSE_VALUE */</span></span><br><span class="line"><span class="comment">/* #define SYSCLK_FREQ_24MHz  24000000 */</span> </span><br><span class="line"><span class="comment">/* #define SYSCLK_FREQ_36MHz  36000000 */</span></span><br><span class="line"><span class="comment">/* #define SYSCLK_FREQ_48MHz  48000000 */</span></span><br><span class="line"><span class="comment">/* #define SYSCLK_FREQ_56MHz  56000000 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCLK_FREQ_72MHz  72000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在system_stem32f10x.c中定义SetSysClockTo72()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 </span></span><br><span class="line"><span class="comment">  *         and PCLK1 prescalers. </span></span><br><span class="line"><span class="comment">  * @note   This function should be used only after reset.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SetSysClockTo72</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __IO <span class="type">uint32_t</span> StartUpCounter = <span class="number">0</span>, HSEStatus = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/</span>    </span><br><span class="line">  <span class="comment">/* Enable HSE */</span>    </span><br><span class="line">  <span class="comment">// 使能HSE</span></span><br><span class="line">  RCC-&gt;CR |= ((<span class="type">uint32_t</span>)RCC_CR_HSEON);</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class="line">  <span class="comment">// 等待 HSE 就绪并作超时处理</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class="line">    StartUpCounter++;  </span><br><span class="line">  &#125; <span class="keyword">while</span>((HSEStatus == <span class="number">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="type">uint32_t</span>)<span class="number">0x01</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="type">uint32_t</span>)<span class="number">0x00</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 HSE启动成功, 程序则继续往下执行</span></span><br><span class="line">  <span class="keyword">if</span> (HSEStatus == (<span class="type">uint32_t</span>)<span class="number">0x01</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable Prefetch Buffer */</span></span><br><span class="line">    <span class="comment">// 启用 Flsh  预取缓冲区</span></span><br><span class="line">    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flash 2 wait state */</span></span><br><span class="line">    <span class="comment">// flash 时延两个等待状态</span></span><br><span class="line">    FLASH-&gt;ACR &amp;= (<span class="type">uint32_t</span>)((<span class="type">uint32_t</span>)~FLASH_ACR_LATENCY);</span><br><span class="line">    FLASH-&gt;ACR |= (<span class="type">uint32_t</span>)FLASH_ACR_LATENCY_2;    </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* HCLK = SYSCLK */</span></span><br><span class="line">    <span class="comment">// 72MHz</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="type">uint32_t</span>)RCC_CFGR_HPRE_DIV1;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* PCLK2 = HCLK */</span></span><br><span class="line">    <span class="comment">// 72MHz</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="type">uint32_t</span>)RCC_CFGR_PPRE2_DIV1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PCLK1 = HCLK */</span></span><br><span class="line">    <span class="comment">// 36MHz</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="type">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 互联型芯片 F105, F107 以下代码不进行分析</span></span><br><span class="line"><span class="comment"> *---------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STM32F10X_CL</span></span><br><span class="line">    <span class="comment">/* Configure PLLs ------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */</span></span><br><span class="line">    <span class="comment">/* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */</span></span><br><span class="line">        </span><br><span class="line">    RCC-&gt;CFGR2 &amp;= (<span class="type">uint32_t</span>)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |</span><br><span class="line">                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);</span><br><span class="line">    RCC-&gt;CFGR2 |= (<span class="type">uint32_t</span>)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |</span><br><span class="line">                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Enable PLL2 */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLL2ON;</span><br><span class="line">    <span class="comment">/* Wait till PLL2 is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */</span> </span><br><span class="line">    <span class="comment">// 锁相环配置</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="type">uint32_t</span>)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="type">uint32_t</span>)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | </span><br><span class="line">                            RCC_CFGR_PLLMULL9); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span>    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable PLL */</span></span><br><span class="line">    <span class="comment">// 使能 PLL</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is ready */</span></span><br><span class="line">    <span class="comment">//  等待 PLL 稳定</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Select PLL as system clock source */</span></span><br><span class="line">    <span class="comment">// 选择 PLLCLK 作为系统时钟</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="type">uint32_t</span>)((<span class="type">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="type">uint32_t</span>)RCC_CFGR_SW_PLL;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is used as system clock source */</span></span><br><span class="line">    <span class="comment">// 等待 PLLCLK 切换为系统时钟</span></span><br><span class="line">    <span class="keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="type">uint32_t</span>)RCC_CFGR_SWS) != (<span class="type">uint32_t</span>)<span class="number">0x08</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">/* If HSE fails to start-up, the application will have wrong clock </span></span><br><span class="line"><span class="comment">         configuration. User can add here some code to deal with this error */</span></span><br><span class="line">    <span class="comment">// 如果 HSE 启动失败,用户可以在这里添加处理错误的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="hse配置系统时钟">HSE配置系统时钟</h3>
<p>项目地址: <strong>16-使用HSE配置系统时钟并使用MCO输出监控系统时钟</strong></p>
<h4 id="在bsp_rccclkconfigc中写入hse的配置函数">在bsp_rccclkconfig.c中写入HSE的配置函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置系统时钟为外部高速晶振（HSE）时钟，并配置PLL倍频系数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param RCC_PLLMul_x PLL倍频系数，范围为2-16。</span></span><br><span class="line"><span class="comment"> * @note 该函数会将RCC模块复位，并使能HSE。如果HSE启动成功，则设置FLASH预取指令使能、FLASH等待周期、AHB总线时钟、APB1总线时钟、APB2总线时钟、PLL倍频系数，并等待PLL稳定后将系统时钟设置为PLL时钟。</span></span><br><span class="line"><span class="comment"> *       如果HSE启动失败，则用户可以在函数中添加处理错误的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSE_SetSysClk</span><span class="params">(<span class="type">uint32_t</span> RCC_PLLMul_x)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_DeInit(); <span class="comment">// RCC复位</span></span><br><span class="line">    ErrorStatus HSEStatus;</span><br><span class="line">    RCC_HSEConfig(RCC_HSE_ON); <span class="comment">// 使能HSE</span></span><br><span class="line">    HSEStatus = RCC_WaitForHSEStartUp(); <span class="comment">// 获取HSE启动状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HSEStatus == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class="comment">// 使能预取指</span></span><br><span class="line">        FLASH_SetLatency(FLASH_ACR_LATENCY_2); <span class="comment">// 设置等待</span></span><br><span class="line">        RCC_HCLKConfig(RCC_SYSCLK_Div1); <span class="comment">//HCLK = SYSCLK = 72MHz</span></span><br><span class="line">        RCC_PCLK1Config(RCC_SYSCLK_Div2); <span class="comment">//PCLK1 = HCLK / 2 = 36MHz</span></span><br><span class="line">        RCC_PCLK2Config(RCC_SYSCLK_Div1); <span class="comment">//PCLK2 = HCLK / 1 = 72MHz</span></span><br><span class="line">        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_x); <span class="comment">// RCC_RLLMul_x 用来超频 频率:(8*x)MHz</span></span><br><span class="line">        RCC_PLLCmd(ENABLE); <span class="comment">// 使能PLL</span></span><br><span class="line">        <span class="keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待PLL稳定</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); <span class="comment">// 设置系统时钟为PLL时钟</span></span><br><span class="line">        <span class="keyword">while</span>(RCC_GetSYSCLKSource() != <span class="number">0x08</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待设置系统时钟</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果HSE启动失败, 用户在此添加处理错误代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_rccclkconfigc中编写mco的gpio初始化函数">在bsp_rccclkconfig.c中编写MCO的GPIO初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Configures the GPIO for MCO (Microcontroller Clock Output).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function initializes the GPIO pin for MCO and configures it as an alternate function push-pull output.</span></span><br><span class="line"><span class="comment"> * The GPIO pin used for MCO is GPIOA Pin 8.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param None</span></span><br><span class="line"><span class="comment"> * @return None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MCO_GPIO_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// MCO的GPIO初始化</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_rccclkconfigh中添加函数声明">在bsp_rccclkconfig.h中添加函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_RCCCLKCONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_RCCCLKCONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSE_SetSysClk</span><span class="params">(<span class="type">uint32_t</span> RCC_PLLMul_x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MCO_GPIO_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__BSP_RCCCLKCONFIG_H</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中调用hse配置系统时钟函数和mco的gpio初始化函数">在main.c中调用HSE配置系统时钟函数和MCO的GPIO初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_rccclkconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数Delay()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; count != <span class="number">0</span>; count--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x2AFF</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HSE_SetSysClk(RCC_PLLMul_9); <span class="comment">// 72MHz</span></span><br><span class="line">    <span class="comment">// HSE_SetSysClk(RCC_PLLMul_16); // 128MHz</span></span><br><span class="line">    MCO_GPIO_Config();</span><br><span class="line">    RCC_MCOConfig(RCC_MCO_SYSCLK); <span class="comment">// 配置MCO选择系统时钟</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED_B(OFF);</span><br><span class="line">        Delay(<span class="number">50</span>); <span class="comment">// 延时</span></span><br><span class="line">        LED_B(ON);</span><br><span class="line">        Delay(<span class="number">50</span>); <span class="comment">// 延时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用hsi配置系统时钟并用mco监控系统时钟">使用HSI配置系统时钟并用MCO监控系统时钟</h3>
<p>项目地址: <strong>16-使用HSI配置系统时钟并用MCO监控系统时钟</strong></p>
<h4 id="在bsp_rccclkconfigc中编写hsi配置系统时钟函数">在bsp_rccclkconfig.c中编写HSI配置系统时钟函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置系统时钟为HSI，并配置PLL倍频系数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param RCC_PLLMul_x PLL倍频系数，范围为2-16</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note 该函数将系统时钟设置为HSI，并根据传入的PLL倍频系数配置PLL，以实现超频功能。</span></span><br><span class="line"><span class="comment"> *       如果HSI启动失败，用户可以在函数的else分支中添加处理错误的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSI_SetSysClk</span><span class="params">(<span class="type">uint32_t</span> RCC_PLLMul_x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Function implementation</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> HSIStatus = <span class="number">0</span>; <span class="comment">// 参考固件库源码</span></span><br><span class="line">    RCC_DeInit(); <span class="comment">// RCC复位</span></span><br><span class="line">    RCC_HSICmd(ENABLE); <span class="comment">// 使能HSI</span></span><br><span class="line">    HSIStatus = RCC-&gt;CR &amp; RCC_CR_HSIRDY; <span class="comment">// 获取HSI启动状态, 参考固件库源码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HSIStatus == RCC_CR_HSIRDY)</span><br><span class="line">    &#123;</span><br><span class="line">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); <span class="comment">// 使能预取指</span></span><br><span class="line">        FLASH_SetLatency(FLASH_ACR_LATENCY_2); <span class="comment">// 设置等待</span></span><br><span class="line">        RCC_HCLKConfig(RCC_SYSCLK_Div1); <span class="comment">//HCLK = SYSCLK = 72MHz</span></span><br><span class="line">        RCC_PCLK1Config(RCC_SYSCLK_Div2); <span class="comment">//PCLK1 = HCLK / 2 = 36MHz</span></span><br><span class="line">        RCC_PCLK2Config(RCC_SYSCLK_Div1); <span class="comment">//PCLK2 = HCLK / 1 = 72MHz</span></span><br><span class="line">        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, RCC_PLLMul_x); <span class="comment">// RCC_RLLMul_x 用来超频 频率:(8*x)MHz</span></span><br><span class="line">        RCC_PLLCmd(ENABLE); <span class="comment">// 使能PLL</span></span><br><span class="line">        <span class="keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待PLL稳定</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); <span class="comment">// 设置系统时钟为PLL时钟</span></span><br><span class="line">        <span class="keyword">while</span>(RCC_GetSYSCLKSource() != <span class="number">0x08</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待设置系统时钟</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果HSI启动失败, 用户在此添加处理错误代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_rccclkconfigh中加入函数声明">在bsp_rccclkconfig.h中加入函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HSI_SetSysClk</span><span class="params">(<span class="type">uint32_t</span> RCC_PLLMul_x)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中调用hsi配置系统时钟函数">在main.c中调用HSI配置系统时钟函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HSI_SetSysClk(RCC_PLLMul_12); <span class="comment">// 4*12=48MHz</span></span><br><span class="line">MCO_GPIO_Config();</span><br><span class="line">RCC_MCOConfig(RCC_MCO_SYSCLK); <span class="comment">// 配置MCO选择系统时钟</span></span><br><span class="line">LED_GPIO_Config();</span><br></pre></td></tr></table></figure>
<h2 id="中断">中断</h2>
<h3 id="stm32中断应用概览">STM32中断应用概览</h3>
<h4 id="中断类型">中断类型</h4>
<ul>
<li>系统异常: 体现在内核水平</li>
<li>外部中断: 体现在外设水平</li>
</ul>
<h4 id="nvic">NVIC</h4>
<p>NVIC负责管理中断</p>
<p>在core_cm3.h中的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC</span></span><br><span class="line"><span class="comment">  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)</span></span><br><span class="line"><span class="comment">  @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 中断使能寄存器</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ISER[<span class="number">8</span>];                      <span class="comment">/*!&lt; Offset: 0x000  Interrupt Set Enable Register           */</span></span><br><span class="line">       <span class="type">uint32_t</span> RESERVED0[<span class="number">24</span>];                                   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断清除寄存器</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICER[<span class="number">8</span>];                      <span class="comment">/*!&lt; Offset: 0x080  Interrupt Clear Enable Register         */</span></span><br><span class="line">       <span class="type">uint32_t</span> RSERVED1[<span class="number">24</span>];                                    </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断使能悬起寄存器</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ISPR[<span class="number">8</span>];                      <span class="comment">/*!&lt; Offset: 0x100  Interrupt Set Pending Register          */</span></span><br><span class="line">       <span class="type">uint32_t</span> RESERVED2[<span class="number">24</span>];                                   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 中断清除悬起寄存器 </span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICPR[<span class="number">8</span>];                      <span class="comment">/*!&lt; Offset: 0x180  Interrupt Clear Pending Register        */</span></span><br><span class="line">       <span class="type">uint32_t</span> RESERVED3[<span class="number">24</span>];                                   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断有效位寄存器</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IABR[<span class="number">8</span>];                      <span class="comment">/*!&lt; Offset: 0x200  Interrupt Active bit Register           */</span></span><br><span class="line">       <span class="type">uint32_t</span> RESERVED4[<span class="number">56</span>];                                   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断优先级寄存器</span></span><br><span class="line">  __IO <span class="type">uint8_t</span>  IP[<span class="number">240</span>];                      <span class="comment">/*!&lt; Offset: 0x300  Interrupt Priority Register (8Bit wide) */</span></span><br><span class="line">       <span class="type">uint32_t</span> RESERVED5[<span class="number">644</span>];                                  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 软件触发中断寄存器</span></span><br><span class="line">  __O  <span class="type">uint32_t</span> STIR;                         <span class="comment">/*!&lt; Offset: 0xE00  Software Trigger Interrupt Register     */</span></span><br><span class="line">&#125;  NVIC_Type;                                               </span><br><span class="line"><span class="comment">/*@&#125;*/</span> <span class="comment">/* end of group CMSIS_CM3_NVIC */</span></span><br></pre></td></tr></table></figure>
<h5 id="nvic的优先级分组">NVIC的优先级分组</h5>
<p>通过<strong>SCB-&gt;AIRCR寄存器的PRIGROUP部分(即bit[10:8])进行分组</strong></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401140238595.png" alt="NVIC优先级"></p>
<h3 id="中断编程的顺序">中断编程的顺序</h3>
<ol>
<li>使能中断请求(<strong>使能外设中断, 使能 NVIC 中断</strong>)</li>
<li>配置中断优先级分组(NVIC_PriorityGroupConfig)</li>
<li>配置 NVIC 寄存器, 初始化NVIC_InitTypeDef</li>
<li>编写中断服务函数</li>
</ol>
<h2 id="exti">EXTI</h2>
<h3 id="exti-输入线">EXTI 输入线</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.13.32.png" alt="EXTI 输入线"></p>
<p>通过寄存器 AFIO_EXTICR1, 2, 3, 4配置</p>
<h3 id="exti-框图讲解">EXTI 框图讲解</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/%E6%88%AA%E5%B1%8F2024-01-15%2015.18.42.png" alt="EXTI 框图"></p>
<h4 id="外部中断流程">外部中断流程</h4>
<ol>
<li>通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1</li>
<li>通过 EXTI_SWIER 来配置软件中断, 配置后为 1</li>
<li>经过逻辑与门后, 进入请求挂起寄存器</li>
<li>通过 EXTI_PR 配置挂起</li>
<li>通过 EXTI_IMR 配置中断屏蔽</li>
<li>请求挂起寄存器的逻辑值与中断屏蔽寄存器的逻辑值做逻辑与至 NVIC 中断控制器</li>
</ol>
<h4 id="外部事件流程">外部事件流程</h4>
<ol>
<li>通过 EXTI_RTSR 和 EXTI_FTSR 来配置上升沿/下降沿触发, 触发后边沿检测电路为 1</li>
<li>通过 EXTI_SWIER 来配置软件中断, 配置后为 1</li>
<li>经过逻辑与门后, 向下跟事件屏蔽寄存器相与</li>
<li>通过 EXTI_EMR 配置事件屏蔽</li>
<li>若为 1 产生脉冲</li>
</ol>
<h3 id="exti-结构体">EXTI 结构体</h3>
<p>EXTI_InitTypeDef</p>
<ul>
<li>EXTI_Line : 用于产生中断/事件线</li>
<li>EXTI_Mode : EXTI 模式(中断/事件)</li>
<li>EXTI_Trigger : 触发(上/下/上下)</li>
<li>EXTI_LineCmd :  使能或者失能(IMR/EMR)</li>
</ul>
<h4 id="exti-的结构体定义">EXTI 的结构体定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  EXTI Init Structure definition  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> EXTI_Line;               <span class="comment">/*!&lt; Specifies the EXTI lines to be enabled or disabled.</span></span><br><span class="line"><span class="comment">                                         This parameter can be any combination of @ref EXTI_Lines */</span></span><br><span class="line">   </span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;       <span class="comment">/*!&lt; Specifies the mode for the EXTI lines.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a value of @ref EXTIMode_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger; <span class="comment">/*!&lt; Specifies the trigger signal active edge for the EXTI lines.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a value of @ref EXTIMode_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  FunctionalState EXTI_LineCmd;     <span class="comment">/*!&lt; Specifies the new state of the selected EXTI lines.</span></span><br><span class="line"><span class="comment">                                         This parameter can be set either to ENABLE or DISABLE */</span> </span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<h5 id="exti_line-的定义">EXTI_Line 的定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @defgroup EXTI_Lines </span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line0       ((uint32_t)0x00001)  <span class="comment">/*!&lt; External interrupt line 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line1       ((uint32_t)0x00002)  <span class="comment">/*!&lt; External interrupt line 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line2       ((uint32_t)0x00004)  <span class="comment">/*!&lt; External interrupt line 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line3       ((uint32_t)0x00008)  <span class="comment">/*!&lt; External interrupt line 3 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line4       ((uint32_t)0x00010)  <span class="comment">/*!&lt; External interrupt line 4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line5       ((uint32_t)0x00020)  <span class="comment">/*!&lt; External interrupt line 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line6       ((uint32_t)0x00040)  <span class="comment">/*!&lt; External interrupt line 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line7       ((uint32_t)0x00080)  <span class="comment">/*!&lt; External interrupt line 7 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line8       ((uint32_t)0x00100)  <span class="comment">/*!&lt; External interrupt line 8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line9       ((uint32_t)0x00200)  <span class="comment">/*!&lt; External interrupt line 9 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line10      ((uint32_t)0x00400)  <span class="comment">/*!&lt; External interrupt line 10 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line11      ((uint32_t)0x00800)  <span class="comment">/*!&lt; External interrupt line 11 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line12      ((uint32_t)0x01000)  <span class="comment">/*!&lt; External interrupt line 12 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line13      ((uint32_t)0x02000)  <span class="comment">/*!&lt; External interrupt line 13 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line14      ((uint32_t)0x04000)  <span class="comment">/*!&lt; External interrupt line 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line15      ((uint32_t)0x08000)  <span class="comment">/*!&lt; External interrupt line 15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line16      ((uint32_t)0x10000)  <span class="comment">/*!&lt; External interrupt line 16 Connected to the PVD Output */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line17      ((uint32_t)0x20000)  <span class="comment">/*!&lt; External interrupt line 17 Connected to the RTC Alarm event */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line18      ((uint32_t)0x40000)  <span class="comment">/*!&lt; External interrupt line 18 Connected to the USB Device/USB OTG FS</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                   Wakeup from suspend event */</span>                                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTI_Line19      ((uint32_t)0x80000)  <span class="comment">/*!&lt; External interrupt line 19 Connected to the Ethernet Wakeup event */</span></span></span><br></pre></td></tr></table></figure>
<h5 id="exti_mode-的定义">EXTI_Mode 的定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  EXTI mode enumeration  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EXTI_Mode_Interrupt = <span class="number">0x00</span>,</span><br><span class="line">  EXTI_Mode_Event = <span class="number">0x04</span></span><br><span class="line">&#125;EXTIMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))</span></span><br></pre></td></tr></table></figure>
<h5 id="exti_trigger-的定义">EXTI_Trigger 的定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  EXTI Trigger enumeration  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EXTI_Trigger_Rising = <span class="number">0x08</span>,</span><br><span class="line">  EXTI_Trigger_Falling = <span class="number">0x0C</span>,  </span><br><span class="line">  EXTI_Trigger_Rising_Falling = <span class="number">0x10</span></span><br><span class="line">&#125;EXTITrigger_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \</span></span><br><span class="line"><span class="meta">                                  ((TRIGGER) == EXTI_Trigger_Falling) || \</span></span><br><span class="line"><span class="meta">                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))</span></span><br></pre></td></tr></table></figure>
<h3 id="gpio-作为 exti 输入线的配置">GPIO 作为 EXTI 输入线的配置</h3>
<p>在 stm32f10x_gpio.c 中, 使用 GPIO_EXTILineConfig 函数进行配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Selects the GPIO pin used as EXTI Line.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.</span></span><br><span class="line"><span class="comment">  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class="line"><span class="comment">  * @param  GPIO_PinSource: specifies the EXTI line to be configured.</span></span><br><span class="line"><span class="comment">  *   This parameter can be GPIO_PinSourcex where x can be (0..15).</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> tmp = <span class="number">0x00</span>;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));</span><br><span class="line">  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));</span><br><span class="line">  </span><br><span class="line">  tmp = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; (<span class="number">0x04</span> * (GPIO_PinSource &amp; (<span class="type">uint8_t</span>)<span class="number">0x03</span>));</span><br><span class="line">  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; <span class="number">0x02</span>] &amp;= ~tmp;</span><br><span class="line">  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; <span class="number">0x02</span>] |= (((<span class="type">uint32_t</span>)GPIO_PortSource) &lt;&lt; (<span class="number">0x04</span> * (GPIO_PinSource &amp; (<span class="type">uint8_t</span>)<span class="number">0x03</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exti中断实验">EXTI中断实验</h3>
<p>项目地址: <strong>18-EXTI</strong></p>
<p><strong>项目需求:</strong></p>
<ol>
<li>PA0 连接到 EXTI 用于产生中断, PA0 的电平变化通过按键来控制</li>
<li>产生一次中断, LED 反转一次</li>
</ol>
<h4 id="在bsp_extic中初始化要连接到exti的gpio">在bsp_exti.c中初始化要连接到EXTI的GPIO</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 Key1(PA0)</span></span><br><span class="line">RCC_APB2PeriphClockCmd(KEY1_INT_GPIO_CLK, ENABLE);</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = KEY1_INT_GPIO_PIN;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_Init(KEY1_INT_GPIO_PORT, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_extic中初始化exti用于产生中断/事件">在bsp_exti.c中初始化EXTI用于产生中断/事件</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); <span class="comment">// 选择输入线</span></span><br><span class="line">EXTI_InitStruct.EXTI_Line = EXTI_Line0;                     <span class="comment">// 选择EXTI线路</span></span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;            <span class="comment">// 选择中断模式</span></span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;         <span class="comment">// 选择触发模式</span></span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;                          <span class="comment">// 使能EXTI线路</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_extic中初始化nvic,-用于处理中断">在bsp_exti.c中初始化NVIC, 用于处理中断</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); <span class="comment">// 配置中断优先级分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn; <span class="comment">// 选择中断源</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>; <span class="comment">// 抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>; <span class="comment">// 子优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能中断</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure>
<h4 id="在stm32f10x_itc中编写中断服务函数">在stm32f10x_it.c中编写中断服务函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief EXTI0_IRQHandler: Interrupt handler for EXTI Line 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is the interrupt handler for EXTI Line 0. It toggles the state of the blue LED.</span></span><br><span class="line"><span class="comment"> * It checks the interrupt status of EXTI Line 0 and clears the interrupt pending bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0) != RESET) <span class="comment">// 判断中断位</span></span><br><span class="line">  &#123;</span><br><span class="line">    LED_B_TOGGLE;</span><br><span class="line">  &#125;</span><br><span class="line">  EXTI_ClearITPendingBit(EXTI_Line0); <span class="comment">// 清除中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_ledh中编写电平反转函数">在bsp_led.h中编写电平反转函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_TOGGLE &#123;LED_B_GPIO_PORT-&gt;ODR ^= LED_B_GPIO_PIN;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="补充:-使能afio时钟">补充: 使能AFIO时钟</h3>
<p>在STM32微控制器系列中，使用外部中断（EXTI）时需要开启AFIO（Alternate Function IO）时钟的原因与STM32的硬件设计和引脚复用功能有关。</p>
<h4 id="afio的作用">AFIO的作用</h4>
<ol>
<li><strong>引脚复用</strong>：STM32的GPIO（通用输入输出）引脚具有多功能性。一个物理引脚可以用作普通的I/O，也可以被配置为特殊功能，如USART、SPI、I2C通信或外部中断（EXTI）等。AFIO（Alternate Function IO）模块负责管理这些引脚的复用功能。</li>
<li><strong>EXTI配置</strong>：在STM32中，外部中断线（EXTI）可以映射到不同的GPIO引脚上。AFIO模块提供了这种映射功能。例如，如果你想将EXTI0配置为由PA0、PB0、PC0等其中一个引脚触发，就需要通过AFIO模块来设置这种映射。</li>
</ol>
<h4 id="开启afio时钟的原因">开启AFIO时钟的原因</h4>
<p><strong>由于AFIO模块负责处理引脚的复用功能，包括EXTI的引脚映射，因此在使用EXTI功能之前，必须确保AFIO模块的时钟是使能的</strong>如果没有使能AFIO时钟，对AFIO寄存器的任何配置操作都不会生效，这意味着EXTI线路无法正确地映射到相应的GPIO引脚上，从而导致外部中断功能无法正常工作。</p>
<h4 id="afio的实际操作">AFIO的实际操作</h4>
<p>在STM32的标准固件库或HAL（硬件抽象层）库中，通常会看到类似以下的代码片段，用于使能AFIO时钟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br></pre></td></tr></table></figure>
<p>或在使用HAL库时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_RCC_AFIO_CLK_ENABLE();</span><br></pre></td></tr></table></figure>
<p>这些函数调用确保了AFIO模块的时钟被使能，从而使得外部中断的相关配置（如引脚映射）能够正确执行。</p>
<h4 id="afio的总结">AFIO的总结</h4>
<p>开启AFIO时钟是使用STM32的EXTI功能的必要步骤，因为AFIO模块控制着GPIO引脚的复用功能，包括将外部中断线路映射到特定的GPIO引脚。未使能AFIO时钟可能导致外部中断配置无效，进而影响整个中断处理机制的正常工作。</p>
<h2 id="systick">SysTick</h2>
<h3 id="systick简介">SysTick简介</h3>
<p>SysTick: 系统定时器, <strong>24位, 只能递减, 存在于内核中</strong>, 嵌套在NVIC中, 所有的Cotex-M内核的单片机都具有这个定时器.</p>
<h3 id="systick-功能框图">SysTick 功能框图</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170017620.png" alt="框图"></p>
<p>重装载寄存器把值写入递减计数器, 可通过STK_VAL实时查询其中的值, 递减计数器从reload值开始递减, 减为0后可产生中断并且置位COUNTFLAG标志位, 置位后从reload获取值重复以上操作</p>
<h3 id="systick-寄存器描述">SysTick 寄存器描述</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170023320.png" alt="SysTick 寄存器描述"></p>
<h3 id="systick-定时时间计算">SysTick 定时时间计算</h3>
<p>需要计算的参数</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025237.png" alt="计算参数"></p>
<p>计算过程</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401170025314.png" alt="计算过程"></p>
<ul>
<li>Clk = 72M时</li>
<li>reload = 72, t = 1us</li>
<li>reload = 72000, t = 1ms</li>
</ul>
<h3 id="补充:-systick 介绍">补充: SysTick 介绍</h3>
<p>SysTick（System Tick Timer）是ARM Cortex-M微控制器内核的一个内置组件，用于提供一个简单但高效的系统定时器。这个定时器通常用于实现操作系统的节拍（tick），也可以用于简单的延时功能。</p>
<h4 id="systick的主要特点">SysTick的主要特点</h4>
<ol>
<li>24位递减计数器：SysTick包含一个24位的递减计数器，当计数器值递减到零时，定时器溢出并触发一个中断。</li>
<li>可编程重载值：可以设置计数器的重载值，这决定了定时器的溢出时间间隔。</li>
<li>可配置的时钟源：SysTick定时器可以配置为使用内核时钟或外部时钟（通常是内核时钟的一半）。</li>
<li>自动重载：在计数到零时，计数器会自动重新加载预设的重载值，从而实现周期性定时。</li>
<li>中断功能：当计数器达到零时，SysTick定时器可以产生一个中断。这个中断可以用于各种定时任务，如操作系统的任务调度。</li>
</ol>
<h4 id="systick的应用场景">SysTick的应用场景</h4>
<ol>
<li>操作系统节拍：在实时操作系统（RTOS）中，SysTick常用于生成操作系统的节拍，这对于任务调度和时间管理非常重要。</li>
<li>延时功能：在不需要RTOS的简单应用中，SysTick可用于生成精确的延时，例如在两个事件之间等待固定的时间。</li>
<li>时间基准：SysTick还可以作为程序中的时间基准，用于测量时间间隔或产生定时事件。</li>
</ol>
<h4 id="systick的配置和使用">SysTick的配置和使用</h4>
<p>在使用SysTick时，一般需要进行以下配置：</p>
<ol>
<li>设置重载值：根据所需的定时周期和时钟源频率设置重载值。</li>
<li>选择时钟源：选择使用内核时钟还是外部时钟作为SysTick的时钟源。</li>
<li>启用中断（可选）：如果需要在定时器溢出时执行特定操作，可以启<br>
用SysTick中断。</li>
<li>启动定时器：启用SysTick定时器开始计数</li>
</ol>
<h4 id="systick的编程示例">SysTick的编程示例</h4>
<p>在STM32等ARM Cortex-M微控制器上，SysTick的配置和使用通常涉及直接操作其控制和状态寄存器。以下是一个简单的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SysTick_Config(SystemCoreClock / <span class="number">1000</span>);  <span class="comment">// 配置SysTick产生</span></span><br></pre></td></tr></table></figure>
<h3 id="systick-源码分析">SysTick 源码分析</h3>
<p>SysTick_Type定义在core_cm3.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick</span></span><br><span class="line"><span class="comment">  memory mapped structure for SysTick</span></span><br><span class="line"><span class="comment">  @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CTRL;                         <span class="comment">/*!&lt; Offset: 0x00  SysTick Control and Status Register */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LOAD;                         <span class="comment">/*!&lt; Offset: 0x04  SysTick Reload Value Register       */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> VAL;                          <span class="comment">/*!&lt; Offset: 0x08  SysTick Current Value Register      */</span></span><br><span class="line">  __I  <span class="type">uint32_t</span> CALIB;                        <span class="comment">/*!&lt; Offset: 0x0C  SysTick Calibration Register        */</span></span><br><span class="line">&#125; SysTick_Type;</span><br></pre></td></tr></table></figure>
<p>SysTick_Config函数在core_cm3.h中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Initialize and start the SysTick counter and its interrupt.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   ticks   number of ticks between two interrupts</span></span><br><span class="line"><span class="comment"> * @return  1 = failed, 0 = successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialise the system tick timer and its interrupt and start the</span></span><br><span class="line"><span class="comment"> * system tick timer / counter in free running mode to generate </span></span><br><span class="line"><span class="comment"> * periodical interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __INLINE <span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">// 判断ticks的值是否大于2^24, 若大于则违法</span></span><br><span class="line">  <span class="keyword">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class="keyword">return</span> (<span class="number">1</span>);            <span class="comment">/* Reload value impossible */</span></span><br><span class="line">                                                               </span><br><span class="line">  <span class="comment">// 初始化reaload寄存器的值</span></span><br><span class="line">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class="number">1</span>;      <span class="comment">/* set reload register */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置中断优先级, 配置为15, 默认为最低的优先级</span></span><br><span class="line">  <span class="comment">/*-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 注: </span></span><br><span class="line"><span class="comment">   * 内核优先级的判断方式:</span></span><br><span class="line"><span class="comment">   * 将内核外设的中断优先级的四个位按照外设的中断优先级进行分组</span></span><br><span class="line"><span class="comment">   * 分组后可判断内核的抢占优先级和响应优先级</span></span><br><span class="line"><span class="comment">   * 即人为分出抢占和响应优先级</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 例:</span></span><br><span class="line"><span class="comment">   * 这里SysTick的中断优先级为15, 二进制为1111</span></span><br><span class="line"><span class="comment">   * 若分组为2位抢占, 2位响应</span></span><br><span class="line"><span class="comment">   * 则SysTick的抢占优先级为11即3, 响应优先级为11即3</span></span><br><span class="line"><span class="comment">   * 若分组为1位抢占, 3位响应</span></span><br><span class="line"><span class="comment">   * 则SysTick的抢占优先级为1即1, 响应优先级为111即7</span></span><br><span class="line"><span class="comment">   * 通过该方法可以比较内核优先级与外设的优先级谁更高</span></span><br><span class="line"><span class="comment">   * ----------------------------------------------------------*/</span></span><br><span class="line">  NVIC_SetPriority (SysTick_IRQn, (<span class="number">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class="number">1</span>);  <span class="comment">/* set Priority for Cortex-M0 System Interrupts */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化counter的值为0</span></span><br><span class="line">  SysTick-&gt;VAL   = <span class="number">0</span>;                                          <span class="comment">/* Load the SysTick Counter Value */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置 SysTick的时钟为 72M</span></span><br><span class="line">  <span class="comment">// 使能中断</span></span><br><span class="line">  <span class="comment">// 使能 SysTick </span></span><br><span class="line">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class="line">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class="line">                   SysTick_CTRL_ENABLE_Msk;                    <span class="comment">/* Enable SysTick IRQ and SysTick Timer */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="systick-实验">SysTick 实验</h3>
<p>项目地址: <strong>19-SysTick</strong></p>
<p>实验要求:</p>
<ol>
<li>编写一个微妙延时函数</li>
<li>编写一个毫秒延时函数</li>
</ol>
<h4 id="在bsp_systickc中编写微妙延时函数">在bsp_systick.c中编写微妙延时函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延时指定的微秒数</span></span><br><span class="line"><span class="comment"> * @param us 延时的微秒数</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">    SysTick_Config(SystemCoreClock / <span class="number">1000000</span>); <span class="comment">// reload 设置为 72, t = 1us</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; us; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            ; <span class="comment">// 等待CTRL的Bit16置1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; <span class="comment">// 状态位清除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_systickc中编写毫秒延时函数">在bsp_systick.c中编写毫秒延时函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延时指定的毫秒数</span></span><br><span class="line"><span class="comment"> * @param ms 延时的毫秒数</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    SysTick_Config(SystemCoreClock / <span class="number">1000</span>); <span class="comment">// reload 设置为 72000, t = 1ms</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ms; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            ; <span class="comment">// 等待CTRL的Bit16置1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; <span class="comment">// 状态位清除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_systickh中引用库文件和进行函数声明">在bsp_systick.h中引用库文件和进行函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_SYSTICK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_SYSTICK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core_cm3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__BSP_SYSTICK_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在mainc中调用延时函数,实现led闪烁">在main.c中调用延时函数,实现LED闪烁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Main function of the program.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function initializes the LED GPIO and enters an infinite loop. </span></span><br><span class="line"><span class="comment"> * In each iteration of the loop, it turns off the blue LED, delays for 0.5 seconds,</span></span><br><span class="line"><span class="comment"> * turns on the blue LED, and delays for 0.5 seconds again.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return int The exit status of the program.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LED_GPIO_Config(); <span class="comment">// Initialize the LED GPIO</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED_B(OFF); <span class="comment">// Turn off the blue LED</span></span><br><span class="line">        SysTick_Delay_ms(<span class="number">500</span>); <span class="comment">// Delay for 0.5 seconds</span></span><br><span class="line">        LED_B(ON); <span class="comment">// Turn on the blue LED</span></span><br><span class="line">        SysTick_Delay_us(<span class="number">500000</span>); <span class="comment">// Delay for 0.5 seconds</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通信的基本概念">通信的基本概念</h2>
<h3 id="串行和并行通信">串行和并行通信</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171542012.png" alt="串行和并行通信"></p>
<ul>
<li>串行协议: USART, I2C, SPI, W500, CAN, LIN</li>
<li>并行协议: FSMC, SDIO</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171546066.png" alt="对比"></p>
<h3 id="全双工,-半双工和单工">全双工, 半双工和单工</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171548657.png" alt="全双工,半双工和单工"></p>
<h3 id="同步与异步">同步与异步</h3>
<p>同步传输通过时钟信号进行同步, 保证数据传输的准确性</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171550768.png" alt="同步"></p>
<p>异步传输通过加入辅助的标识符, 保证数据传输的准确性</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171552733.png" alt="异步"></p>
<h4 id="同步与异步的区别">同步与异步的区别</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171554763.png" alt="区别"></p>
<h3 id="通信的速率">通信的速率</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171555519.png" alt="通信的速率"></p>
<p>当用一个二进制位表示一个码元时, 比特率和波特率相等</p>
<h2 id="usart-串口通信">USART-串口通信</h2>
<h3 id="串口通信协议简介">串口通信协议简介</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610065.png" alt="USART"></p>
<h4 id="物理层的常用标准">物理层的常用标准</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171610887.png" alt="USART"></p>
<h5 id="232和ttl电平区别">232和TTL电平区别</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171611637.png" alt="USART"></p>
<ul>
<li>TTL: 从芯片出来的基本是TTL电平</li>
<li>232: 负逻辑, 压差大</li>
</ul>
<h6 id="232通信通讯结构图">232通信通讯结构图</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171631235.png" alt="232"></p>
<p>DB9接口图</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171634288.png" alt="DB9接口"></p>
<h6 id="usb转串口通讯结构图">USB转串口通讯结构图</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171644660.png" alt="USB转串口"></p>
<h5 id="串口到串口通讯结构图">串口到串口通讯结构图</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171655718.png" alt="串口到串口"></p>
<h4 id="串口数据包的组成">串口数据包的组成</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171658813.png" alt="串口数据包"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171659831.png" alt="串口数据包"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171702232.png" alt="串口数据包"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703446.png" alt="串口数据包"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171703050.png" alt="串口数据包"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171704956.png" alt="串口数据包"></p>
<h3 id="stm32串口功能框图讲解">STM32串口功能框图讲解</h3>
<h4 id="引脚部分讲解">引脚部分讲解</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708669.png" alt="STM32串口功能框图"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171708578.png" alt="STM32串口功能框图"></p>
<h5 id="引脚对应">引脚对应</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171710068.png" alt="引脚对应"></p>
<h4 id="数据寄存器部分">数据寄存器部分</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171723621.png" alt="数据寄存器部分"></p>
<h5 id="数据格式">数据格式</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171725627.png" alt="数据格式"></p>
<h6 id="usart_cr1的bit12-m控制字长">USART_CR1的bit12 M控制字长</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727509.png" alt="寄存器"></p>
<h6 id="usart_cr2的bit[13:12]-stop控制停止位的位数">USART_CR2的bit[13:12] STOP控制停止位的位数</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171727238.png" alt="寄存器"></p>
<h6 id="usart_cr1的bit10(pse),-bit9(ps)来使能校验和选择校验模式">USART_CR1的bit10(PSE), bit9(PS)来使能校验和选择校验模式</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171730822.png" alt="寄存器"></p>
<h6 id="usart_cr1的bit8(peie)来使能中断">USART_CR1的bit8(PEIE)来使能中断</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171731175.png" alt="寄存器"></p>
<h6 id="usart_sr的bit0(pe)来检测校验错误">USART_SR的bit0(PE)来检测校验错误</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171732400.png" alt="寄存器"></p>
<h4 id="发送数据部分">发送数据部分</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171739676.png" alt="发送数据"></p>
<ol>
<li>先将USART_CR1的UE位置1(<em>使能USART模块</em>), 再将USART_CR1的TE位置1(<em>使能发送</em>)</li>
<li>数据从CPU或DMA中写入发送数据寄存器(TDR), TDR发送完毕后, USART_SR的TXE位置1(<em>数据已经被转移到移位寄存器中</em>)</li>
<li>发送移位寄存器发送完毕后, USART_SR的TC位置1(<em>表示发送完成</em>)</li>
</ol>
<h4 id="接收数据部分">接收数据部分</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171900970.png" alt="接收数据部分"></p>
<ol>
<li>先将USART_CR1的UE位置1(<em>使能USART模块</em>), 再将USART_CR1的RE位置1(<em>使能接收</em>)</li>
<li>数据从RX到接收移位寄存器到接收数据寄存器(RDR), 接收完毕后, USART_SR的RXNE位置1(<em>收到数据, 可以读出</em>)</li>
</ol>
<h4 id="波特率设置">波特率设置</h4>
<h5 id="使用usart_brr进行配置">使用USART_BRR进行配置</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171906798.png" alt="USART_BRR"></p>
<h5 id="波特率的计算公式">波特率的计算公式</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171909589.png" alt="波特率的计算公式"></p>
<ul>
<li>APB2时钟: 72MHz, 挂载USART1</li>
<li>APB1时钟: 36MHz, 挂载USART2, 3, 4, 5</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401171910703.png" alt="波特率"></p>
<h3 id="串口初始化结构体和固件库讲解">串口初始化结构体和固件库讲解</h3>
<h4 id="串口初始化结构体">串口初始化结构体</h4>
<p>在stm32f10x_usart.h中定义串口初始化结构体(异步)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  USART Init Structure definition  </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 设置波特率</span></span><br><span class="line">  <span class="type">uint32_t</span> USART_BaudRate;            <span class="comment">/*!&lt; This member configures the USART communication baud rate.</span></span><br><span class="line"><span class="comment">                                           The baud rate is computed using the following formula:</span></span><br><span class="line"><span class="comment">                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))</span></span><br><span class="line"><span class="comment">                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置字长</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_WordLength_8b                  ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_WordLength_9b                  ((uint16_t)0x1000)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_WordLength;          <span class="comment">/*!&lt; Specifies the number of data bits transmitted or received in a frame.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Word_Length */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置停止位</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_StopBits_1                     ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_StopBits_0_5                   ((uint16_t)0x1000)</span></span><br><span class="line"><span class="comment">   * #define USART_StopBits_2                     ((uint16_t)0x2000)</span></span><br><span class="line"><span class="comment">   * #define USART_StopBits_1_5                   ((uint16_t)0x3000)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_StopBits;            <span class="comment">/*!&lt; Specifies the number of stop bits transmitted.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Stop_Bits */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置校验</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_Parity_No                      ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_Parity_Even                    ((uint16_t)0x0400)</span></span><br><span class="line"><span class="comment">   * #define USART_Parity_Odd                     ((uint16_t)0x0600)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_Parity;              <span class="comment">/*!&lt; Specifies the parity mode.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Parity</span></span><br><span class="line"><span class="comment">                                           @note When parity is enabled, the computed parity is inserted</span></span><br><span class="line"><span class="comment">                                                 at the MSB position of the transmitted data (9th bit when</span></span><br><span class="line"><span class="comment">                                                 the word length is set to 9 data bits; 8th bit when the</span></span><br><span class="line"><span class="comment">                                                 word length is set to 8 data bits). */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 设置模式</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_Mode_Rx                        ((uint16_t)0x0004)</span></span><br><span class="line"><span class="comment">   * #define USART_Mode_Tx                        ((uint16_t)0x0008)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_Mode;                <span class="comment">/*!&lt; Specifies wether the Receive or Transmit mode is enabled or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置硬件控制流</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)</span></span><br><span class="line"><span class="comment">   * #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)</span></span><br><span class="line"><span class="comment">   * #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_HardwareFlowControl; <span class="comment">/*!&lt; Specifies wether the hardware flow control mode is enabled</span></span><br><span class="line"><span class="comment">                                           or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */</span></span><br><span class="line">&#125; USART_InitTypeDef;</span><br></pre></td></tr></table></figure>
<p>在stm32f10x_usart.h中定义串口初始化结构体(同步)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  USART Clock Init Structure definition  </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置使能时钟</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_Clock_Disable                  ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_Clock_Enable                   ((uint16_t)0x0800)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_Clock;   <span class="comment">/*!&lt; Specifies whether the USART clock is enabled or disabled.</span></span><br><span class="line"><span class="comment">                               This parameter can be a value of @ref USART_Clock */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置时钟的极性, 即总线空闲时CK引脚保持低电平还是高电平</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_CPOL_Low                       ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_CPOL_High                      ((uint16_t)0x0400)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_CPOL;    <span class="comment">/*!&lt; Specifies the steady state value of the serial clock.</span></span><br><span class="line"><span class="comment">                               This parameter can be a value of @ref USART_Clock_Polarity */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置时钟的相位, 即数据采样的时机为第一个边沿还是第二个边沿</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_CPHA_1Edge                     ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_CPHA_2Edge                     ((uint16_t)0x0200)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_CPHA;    <span class="comment">/*!&lt; Specifies the clock transition on which the bit capture is made.</span></span><br><span class="line"><span class="comment">                               This parameter can be a value of @ref USART_Clock_Phase */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置时钟的最后一个数据位的时钟脉冲是否输出到SCLK引脚</span></span><br><span class="line">  <span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 参数如下:</span></span><br><span class="line"><span class="comment">   * #define USART_LastBit_Disable                ((uint16_t)0x0000)</span></span><br><span class="line"><span class="comment">   * #define USART_LastBit_Enable                 ((uint16_t)0x0100)</span></span><br><span class="line"><span class="comment">   * ---------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> USART_LastBit; <span class="comment">/*!&lt; Specifies whether the clock pulse corresponding to the last transmitted</span></span><br><span class="line"><span class="comment">                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.</span></span><br><span class="line"><span class="comment">                               This parameter can be a value of @ref USART_Last_Bit */</span></span><br><span class="line">&#125; USART_ClockInitTypeDef;</span><br></pre></td></tr></table></figure>
<h4 id="串口库函数">串口库函数</h4>
<ul>
<li><strong>串口初始化函数</strong>: void USART_Init(USART_TypeDef<em>USARTx, USART_InitTypeDef</em> USART_InitStruct);</li>
<li><strong>中断配置函数</strong>: void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);</li>
<li><strong>串口使能函数</strong>: void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);</li>
<li><strong>数据发送函数</strong>: void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);</li>
<li><strong>数据接收函数</strong>: void USART_ReceiveData(USART_TypeDef* USARTx);</li>
<li><strong>中断状态位获取函数</strong>: ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);</li>
</ul>
<h3 id="usb转串口的硬件原理图">USB转串口的硬件原理图</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401172002602.png" alt="硬件原理图"></p>
<h3 id="串口gpio汇总">串口GPIO汇总</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220859886.png" alt="串口GPIO"></p>
<h3 id="补充:-外设的gpio配置">补充: 外设的GPIO配置</h3>
<p>在STM32F10x参考手册中的8.1.11节可找到外设的GPIO配置, 其中关于USART部分的GPIO配置如下图</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401220904826.png" alt="USART的GPIO配置"></p>
<h3 id="配置串口助手">配置串口助手</h3>
<p>本项目使用的串口助手: 野火多功能调试助手V1.0.2.9</p>
<p>串口配置如下图(<em>串口配置参数与串口的初始化配置有关, 该配置符合下文代码的初始化</em>)</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401250242370.png" alt="串口助手配置"></p>
<h3 id="usart接收和发送实验">USART接收和发送实验</h3>
<p>项目地址: <strong>21-USART-接收和发送</strong></p>
<p><strong>实验需求</strong>: 单片机给电脑发送数据, 电脑上位机把数据打印出来; 电脑上位机给单片机发数据, 单片机接收到数据之后立马发回给电脑, 并打印出来.</p>
<h4 id="在bsp_usarth中进行串口的宏定义,-并使用条件编译来选择串口">在bsp_usart.h中进行串口的宏定义, 并使用条件编译来选择串口</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏</span></span><br><span class="line"><span class="comment">  * 1-修改总线时钟的宏，uart1挂载到apb2总线，其他uart挂载到apb1总线</span></span><br><span class="line"><span class="comment">  * 2-修改GPIO的宏</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过条件编译选择串口, 使用的串口置1，其余置0</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> DEBUG_USART1 1</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> DEBUG_USART2 0</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> DEBUG_USART3 0</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> DEBUG_USART4 0</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> DEBUG_USART5 0</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_USART1</span></span><br><span class="line"><span class="comment">// 串口1-USART1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USARTx                   USART1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_CLK                RCC_APB2Periph_USART1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART GPIO 引脚宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQ                USART1_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQHandler         USART1_IRQHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEBUG_USART2</span></span><br><span class="line"><span class="comment">// 串口2-USART2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USARTx                   USART2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_USART2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART GPIO 引脚宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQ                USART2_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQHandler         USART2_IRQHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEBUG_USART3</span></span><br><span class="line"><span class="comment">// 串口3-USART3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USARTx                   USART3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_USART3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART GPIO 引脚宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOB)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOB   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQ                USART3_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQHandler         USART3_IRQHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEBUG_USART4</span></span><br><span class="line"><span class="comment">//串口4-UART4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USARTx                   UART4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_UART4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART GPIO 引脚宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOC   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_11</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQ                UART4_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQHandler         UART4_IRQHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DEBUG_UART5</span></span><br><span class="line"><span class="comment">// 串口5-UART5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USARTx                   UART5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_CLK                RCC_APB1Periph_UART5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB1PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART GPIO 引脚宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOC   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQ                UART5_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_IRQHandler         UART5_IRQHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写usart的初始化函数">在bsp_usart.c中编写usart的初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    USART_InitTypeDef USART_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口GPIO的时钟</span></span><br><span class="line">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开串口外设的时钟</span></span><br><span class="line">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置串口的工作参数</span></span><br><span class="line">    <span class="comment">// 配置波特率</span></span><br><span class="line">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class="line">    <span class="comment">// 配置 针数据字长</span></span><br><span class="line">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    <span class="comment">// 配置停止位</span></span><br><span class="line">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    <span class="comment">// 配置校验位</span></span><br><span class="line">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class="line">    <span class="comment">// 配置硬件流控制</span></span><br><span class="line">    USART_InitStructure.USART_HardwareFlowControl = </span><br><span class="line">    USART_HardwareFlowControl_None;</span><br><span class="line">    <span class="comment">// 配置工作模式，收发一起</span></span><br><span class="line">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">    <span class="comment">// 完成串口的初始化配置</span></span><br><span class="line">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 串口中断优先级配置</span></span><br><span class="line">    NVIC_Configuration();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使能串口接收中断</span></span><br><span class="line">    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使能串口</span></span><br><span class="line">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写串口中断优先级配置函数">在bsp_usart.c中编写串口中断优先级配置函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  配置嵌套向量中断控制器NVIC</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Configuration</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 嵌套向量中断控制器组选择 */</span></span><br><span class="line">  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 配置USART为中断源 */</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;</span><br><span class="line">  <span class="comment">/* 抢断优先级*/</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* 子优先级 */</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* 使能中断 */</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">  <span class="comment">/* 初始化配置NVIC */</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写发送一个字节到串口的函数">在bsp_usart.c中编写发送一个字节到串口的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送一个字节到指定的USART外设</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param pUSARTx USART外设指针</span></span><br><span class="line"><span class="comment"> * @param ch 要发送的字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_SendByte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 发送一个字节</span></span><br><span class="line">    USART_SendData(pUSARTx, ch);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待发送数据寄存器为空</span></span><br><span class="line">    <span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">     ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写发送两个字节到串口的函数">在bsp_usart.c中编写发送两个字节到串口的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送两个字节的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param pUSARTx USART外设指针</span></span><br><span class="line"><span class="comment"> * @param ch 要发送的16位数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_SendHalfWord</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint16_t</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> tmp_h, tmp_l;</span><br><span class="line"></span><br><span class="line">    tmp_h = (ch &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>; <span class="comment">// 取出高八位</span></span><br><span class="line">    tmp_l = (ch &amp; <span class="number">0xFF</span>) &gt;&gt; <span class="number">0</span>; <span class="comment">// 取出低八位</span></span><br><span class="line"></span><br><span class="line">    USART_SendData(pUSARTx, tmp_h); <span class="comment">// 发送高八位</span></span><br><span class="line">    <span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    USART_SendData(pUSARTx, tmp_l); <span class="comment">// 发送低八位</span></span><br><span class="line">    <span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写发送数组的函数">在bsp_usart.c中编写发送数组的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Sends an array of bytes over USART.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function sends an array of bytes over the specified USART peripheral.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param pUSARTx The USART peripheral to use.</span></span><br><span class="line"><span class="comment"> * @param array Pointer to the array of bytes to send.</span></span><br><span class="line"><span class="comment"> * @param num The number of bytes to send.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_SendArray</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span>* <span class="built_in">array</span>, <span class="type">uint16_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">     Usart_SendByte(pUSARTx, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">     ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写发送字符串的函数">在bsp_usart.c中编写发送字符串的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送字符串到USART外设</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param pUSARTx USART外设指针</span></span><br><span class="line"><span class="comment"> * @param str 要发送的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_SendString</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">     Usart_SendByte(pUSARTx, *(str + i));</span><br><span class="line">     i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (*(str + i) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发送完成</span></span><br><span class="line">    <span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">     ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中编写重定向标准输出输入函数,-使得串口可使用scanf printf等函数">在bsp_usart.c中编写重定向标准输出输入函数, 使得串口可使用scanf printf等函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向c库函数printf, putchar到串口，重定向后可使用printf, putchar函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重定向标准输出函数</span></span><br><span class="line"><span class="comment"> * @param ch 要发送的字符</span></span><br><span class="line"><span class="comment"> * @param f 文件指针</span></span><br><span class="line"><span class="comment"> * @retval 发送的字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    USART_SendData(DEBUG_USARTx, (<span class="type">uint8_t</span>)ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">     ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param f 文件指针</span></span><br><span class="line"><span class="comment"> * @return int 从串口接收到的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 等待串口输入数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)USART_ReceiveData(DEBUG_USARTx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在mainc函数中进行测试">在main.c函数中进行测试</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    USART_Config(); <span class="comment">// 初始化USART</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送1字节数据</span></span><br><span class="line">    Usart_SendByte(DEBUG_USARTx, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    Usart_SendByte(DEBUG_USARTx, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送2字节数据</span></span><br><span class="line">    Usart_SendHalfWord(DEBUG_USARTx, <span class="number">0xFF56</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数组</span></span><br><span class="line">    Usart_SendArray(DEBUG_USARTx, (<span class="type">uint8_t</span>*)<span class="string">&quot;Hello World!&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">11</span>] = &#123;<span class="string">&quot;Hello World!&quot;</span>&#125;;</span><br><span class="line">    Usart_SendArray(DEBUG_USARTx, <span class="built_in">array</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送字符串</span></span><br><span class="line">    Usart_SendString(DEBUG_USARTx, <span class="string">&quot;\nString: Hello World\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向printf函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf: Hello World\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向putchar函数</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在stm32f10x_itc中编写中断服务函数实现串口数据的接收并发送">在stm32f10x_it.c中编写中断服务函数实现串口数据的接收并发送</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Interrupt handler for the DEBUG_USART.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called when there is a receive interrupt from the DEBUG_USART.</span></span><br><span class="line"><span class="comment"> * It receives data from the DEBUG_USART and sends it back.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DEBUG_USART_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> ucTemp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(USART_GetITStatus(DEBUG_USARTx, USART_IT_RXNE) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    ucTemp = USART_ReceiveData(DEBUG_USARTx); <span class="comment">// Receive data into ucTemp</span></span><br><span class="line">    USART_SendData(DEBUG_USARTx, ucTemp); <span class="comment">// Send data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充:-通过重写fputc函数重定向c库函数printf到串口">补充: 通过重写fputc函数重定向C库函数printf到串口</h3>
<p>通过重写 fputc 函数可以实现重定向 printf 到串口的效果。这是因为 printf 函数实际上是通过 C 标准库中的输出函数 fputc 来将字符一个个地发送到输出设备的。当你重写了 fputc 函数，实际上就改变了字符的输出方式，使得字符被发送到你所定义的输出设备，比如串口。</p>
<p>下面是一个简单的示例，演示了如何通过重写 fputc 函数来重定向 printf 到串口。这里假设你已经在系统中初始化了串口的硬件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 串口初始化函数，假设已经在系统中实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initSerialPort</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 串口初始化的相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向标准输出函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span> &#123;</span><br><span class="line">    <span class="comment">// 将字符发送到串口</span></span><br><span class="line">    <span class="comment">// 你需要在这里添加实际的串口发送代码</span></span><br><span class="line">    <span class="comment">// 例如：sendCharacterToSerialPort(ch);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化串口</span></span><br><span class="line">    initSerialPort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这之后，调用printf将输出信息发送到串口</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, Serial Port!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们重写了 fputc 函数，使其将字符发送到串口。当 printf 调用 fputc 函数时，字符就会被发送到串口。这样就实现了将 printf 输出重定向到串口的效果。</p>
<p>需要注意的是，具体的串口发送函数实现（比如 sendCharacterToSerialPort）需要根据你的具体硬件和系统来编写。这个示例只是演示了重定向的基本原理。</p>
<h3 id="usart控制rgb灯实验">USART控制RGB灯实验</h3>
<p>项目地址: <strong>21-USART-控制RGB灯</strong></p>
<p><strong>实验需求</strong>: 电脑给单片机发命令, 用于控制开发板上的RGB灯.</p>
<h4 id="在bsp_ledh中定义rgb灯的宏">在bsp_led.h中定义RGB灯的宏</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */</span></span><br><span class="line"><span class="comment">// R-红色</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT     GPIOB                 <span class="comment">/* GPIO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class="comment">/* GPIO端口时钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PIN  GPIO_Pin_5           <span class="comment">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// G-绿色</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT     GPIOB                 <span class="comment">/* GPIO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class="comment">/* GPIO端口时钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PIN  GPIO_Pin_0           <span class="comment">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// B-蓝色</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_GPIO_PORT     GPIOB                 <span class="comment">/* GPIO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_GPIO_CLK      RCC_APB2Periph_GPIOB  <span class="comment">/* GPIO端口时钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_GPIO_PIN  GPIO_Pin_1           <span class="comment">/* 连接到SCL时钟线的GPIO */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** the macro definition to trigger the led on or off </span></span><br><span class="line"><span class="comment">  * 1 - off</span></span><br><span class="line"><span class="comment">  *0 - on</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用标准的固件库控制IO*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1(a) <span class="keyword">if</span> (a) \</span></span><br><span class="line"><span class="meta">     GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>  \</span></span><br><span class="line"><span class="meta">     GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2(a) <span class="keyword">if</span> (a) \</span></span><br><span class="line"><span class="meta">     GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>  \</span></span><br><span class="line"><span class="meta">     GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3(a) <span class="keyword">if</span> (a) \</span></span><br><span class="line"><span class="meta">     GPIO_SetBits(LED3_GPIO_PORT,LED3_GPIO_PIN);\</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>  \</span></span><br><span class="line"><span class="meta">     GPIO_ResetBits(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接操作寄存器的方法控制IO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> digitalHi(p,i)   &#123;p-&gt;BSRR=i;&#125;  <span class="comment">//输出为高电平  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> digitalLo(p,i)   &#123;p-&gt;BRR=i;&#125;  <span class="comment">//输出低电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> digitalToggle(p,i) &#123;p-&gt;ODR ^=i;&#125; <span class="comment">//输出反转状态</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义控制IO的宏 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_TOGGLE   digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF     digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON      digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_TOGGLE   digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_OFF     digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_ON      digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_TOGGLE   digitalToggle(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_OFF     digitalHi(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED3_ON      digitalLo(LED3_GPIO_PORT,LED3_GPIO_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//红</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RED  \</span></span><br><span class="line"><span class="meta">     LED1_ON;\</span></span><br><span class="line"><span class="meta">     LED2_OFF\</span></span><br><span class="line"><span class="meta">     LED3_OFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_GREEN  \</span></span><br><span class="line"><span class="meta">     LED1_OFF;\</span></span><br><span class="line"><span class="meta">     LED2_ON\</span></span><br><span class="line"><span class="meta">     LED3_OFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_BLUE \</span></span><br><span class="line"><span class="meta">     LED1_OFF;\</span></span><br><span class="line"><span class="meta">     LED2_OFF\</span></span><br><span class="line"><span class="meta">     LED3_ON</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"><span class="comment">//黄(红+绿)     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_YELLOW \</span></span><br><span class="line"><span class="meta">     LED1_ON;\</span></span><br><span class="line"><span class="meta">     LED2_ON\</span></span><br><span class="line"><span class="meta">     LED3_OFF</span></span><br><span class="line"><span class="comment">//紫(红+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PURPLE \</span></span><br><span class="line"><span class="meta">     LED1_ON;\</span></span><br><span class="line"><span class="meta">     LED2_OFF\</span></span><br><span class="line"><span class="meta">     LED3_ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//青(绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CYAN \</span></span><br><span class="line"><span class="meta">     LED1_OFF;\</span></span><br><span class="line"><span class="meta">     LED2_ON\</span></span><br><span class="line"><span class="meta">     LED3_ON</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">//白(红+绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WHITE \</span></span><br><span class="line"><span class="meta">     LED1_ON;\</span></span><br><span class="line"><span class="meta">     LED2_ON\</span></span><br><span class="line"><span class="meta">     LED3_ON</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">//黑(全部关闭)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RGBOFF \</span></span><br><span class="line"><span class="meta">     LED1_OFF;\</span></span><br><span class="line"><span class="meta">     LED2_OFF\</span></span><br><span class="line"><span class="meta">     LED3_OFF</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LED_H */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_ledc中编写led初始化函数">在bsp_led.c中编写led初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    bsp_led.c</span></span><br><span class="line"><span class="comment">  * @author  fire</span></span><br><span class="line"><span class="comment">  * @version V1.0</span></span><br><span class="line"><span class="comment">  * @date    2013-xx-xx</span></span><br><span class="line"><span class="comment">  * @brief   led应用函数接口</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 实验平台:野火 F103-霸道 STM32 开发板 </span></span><br><span class="line"><span class="comment">  * 论坛    :http://www.firebbs.cn</span></span><br><span class="line"><span class="comment">  * 淘宝    :https://fire-stm32.taobao.com</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./led/bsp_led.h&quot;</span>   </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  初始化控制LED的IO</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">/*定义一个GPIO_InitTypeDef类型的结构体*/</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*开启LED相关的GPIO外设时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK | LED3_GPIO_CLK, ENABLE);</span><br><span class="line">    <span class="comment">/*选择要控制的GPIO引脚*/</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置引脚模式为通用推挽输出*/</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置引脚速率为50MHz */</span>   </span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*调用库函数，初始化GPIO*/</span></span><br><span class="line">    GPIO_Init(LED1_GPIO_PORT, &amp;GPIO_InitStructure); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*选择要控制的GPIO引脚*/</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*调用库函数，初始化GPIO*/</span></span><br><span class="line">    GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*选择要控制的GPIO引脚*/</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = LED3_GPIO_PIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*调用库函数，初始化GPIOF*/</span></span><br><span class="line">    GPIO_Init(LED3_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭所有led灯 */</span></span><br><span class="line">    GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭所有led灯 */</span></span><br><span class="line">    GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);  </span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* 关闭所有led灯 */</span></span><br><span class="line">    GPIO_SetBits(LED3_GPIO_PORT, LED3_GPIO_PIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_failed</span><span class="params">(<span class="type">uint8_t</span>* file, <span class="type">uint32_t</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 断言错误时执行的代码</span></span><br><span class="line">    LED1_ON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************END OF FILE**********************/</span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_usartc中关闭串口中断">在bsp_usart.c中关闭串口中断</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    USART_InitTypeDef USART_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口GPIO的时钟</span></span><br><span class="line">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开串口外设的时钟</span></span><br><span class="line">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置串口的工作参数</span></span><br><span class="line">    <span class="comment">// 配置波特率</span></span><br><span class="line">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class="line">    <span class="comment">// 配置 针数据字长</span></span><br><span class="line">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    <span class="comment">// 配置停止位</span></span><br><span class="line">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    <span class="comment">// 配置校验位</span></span><br><span class="line">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class="line">    <span class="comment">// 配置硬件流控制</span></span><br><span class="line">    USART_InitStructure.USART_HardwareFlowControl = </span><br><span class="line">    USART_HardwareFlowControl_None;</span><br><span class="line">    <span class="comment">// 配置工作模式，收发一起</span></span><br><span class="line">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">    <span class="comment">// 完成串口的初始化配置</span></span><br><span class="line">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将中断失能</span></span><br><span class="line">    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, DISABLE); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使能串口</span></span><br><span class="line">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中编写测试程序">在main.c中编写测试程序</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    USART_Config(); <span class="comment">// 初始化USART</span></span><br><span class="line">    LED_GPIO_Config(); <span class="comment">// 初始化LED</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;USART-RGB\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1:RED, 2:GREEN, 3:BLUE, 4:YELLOW, 5:PURPLE, 6:CYAN, 7:WHITE\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Others: BLACK\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: LED_RED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: LED_GREEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: LED_BLUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: LED_YELLOW;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: LED_PURPLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: LED_CYAN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: LED_WHITE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>: LED_RGBOFF;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dma">DMA</h2>
<p>DMA: Direct Memory Access, 直接寄存器访问. 主要功能是可以把数据从一个地方搬到另一个地方, 而且不占用CPU</p>
<ul>
<li>DMA1: 有7个通道, 可实现P-&gt;M, M-&gt;P, M-&gt;M</li>
<li>DMA2: 有5个通道, 可实现P-&gt;M, M-&gt;P, M-&gt;M(<em>只存在于大容量和互联型产品中</em>)</li>
</ul>
<h3 id="补充:-dma介绍">补充: DMA介绍</h3>
<p>DMA（Direct Memory Access，直接内存访问）是计算机系统中的一种技术，<strong>它允许外设或内存模块通过绕过中央处理器（CPU）直接与系统内存进行数据传输</strong>。DMA的目标是提高数据传输效率，减轻CPU的负担，使CPU能够专注于执行其他任务。</p>
<p>以下是关于DMA的一些重要概念和特性：</p>
<h4 id="dma的工作原理">DMA的工作原理</h4>
<p>DMA通过在系统总线上控制数据传输而不涉及CPU来工作。它可以在CPU不介入的情况下，直接将数据从一个位置传输到另一个位置。</p>
<ol>
<li>配置： CPU负责配置DMA，确定源地址、目标地址、传输方向、传输大小等参数。</li>
<li>启动： 一旦DMA被配置，CPU就可以启动DMA控制器，它将负责管理数据传输。</li>
<li>传输： DMA控制器在总线上控制数据传输，无需CPU的干预。数据在源和目标之间直接传输。</li>
<li>中断通知： DMA传输完成后，通常会发出一个中断信号，以通知CPU或其他系统组件。</li>
</ol>
<h4 id="dma的优点">DMA的优点</h4>
<ol>
<li>提高性能： 通过绕过CPU，减轻了CPU的负担，使其能够执行其他任务，提高了整体系统性能。</li>
<li>实时数据传输： 特别适用于实时数据传输，如音频、视频流等。</li>
<li>高效处理大量数据： 对于大量数据的块传输，DMA比CPU执行这样的传输更为高效。</li>
</ol>
<h4 id="dma的应用领域">DMA的应用领域</h4>
<p>DMA在多种应用场景中都得到了广泛应用，包括但不限于：</p>
<ol>
<li>嵌入式系统： 用于处理外设和内存之间的数据传输，例如，处理音频、图像等。</li>
<li>网络通信： 在网络接口控制器和系统内存之间快速传输数据。</li>
<li>存储系统： 用于在磁盘、固态硬盘等存储设备和系统内存之间进行数据传输。</li>
<li>图形处理： 在图形卡和系统内存之间进行大规模图形数据的传输。</li>
</ol>
<h4 id="dma控制器">DMA控制器</h4>
<p>DMA通常由专门的硬件单元，称为DMA控制器，来管理。DMA控制器的设计和功能因芯片架构而异，但通常包括寄存器用于配置、启动和监视传输。</p>
<p>总的来说，DMA是一项重要的技术，对于需要高效数据传输的系统是至关重要的。通过减轻CPU的负担，DMA提高了系统的整体性能和响应速度。</p>
<h3 id="dma功能框图讲解">DMA功能框图讲解</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261122722.png" alt="DMA功能框图讲解"></p>
<h4 id="dma请求映射">DMA请求映射</h4>
<p>DMA1请求映射</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261126729.png" alt="DMA1请求映射"></p>
<p>DMA2请求映射</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261127579.png" alt="DMA2请求映射"></p>
<h4 id="dma仲裁器">DMA仲裁器</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401261128690.png" alt="DMA仲裁器"></p>
<p>软件配置在寄存器DMA_CCRx:PL[1:0]进行通道优先级配置</p>
<h3 id="dma固件库-初始化结构体">DMA固件库-初始化结构体</h3>
<p>初始化结构体在stm32f10x_dma.h文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  DMA Init structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 外设地址</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CPARx 进行配置</span></span><br><span class="line"><span class="comment">   *---------------------------------------------------------------------------- */</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_PeripheralBaseAddr; <span class="comment">/*!&lt; Specifies the peripheral base address for DMAy Channelx. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 存储器地址</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CMARx 进行配置</span></span><br><span class="line"><span class="comment">   *---------------------------------------------------------------------------- */</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_MemoryBaseAddr;     <span class="comment">/*!&lt; Specifies the memory base address for DMAy Channelx. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 传输方向</span></span><br><span class="line"><span class="comment">   * P-&gt;M 和 M-&gt;P 由寄存器 DMA_CCRx:DIR[4] 进行配置</span></span><br><span class="line"><span class="comment">   * M-&gt;M 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_DIR;                <span class="comment">/*!&lt; Specifies if the peripheral is the source or destination.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_data_transfer_direction */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 缓冲区大小, 传输数目</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CNDTRx 进行配置</span></span><br><span class="line"><span class="comment">   *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_BufferSize;         <span class="comment">/*!&lt; Specifies the buffer size, in data unit, of the specified Channel. </span></span><br><span class="line"><span class="comment">                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize</span></span><br><span class="line"><span class="comment">                                        or DMA_MemoryDataSize members depending in the transfer direction. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 外设增量模式</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:PINC[6] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_PeripheralInc;      <span class="comment">/*!&lt; Specifies whether the Peripheral address register is incremented or not.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 存储器增量模式</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:MINC[7] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_MemoryInc;          <span class="comment">/*!&lt; Specifies whether the memory address register is incremented or not.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_memory_incremented_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 外设数据宽度</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:PSIZE[9:8] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_PeripheralDataSize; <span class="comment">/*!&lt; Specifies the Peripheral data width.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_peripheral_data_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 存储器数据宽度</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:MSIZE[11:10] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_MemoryDataSize;     <span class="comment">/*!&lt; Specifies the Memory data width.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_memory_data_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 传输模式</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:CIRC[5] 进行配置</span></span><br><span class="line"><span class="comment">   * 通过 DMA_ISR 判断传输状态来判断传输完成, 传输一半, 传输错误</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_Mode;               <span class="comment">/*!&lt; Specifies the operation mode of the DMAy Channelx.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_circular_normal_mode.</span></span><br><span class="line"><span class="comment">                                        @note: The circular buffer mode cannot be used if the memory-to-memory</span></span><br><span class="line"><span class="comment">                                              data transfer is configured on the selected Channel */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 优先级</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:PL[1:0] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_Priority;           <span class="comment">/*!&lt; Specifies the software priority for the DMAy Channelx.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_priority_level */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 存储器到存储器模式</span></span><br><span class="line"><span class="comment">   * 由寄存器 DMA_CCRx:MEM2MEM[14] 进行配置</span></span><br><span class="line"><span class="comment">   *--------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_M2M;                <span class="comment">/*!&lt; Specifies if the DMAy Channelx will be used in memory-to-memory transfer.</span></span><br><span class="line"><span class="comment">                                        This parameter can be a value of @ref DMA_memory_to_memory */</span></span><br><span class="line">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>
<h3 id="dma固件库-固件库函数">DMA固件库-固件库函数</h3>
<p>在stm32f10x_dma.h文件中可以找到DMA固件库函数的声明, 以下是常用的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>; <span class="comment">// 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>; <span class="comment">// 使能DMA</span></span><br><span class="line">FlagStatus <span class="title function_">DMA_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>; <span class="comment">// 判断标志位</span></span><br></pre></td></tr></table></figure>
<h3 id="dma实验1:-m to m">DMA实验1: M to M</h3>
<p>项目地址: <strong>22-DMA-MtoM</strong></p>
<p><strong>实验需求</strong>: FLASH to SRAM, 把内部FLASH的数据传输到内部的SRAM</p>
<h4 id="在bsp_dma_m2mh增加宏定义">在bsp_dma_m2m.h增加宏定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当使用存储器到存储器模式时候，通道可以随便选，没有硬性的规定</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2M_DMA_CHANNEL     DMA1_Channel6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2M_DMA_CLOCK       RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="comment">// 传输完成标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2M_DMA_FLAG_TC     DMA1_FLAG_TC6</span></span><br><span class="line"><span class="comment">// 要发送的数据大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE     32</span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_dma_m2mc中定义源和目标变量">在bsp_dma_m2m.c中定义源和目标变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义aSRC_Const_Buffer数组作为DMA传输数据源</span></span><br><span class="line"><span class="comment"> * const关键字将aSRC_Const_Buffer数组变量定义为常量类型</span></span><br><span class="line"><span class="comment"> * 表示数据存储在内部的FLASH中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE]= &#123;</span><br><span class="line">                                    <span class="number">0x01020304</span>,<span class="number">0x05060708</span>,<span class="number">0x090A0B0C</span>,<span class="number">0x0D0E0F10</span>,</span><br><span class="line">                                    <span class="number">0x11121314</span>,<span class="number">0x15161718</span>,<span class="number">0x191A1B1C</span>,<span class="number">0x1D1E1F20</span>,</span><br><span class="line">                                    <span class="number">0x21222324</span>,<span class="number">0x25262728</span>,<span class="number">0x292A2B2C</span>,<span class="number">0x2D2E2F30</span>,</span><br><span class="line">                                    <span class="number">0x31323334</span>,<span class="number">0x35363738</span>,<span class="number">0x393A3B3C</span>,<span class="number">0x3D3E3F40</span>,</span><br><span class="line">                                    <span class="number">0x41424344</span>,<span class="number">0x45464748</span>,<span class="number">0x494A4B4C</span>,<span class="number">0x4D4E4F50</span>,</span><br><span class="line">                                    <span class="number">0x51525354</span>,<span class="number">0x55565758</span>,<span class="number">0x595A5B5C</span>,<span class="number">0x5D5E5F60</span>,</span><br><span class="line">                                    <span class="number">0x61626364</span>,<span class="number">0x65666768</span>,<span class="number">0x696A6B6C</span>,<span class="number">0x6D6E6F70</span>,</span><br><span class="line">                                    <span class="number">0x71727374</span>,<span class="number">0x75767778</span>,<span class="number">0x797A7B7C</span>,<span class="number">0x7D7E7F80</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义DMA传输目标存储器</span></span><br><span class="line"><span class="comment"> * 存储在内部的SRAM中                  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_dma_m2mc中增加dma初始化函数">在bsp_dma_m2m.c中增加DMA初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 配置存储器到存储器的DMA传输</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param None</span></span><br><span class="line"><span class="comment"> * @return None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">M2M_DMA_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_InitTypeDef DMA_InitStructure; <span class="comment">// 定义DMA初始化结构体变量</span></span><br><span class="line">    </span><br><span class="line">    RCC_AHBPeriphClockCmd(M2M_DMA_CLOCK, ENABLE); <span class="comment">// 打开DMA时钟</span></span><br><span class="line"></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)aSRC_Const_Buffer; <span class="comment">// 配置外设地址, 实际将FLASH的数据配置成了外设</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)aDST_Buffer; <span class="comment">// 配置存储器地址</span></span><br><span class="line">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; <span class="comment">// 配置传输方向，从外设读取数据发送到存储器</span></span><br><span class="line">    DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE; <span class="comment">// 配置传输数据大小</span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable; <span class="comment">// 配置外设地址自增</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; <span class="comment">// 配置存储器地址自增</span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; <span class="comment">// 配置外设数据大小</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; <span class="comment">// 配置存储器数据大小</span></span><br><span class="line">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; <span class="comment">// 配置传输模式，非循环模式</span></span><br><span class="line">    DMA_InitStructure.DMA_Priority = DMA_Priority_High; <span class="comment">// 配置传输通道优先级</span></span><br><span class="line">    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable; <span class="comment">// 配置存储器到存储器模式</span></span><br><span class="line"></span><br><span class="line">    DMA_Init(M2M_DMA_CHANNEL, &amp;DMA_InitStructure); <span class="comment">// 初始化DMA通道</span></span><br><span class="line">    DMA_ClearFlag(M2M_DMA_FLAG_TC); <span class="comment">// 清除DMA通道传输完成标志位</span></span><br><span class="line">    DMA_Cmd(M2M_DMA_CHANNEL, ENABLE); <span class="comment">// 使能DMA通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_dma_m2mc中增加判断数据相等的函数">在bsp_dma_m2m.c中增加判断数据相等的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 比较两个缓冲区的数据是否相等</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param pBuffer 指向第一个缓冲区的指针</span></span><br><span class="line"><span class="comment"> * @param pBuffer1 指向第二个缓冲区的指针</span></span><br><span class="line"><span class="comment"> * @param BufferLength 缓冲区的长度</span></span><br><span class="line"><span class="comment"> * @return uint8_t 如果两个缓冲区的数据相等，则返回1；否则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer, <span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 数据长度递减 */</span></span><br><span class="line">    <span class="keyword">while</span>(BufferLength--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 判断两个数据源是否对应相等 */</span></span><br><span class="line">        <span class="keyword">if</span>(*pBuffer != *pBuffer1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 对应数据源不相等马上退出函数，并返回0 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 递增两个数据源的地址指针 */</span></span><br><span class="line">        pBuffer++;</span><br><span class="line">        pBuffer1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 完成判断并且对应数据相对 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc函数中进行dma测试">在main.c函数中进行DMA测试</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明以下变量来自外部文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Delays the execution for a specified number of milliseconds.(Not Sure)</span></span><br><span class="line"><span class="comment"> * @param ms The number of milliseconds to delay.</span></span><br><span class="line"><span class="comment"> * @return None.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ms; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint16_t</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> status = <span class="number">0</span>; <span class="comment">// 接收比较的结构</span></span><br><span class="line"></span><br><span class="line">    LED_GPIO_Config(); <span class="comment">// 初始化LED</span></span><br><span class="line">    M2M_DMA_Config(); <span class="comment">// 初始化DMA</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 等待DMA1传送完毕</span></span><br><span class="line">    <span class="keyword">while</span>(DMA_GetFlagStatus(M2M_DMA_FLAG_TC) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LED_YELLOW;</span><br><span class="line">    Delay_ms(<span class="number">10000</span>); <span class="comment">// DMA初始化完成后亮黄灯</span></span><br><span class="line"></span><br><span class="line">    status = Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE); <span class="comment">// 比较两个数组的数据是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(status == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED_RED; <span class="comment">// 数据不相等亮红灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LED_GREEN; <span class="comment">// 数据相等亮绿灯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dma实验2:-m to p">DMA实验2: M to P</h3>
<p>项目地址: <strong>22-DMA-MtoP</strong></p>
<p><strong>实验需求</strong>: SRAM to 串口, 同时LED灯闪烁, 演示DMA数据不需占用CPU</p>
<h3 id="在bsp_dma_m2ph中加入宏定义">在bsp_dma_m2p.h中加入宏定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串口工作参数宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USARTx                   USART1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_CLK                RCC_APB2Periph_USART1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_BAUDRATE           115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART GPIO 引脚宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PORT       GPIOA   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PORT       GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_TX_DMA_CLK RCC_AHBPeriph_DMA1 <span class="comment">// 串口DMA时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  USART_TX_DMA_CHANNEL     DMA1_Channel4 <span class="comment">// 串口对应的DMA请求通道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  USART_DR_ADDRESS        (USART1_BASE+0x04) <span class="comment">// 外设寄存器地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SENDBUFF_SIZE            5000 <span class="comment">// 一次发送的数据量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  USART_TX_DMA_FLAG_TC DMA1_FLAG_TC4 <span class="comment">// 标志位</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_dma_m2pc中加入usart的初始化函数">在bsp_dma_m2p.c中加入USART的初始化函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  USART GPIO 配置,工作参数配置</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    USART_InitTypeDef USART_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口GPIO的时钟</span></span><br><span class="line">    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口外设的时钟</span></span><br><span class="line">    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将USART Tx的GPIO配置为推挽复用模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将USART Rx的GPIO配置为浮空输入模式</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置串口的工作参数</span></span><br><span class="line">    <span class="comment">// 配置波特率</span></span><br><span class="line">    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;</span><br><span class="line">    <span class="comment">// 配置 针数据字长</span></span><br><span class="line">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    <span class="comment">// 配置停止位</span></span><br><span class="line">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    <span class="comment">// 配置校验位</span></span><br><span class="line">    USART_InitStructure.USART_Parity = USART_Parity_No ;</span><br><span class="line">    <span class="comment">// 配置硬件流控制</span></span><br><span class="line">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">    <span class="comment">// 配置工作模式，收发一起</span></span><br><span class="line">    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">    <span class="comment">// 完成串口的初始化配置</span></span><br><span class="line">    USART_Init(DEBUG_USARTx, &amp;USART_InitStructure); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能串口</span></span><br><span class="line">    USART_Cmd(DEBUG_USARTx, ENABLE);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_dma_m2pc中加入usartx_tx-dma配置">在bsp_dma_m2p.c中加入USARTx_TX DMA配置</h4>
<p>实现内存到外设(USART1-&gt;DR)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  USARTx TX DMA 配置，内存到外设(USART1-&gt;DR)</span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USARTx_DMA_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启DMA时钟</span></span><br><span class="line">    RCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);</span><br><span class="line">    <span class="comment">// 设置DMA源地址：串口数据寄存器地址*/</span></span><br><span class="line">       DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;</span><br><span class="line">    <span class="comment">// 内存地址(要传输的变量的指针)</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff;</span><br><span class="line">    <span class="comment">// 方向：从内存到外设 </span></span><br><span class="line">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;</span><br><span class="line">    <span class="comment">// 传输大小 </span></span><br><span class="line">    DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;</span><br><span class="line">    <span class="comment">// 外设地址不增     </span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">    <span class="comment">// 内存地址自增</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">    <span class="comment">// 外设数据单位 </span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">    <span class="comment">// 内存数据单位</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  </span><br><span class="line">    <span class="comment">// DMA模式，一次或者循环模式</span></span><br><span class="line">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;</span><br><span class="line">    <span class="comment">// DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; </span></span><br><span class="line">    <span class="comment">// 优先级：中 </span></span><br><span class="line">    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; </span><br><span class="line">    <span class="comment">// 禁止内存到内存的传输</span></span><br><span class="line">    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">    <span class="comment">// 配置DMA通道     </span></span><br><span class="line">    DMA_Init(USART_TX_DMA_CHANNEL, &amp;DMA_InitStructure);  </span><br><span class="line">    <span class="comment">// 清除TC标志位</span></span><br><span class="line">    DMA_ClearFlag(USART_TX_DMA_FLAG_TC);</span><br><span class="line">    <span class="comment">// 使能DMA</span></span><br><span class="line">    DMA_Cmd (USART_TX_DMA_CHANNEL, ENABLE);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="在bsp_dma_m2pc中声明在内存的变量">在bsp_dma_m2p.c中声明在内存的变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中声明外部变量">在main.c中声明外部变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中测试dma">在main.c中测试DMA</h4>
<p>实现DMA将储存器中的数据发送到USART-&gt;DR, 并实现LED1闪烁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 实现DMA将储存器中的数据发送到USART-&gt;DR, 并实现LED1闪烁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LED_GPIO_Config(); <span class="comment">// 初始化LED</span></span><br><span class="line">    USART_Config(); <span class="comment">// 串口初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; SENDBUFF_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SendBuff[i] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    USARTx_DMA_Config(); <span class="comment">// 初始化DMA</span></span><br><span class="line">    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); <span class="comment">// 使能DMA发送</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1_TOGGLE;</span><br><span class="line">        Delay_ms(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用存储器">常用存储器</h2>
<h3 id="存储器的种类">存储器的种类</h3>
<p>易失性和非易失性区别在于<strong>掉电数据是否会丢失</strong>, 易失性存储器<strong>读写速度相对较快</strong></p>
<ul>
<li>易失性存储器(RAM)
<ul>
<li>DRAM(动态RAM, 常用于PC机)
<ul>
<li>SDRAM(STM32F429)</li>
<li>DDR SDRAM</li>
<li>DDRII SDRAM</li>
<li>DDRIII SDRAM(常用于PC机)</li>
</ul>
</li>
<li>SRAM(静态RAM, STM32F103)</li>
</ul>
</li>
<li>非易失性存储器
<ul>
<li>ROM(半导体类)
<ul>
<li>MASK ROM(对于STM32可读不可写)</li>
<li>PROM(可编程ROM)
<ul>
<li>OTPROM(可写一次的ROM)</li>
<li>EPROM(可用高电压擦除的ROM)</li>
<li>EEPROM(STM32F103, 可用较低电压3.3V擦除的ROM)</li>
</ul>
</li>
<li>FLASH(半导体类)</li>
<li>NOR FLASH(一般用来存储程序)</li>
<li>NAND FLASH(一般用来存储数据)</li>
<li>光盘</li>
<li>软盘</li>
<li>机械硬盘</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ram存储器(易失性存储器)">RAM存储器(易失性存储器)</h3>
<h4 id="ram介绍">RAM介绍</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262322421.png" alt="RAM介绍"></p>
<h4 id="dram的存储单元结构">DRAM的存储单元结构</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262327533.png" alt="DRAM的存储单元结构"></p>
<p><strong>DRAM通过电容充放电与MOS管配合产生高低电平</strong>, 需要配合电平检测阈值来减少电容漏电带来的影响</p>
<h4 id="sram的存储单元结构">SRAM的存储单元结构</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262328328.png" alt="SRAM的存储单元结构"></p>
<p><strong>SRAM以锁存器结构来存储数据</strong>, 锁存器结构在没有输入的情况下会一直保持原来的状态</p>
<h4 id="sram和dram的比较">SRAM和DRAM的比较</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262336065.png" alt="SRAM和DRAM的比较"></p>
<p>SDRAM使用同步通信方式</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401262341860.png" alt="SDRAM同步通信"></p>
<p>SRAM使用异步方式通信</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270000903.png" alt="SRAM异步通信"></p>
<h3 id="非易失性存储器">非易失性存储器</h3>
<h4 id="rom简介">ROM简介</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270001764.png" alt="ROM简介"></p>
<h4 id="flash简介">FLASH简介</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270007166.png" alt="FLASH简介"></p>
<p>在嵌入式开发中选择 NOR FLASH 主要因为坏区较少, 基于字节读写可以支持XIP</p>
<p>XIP(Execute In Place，就地执行)功能，它是一种特性，允许直接从 Flash 存储器中执行代码，而无需将代码首先复制到RAM中。XIP功能在嵌入式系统中很常见，它带来了一些优势，包括更少的RAM使用和更快的启动速度</p>
<p>与ROM不同, FLASH必须先按块擦除数据后才能写入数据</p>
<h2 id="i2c-读写eeprom">I2C-读写EEPROM</h2>
<h3 id="补充:-i2c简介">补充: I2C简介</h3>
<p>I2C（Inter-Integrated Circuit）是一种串行通信协议，<strong>用于在集成电路之间进行短距离通信</strong> I2C 由飞利浦公司（Philips）于1982年开发，并且现在由多家公司支持和采用。该协议通常用于连接芯片、传感器、存储器、外设等设备。</p>
<p>以下是 I2C 协议的一些关键特点和基本概念：</p>
<ol>
<li>总线结构
<ul>
<li>主从结构： I2C 使用主从结构，其中一个设备充当主设备（通常是微控制器或处理器），而其他设备则充当从设备。主设备负责发起通信和生成时钟信号。</li>
<li>双线制： I2C 使用两根线，一根是数据线（SDA），另一根是时钟线（SCL）。这两根线上都有上拉电阻，以便在设备不主动拉低时保持高电平。</li>
</ul>
</li>
<li>数据传输：
<ul>
<li>起始和停止条件： 数据传输始于主设备发送起始条件（Start Condition），并以主设备发送停止条件（Stop Condition）结束。这两个条件都是由主设备在总线上生成的。</li>
<li>地址帧： 每个数据传输都以地址帧开始，其中包含目标设备的地址和读写位。地址帧由主设备发送。</li>
<li>数据帧： 在地址帧之后是一个或多个数据帧，其中包含实际的数据。数据帧的传输由主设备和从设备之间交替进行。</li>
<li>应答（Acknowledge）： 在每个数据帧之后，接收方发送一个应答信号，通常是一个低电平，以确认数据的接收。</li>
</ul>
</li>
<li>速率和模式：
<ul>
<li>速率： I2C 支持不同的传输速率，常见的有 100 kHz、400 kHz 和 1 MHz 等。</li>
<li>模式： I2C 支持标准模式（100 kHz），快速模式（400 kHz），高速模式（1 MHz）等不同的工作模式。</li>
</ul>
</li>
<li>多主设备和重复启动：
<ul>
<li>多主设备： I2C 支持多主设备共享同一总线。主设备之间通过仲裁（Arbitration）来确定哪个主设备能够继续发送。</li>
<li>重复启动： 主设备可以在一个传输结束后发送重复启动条件，而无需先发送停止条件，从而在同一次通信中与另一个从设备建立连接。</li>
</ul>
</li>
<li>I2C设备地址：
<ul>
<li>7位或10位地址： I2C 设备使用 7 位或 10 位地址来识别自己。大多数设备使用 7 位地址。</li>
</ul>
</li>
</ol>
<p>I2C 协议的简洁性和灵活性使得它在连接各种设备和传感器时非常有用，尤其是在嵌入式系统中。</p>
<h3 id="补充:-高阻态">补充: 高阻态</h3>
<p>在嵌入式领域中，高阻态的概念同样非常重要，并涉及到数字电路设计和信号完整性的方面。以下是在嵌入式系统中高阻态的一些关键应用和概念：</p>
<ol>
<li>输入端口的高阻态： 很多嵌入式系统包括微控制器或微处理器，<strong>其输入端口通常具有高阻抗特性。这意味着当输入端口未连接到任何外部设备时，输入端口会处于高阻态状态。这有助于避免在未连接设备时引入不必要的电流，同时防止信号线上的悬空状态(floating)</strong>。</li>
<li>悬空输入的高阻态： 在数字电路中，当一个输入端未连接时，它被称为悬空输入。在悬空输入的情况下，该输入端常常设计为高阻态，以减少对电路的干扰和功耗。</li>
<li>总线冲突的高阻态： <strong>在多主设备共享总线的系统中，当多个主设备尝试在同一时刻传输数据时可能会发生总线冲突。为了避免冲突设备之间的干扰，某些设备在冲突时会将总线设置为高阻态，以允许其他设备继续操作</strong>。</li>
<li>三态逻辑门： 一些数字逻辑门（如三态门）具有高阻态输出。这允许将多个门连接到同一总线上，当其中一个门处于高阻态时，其他门仍能够正常工作。</li>
<li>输入缓冲器的高阻态： 在输入缓冲器中，当输入未被有效驱动时，输入缓冲器通常进入高阻态，以避免对电路产生负面影响。</li>
</ol>
<p>在这些情况下，高阻态的概念有助于确保电路在非活动状态时不引入不必要的电流，提高系统的稳定性和可靠性。这对于嵌入式系统中对功耗、信号完整性和总线冲突等方面的考虑非常重要。</p>
<h3 id="i2c物理层">I2C物理层</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270111246.png" alt="I2C物理层"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270140896.png" alt="I2C物理层"></p>
<h4 id="i2c物理层主要特点">I2C物理层主要特点</h4>
<ul>
<li>I2C是支持多设备的总线, 可支持多个通讯主机和从机</li>
<li>I2C使用两条线路, 一条SDA(双向串行数据线)来表示数据, 一条SCL(串行时钟线)来同步数据, 属于同步通信</li>
<li>连接到总线的设备分配独立地址(7位或10位)</li>
<li>总线接上拉电阻到电源(一般4.7KΩ, 具体看手册)
<ol>
<li>当设备空闲时输出高阻态<em>防止短路总线上的其他接地设备</em></li>
<li>当所有设备都空闲时全部输出高阻态, 可通过上拉电阻把总线拉到高电平</li>
<li>输出高阻态的特性需要GPIO的开漏输出</li>
</ol>
</li>
<li>多设备占用总线会仲裁</li>
<li>具有三种传输速度模式, <strong>实际开发中可使用低于最高速的速度, 协调总线设备速度一致即可</strong></li>
<li>I2C可接入的设备数量受到最大电容负载的限制, 一般为400pF, <em>也就是说总线上的设备数量越多, 传输速度越慢</em></li>
</ul>
<h3 id="i2c协议层">I2C协议层</h3>
<p>I2C协议定义了<strong>通讯的起始和停止信号, 数据有效性, 响应, 仲裁, 时钟同步和地址广播等环节</strong></p>
<h4 id="i2c基本读写过程">I2C基本读写过程</h4>
<h5 id="主机写数据到从机">主机写数据到从机</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270157626.png" alt="I2C基本读写过程"></p>
<ol>
<li>S: 主机传输开始信号</li>
<li>SLAVE ADDRESS: 主机传输需要通信的从机地址</li>
<li>R/!W: 主机传输读或写信号, <em>若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据</em></li>
<li>A: 从机传输响应</li>
<li>DATA: 主机传输数据段</li>
<li>A: 从机响应</li>
<li>DATA: 主机继续发送数据段</li>
<li>A/!A: 从机响应是否继续接收</li>
<li>P: 若从机响应不继续接收, 则主机传输停止位</li>
</ol>
<h5 id="主机由从机读数据">主机由从机读数据</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270207508.png" alt="I2C基本读写过程"></p>
<ol>
<li>S: 主机传输开始信号</li>
<li>SLAVE ADDRESS: 主机传输需要通信的从机地址</li>
<li>R/!W: 主机传输读或写信号, <em>若为1(写)则主机向从机发送数据, 若为0(读)则从机向主机发送数据</em></li>
<li>A: 从机传输响应</li>
<li>DATA: 从机传输数据段</li>
<li>A: 主机响应</li>
<li>DATA: 从机继续发送数据段</li>
<li>A/!A: 主机响应是否继续接收</li>
<li>P: 若主机响应不继续接收, 则主机传输停止位</li>
</ol>
<p>注意:</p>
<ul>
<li>S: 开始信号只能由主机产生</li>
<li>SLAVE ADDRESS: 进行通信的从机地址只能由主机产生</li>
<li>R/!W: 读/写信号只能由主机产生</li>
<li>P: 停止信号只能由主机产生</li>
<li>DATA 和 A: 数据段和响应段由主机和从机交替产生, 具体由主机和从机的读写决定</li>
</ul>
<h5 id="通信复合格式">通信复合格式</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270209992.png" alt="通信复合格式"></p>
<p>常用的复合通信的方法, <strong>即先写入外设地址后将外设的寄存器地址返回进行读取</strong></p>
<ul>
<li>S: 主机传输开始信号</li>
<li>SLAVE ADDRESS: 进行通信的从机地址(一般为外设)</li>
<li>R/W!: 一般为写操作</li>
<li>DATA: 写入的外设地址</li>
<li>A/A!: 从机响应</li>
<li>Sr: 主机传输开始信号</li>
<li>SLAVE ADDRESS: 进行通信的从机地址(一般为同一个外设)</li>
<li>R/W!: 一般为读操作</li>
<li>DATA: 读取外设的寄存器的具体地址</li>
<li>A/A!: 逐个字节进行读取外设每个寄存器的地址并做出响应</li>
<li>P: 全部读取完毕后主机传输停止信号</li>
</ul>
<h4 id="通讯的起始和停止信号">通讯的起始和停止信号</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270225648.png" alt="通讯的起始和停止信号"></p>
<ul>
<li>起始信号: <strong>SCL高电平, SDA由高电平向低电平转换</strong></li>
<li>停止信号: <strong>SCL高电平, SDA由低电平向高电平转换</strong></li>
</ul>
<h4 id="数据的有效性">数据的有效性</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270237788.png" alt="数据有效性"></p>
<ul>
<li>SDA: 负责传输数据</li>
<li>SCL: 高电平时采集SDA上1bit数据, 低电平时SDA进行电平转换</li>
</ul>
<h4 id="地址及数据方向">地址及数据方向</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270243764.png" alt="地址及数据方向"></p>
<p>I2C采用高位先行, 由高位到低位进行传输</p>
<p>一般使用7位表示I2C上的设备地址, 设备地址加上其后的读写位可以凑成8位即1字节方便传输</p>
<p>例如, 某设备在I2C上的设备地址为7位的0x78(0b01111000), 可加入读写位凑到八位</p>
<ul>
<li>8位设备的读地址位为0xF1(0b11110001)</li>
<li>8位设备的写地址位为0xF0(0b11110000)</li>
</ul>
<h4 id="响应">响应</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270254565.png" alt="响应"></p>
<ol>
<li>1-8个时钟信号中: 数据发送端控制SDA传输7位设备地址和1位读写信号</li>
<li>在第9个时钟信号时: 数据接收端获得SDA控制权, 发送应答信号(低电平表示应答)</li>
</ol>
<h3 id="stm32的i2c特性及架构">STM32的I2C特性及架构</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270305500.png" alt="STM32的I2C特性及架构"></p>
<ul>
<li>软件模拟协议: 较为繁琐</li>
<li>硬件模拟协议: 较为方便, 减轻CPU负担</li>
</ul>
<p>注: <em>STM32硬件的I2C逻辑可能会有问题</em></p>
<h4 id="stm32的i2c架构分析">STM32的I2C架构分析</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270315440.png" alt="STM32的I2C架构分析"></p>
<h5 id="i2c的通讯引脚">I2C的通讯引脚</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270346561.png" alt="I2C的通讯引脚"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270316720.png" alt="I2C的通讯引脚"></p>
<p>勘误: <em>I2C1_SCL默认映射到PB5, I2C1_SDA默认映射到PB7, 图片中有误</em></p>
<p>STM32兼容smbus协议</p>
<h5 id="时钟控制逻辑">时钟控制逻辑</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347794.png" alt="时钟控制逻辑"><br>
<img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270325594.png" alt="时钟控制逻辑"></p>
<p>注: <em>Tpck1: 指的是APB1时钟周期(1/36MHz)</em></p>
<h6 id="计算时钟频率的方法">计算时钟频率的方法</h6>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270333989.png" alt="计算时钟频率的方法"></p>
<p>实际就是解未知数CCR的一元一次方程</p>
<h5 id="数据控制逻辑">数据控制逻辑</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270347332.png" alt="数据控制逻辑"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270337311.png" alt="数据控制逻辑"></p>
<ol>
<li>将8位数据写入数据寄存器(DR)</li>
<li>数据寄存器里面的数据会被发送到数据移位寄存器</li>
</ol>
<h5 id="整体控制逻辑">整体控制逻辑</h5>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270348369.png" alt="整体控制逻辑"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270355991.png" alt="整体控制逻辑"></p>
<h3 id="stm32硬件i2c的通讯过程">STM32硬件I2C的通讯过程</h3>
<h4 id="stm32作为主发送器的通讯过程">STM32作为主发送器的通讯过程</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270357886.png" alt="STM32作为主发送器的通讯过程"></p>
<p>勘误: <em>EV8_2: TxE=1, BTF=1, 请求设置停止位. TxE和BTF位由硬件在产生停止条件时清除</em></p>
<ul>
<li>EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)</li>
<li>EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)</li>
<li>EV8: 在正常数据发送完毕后会产生EV8事件(I2C_SRx:TxE[7]置1表示数据寄存器空)</li>
<li>EV8_2: 在从机发送结束应答后会产生EV8_2事件(I2C_SRx:TxE[7]置1表示数据寄存器空, I2C_SRx:BTF[2]置1表示字节发送结束, I2C_CRx:STOP[9]置1表示在当前字节传输或在当前起始条件发出后产生停止条件, 产生停止条件后由硬件清除TxE和BTF位)</li>
</ul>
<h4 id="stm32作为主接收器的通讯过程">STM32作为主接收器的通讯过程</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401270423471.png" alt="STM32作为主接收器的通讯过程"></p>
<p>勘误: <em>EV7_1: RxNE=1, 读DR寄存器清除该事件. 设置ACK=0和STOP请求</em></p>
<ul>
<li>EV5: 在正常产生S起始信号后会产生EV5事件(I2C_SRx:SB[0]置1表示起始条件已发送)</li>
<li>EV6: 在正常发送SLAVE ADDRESS和R/!W位后会产生EV6事件(I2C_SRx:ADDR[1]置1表示地址发送结束)</li>
<li>EV7: 在正常数据发送完毕后会产生EV7事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空)</li>
<li>EV7_1: 在主机发送结束应答后会产生EV7_1事件(I2C_SRx:RxNE[6]置1表示数据寄存器(接收时)非空, I2C_CRx:ACK[10]置0表示设置为无应答返回, I2C_CRx:STOP[9]置1表示在当前字节传输或释放SCL和SDA线)</li>
</ul>
<p>每个状态标志位的清除方法各不相同, 使用库函数的方法可以较方便的清除寄存器的标志位</p>
<h3 id="i2c初始化结构体">I2C初始化结构体</h3>
<p>在stm32f10x_i2c.h中定义I2C初始化结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  I2C Init structure definition  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/*---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 设置时钟频率</span></span><br><span class="line"><span class="comment">   * 设置I2C的传输速率, 函数根据该值经过运算后写入I2C_CCR寄存器</span></span><br><span class="line"><span class="comment">   * 不得高于400kHz, 即400 000</span></span><br><span class="line"><span class="comment">   * 由于I2C_CCR寄存器不能写入浮点数, 可能会导致实际速率小于设定的传输速率参数</span></span><br><span class="line"><span class="comment">   * 使得通讯稍慢, 但是并不会对I2C的通讯造成其他影响</span></span><br><span class="line"><span class="comment">   *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint32_t</span> I2C_ClockSpeed;          <span class="comment">/*!&lt; Specifies the clock frequency.</span></span><br><span class="line"><span class="comment">                                         This parameter must be set to a value lower than 400kHz */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 设置I2C的模式</span></span><br><span class="line"><span class="comment">   * I2C_Mode_I2C: 标准I2C模式</span></span><br><span class="line"><span class="comment">   * I2C_Mode_SMBusDevice: SMBus设备模式</span></span><br><span class="line"><span class="comment">   * I2C_Mode_SMBusHost: SMBus主机模式</span></span><br><span class="line"><span class="comment">   *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> I2C_Mode;                <span class="comment">/*!&lt; Specifies the I2C mode.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a value of @ref I2C_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 设置I2C的SCL时钟的占空比</span></span><br><span class="line"><span class="comment">   * I2C_DutyCycle_16_9: Tlow/Thigh = 16:9</span></span><br><span class="line"><span class="comment">   * I2C_DutyCycle_2: Tlow/Thigh = 2:1</span></span><br><span class="line"><span class="comment">   * 这两个选项差别不大, 开发中一般不会进行严格区分</span></span><br><span class="line"><span class="comment">   *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> I2C_DutyCycle;           <span class="comment">/*!&lt; Specifies the I2C fast mode duty cycle.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 配置STM32的I2C设备自己的地址</span></span><br><span class="line"><span class="comment">   * 此参数可以是 7 位或 10 位地址</span></span><br><span class="line"><span class="comment">   * 第二个地址可以通过函数I2C_OwnAddress2Config进行配置, 只能是7位地址</span></span><br><span class="line"><span class="comment">   *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> I2C_OwnAddress1;         <span class="comment">/*!&lt; Specifies the first device own address.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a 7-bit or 10-bit address. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 配置I2C应答是否使能</span></span><br><span class="line"><span class="comment">   * I2C_Ack_Enable: 允许应答使能</span></span><br><span class="line"><span class="comment">   * I2C_Ack_Disable: 禁止应答使能</span></span><br><span class="line"><span class="comment">   * 一般配置为允许应答使能, 改为禁止应答使能往往会导致通讯错误</span></span><br><span class="line"><span class="comment">   *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> I2C_Ack;                 <span class="comment">/*!&lt; Enables or disables the acknowledgement.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a value of @ref I2C_acknowledgement */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 配置I2C的寻址长度</span></span><br><span class="line"><span class="comment">   * I2C_AcknowledgedAddress_7bit: 7位地址</span></span><br><span class="line"><span class="comment">   * I2C_AcknowledgedAddress_10bit: 10位地址</span></span><br><span class="line"><span class="comment">   * 需要根据连接到I2C总线上的设备进行选择, 确保地址长度一致, 才能进行通信</span></span><br><span class="line"><span class="comment">   * 只有I2C_OwnAddress1才能配置10位地址, I2C_OwnAddress2只支持7位地址 *-------------------------------------------------------------------------------*/</span></span><br><span class="line">  <span class="type">uint16_t</span> I2C_AcknowledgedAddress; <span class="comment">/*!&lt; Specifies if 7-bit or 10-bit address is acknowledged.</span></span><br><span class="line"><span class="comment">                                         This parameter can be a value of @ref I2C_acknowledged_address */</span></span><br><span class="line">&#125;I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>
<h3 id="i2c库函数">I2C库函数</h3>
<h4 id="i2c_generatestart函数,-用于产生起始条件">I2C_GenerateSTART函数, 用于产生起始条件</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271607885.png" alt="I2C库函数"></p>
<h4 id="i2c_getflagstatus函数,-用于获取状态位">I2C_GetFlagStatus函数, 用于获取状态位</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271610721.png" alt="I2C库函数"></p>
<p>I2C_FLAG参数列表对应I2C_SRx状态寄存器的各个位, 可通过查询手册查看其含义</p>
<p>返回值说明</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271612900.png" alt="返回值说明"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>RESET = <span class="number">0</span>, SET = !RESET&#125; FlagStatus, ITStatus;</span><br></pre></td></tr></table></figure>
<ul>
<li>RESET: 0, 返回RESET表示该状态位为0</li>
<li>SET: 1, 返回SET表示该状态位为1</li>
</ul>
<h4 id="i2c_send7bitaddress函数,-用于发送7位地址">I2C_Send7bitAddress函数, 用于发送7位地址</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271616560.png" alt="I2C库函数"></p>
<p>参数Address为八位读/写地址, 通过I2C_Direction实际配置读写方向, 最终方向以I2C_Direction配置为准, 参数Address的读写位失效</p>
<h4 id="i2c_senddate函数,-通过i2cx外设发送数据字节">I2C_SendDate函数, 通过I2Cx外设发送数据字节</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271618557.png" alt="I2C库函数"></p>
<h4 id="i2c_receivedata函数,-返回 i2cx 外设最近接收的数据">I2C_ReceiveData函数, 返回 I2Cx 外设最近接收的数据</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271622473.png" alt="I2C库函数"></p>
<h4 id="acknowledgeconfig函数,-使能或禁用i2c的应答">AcknowledgeConfig函数, 使能或禁用I2C的应答</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271623317.png" alt="I2C库函数"></p>
<h4 id="i2c_cmd函数,-使能或禁用i2cx外设">I2C_Cmd函数, 使能或禁用I2Cx外设</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271625131.png" alt="I2C库函数"></p>
<h4 id="i2c_checkevent函数,-i2c状态监测函数">I2C_CheckEvent函数, I2C状态监测函数</h4>
<p>监测的事件发生则返回SUCCESS</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280036252.png" alt="I2C库函数"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037103.png" alt="I2C_CheckEvent函数"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280037758.png" alt="I2C_CheckEvent函数"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038783.png" alt="I2C_CheckEvent函数"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280038105.png" alt="I2C_CheckEvent函数"></p>
<h3 id="eeprom硬件结构">EEPROM硬件结构</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271630443.png" alt="EEPROM"></p>
<h4 id="引脚说明">引脚说明</h4>
<ul>
<li>VCC: 电源引脚, 接3V3</li>
<li>GND: 地引脚, 接地</li>
<li>SCL: 时钟线, 经2.2K上拉电阻接3V3, 接PB6引脚(默认映射I2C1_SCL)</li>
<li>SDA: 数据线, 经2,2K上拉电阻接3V3, 接PB7引脚(默认映射I2C1_SDA)</li>
<li>HOLD: WP引脚, 接地, 不启用写保护(即可向AT24C02写数据)</li>
<li>A0-A2: 地址引脚, 接地, A0:A2为000, 如需拓展EEPROM则可通过配置A0-A2的地址引脚来进行区分(如: 配置A0:A2为001, 则可对两EEPROM进行区分)</li>
</ul>
<h3 id="at24c02介绍">AT24C02介绍</h3>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271642465.png" alt="AT24C02"></p>
<p>AT24C02可存储256字节数据</p>
<h4 id="at24c02引脚说明">AT24C02引脚说明</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271648925.png" alt="AT24C02"></p>
<ul>
<li>A0-A2: AT24C02用来区分不同AT24C0x芯片的设备地址</li>
<li>SDA: 数据线</li>
<li>SCL: 时钟线</li>
<li>WP: 写保护, 置1启用写保护</li>
<li>NC: 不连接</li>
</ul>
<h4 id="at24c02设备地址">AT24C02设备地址</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702961.png" alt="设备地址"></p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271702718.png" alt="设备地址"></p>
<p>AT24C02有256字节, 即属于2K(256*8)</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271701248.png" alt="设备地址"></p>
<p>根据原理图, 将A2-A0均接地, 则A2 = A1 = A0 = 0</p>
<p>AT24C02的地址为0b1010000R/W, Bit0为R/!W位</p>
<ul>
<li>AT24C02在A2:A1[000]情况下读地址: 0b10100001(0xA1)</li>
<li>AT24C02在A2:A1[000]情况下写地址: 0b10100000(0xA0)</li>
</ul>
<h4 id="at24c02的byte-write(以字节方式写数据)操作">AT24C02的Byte Write(以字节方式写数据)操作</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271719435.png" alt="Byte Write"></p>
<p>第一个传输的数据段(DATA)为WORD ADDRESS(需要写入的字节所在的地址), 第二次传输数据段(DATA)才为真正需要写入的内容</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271723653.png" alt="Byte Write"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">翻译: Byte Write的工作流程</span><br><span class="line"></span><br><span class="line">1. 在发送完SLAVE ADDRESS和W/!R后, 需要发送一个字节的数据地址(WORD ADDRESS)(即需要写入的字节所在的地址)</span><br><span class="line">2. 收到地址(WORD ADDRESS)后, EEPROM会响应ACK, 然后接收一个字节的数据(DATA)(真正要写入的内容)</span><br><span class="line">3. 接收到数据(DATA)后, EEPROM响应ACK, 单片机必须发送STOP信号, 不能继续传输第二段数据(给EEPROM预留写入时间)</span><br><span class="line">4. 接收到停止信号后, EEPROM在tWR的周期时间内进行向内部写入数据</span><br><span class="line">5. 在此写入周期中, 所有输入被禁用, EEPROM不进行响应</span><br></pre></td></tr></table></figure>
<h4 id="at24c02的page-write(以页方式写数据)操作">AT24C02的Page Write(以页方式写数据)操作</h4>
<p>又称突发写入(即仅发送一个地址可写入多个数据)</p>
<p>Page Write解决了Byte Write不能连续写入的缺陷</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271734727.png" alt="Page Write"></p>
<ul>
<li>WORD ADDRESS(n): 数据的起始地址</li>
<li>DATA(n): 写入到WORD ADDRESS(n)中</li>
<li>DATA(n+1): 写入到WORD ADDRESS(n+1)中</li>
<li>DATA(n+x): 写入到WORD ADDRESS(n+x)中</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271741445.png" alt="Page Write"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">翻译: Page Write工作流程</span><br><span class="line"></span><br><span class="line">1. AT24C02能以8字节进行Page Write</span><br><span class="line">2. 与Byte Write类似, 第一个字节是数据地址(WORD ADDRESS)(即需要写入的字节所在的地址), 在接受到第二个字节(DATA)后不会要求单片机发送STOP信号</span><br><span class="line">3. 相反, EEPROM在接收到第一个DATA(真正要写入的数据)后, 对于AT24C02来说, 能再最多传输7个DATA</span><br><span class="line">4. EEPROM每接收到一个数据位都会响应ACK, 单片机必须发送停止信号来结束Page Writting</span><br><span class="line">5. 收到每个DATA后, 对于AT24C02来说, 数据地址(WORD ADDRESS)的低三位会递增(低三位的取值情况为2<span class="built_in">^</span>3 = 8, 即8字节)</span><br><span class="line">6. 高位地址不会递增, 从而保证原来的初始数据地址不发生改变(确保低三位正确递增)</span><br><span class="line">7. 当递增的地址到达Page的界限后, 剩下的8位数据会覆盖Page的开头</span><br><span class="line">8. 如果向EEPROM传输的DATA超过8个字节(对于AT24C02), 则数据会从头覆盖</span><br></pre></td></tr></table></figure>
<h4 id="at24c02的acknowledge-polling(确认轮询)">AT24C02的ACKNOWLEDGE POLLING(确认轮询)</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280423663.png" alt="ACKNOWLEDGE POLLING"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。</span><br><span class="line">这涉及发送一个启动条件，后跟设备地址。读/写位是代表所需的操作。</span><br><span class="line">仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列</span><br></pre></td></tr></table></figure>
<p>需要在向AT24C02写入数据操作后, 进行确认询问, 主机需要发送启动条件, 设备地址, 读写位, 如果AT24C02准备完毕会响应0才能继续进行操作</p>
<p>以I2C1为例, 软件编程实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认询问 </span></span><br><span class="line"><span class="comment"> *   STM32向EEPROM写入数据后, EEPROM需要时间向内部存储期间进行写入</span></span><br><span class="line"><span class="comment"> *   此时EEPROM不应答, 所以在发送下一次I2C请求之前,应等待EEPROM写入完成</span></span><br><span class="line"><span class="comment"> *   以上步骤称为ACKNOWLEDGE POLLING</span></span><br><span class="line"><span class="comment"> * @param None</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_ACK_Polling</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* STM32产生START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的写地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    &#125; <span class="keyword">while</span> (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); </span><br><span class="line">    <span class="comment">/* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="comment">/* 结束询问 */</span></span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="at24c02的current-address read(从当前地址读数据)操作">AT24C02的Current Address Read(从当前地址读数据)操作</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271810617.png" alt="Current Address Read"></p>
<p>一般不用, 因为在开发中不好确定当前地址的位置</p>
<h4 id="at24c02的random-read(随机读数据)操作">AT24C02的Random Read(随机读数据)操作</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271813901.png" alt="Random Read"></p>
<ol>
<li>产生起始信号, 向EEPROM发送要读取数据的数据地址(写方向)</li>
<li>再次产生起始信号, 从EEPROM中读取数据(读方向)</li>
<li>EEPROM在被写入要读取数据的数据地址后会进行确认并输出该数据内容</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271821179.png" alt="Random Read"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">翻译: Random Read流程</span><br><span class="line"></span><br><span class="line">1. Random Read需要&quot;dummy&quot;来写入要读取数据(DATA)的数据地址(WORD ADDRESS)</span><br><span class="line">2. 一旦DEVICE ADDRESS和WORD ADDRESS被EEPROM响应, 单片机必须生成另一个START信号</span><br><span class="line">3. 单片机发送读信号来读取当前地址(DEVICE ADDRESS)</span><br><span class="line">4. EEPROM响应DEVICE ADDRESS并串行输出数据(DATA)</span><br><span class="line">5. 单片机响应NO ACK并紧跟生成STOP信号</span><br></pre></td></tr></table></figure>
<h4 id="at24c02的sequential-read(顺序读数据)操作">AT24C02的Sequential Read(顺序读数据)操作</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271838678.png" alt="Sequential Read"></p>
<p>与Page Write类似</p>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401271841941.png" alt="Sequential Read"></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">翻译: Sequential Read流程</span><br><span class="line"></span><br><span class="line">1. Sequntial Read从当前地址读取或随机地址开始读取</span><br><span class="line">2. 单片机收到DATA后，会响应ACK</span><br><span class="line">3. 只要EEPROM收到ACK响应，它就会继续递增数据地址，并顺序串行输出DATA</span><br><span class="line">4. 当达到内存地址限制时，数据地址将&quot;roll over&quot;，顺序读取将继续从头开始重新读取数据</span><br><span class="line">5. 当单片机NO ACK响应并生成STOP，则终止Sequential Read</span><br></pre></td></tr></table></figure>
<h3 id="i2c-读写eeprom实验">I2C-读写EEPROM实验</h3>
<p>项目地址: <strong>24-I2C-EEPROM</strong></p>
<h4 id="操作流程">操作流程</h4>
<ol>
<li>初始化I2C相关的GPIO</li>
<li>配置I2C外设的工作模式</li>
<li>编写I2C写入EEPROM的Byte Write函数</li>
<li>编写I2C读取EEPROM的Random Read函数</li>
<li>使用read函数和write函数进行读写校验</li>
<li>编写Page Write和Sequential Read函数进行校验</li>
</ol>
<h4 id="在bsp_i2ch中定义相关宏">在bsp_i2c.h中定义相关宏</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @defgroup I2C_EEPROM_Define </span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief I2C的宏定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C I2C1 <span class="comment">/*!&lt; EEPROM所使用的I2Cx */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_CLK RCC_APB1Periph_I2C1 <span class="comment">/*!&lt; I2C的时钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_APBxClkCmd RCC_APB1PeriphClockCmd <span class="comment">/*!&lt; I2C时钟的使能函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_BAUDRATE 400000 <span class="comment">/*!&lt; I2C的通信速率 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_I2C_OWN_ADDR 0x5F <span class="comment">/*!&lt; STM32在I2C总线上的自身地址, 可任意配置(只要在I2C总线上唯一即可) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_WRITE_ADDRESS 0xA0 <span class="comment">/*!&lt; EEPROM在I2C总线上的8位写地址 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_READ_ADDRESS 0xA1 <span class="comment">/*!&lt; EEPROM在I2C总线上的8位读地址 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief I2C的GPIO引脚宏定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_SCL_GPIO_CLK (RCC_APB2Periph_GPIOB) <span class="comment">/*!&lt; I2C的SCL引脚的GPIO时钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_SDA_GPIO_CLK (RCC_APB2Periph_GPIOB) <span class="comment">/*!&lt; I2C的SDA引脚的GPIO时钟 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd <span class="comment">/*!&lt; I2C的GPIO时钟的使能函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_SCL_GPIO_PORT GPIOB <span class="comment">/*!&lt; I2C的SCL引脚的GPIO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_SCL_GPIO_Pin GPIO_Pin_6 <span class="comment">/*!&lt; I2C的SCL引脚的GPIO引脚 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_SDA_GPIO_PORT GPIOB <span class="comment">/*!&lt; I2C的SDA引脚的GPIO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_SDA_GPIO_Pin GPIO_Pin_7 <span class="comment">/*!&lt; I2C的SDA引脚的GPIO引脚 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2ch中进行函数声明">在bsp_i2c.h中进行函数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @defgroup EEPROM_I2C_Functions </span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_EEPROM_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Byte_Writting</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Page_Writting</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span>* Data, <span class="type">uint8_t</span> NumByteToWrite)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Random_Read</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span>* Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Sequential_Read</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span>* Data, <span class="type">uint8_t</span> NumByteToRead)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_ACK_Polling</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @&#125; </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2cc中编写i2c_eeprom配置函数">在bsp_i2c.c中编写I2C_EEPROM配置函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief I2C EEPROM配置函数 </span></span><br><span class="line"><span class="comment"> * @param None</span></span><br><span class="line"><span class="comment"> * @retval None </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_EEPROM_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------------- 时钟配置 ------------------------------*/</span></span><br><span class="line">    <span class="comment">/* 使能I2C GPIO的时钟 */</span></span><br><span class="line">    EEPROM_I2C_GPIO_APBxClkCmd(EEPROM_I2C_SCL_GPIO_CLK | EEPROM_I2C_SDA_GPIO_CLK, ENABLE);</span><br><span class="line">    <span class="comment">/* 使能I2C的时钟 */</span></span><br><span class="line">    EEPROM_I2C_APBxClkCmd(EEPROM_I2C_CLK, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------------- I2C_SCL的GPIO配置 ------------------------------*/</span></span><br><span class="line">    <span class="comment">/* 配置引脚为I2C的SCL */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_GPIO_Pin;</span><br><span class="line">    <span class="comment">/* 配置输出速率为50MHz */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">/* 配置模式开漏复用输出 */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">    <span class="comment">/* 初始化I2C_SCL的GPIO配置 */</span> </span><br><span class="line">    GPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------------- I2C_SDA的GPIO配置 ------------------------------*/</span></span><br><span class="line">    <span class="comment">/* 配置引脚为I2C的SDA */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_GPIO_Pin;</span><br><span class="line">    <span class="comment">/* 配置输出速率为50MHz */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">/* 配置模式开漏复用输出 */</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">    <span class="comment">/* 初始化I2C_SDA的GPIO配置 */</span> </span><br><span class="line">    GPIO_Init(EEPROM_I2C_SDA_GPIO_PORT, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------------------------- I2C的工作模式配置 ------------------------------*/</span></span><br><span class="line">    <span class="comment">/* 使能响应 */</span></span><br><span class="line">    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">    <span class="comment">/* 使用7位地址 */</span></span><br><span class="line">    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class="line">    <span class="comment">/* 时钟频率 400kHz*/</span></span><br><span class="line">    I2C_InitStructure.I2C_ClockSpeed = EEPROM_I2C_BAUDRATE;</span><br><span class="line">    <span class="comment">/* 占空比 Tlow/Thigh = 2 */</span></span><br><span class="line">    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class="line">    <span class="comment">/* 模式 I2C */</span></span><br><span class="line">    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">    <span class="comment">/* STM32主机地址 */</span></span><br><span class="line">    I2C_InitStructure.I2C_OwnAddress1 = STM32_I2C_OWN_ADDR;</span><br><span class="line">    <span class="comment">/* 初始化I2C */</span></span><br><span class="line">    I2C_Init(EEPROM_I2C, &amp;I2C_InitStructure); </span><br><span class="line">    <span class="comment">/* 使能I2C */</span></span><br><span class="line">    I2C_Cmd(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2cc中编写byte-writting方式的函数">在bsp_i2c.c中编写Byte Writting方式的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数实现了STM32作为主发送器向EEPROM以Byte Writting的方式写数据 </span></span><br><span class="line"><span class="comment"> * @param WordAddress: 需要写入的字节所在的地址</span></span><br><span class="line"><span class="comment"> * @param Data: 真正要写入的内容</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Byte_Writting</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32产生START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的写地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="comment">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class="line">    <span class="comment">/* STM32向EEPROM发送WordAddress */</span></span><br><span class="line">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class="line">    <span class="comment">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*---------------- STM32发送Data ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32向EEPROM发送Data */</span></span><br><span class="line">    I2C_SendData(EEPROM_I2C, Data);</span><br><span class="line">    <span class="comment">/* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32产生STOP信号 */</span></span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class="line">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2cc中编写page-writting方式的函数">在bsp_i2c.c中编写Page Writting方式的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数实现了STM32作为主发送器向EEPROM以Page Writting的方式写数据(每次不超过8字节) </span></span><br><span class="line"><span class="comment"> * @param WordAddress: 需要写入的字节所在的地址</span></span><br><span class="line"><span class="comment"> * @param Data: 真正要写入的数据的指针</span></span><br><span class="line"><span class="comment"> * @param NumByteToWrite: 要写入数据的个数小于8</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Page_Writting</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span>* Data, <span class="type">uint8_t</span> NumByteToWrite)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32产生START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的写地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="comment">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class="line">    <span class="comment">/* STM32向EEPROM发送WordAddress */</span></span><br><span class="line">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class="line">    <span class="comment">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*---------------- STM32发送Data ----------------*/</span></span><br><span class="line">    <span class="comment">/* 循环写入数据 */</span></span><br><span class="line">    <span class="keyword">while</span>(NumByteToWrite)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* STM32向EEPROM发送Data */</span></span><br><span class="line">        I2C_SendData(EEPROM_I2C, *Data);</span><br><span class="line">        <span class="comment">/* 数据指针自增 */</span></span><br><span class="line">        Data++;</span><br><span class="line">        <span class="comment">/* 等待EV8_2事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">        <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">        ;</span><br><span class="line">        &#125;</span><br><span class="line">        NumByteToWrite--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32产生STOP信号 */</span></span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class="line">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2cc中编写random-read方式的函数">在bsp_i2c.c中编写Random Read方式的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数实现STM32从EEPROM以Random Read方式读取数据</span></span><br><span class="line"><span class="comment"> * @param WordAddress: 要读取数据的地址</span></span><br><span class="line"><span class="comment"> * @param Data: 读取数据要写入到的变量</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Random_Read</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span>* Data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32产生START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的写地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="comment">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class="line">    <span class="comment">/* STM32向EEPROM发送WordAddress */</span></span><br><span class="line">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class="line">    <span class="comment">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*---------------- STM32接收Data ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32另外产生一个START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的读地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);</span><br><span class="line">    <span class="comment">/* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    * 注意: </span></span><br><span class="line"><span class="comment">    * 该部分为STM32接收来自EEPROM的数据</span></span><br><span class="line"><span class="comment">    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作</span></span><br><span class="line"><span class="comment">    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据</span></span><br><span class="line"><span class="comment">    * 而不是进行数据接收</span></span><br><span class="line"><span class="comment">    *------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 监测到EV7事件发生, 说明接收到了新数据 */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将接收到的数据赋值给Data变量 */</span></span><br><span class="line">    *Data = I2C_ReceiveData(EEPROM_I2C);</span><br><span class="line">    <span class="comment">/* STM32产生NO ACK响应 */</span></span><br><span class="line">    I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);</span><br><span class="line">    <span class="comment">/* STM32产生STOP信号 */</span></span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2cc中编写sequential-read方式的函数">在bsp_i2c.c中编写Sequential Read方式的函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数实现STM32从EEPROM以Sequential Read方式读取数据</span></span><br><span class="line"><span class="comment"> * @param WordAddress: 要读取数据的地址</span></span><br><span class="line"><span class="comment"> * @param Data: 读取数据要写入到的变量</span></span><br><span class="line"><span class="comment"> * @param NumByteToRead: 要读取数据的个数</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Sequential_Read</span><span class="params">(<span class="type">uint8_t</span> WordAddress, <span class="type">uint8_t</span>* Data, <span class="type">uint8_t</span> NumByteToRead)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*---------------- STM32发送WordAddress ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32产生START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的写地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="comment">/* 等待EV6事件(发送)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">      ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 不检测EV8事件(I2C_SRx:TxE[7] = 1, 数据寄存器空很正常, 不进行检测) */</span></span><br><span class="line">    <span class="comment">/* STM32向EEPROM发送WordAddress */</span></span><br><span class="line">    I2C_SendData(EEPROM_I2C, WordAddress);</span><br><span class="line">    <span class="comment">/* 等待EV8事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*---------------- STM32接收Data ----------------*/</span></span><br><span class="line">    <span class="comment">/* STM32另外产生一个START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_MODE_SELECT) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的读地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_READ_ADDRESS, I2C_Direction_Receiver);</span><br><span class="line">    <span class="comment">/* 等待EV6事件(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    * 注意: </span></span><br><span class="line"><span class="comment">    * 该部分为STM32接收来自EEPROM的数据</span></span><br><span class="line"><span class="comment">    * 接收数据部分, 硬件会自动进行接收, 软件编程时无需操作</span></span><br><span class="line"><span class="comment">    * I2C_ReceiveData函数只是返回I2Cx上最近接收到的数据</span></span><br><span class="line"><span class="comment">    * 而不是进行数据接收</span></span><br><span class="line"><span class="comment">    *------------------------------------------------------------------------*/</span></span><br><span class="line">    <span class="keyword">while</span>(NumByteToRead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NumByteToRead == <span class="number">1</span>) <span class="comment">/* 如果为最后一个字节, 产生NO ACK响应 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* STM32产生NO ACK响应 */</span></span><br><span class="line">            I2C_AcknowledgeConfig(EEPROM_I2C, DISABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 监测到EV7事件发生, 说明接收到了新数据 */</span></span><br><span class="line">        <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED ) == ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将接收到的数据赋值给Data变量 */</span></span><br><span class="line">        *Data = I2C_ReceiveData(EEPROM_I2C);</span><br><span class="line">        <span class="comment">/* Data 指针自增 */</span></span><br><span class="line">        Data++;</span><br><span class="line">        <span class="comment">/* NumByteToRead递减 */</span></span><br><span class="line">        NumByteToRead--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32产生STOP信号 */</span></span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* STM32使能ACK信号, 恢复到默认状态 */</span></span><br><span class="line">    I2C_AcknowledgeConfig(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在bsp_i2cc中编写确认询问函数">在bsp_i2c.c中编写确认询问函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief ACKNOWLEDGE POLLING 对EEPROM进行确认轮询</span></span><br><span class="line"><span class="comment"> *   一旦内部定时写周期开始并且EEPROM输入被禁用，可以启动确认轮询。</span></span><br><span class="line"><span class="comment"> *   这涉及发送一个启动条件，后跟设备地址。</span></span><br><span class="line"><span class="comment"> *   读/写位是代表所需的操作。</span></span><br><span class="line"><span class="comment"> *   仅当内部写周期完成时EEPROM 会响应“0”，允许继续读取或写入序列</span></span><br><span class="line"><span class="comment"> *   以上步骤称为ACKNOWLEDGE POLLING</span></span><br><span class="line"><span class="comment"> * @param None</span></span><br><span class="line"><span class="comment"> * @retval None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_ACK_Polling</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* STM32产生START信号 */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2C, ENABLE);</span><br><span class="line">    <span class="comment">/* 等待EV5事件完成, SB=1(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="keyword">while</span>(I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_SB) == RESET)</span><br><span class="line">    &#123;</span><br><span class="line">       ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* STM32发送EEPROM的写地址 */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2C, EEPROM_I2C_WRITE_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">    &#125; <span class="keyword">while</span> (I2C_GetFlagStatus(EEPROM_I2C, I2C_FLAG_ADDR) == RESET); </span><br><span class="line">    <span class="comment">/* 循环监测EV6事件(ADDR=1)(接收)完成(未设置检测时间超时, 不严谨) */</span></span><br><span class="line">    <span class="comment">/* 结束轮询 */</span></span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2C, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在mainc中进行读写测试">在main.c中进行读写测试</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    main.c</span></span><br><span class="line"><span class="comment">  * @author  eric</span></span><br><span class="line"><span class="comment">  * @version V0.0.1</span></span><br><span class="line"><span class="comment">  * @date    27-January-2024</span></span><br><span class="line"><span class="comment">  * @brief   STM32与EEPROM通过I2C协议进行读写测试</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * THE PRESENT FUNTIONS WHICH IS FOR GUIDANCE ONLY</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_i2c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 操作流程:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 初始化I2C相关的GPIO</span></span><br><span class="line"><span class="comment"> * 2. 配置I2C外设的工作模式</span></span><br><span class="line"><span class="comment"> * 3. 编写I2C写入EEPROM的Byte Write函数 </span></span><br><span class="line"><span class="comment"> * 4. 编写I2C读取EEPROM的Random Read函数</span></span><br><span class="line"><span class="comment"> * 5. 使用read函数和write函数进行读写校验</span></span><br><span class="line"><span class="comment"> * 6. 编写Page Write和Sequential Read函数进行校验</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @defgroup: Global_Values</span></span><br><span class="line"><span class="comment"> * @&#123;  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ReadData[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> WriteData[<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @&#125; </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief STM32与EEPROM通过I2C协议进行读写测试 </span></span><br><span class="line"><span class="comment"> * @param None</span></span><br><span class="line"><span class="comment"> * @retval None </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化USART */</span></span><br><span class="line">    USART_Config(); </span><br><span class="line">    <span class="comment">/* 串口打印 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I2C-EEPROM\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 初始化I2C */</span></span><br><span class="line">    I2C_EEPROM_Config();</span><br><span class="line">    <span class="comment">/* STM32向EEPROM 地址1写入数据0x01 */</span></span><br><span class="line">    EEPROM_Byte_Writting(<span class="number">1</span>, <span class="number">0x01</span>);</span><br><span class="line">    <span class="comment">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class="line">    EEPROM_ACK_Polling();</span><br><span class="line">    <span class="comment">/* STM32向EEPROM 地址2写入数据0x02 */</span></span><br><span class="line">    EEPROM_Byte_Writting(<span class="number">2</span>, <span class="number">0x02</span>);</span><br><span class="line">    <span class="comment">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class="line">    EEPROM_ACK_Polling();</span><br><span class="line">    <span class="comment">/*----------------------------------------</span></span><br><span class="line"><span class="comment">     * Page Writting的地址对齐</span></span><br><span class="line"><span class="comment">     * 为保证数据无误需addr%8 == 0</span></span><br><span class="line"><span class="comment">     *----------------------------------------*/</span> </span><br><span class="line">    <span class="comment">/* STM32向EEPROM 地址3-5写入数据0x03-0x05 */</span></span><br><span class="line">    EEPROM_Page_Writting(<span class="number">0x03</span>, WriteData, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* ACKNOWLEDGE POLLING 确认询问 */</span></span><br><span class="line">    EEPROM_ACK_Polling();</span><br><span class="line">    <span class="comment">/* STM32从EEPROM以SequentialRead方式读取地址1-4的数据 */</span> </span><br><span class="line">    EEPROM_Sequential_Read((<span class="type">uint8_t</span>)<span class="number">1</span>, ReadData, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/* STM32从EEPROM以RandomRead方式读取地址5的数据 */</span> </span><br><span class="line">    EEPROM_Random_Read((<span class="type">uint8_t</span>)<span class="number">5</span>, &amp;ReadData[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">/* 将读出的数据循环打印 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ReadData[%d] = 0x%x\n&quot;</span>, i, ReadData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 空循环 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="串口实验现象">串口实验现象</h4>
<p><img data-src="https://raw.githubusercontent.com/See-YouL/MarkdownPhotos/main/202401280831099.png" alt="实验现象"></p>
<h4 id="完善功能">完善功能</h4>
<p>以下函数是对实验中出现函数的进一步完善, 源文件不在工程中</p>
<h5 id="增加的宏定义">增加的宏定义</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* STM32 I2C 快速模式 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Speed              400000  <span class="comment">//*</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2Cx_OWN_ADDRESS7      0X0A   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AT24C01/02每页有8个字节 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_PageSize           8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AT24C04/08A/16A每页有16个字节 */</span></span><br><span class="line"><span class="comment">//#define I2C_PageSize           16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待超时时间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT)</span></span><br></pre></td></tr></table></figure>
<h5 id="调试功能">调试功能</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_DEBUG_ON         0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_INFO(fmt,arg...)           printf(<span class="string">&quot;&lt;&lt;-EEPROM-INFO-&gt;&gt; &quot;</span>fmt<span class="string">&quot;\n&quot;</span>,##arg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_ERROR(fmt,arg...)          printf(<span class="string">&quot;&lt;&lt;-EEPROM-ERROR-&gt;&gt; &quot;</span>fmt<span class="string">&quot;\n&quot;</span>,##arg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_DEBUG(fmt,arg...)          do&#123;\</span></span><br><span class="line"><span class="meta">                                          <span class="keyword">if</span>(EEPROM_DEBUG_ON)\</span></span><br><span class="line"><span class="meta">                                          printf(<span class="string">&quot;&lt;&lt;-EEPROM-DEBUG-&gt;&gt; [%s][%d]&quot;</span>fmt<span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, ##arg);\</span></span><br><span class="line"><span class="meta">                                          &#125;while(0)</span></span><br></pre></td></tr></table></figure>
<h5 id="超时处理函数">超时处理函数</h5>
<p>完善了对于超时的处理</p>
<h6 id="超时处理相关宏定义">超时处理相关宏定义</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*等待超时时间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CT_FLAG_TIMEOUT         ((uint32_t)0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2CT_LONG_TIMEOUT         ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))</span></span><br></pre></td></tr></table></figure>
<h6 id="超时处理相关变量声明">超时处理相关变量声明</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __IO <span class="type">uint32_t</span>  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">I2C_TIMEOUT_UserCallback</span><span class="params">(<span class="type">uint8_t</span> errorCode)</span>;</span><br></pre></td></tr></table></figure>
<h6 id="超时状态函数">超时状态函数</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Basic management of the timeout situation.</span></span><br><span class="line"><span class="comment">  * @param  errorCode：错误代码，可以用来定位是哪个环节出错.</span></span><br><span class="line"><span class="comment">  * @retval 返回0，表示IIC读取失败.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span>  <span class="type">uint32_t</span> <span class="title function_">I2C_TIMEOUT_UserCallback</span><span class="params">(<span class="type">uint8_t</span> errorCode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Block communication and all processes */</span></span><br><span class="line">  EEPROM_ERROR(<span class="string">&quot;I2C 等待超时!errorCode = %d&quot;</span>,errorCode);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多字节写入函数">多字节写入函数</h5>
<p>完善了在Page Write中字节对齐的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   将缓冲区中的数据写到I2C EEPROM中</span></span><br><span class="line"><span class="comment">  * @param   </span></span><br><span class="line"><span class="comment">  *  @arg pBuffer:缓冲区指针</span></span><br><span class="line"><span class="comment">  *  @arg WriteAddr:写地址</span></span><br><span class="line"><span class="comment">  *     @arg NumByteToWrite:写的字节数</span></span><br><span class="line"><span class="comment">  * @retval  无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_EE_BufferWrite</span><span class="params">(u8* pBuffer, u8 WriteAddr, u16 NumByteToWrite)</span></span><br><span class="line">&#123;</span><br><span class="line">  u8 NumOfPage = <span class="number">0</span>, NumOfSingle = <span class="number">0</span>, Addr = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Addr = WriteAddr % I2C_PageSize;</span><br><span class="line">  count = I2C_PageSize - Addr;</span><br><span class="line">  NumOfPage =  NumByteToWrite / I2C_PageSize;</span><br><span class="line">  NumOfSingle = NumByteToWrite % I2C_PageSize;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* If WriteAddr is I2C_PageSize aligned  */</span></span><br><span class="line">  <span class="keyword">if</span>(Addr == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* If NumByteToWrite &lt; I2C_PageSize */</span></span><br><span class="line">    <span class="keyword">if</span>(NumOfPage == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class="line">      I2C_EE_WaitEepromStandbyState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If NumByteToWrite &gt; I2C_PageSize */</span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(NumOfPage--)</span><br><span class="line">      &#123;</span><br><span class="line">        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); </span><br><span class="line">     I2C_EE_WaitEepromStandbyState();</span><br><span class="line">        WriteAddr +=  I2C_PageSize;</span><br><span class="line">        pBuffer += I2C_PageSize;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(NumOfSingle!=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class="line">        I2C_EE_WaitEepromStandbyState();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If WriteAddr is not I2C_PageSize aligned  */</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* If NumByteToWrite &lt; I2C_PageSize */</span></span><br><span class="line">    <span class="keyword">if</span>(NumOfPage== <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</span><br><span class="line">      I2C_EE_WaitEepromStandbyState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If NumByteToWrite &gt; I2C_PageSize */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      NumByteToWrite -= count;</span><br><span class="line">      NumOfPage =  NumByteToWrite / I2C_PageSize;</span><br><span class="line">      NumOfSingle = NumByteToWrite % I2C_PageSize; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(count != <span class="number">0</span>)</span><br><span class="line">      &#123;  </span><br><span class="line">        I2C_EE_PageWrite(pBuffer, WriteAddr, count);</span><br><span class="line">        I2C_EE_WaitEepromStandbyState();</span><br><span class="line">        WriteAddr += count;</span><br><span class="line">        pBuffer += count;</span><br><span class="line">      &#125; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(NumOfPage--)</span><br><span class="line">      &#123;</span><br><span class="line">        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);</span><br><span class="line">        I2C_EE_WaitEepromStandbyState();</span><br><span class="line">        WriteAddr +=  I2C_PageSize;</span><br><span class="line">        pBuffer += I2C_PageSize;  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(NumOfSingle != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); </span><br><span class="line">        I2C_EE_WaitEepromStandbyState();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单字节写入函数">单字节写入函数</h5>
<p>增加超时处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   写一个字节到I2C EEPROM中</span></span><br><span class="line"><span class="comment">  * @param   </span></span><br><span class="line"><span class="comment">  * @arg pBuffer:缓冲区指针</span></span><br><span class="line"><span class="comment">  * @arg WriteAddr:写地址 </span></span><br><span class="line"><span class="comment">  * @retval  无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_EE_ByteWrite</span><span class="params">(u8* pBuffer, u8 WriteAddr)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Send START condition */</span></span><br><span class="line">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class="line"></span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;  </span><br><span class="line">  <span class="comment">/* Test on EV5 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Send EEPROM address for write */</span></span><br><span class="line">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Test on EV6 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">1</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/* Send the EEPROM&#x27;s internal address to write to */</span></span><br><span class="line">  I2C_SendData(EEPROM_I2Cx, WriteAddr);</span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV8 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">2</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send the byte to be written */</span></span><br><span class="line">  I2C_SendData(EEPROM_I2Cx, *pBuffer); </span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;  </span><br><span class="line">  <span class="comment">/* Test on EV8 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">3</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send STOP condition */</span></span><br><span class="line">  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单页写入函数">单页写入函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数</span></span><br><span class="line"><span class="comment">  *          不能超过EEPROM页的大小，AT24C02每页有8个字节</span></span><br><span class="line"><span class="comment">  * @param   </span></span><br><span class="line"><span class="comment">  *     @arg pBuffer:缓冲区指针</span></span><br><span class="line"><span class="comment">  *     @arg WriteAddr:写地址</span></span><br><span class="line"><span class="comment">  *     @arg NumByteToWrite:写的字节数</span></span><br><span class="line"><span class="comment">  * @retval  无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_EE_PageWrite</span><span class="params">(u8* pBuffer, u8 WriteAddr, u8 NumByteToWrite)</span></span><br><span class="line">&#123;</span><br><span class="line">  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))   </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">4</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send START condition */</span></span><br><span class="line">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV5 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">5</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send EEPROM address for write */</span></span><br><span class="line">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV6 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">6</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send the EEPROM&#x27;s internal address to write to */</span>    </span><br><span class="line">  I2C_SendData(EEPROM_I2Cx, WriteAddr);  </span><br><span class="line"></span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV8 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(! I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">7</span>);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While there is data to be written */</span></span><br><span class="line">  <span class="keyword">while</span>(NumByteToWrite--)  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Send the current byte */</span></span><br><span class="line">    I2C_SendData(EEPROM_I2Cx, *pBuffer); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Point to the next byte to be written */</span></span><br><span class="line">    pBuffer++; </span><br><span class="line">  </span><br><span class="line">    I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test on EV8 and clear it */</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">8</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send STOP condition */</span></span><br><span class="line">  I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="读取数据函数">读取数据函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   从EEPROM里面读取一块数据 </span></span><br><span class="line"><span class="comment">  * @param   </span></span><br><span class="line"><span class="comment">  *     @arg pBuffer:存放从EEPROM读取的数据的缓冲区指针</span></span><br><span class="line"><span class="comment">  *     @arg WriteAddr:接收数据的EEPROM的地址</span></span><br><span class="line"><span class="comment">  *     @arg NumByteToWrite:要从EEPROM读取的字节数</span></span><br><span class="line"><span class="comment">  * @retval  无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_EE_BufferRead</span><span class="params">(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)</span></span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//*((u8 *)0x4001080c) |=0x80; </span></span><br><span class="line">  <span class="keyword">while</span>(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">9</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send START condition */</span></span><br><span class="line">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class="line">  <span class="comment">//*((u8 *)0x4001080c) &amp;=~0x80;</span></span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV5 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Send EEPROM address for write */</span></span><br><span class="line">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line"></span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV6 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">11</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Clear EV6 by setting again the PE bit */</span></span><br><span class="line">  I2C_Cmd(EEPROM_I2Cx, ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send the EEPROM&#x27;s internal address to write to */</span></span><br><span class="line">  I2C_SendData(EEPROM_I2Cx, ReadAddr);  </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV8 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">12</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Send START condition a second time */</span>  </span><br><span class="line">  I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV5 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">13</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Send EEPROM address for read */</span></span><br><span class="line">  I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver);</span><br><span class="line">  </span><br><span class="line">  I2CTimeout = I2CT_FLAG_TIMEOUT;</span><br><span class="line">  <span class="comment">/* Test on EV6 and clear it */</span></span><br><span class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">14</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* While there is data to be read */</span></span><br><span class="line">  <span class="keyword">while</span>(NumByteToRead)  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(NumByteToRead == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Disable Acknowledgement */</span></span><br><span class="line">      I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* Send STOP Condition */</span></span><br><span class="line">      I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test on EV7 and clear it */</span>    </span><br><span class="line">    I2CTimeout = I2CT_LONG_TIMEOUT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==<span class="number">0</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((I2CTimeout--) == <span class="number">0</span>) <span class="keyword">return</span> I2C_TIMEOUT_UserCallback(<span class="number">3</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    &#123;      </span><br><span class="line">      <span class="comment">/* Read a byte from the EEPROM */</span></span><br><span class="line">      *pBuffer = I2C_ReceiveData(EEPROM_I2Cx);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Point to the next location where the byte read will be saved */</span></span><br><span class="line">      pBuffer++; </span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* Decrement the read bytes counter */</span></span><br><span class="line">      NumByteToRead--;        </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable Acknowledgement to be ready for another reception */</span></span><br><span class="line">  I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="等待eeprom函数">等待EEPROM函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Wait for EEPROM Standby state </span></span><br><span class="line"><span class="comment">  * @param  无</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_EE_WaitEepromStandbyState</span><span class="params">(<span class="type">void</span>)</span>      </span><br><span class="line">&#123;</span><br><span class="line">  vu16 SR1_Tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Send START condition */</span></span><br><span class="line">    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);</span><br><span class="line">    <span class="comment">/* Read I2C1 SR1 register */</span></span><br><span class="line">    SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1);</span><br><span class="line">    <span class="comment">/* Send EEPROM address for write */</span></span><br><span class="line">    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">  &#125;<span class="keyword">while</span>(!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) &amp; <span class="number">0x0002</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Clear AF flag */</span></span><br><span class="line">  I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF);</span><br><span class="line">    <span class="comment">/* STOP condition */</span>    </span><br><span class="line">    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag"># 嵌入式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/17/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="prev" title="Git常用命令">
      <i class="fa fa-chevron-left"></i> Git常用命令
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/17/%E6%B3%A2%E7%89%B9%E7%8E%87%E4%B8%8E%E6%AF%94%E7%89%B9%E7%8E%87/" rel="next" title="波特率与比特率">
      波特率与比特率 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#stm32f103%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">STM32F103学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.</span> <span class="nav-text">基础配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEkeilmdk"><span class="nav-number">1.2.1.</span> <span class="nav-text">配置KeilMDK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">配置串口下载程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BE%8E%E5%8C%96keil%E7%95%8C%E9%9D%A2"><span class="nav-number">1.2.3.</span> <span class="nav-text">美化Keil界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEvscode"><span class="nav-number">1.2.4.</span> <span class="nav-text">配置VScode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="nav-number">1.3.</span> <span class="nav-text">理论知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stm32%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">STM32命名方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%AE%E4%BD%8D%E4%B8%8E%E6%B8%85%E9%9B%B6"><span class="nav-number">1.4.</span> <span class="nav-text">置位与清零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gpio"><span class="nav-number">1.5.</span> <span class="nav-text">GPIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gpio%E7%AE%80%E4%BB%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">GPIO简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gpio%E5%92%8C%E5%BC%95%E8%84%9A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">GPIO和引脚的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%84%9A%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">引脚的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gpio-%E6%A1%86%E5%9B%BE%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.5.2.</span> <span class="nav-text">GPIO 框图讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E4%BA%8C%E6%9E%81%E7%AE%A1"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">保护二极管</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">推挽输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">推挽输出的含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.2.2.2.</span> <span class="nav-text">推挽输出的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.2.2.3.</span> <span class="nav-text">推挽输出的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.5.2.2.4.</span> <span class="nav-text">推挽输出的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E5%AF%B9%E6%AF%94%E5%BC%80%E6%BC%8F/%E5%BC%80%E9%9B%86%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.2.2.5.</span> <span class="nav-text">推挽输出对比开漏&#x2F;开集输出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">开漏输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">开漏输出的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">开漏输出的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.5.2.3.3.</span> <span class="nav-text">开漏输出的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E5%AF%B9%E6%AF%94%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.2.3.4.</span> <span class="nav-text">开漏输出对比推挽输出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E9%AB%98%E9%98%BB%E6%80%81%E4%B8%8E%E6%82%AC%E7%A9%BA"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">补充: 高阻态与悬空</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E9%98%BB%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.5.2.4.1.</span> <span class="nav-text">高阻态的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E9%98%BB%E6%80%81%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.5.2.4.2.</span> <span class="nav-text">高阻态的重要性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E9%98%BB%E6%80%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.5.2.4.3.</span> <span class="nav-text">高阻态的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%82%AC%E7%A9%BA%E7%8A%B6%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.2.4.4.</span> <span class="nav-text">悬空状态的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E9%98%BB%E6%80%81%E4%B8%8E%E6%82%AC%E7%A9%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.5.2.4.5.</span> <span class="nav-text">高阻态与悬空的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E9%98%BB%E6%80%81%E4%B8%8E%E6%82%AC%E7%A9%BA%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">1.5.2.4.6.</span> <span class="nav-text">高阻态与悬空区别和联系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%82%AC%E7%A9%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.5.2.4.7.</span> <span class="nav-text">悬空的注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E8%BE%93%E5%87%BA"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">复用功能输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">输入模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gpio%E6%A1%86%E5%9B%BE%E5%AF%B9%E5%BA%94%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">GPIO框图对应寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gpio%E8%BE%93%E5%87%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.5.3.</span> <span class="nav-text">GPIO输出初始化顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E5%BA%93"><span class="nav-number">1.6.</span> <span class="nav-text">手写库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%9C%B0%E5%9D%80%E4%BD%BF%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">通过地址使用寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mainc%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">main.c中的主要代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.6.2.</span> <span class="nav-text">通过头文件定义使用寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10xh%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">在stm32f10x.h中增加宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E7%9A%84%E4%B8%BB%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E6%94%B9%E4%B8%BA"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">在main.c中的主函数代码改为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E5%85%B3%E9%94%AE%E5%AD%97volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">补充: 关键字volatile的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%90%AB%E4%B9%89"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">关键字volatile含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97volatile%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">关键字volatile的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97volative%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">关键字volative的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%BB%93%E6%9E%84%E4%BD%93%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.6.3.</span> <span class="nav-text">通过结构体操作寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10xh%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">在stm32f10x.h中添加结构体定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10xh%E4%B8%AD%E5%A2%9E%E5%8A%A0rcc%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89,%E5%A6%82%E4%B8%8B"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">在stm32f10x.h中增加RCC的结构体定义,如下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E9%80%9A%E8%BF%87%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BF%E9%97%AErcc%E5%AF%84%E5%AD%98%E5%99%A8,%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">在main.c中通过结构体访问RCC寄存器,代码如下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%8D%A2led%E8%AF%B4%E6%98%8E"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">更换LED说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E7%AB%AF%E5%8F%A3%E7%BD%AE%E4%BD%8D/%E5%A4%8D%E4%BD%8D%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.4.</span> <span class="nav-text">增加端口置位&#x2F;复位函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10x_gpioc%E4%B8%AD%E5%A2%9E%E5%8A%A0%E7%BD%AE%E4%BD%8D/%E5%A4%8D%E4%BD%8D%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">在stm32f10x_gpio.c中增加置位&#x2F;复位函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10x_gpioh%E4%B8%AD%E6%B7%BB%E5%8A%A016%E4%BD%8Dpin%E7%BD%AE1%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">在stm32f10x_gpio.h中添加16位PIN置1的宏定义与函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BD%AE%E4%BD%8D/%E5%A4%8D%E4%BD%8D%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">在main.c函数中使用置位&#x2F;复位函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10xh%E4%B8%AD%E5%A2%9E%E5%8A%A0#ifndef"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">在stm32f10x.h中增加#ifndef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E5%9C%A8c%E8%AF%AD%E8%A8%80%E4%B8%AD#ifndef%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.6.4.5.</span> <span class="nav-text">补充: 在C语言中#ifndef的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ifndef%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.6.4.5.1.</span> <span class="nav-text">ifndef的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ifndef%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.4.5.2.</span> <span class="nav-text">ifndef的使用方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ifndef%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.6.4.5.3.</span> <span class="nav-text">ifndef的重要性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E4%BD%BF%E7%94%A8#ifndef%E5%91%BD%E5%90%8D%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E8%AF%B4%E6%98%8E"><span class="nav-number">1.6.4.6.</span> <span class="nav-text">补充: 使用#ifndef命名使用双下划线说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.6.4.6.1.</span> <span class="nav-text">使用双下划线的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.6.4.6.2.</span> <span class="nav-text">使用双下划线的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.6.4.6.3.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0gpio%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.6.5.</span> <span class="nav-text">增加GPIO初始化结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10x_gpioh%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">在stm32f10x_gpio.h中增加宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10x_gpioc%E4%B8%AD%E5%86%99%E5%85%A5gpio%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">在stm32f10x_gpio.c中写入GPIO初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E4%BD%BF%E7%94%A8gpio%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">在main.c中使用GPIO初始化函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9D%A5%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="nav-number">1.6.6.</span> <span class="nav-text">增加宏定义来增强代码可移植性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">在main.c中增加宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0led%E9%97%AA%E7%83%81"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">在main.c中使用宏定义后的代码实现LED闪烁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%BC%96%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">固件库编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stm32%E5%9B%BA%E4%BB%B6%E5%BA%93%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="nav-number">1.7.1.</span> <span class="nav-text">STM32固件库文件分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%89%88%E6%9C%AC%E5%B7%A5%E7%A8%8B"><span class="nav-number">1.7.2.</span> <span class="nav-text">新建固件库版本工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gpio%E8%BE%93%E5%87%BA-%E4%BD%BF%E7%94%A8%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%82%B9%E4%BA%AEled"><span class="nav-number">1.7.3.</span> <span class="nav-text">GPIO输出-使用固件库点亮LED</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledh%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">在bsp_led.h中添加所使用的宏定义和函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledc%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">在bsp_led.c中添加初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%BD%AF%E4%BB%B6%E5%BB%B6%E6%97%B6%EF%BC%8C%E5%AE%9E%E7%8E%B0led%E9%97%AA%E7%83%81"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">在main.c中调用初始化函数，并进行软件延时，实现LED闪烁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledh%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%87%BD%E6%95%B0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">在bsp_led.h中增加函数宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">在main.c中使用宏定义的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-c%E8%AF%AD%E8%A8%80%E5%8F%8D%E6%96%9C%E6%9D%A0%5C%E6%8D%A2%E8%A1%8C"><span class="nav-number">1.7.3.6.</span> <span class="nav-text">补充: C语言反斜杠\换行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%8F%8D%E6%96%9C%E6%9D%A0%5C%E6%8D%A2%E8%A1%8C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.7.3.6.1.</span> <span class="nav-text">C语言反斜杠\换行的注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%8F%8D%E6%96%9C%E6%9D%A0%5C%E6%8D%A2%E8%A1%8C%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.3.6.2.</span> <span class="nav-text">C语言反斜杠\换行的示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gpio%E8%BE%93%E5%85%A5"><span class="nav-number">1.7.4.</span> <span class="nav-text">GPIO输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledh%E4%B8%AD%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%94%B5%E5%B9%B3%E7%BF%BB%E8%BD%AC%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">在bsp_led.h中宏定义电平翻转函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_keyh%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">在bsp_key.h中进行宏定义和函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_keyc%E4%B8%AD%E5%86%99%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">在bsp_key.c中写初始化函数和端口扫描函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">在main.c中进行调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.4.5.</span> <span class="nav-text">补充: C语言中的异或操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.7.4.5.1.</span> <span class="nav-text">C语言异或运算的特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.7.4.5.2.</span> <span class="nav-text">C语言异或操作的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.4.5.3.</span> <span class="nav-text">C语言异或操作的示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.</span> <span class="nav-text">位带操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%B8%A6%E7%AE%80%E4%BB%8B"><span class="nav-number">1.8.1.</span> <span class="nav-text">位带简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.2.</span> <span class="nav-text">位带操作的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">1.8.3.</span> <span class="nav-text">位带操作的地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.8.4.</span> <span class="nav-text">位带操作的示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.8.5.</span> <span class="nav-text">位带操作的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0gpio%E7%9A%84%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5"><span class="nav-number">1.8.6.</span> <span class="nav-text">使用位带操作实现GPIO的输出和输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">在main.c中添加位带操作的宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%82%B9%E7%81%AF"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">在main.c中使用位带操作点灯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_keyh%E4%B8%AD%E6%B7%BB%E5%8A%A0key2%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.8.6.3.</span> <span class="nav-text">在bsp_key.h中添加KEY2的宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bspc%E4%B8%AD%E5%A2%9E%E5%8A%A0key2%E7%9A%84gpio%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.8.6.4.</span> <span class="nav-text">在bsp.c中增加KEY2的GPIO初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E6%B7%BB%E5%8A%A0gpio%E8%BE%93%E5%85%A5%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.8.6.5.</span> <span class="nav-text">在main.c中添加GPIO输入位带操作的宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E6%B5%8B%E8%AF%95led%E9%97%AA%E7%83%81"><span class="nav-number">1.8.6.6.</span> <span class="nav-text">在main.c中测试LED闪烁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.9.</span> <span class="nav-text">启动文件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equ%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.1.</span> <span class="nav-text">EQU指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equ%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">EQU手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#area%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.2.</span> <span class="nav-text">AREA指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#area%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">AREA手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#space%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.3.</span> <span class="nav-text">SPACE指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#space%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">SPACE手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#preserve8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.4.</span> <span class="nav-text">PRESERVE8指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#preserve8%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">PRESERVE8手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thumb%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.5.</span> <span class="nav-text">THUMB指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#thumb%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">THUMB手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#export%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.6.</span> <span class="nav-text">EXPORT指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#export%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">EXPORT手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dcd%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.7.</span> <span class="nav-text">DCD指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dcd%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.7.1.</span> <span class="nav-text">DCD手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proc%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.8.</span> <span class="nav-text">PROC指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#proc%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.8.1.</span> <span class="nav-text">PROC手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.9.</span> <span class="nav-text">IMPORT指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#import%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.9.1.</span> <span class="nav-text">IMPORT手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ldr%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.10.</span> <span class="nav-text">LDR指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ldr%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.10.1.</span> <span class="nav-text">LDR手册说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#blx%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.11.</span> <span class="nav-text">BLX指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bx%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.12.</span> <span class="nav-text">BX指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#align%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.13.</span> <span class="nav-text">ALIGN指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#align%E6%89%8B%E5%86%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.13.1.</span> <span class="nav-text">ALIGN手册说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%92%9F"><span class="nav-number">1.10.</span> <span class="nav-text">时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE"><span class="nav-number">1.10.1.</span> <span class="nav-text">时钟系统框图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sysclk%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E6%BA%90%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">SYSCLK系统时钟源选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sysclk-%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.1.1.1.</span> <span class="nav-text">SYSCLK 系统时钟的选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pll%E9%94%81%E7%9B%B8%E7%8E%AF%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.1.1.2.</span> <span class="nav-text">PLL锁相环的选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rtcclk%E6%97%B6%E9%92%9F%E6%BA%90%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">RTCCLK时钟源选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#rtc_clk(rtc-%E6%97%B6%E9%92%9F)%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.1.2.1.</span> <span class="nav-text">RTC_CLK(RTC 时钟)的选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iwdgclk%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E6%97%B6%E9%92%9F%E6%BA%90"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">IWDGCLK独立看门狗时钟源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mco-%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">MCO 的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%B1%BB%E6%80%BB%E7%BA%BF%E6%97%B6%E9%92%9F"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">各类总线时钟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.10.1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0-setsysclockto72()%E5%88%86%E6%9E%90"><span class="nav-number">1.10.2.</span> <span class="nav-text">系统时钟配置函数 SetSysClockTo72()分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hse%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="nav-number">1.10.3.</span> <span class="nav-text">HSE配置系统时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_rccclkconfigc%E4%B8%AD%E5%86%99%E5%85%A5hse%E7%9A%84%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">在bsp_rccclkconfig.c中写入HSE的配置函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_rccclkconfigc%E4%B8%AD%E7%BC%96%E5%86%99mco%E7%9A%84gpio%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">在bsp_rccclkconfig.c中编写MCO的GPIO初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_rccclkconfigh%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">在bsp_rccclkconfig.h中添加函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E8%B0%83%E7%94%A8hse%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%87%BD%E6%95%B0%E5%92%8Cmco%E7%9A%84gpio%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.4.</span> <span class="nav-text">在main.c中调用HSE配置系统时钟函数和MCO的GPIO初始化函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8hsi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%B9%B6%E7%94%A8mco%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="nav-number">1.10.4.</span> <span class="nav-text">使用HSI配置系统时钟并用MCO监控系统时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_rccclkconfigc%E4%B8%AD%E7%BC%96%E5%86%99hsi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">在bsp_rccclkconfig.c中编写HSI配置系统时钟函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_rccclkconfigh%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">在bsp_rccclkconfig.h中加入函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E8%B0%83%E7%94%A8hsi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">在main.c中调用HSI配置系统时钟函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">1.11.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stm32%E4%B8%AD%E6%96%AD%E5%BA%94%E7%94%A8%E6%A6%82%E8%A7%88"><span class="nav-number">1.11.1.</span> <span class="nav-text">STM32中断应用概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">中断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nvic"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">NVIC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#nvic%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="nav-number">1.11.1.2.1.</span> <span class="nav-text">NVIC的优先级分组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.11.2.</span> <span class="nav-text">中断编程的顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exti"><span class="nav-number">1.12.</span> <span class="nav-text">EXTI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exti-%E8%BE%93%E5%85%A5%E7%BA%BF"><span class="nav-number">1.12.1.</span> <span class="nav-text">EXTI 输入线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exti-%E6%A1%86%E5%9B%BE%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.12.2.</span> <span class="nav-text">EXTI 框图讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">外部中断流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">外部事件流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exti-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.12.3.</span> <span class="nav-text">EXTI 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exti-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">EXTI 的结构体定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#exti_line-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.12.3.1.1.</span> <span class="nav-text">EXTI_Line 的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exti_mode-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.12.3.1.2.</span> <span class="nav-text">EXTI_Mode 的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exti_trigger-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.12.3.1.3.</span> <span class="nav-text">EXTI_Trigger 的定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gpio-%E4%BD%9C%E4%B8%BA%20exti%20%E8%BE%93%E5%85%A5%E7%BA%BF%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">1.12.4.</span> <span class="nav-text">GPIO 作为 EXTI 输入线的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exti%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.12.5.</span> <span class="nav-text">EXTI中断实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_extic%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A6%81%E8%BF%9E%E6%8E%A5%E5%88%B0exti%E7%9A%84gpio"><span class="nav-number">1.12.5.1.</span> <span class="nav-text">在bsp_exti.c中初始化要连接到EXTI的GPIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_extic%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96exti%E7%94%A8%E4%BA%8E%E4%BA%A7%E7%94%9F%E4%B8%AD%E6%96%AD/%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.12.5.2.</span> <span class="nav-text">在bsp_exti.c中初始化EXTI用于产生中断&#x2F;事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_extic%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96nvic,-%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD"><span class="nav-number">1.12.5.3.</span> <span class="nav-text">在bsp_exti.c中初始化NVIC, 用于处理中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10x_itc%E4%B8%AD%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="nav-number">1.12.5.4.</span> <span class="nav-text">在stm32f10x_it.c中编写中断服务函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledh%E4%B8%AD%E7%BC%96%E5%86%99%E7%94%B5%E5%B9%B3%E5%8F%8D%E8%BD%AC%E5%87%BD%E6%95%B0"><span class="nav-number">1.12.5.5.</span> <span class="nav-text">在bsp_led.h中编写电平反转函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E4%BD%BF%E8%83%BDafio%E6%97%B6%E9%92%9F"><span class="nav-number">1.12.6.</span> <span class="nav-text">补充: 使能AFIO时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#afio%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.12.6.1.</span> <span class="nav-text">AFIO的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%90%AFafio%E6%97%B6%E9%92%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.12.6.2.</span> <span class="nav-text">开启AFIO时钟的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afio%E7%9A%84%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="nav-number">1.12.6.3.</span> <span class="nav-text">AFIO的实际操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afio%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.12.6.4.</span> <span class="nav-text">AFIO的总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#systick"><span class="nav-number">1.13.</span> <span class="nav-text">SysTick</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#systick%E7%AE%80%E4%BB%8B"><span class="nav-number">1.13.1.</span> <span class="nav-text">SysTick简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#systick-%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="nav-number">1.13.2.</span> <span class="nav-text">SysTick 功能框图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#systick-%E5%AF%84%E5%AD%98%E5%99%A8%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.13.3.</span> <span class="nav-text">SysTick 寄存器描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#systick-%E5%AE%9A%E6%97%B6%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="nav-number">1.13.4.</span> <span class="nav-text">SysTick 定时时间计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-systick%20%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.13.5.</span> <span class="nav-text">补充: SysTick 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#systick%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.13.5.1.</span> <span class="nav-text">SysTick的主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#systick%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.13.5.2.</span> <span class="nav-text">SysTick的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#systick%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.13.5.3.</span> <span class="nav-text">SysTick的配置和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#systick%E7%9A%84%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.13.5.4.</span> <span class="nav-text">SysTick的编程示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#systick-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.13.6.</span> <span class="nav-text">SysTick 源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#systick-%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.13.7.</span> <span class="nav-text">SysTick 实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_systickc%E4%B8%AD%E7%BC%96%E5%86%99%E5%BE%AE%E5%A6%99%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="nav-number">1.13.7.1.</span> <span class="nav-text">在bsp_systick.c中编写微妙延时函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_systickc%E4%B8%AD%E7%BC%96%E5%86%99%E6%AF%AB%E7%A7%92%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="nav-number">1.13.7.2.</span> <span class="nav-text">在bsp_systick.c中编写毫秒延时函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_systickh%E4%B8%AD%E5%BC%95%E7%94%A8%E5%BA%93%E6%96%87%E4%BB%B6%E5%92%8C%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.13.7.3.</span> <span class="nav-text">在bsp_systick.h中引用库文件和进行函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E8%B0%83%E7%94%A8%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0,%E5%AE%9E%E7%8E%B0led%E9%97%AA%E7%83%81"><span class="nav-number">1.13.7.4.</span> <span class="nav-text">在main.c中调用延时函数,实现LED闪烁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.14.</span> <span class="nav-text">通信的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="nav-number">1.14.1.</span> <span class="nav-text">串行和并行通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%8F%8C%E5%B7%A5,-%E5%8D%8A%E5%8F%8C%E5%B7%A5%E5%92%8C%E5%8D%95%E5%B7%A5"><span class="nav-number">1.14.2.</span> <span class="nav-text">全双工, 半双工和单工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-number">1.14.3.</span> <span class="nav-text">同步与异步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.14.3.1.</span> <span class="nav-text">同步与异步的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E7%9A%84%E9%80%9F%E7%8E%87"><span class="nav-number">1.14.4.</span> <span class="nav-text">通信的速率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#usart-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="nav-number">1.15.</span> <span class="nav-text">USART-串口通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="nav-number">1.15.1.</span> <span class="nav-text">串口通信协议简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86"><span class="nav-number">1.15.1.1.</span> <span class="nav-text">物理层的常用标准</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#232%E5%92%8Cttl%E7%94%B5%E5%B9%B3%E5%8C%BA%E5%88%AB"><span class="nav-number">1.15.1.1.1.</span> <span class="nav-text">232和TTL电平区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#232%E9%80%9A%E4%BF%A1%E9%80%9A%E8%AE%AF%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">1.15.1.1.1.1.</span> <span class="nav-text">232通信通讯结构图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#usb%E8%BD%AC%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">1.15.1.1.1.2.</span> <span class="nav-text">USB转串口通讯结构图</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%88%B0%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">1.15.1.1.2.</span> <span class="nav-text">串口到串口通讯结构图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.15.1.2.</span> <span class="nav-text">串口数据包的组成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stm32%E4%B8%B2%E5%8F%A3%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.15.2.</span> <span class="nav-text">STM32串口功能框图讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%84%9A%E9%83%A8%E5%88%86%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.15.2.1.</span> <span class="nav-text">引脚部分讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E8%84%9A%E5%AF%B9%E5%BA%94"><span class="nav-number">1.15.2.1.1.</span> <span class="nav-text">引脚对应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E9%83%A8%E5%88%86"><span class="nav-number">1.15.2.2.</span> <span class="nav-text">数据寄存器部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.15.2.2.1.</span> <span class="nav-text">数据格式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#usart_cr1%E7%9A%84bit12-m%E6%8E%A7%E5%88%B6%E5%AD%97%E9%95%BF"><span class="nav-number">1.15.2.2.1.1.</span> <span class="nav-text">USART_CR1的bit12 M控制字长</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#usart_cr2%E7%9A%84bit%5B13:12%5D-stop%E6%8E%A7%E5%88%B6%E5%81%9C%E6%AD%A2%E4%BD%8D%E7%9A%84%E4%BD%8D%E6%95%B0"><span class="nav-number">1.15.2.2.1.2.</span> <span class="nav-text">USART_CR2的bit[13:12] STOP控制停止位的位数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#usart_cr1%E7%9A%84bit10(pse),-bit9(ps)%E6%9D%A5%E4%BD%BF%E8%83%BD%E6%A0%A1%E9%AA%8C%E5%92%8C%E9%80%89%E6%8B%A9%E6%A0%A1%E9%AA%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.15.2.2.1.3.</span> <span class="nav-text">USART_CR1的bit10(PSE), bit9(PS)来使能校验和选择校验模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#usart_cr1%E7%9A%84bit8(peie)%E6%9D%A5%E4%BD%BF%E8%83%BD%E4%B8%AD%E6%96%AD"><span class="nav-number">1.15.2.2.1.4.</span> <span class="nav-text">USART_CR1的bit8(PEIE)来使能中断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#usart_sr%E7%9A%84bit0(pe)%E6%9D%A5%E6%A3%80%E6%B5%8B%E6%A0%A1%E9%AA%8C%E9%94%99%E8%AF%AF"><span class="nav-number">1.15.2.2.1.5.</span> <span class="nav-text">USART_SR的bit0(PE)来检测校验错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86"><span class="nav-number">1.15.2.3.</span> <span class="nav-text">发送数据部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86"><span class="nav-number">1.15.2.4.</span> <span class="nav-text">接收数据部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.15.2.5.</span> <span class="nav-text">波特率设置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8usart_brr%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">1.15.2.5.1.</span> <span class="nav-text">使用USART_BRR进行配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="nav-number">1.15.2.5.2.</span> <span class="nav-text">波特率的计算公式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%9B%BA%E4%BB%B6%E5%BA%93%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.15.3.</span> <span class="nav-text">串口初始化结构体和固件库讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">串口初始化结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.3.2.</span> <span class="nav-text">串口库函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usb%E8%BD%AC%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">1.15.4.</span> <span class="nav-text">USB转串口的硬件原理图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3gpio%E6%B1%87%E6%80%BB"><span class="nav-number">1.15.5.</span> <span class="nav-text">串口GPIO汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E5%A4%96%E8%AE%BE%E7%9A%84gpio%E9%85%8D%E7%BD%AE"><span class="nav-number">1.15.6.</span> <span class="nav-text">补充: 外设的GPIO配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3%E5%8A%A9%E6%89%8B"><span class="nav-number">1.15.7.</span> <span class="nav-text">配置串口助手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usart%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.15.8.</span> <span class="nav-text">USART接收和发送实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usarth%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%B8%B2%E5%8F%A3%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89,-%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%9D%A5%E9%80%89%E6%8B%A9%E4%B8%B2%E5%8F%A3"><span class="nav-number">1.15.8.1.</span> <span class="nav-text">在bsp_usart.h中进行串口的宏定义, 并使用条件编译来选择串口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99usart%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.2.</span> <span class="nav-text">在bsp_usart.c中编写usart的初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.3.</span> <span class="nav-text">在bsp_usart.c中编写串口中断优先级配置函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E5%88%B0%E4%B8%B2%E5%8F%A3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.4.</span> <span class="nav-text">在bsp_usart.c中编写发送一个字节到串口的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%91%E9%80%81%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82%E5%88%B0%E4%B8%B2%E5%8F%A3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.5.</span> <span class="nav-text">在bsp_usart.c中编写发送两个字节到串口的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%91%E9%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.6.</span> <span class="nav-text">在bsp_usart.c中编写发送数组的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99%E5%8F%91%E9%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.7.</span> <span class="nav-text">在bsp_usart.c中编写发送字符串的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E7%BC%96%E5%86%99%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0,-%E4%BD%BF%E5%BE%97%E4%B8%B2%E5%8F%A3%E5%8F%AF%E4%BD%BF%E7%94%A8scanf%20printf%E7%AD%89%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.8.8.</span> <span class="nav-text">在bsp_usart.c中编写重定向标准输出输入函数, 使得串口可使用scanf printf等函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">1.15.8.9.</span> <span class="nav-text">在main.c函数中进行测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8stm32f10x_itc%E4%B8%AD%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E5%B9%B6%E5%8F%91%E9%80%81"><span class="nav-number">1.15.8.10.</span> <span class="nav-text">在stm32f10x_it.c中编写中断服务函数实现串口数据的接收并发送</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E9%80%9A%E8%BF%87%E9%87%8D%E5%86%99fputc%E5%87%BD%E6%95%B0%E9%87%8D%E5%AE%9A%E5%90%91c%E5%BA%93%E5%87%BD%E6%95%B0printf%E5%88%B0%E4%B8%B2%E5%8F%A3"><span class="nav-number">1.15.9.</span> <span class="nav-text">补充: 通过重写fputc函数重定向C库函数printf到串口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usart%E6%8E%A7%E5%88%B6rgb%E7%81%AF%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.15.10.</span> <span class="nav-text">USART控制RGB灯实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledh%E4%B8%AD%E5%AE%9A%E4%B9%89rgb%E7%81%AF%E7%9A%84%E5%AE%8F"><span class="nav-number">1.15.10.1.</span> <span class="nav-text">在bsp_led.h中定义RGB灯的宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_ledc%E4%B8%AD%E7%BC%96%E5%86%99led%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.15.10.2.</span> <span class="nav-text">在bsp_led.c中编写led初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_usartc%E4%B8%AD%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD"><span class="nav-number">1.15.10.3.</span> <span class="nav-text">在bsp_usart.c中关闭串口中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.15.10.4.</span> <span class="nav-text">在main.c中编写测试程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dma"><span class="nav-number">1.16.</span> <span class="nav-text">DMA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-dma%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.16.1.</span> <span class="nav-text">补充: DMA介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.16.1.1.</span> <span class="nav-text">DMA的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.16.1.2.</span> <span class="nav-text">DMA的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="nav-number">1.16.1.3.</span> <span class="nav-text">DMA的应用领域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.16.1.4.</span> <span class="nav-text">DMA控制器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.16.2.</span> <span class="nav-text">DMA功能框图讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="nav-number">1.16.2.1.</span> <span class="nav-text">DMA请求映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma%E4%BB%B2%E8%A3%81%E5%99%A8"><span class="nav-number">1.16.2.2.</span> <span class="nav-text">DMA仲裁器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma%E5%9B%BA%E4%BB%B6%E5%BA%93-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.16.3.</span> <span class="nav-text">DMA固件库-初始化结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma%E5%9B%BA%E4%BB%B6%E5%BA%93-%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.16.4.</span> <span class="nav-text">DMA固件库-固件库函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma%E5%AE%9E%E9%AA%8C1:-m%20to%20m"><span class="nav-number">1.16.5.</span> <span class="nav-text">DMA实验1: M to M</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2mh%E5%A2%9E%E5%8A%A0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.16.5.1.</span> <span class="nav-text">在bsp_dma_m2m.h增加宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2mc%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%BA%90%E5%92%8C%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F"><span class="nav-number">1.16.5.2.</span> <span class="nav-text">在bsp_dma_m2m.c中定义源和目标变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2mc%E4%B8%AD%E5%A2%9E%E5%8A%A0dma%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.16.5.3.</span> <span class="nav-text">在bsp_dma_m2m.c中增加DMA初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2mc%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%9B%B8%E7%AD%89%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.16.5.4.</span> <span class="nav-text">在bsp_dma_m2m.c中增加判断数据相等的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%9B%E8%A1%8Cdma%E6%B5%8B%E8%AF%95"><span class="nav-number">1.16.5.5.</span> <span class="nav-text">在main.c函数中进行DMA测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma%E5%AE%9E%E9%AA%8C2:-m%20to%20p"><span class="nav-number">1.16.6.</span> <span class="nav-text">DMA实验2: M to P</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2ph%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.16.7.</span> <span class="nav-text">在bsp_dma_m2p.h中加入宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2pc%E4%B8%AD%E5%8A%A0%E5%85%A5usart%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">1.16.7.1.</span> <span class="nav-text">在bsp_dma_m2p.c中加入USART的初始化函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2pc%E4%B8%AD%E5%8A%A0%E5%85%A5usartx_tx-dma%E9%85%8D%E7%BD%AE"><span class="nav-number">1.16.7.2.</span> <span class="nav-text">在bsp_dma_m2p.c中加入USARTx_TX DMA配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_dma_m2pc%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.16.7.3.</span> <span class="nav-text">在bsp_dma_m2p.c中声明在内存的变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.16.7.4.</span> <span class="nav-text">在main.c中声明外部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E6%B5%8B%E8%AF%95dma"><span class="nav-number">1.16.7.5.</span> <span class="nav-text">在main.c中测试DMA</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">1.17.</span> <span class="nav-text">常用存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.17.1.</span> <span class="nav-text">存储器的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ram%E5%AD%98%E5%82%A8%E5%99%A8(%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8)"><span class="nav-number">1.17.2.</span> <span class="nav-text">RAM存储器(易失性存储器)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ram%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.17.2.1.</span> <span class="nav-text">RAM介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dram%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84"><span class="nav-number">1.17.2.2.</span> <span class="nav-text">DRAM的存储单元结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sram%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84"><span class="nav-number">1.17.2.3.</span> <span class="nav-text">SRAM的存储单元结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sram%E5%92%8Cdram%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.17.2.4.</span> <span class="nav-text">SRAM和DRAM的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">1.17.3.</span> <span class="nav-text">非易失性存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rom%E7%AE%80%E4%BB%8B"><span class="nav-number">1.17.3.1.</span> <span class="nav-text">ROM简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flash%E7%AE%80%E4%BB%8B"><span class="nav-number">1.17.3.2.</span> <span class="nav-text">FLASH简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#i2c-%E8%AF%BB%E5%86%99eeprom"><span class="nav-number">1.18.</span> <span class="nav-text">I2C-读写EEPROM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-i2c%E7%AE%80%E4%BB%8B"><span class="nav-number">1.18.1.</span> <span class="nav-text">补充: I2C简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85:-%E9%AB%98%E9%98%BB%E6%80%81"><span class="nav-number">1.18.2.</span> <span class="nav-text">补充: 高阻态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i2c%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">1.18.3.</span> <span class="nav-text">I2C物理层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.18.3.1.</span> <span class="nav-text">I2C物理层主要特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i2c%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="nav-number">1.18.4.</span> <span class="nav-text">I2C协议层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B"><span class="nav-number">1.18.4.1.</span> <span class="nav-text">I2C基本读写过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E5%86%99%E6%95%B0%E6%8D%AE%E5%88%B0%E4%BB%8E%E6%9C%BA"><span class="nav-number">1.18.4.1.1.</span> <span class="nav-text">主机写数据到从机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E7%94%B1%E4%BB%8E%E6%9C%BA%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">1.18.4.1.2.</span> <span class="nav-text">主机由从机读数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%A4%8D%E5%90%88%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.18.4.1.3.</span> <span class="nav-text">通信复合格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%AE%AF%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%92%8C%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.18.4.2.</span> <span class="nav-text">通讯的起始和停止信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"><span class="nav-number">1.18.4.3.</span> <span class="nav-text">数据的有效性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%96%B9%E5%90%91"><span class="nav-number">1.18.4.4.</span> <span class="nav-text">地址及数据方向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94"><span class="nav-number">1.18.4.5.</span> <span class="nav-text">响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stm32%E7%9A%84i2c%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9E%B6%E6%9E%84"><span class="nav-number">1.18.5.</span> <span class="nav-text">STM32的I2C特性及架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stm32%E7%9A%84i2c%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="nav-number">1.18.5.1.</span> <span class="nav-text">STM32的I2C架构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c%E7%9A%84%E9%80%9A%E8%AE%AF%E5%BC%95%E8%84%9A"><span class="nav-number">1.18.5.1.1.</span> <span class="nav-text">I2C的通讯引脚</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="nav-number">1.18.5.1.2.</span> <span class="nav-text">时钟控制逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%92%9F%E9%A2%91%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.18.5.1.2.1.</span> <span class="nav-text">计算时钟频率的方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="nav-number">1.18.5.1.3.</span> <span class="nav-text">数据控制逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="nav-number">1.18.5.1.4.</span> <span class="nav-text">整体控制逻辑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stm32%E7%A1%AC%E4%BB%B6i2c%E7%9A%84%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B"><span class="nav-number">1.18.6.</span> <span class="nav-text">STM32硬件I2C的通讯过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stm32%E4%BD%9C%E4%B8%BA%E4%B8%BB%E5%8F%91%E9%80%81%E5%99%A8%E7%9A%84%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B"><span class="nav-number">1.18.6.1.</span> <span class="nav-text">STM32作为主发送器的通讯过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stm32%E4%BD%9C%E4%B8%BA%E4%B8%BB%E6%8E%A5%E6%94%B6%E5%99%A8%E7%9A%84%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B"><span class="nav-number">1.18.6.2.</span> <span class="nav-text">STM32作为主接收器的通讯过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i2c%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.18.7.</span> <span class="nav-text">I2C初始化结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i2c%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.8.</span> <span class="nav-text">I2C库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_generatestart%E5%87%BD%E6%95%B0,-%E7%94%A8%E4%BA%8E%E4%BA%A7%E7%94%9F%E8%B5%B7%E5%A7%8B%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.18.8.1.</span> <span class="nav-text">I2C_GenerateSTART函数, 用于产生起始条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_getflagstatus%E5%87%BD%E6%95%B0,-%E7%94%A8%E4%BA%8E%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%E4%BD%8D"><span class="nav-number">1.18.8.2.</span> <span class="nav-text">I2C_GetFlagStatus函数, 用于获取状态位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_send7bitaddress%E5%87%BD%E6%95%B0,-%E7%94%A8%E4%BA%8E%E5%8F%91%E9%80%817%E4%BD%8D%E5%9C%B0%E5%9D%80"><span class="nav-number">1.18.8.3.</span> <span class="nav-text">I2C_Send7bitAddress函数, 用于发送7位地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_senddate%E5%87%BD%E6%95%B0,-%E9%80%9A%E8%BF%87i2cx%E5%A4%96%E8%AE%BE%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%AD%97%E8%8A%82"><span class="nav-number">1.18.8.4.</span> <span class="nav-text">I2C_SendDate函数, 通过I2Cx外设发送数据字节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_receivedata%E5%87%BD%E6%95%B0,-%E8%BF%94%E5%9B%9E%20i2cx%20%E5%A4%96%E8%AE%BE%E6%9C%80%E8%BF%91%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.18.8.5.</span> <span class="nav-text">I2C_ReceiveData函数, 返回 I2Cx 外设最近接收的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acknowledgeconfig%E5%87%BD%E6%95%B0,-%E4%BD%BF%E8%83%BD%E6%88%96%E7%A6%81%E7%94%A8i2c%E7%9A%84%E5%BA%94%E7%AD%94"><span class="nav-number">1.18.8.6.</span> <span class="nav-text">AcknowledgeConfig函数, 使能或禁用I2C的应答</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_cmd%E5%87%BD%E6%95%B0,-%E4%BD%BF%E8%83%BD%E6%88%96%E7%A6%81%E7%94%A8i2cx%E5%A4%96%E8%AE%BE"><span class="nav-number">1.18.8.7.</span> <span class="nav-text">I2C_Cmd函数, 使能或禁用I2Cx外设</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c_checkevent%E5%87%BD%E6%95%B0,-i2c%E7%8A%B6%E6%80%81%E7%9B%91%E6%B5%8B%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.8.8.</span> <span class="nav-text">I2C_CheckEvent函数, I2C状态监测函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eeprom%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.18.9.</span> <span class="nav-text">EEPROM硬件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E"><span class="nav-number">1.18.9.1.</span> <span class="nav-text">引脚说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#at24c02%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.18.10.</span> <span class="nav-text">AT24C02介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E"><span class="nav-number">1.18.10.1.</span> <span class="nav-text">AT24C02引脚说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80"><span class="nav-number">1.18.10.2.</span> <span class="nav-text">AT24C02设备地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E7%9A%84byte-write(%E4%BB%A5%E5%AD%97%E8%8A%82%E6%96%B9%E5%BC%8F%E5%86%99%E6%95%B0%E6%8D%AE)%E6%93%8D%E4%BD%9C"><span class="nav-number">1.18.10.3.</span> <span class="nav-text">AT24C02的Byte Write(以字节方式写数据)操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E7%9A%84page-write(%E4%BB%A5%E9%A1%B5%E6%96%B9%E5%BC%8F%E5%86%99%E6%95%B0%E6%8D%AE)%E6%93%8D%E4%BD%9C"><span class="nav-number">1.18.10.4.</span> <span class="nav-text">AT24C02的Page Write(以页方式写数据)操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E7%9A%84acknowledge-polling(%E7%A1%AE%E8%AE%A4%E8%BD%AE%E8%AF%A2)"><span class="nav-number">1.18.10.5.</span> <span class="nav-text">AT24C02的ACKNOWLEDGE POLLING(确认轮询)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E7%9A%84current-address%20read(%E4%BB%8E%E5%BD%93%E5%89%8D%E5%9C%B0%E5%9D%80%E8%AF%BB%E6%95%B0%E6%8D%AE)%E6%93%8D%E4%BD%9C"><span class="nav-number">1.18.10.6.</span> <span class="nav-text">AT24C02的Current Address Read(从当前地址读数据)操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E7%9A%84random-read(%E9%9A%8F%E6%9C%BA%E8%AF%BB%E6%95%B0%E6%8D%AE)%E6%93%8D%E4%BD%9C"><span class="nav-number">1.18.10.7.</span> <span class="nav-text">AT24C02的Random Read(随机读数据)操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#at24c02%E7%9A%84sequential-read(%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%95%B0%E6%8D%AE)%E6%93%8D%E4%BD%9C"><span class="nav-number">1.18.10.8.</span> <span class="nav-text">AT24C02的Sequential Read(顺序读数据)操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i2c-%E8%AF%BB%E5%86%99eeprom%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.18.11.</span> <span class="nav-text">I2C-读写EEPROM实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.18.11.1.</span> <span class="nav-text">操作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2ch%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="nav-number">1.18.11.2.</span> <span class="nav-text">在bsp_i2c.h中定义相关宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2ch%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">1.18.11.3.</span> <span class="nav-text">在bsp_i2c.h中进行函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2cc%E4%B8%AD%E7%BC%96%E5%86%99i2c_eeprom%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.4.</span> <span class="nav-text">在bsp_i2c.c中编写I2C_EEPROM配置函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2cc%E4%B8%AD%E7%BC%96%E5%86%99byte-writting%E6%96%B9%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.5.</span> <span class="nav-text">在bsp_i2c.c中编写Byte Writting方式的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2cc%E4%B8%AD%E7%BC%96%E5%86%99page-writting%E6%96%B9%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.6.</span> <span class="nav-text">在bsp_i2c.c中编写Page Writting方式的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2cc%E4%B8%AD%E7%BC%96%E5%86%99random-read%E6%96%B9%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.7.</span> <span class="nav-text">在bsp_i2c.c中编写Random Read方式的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2cc%E4%B8%AD%E7%BC%96%E5%86%99sequential-read%E6%96%B9%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.8.</span> <span class="nav-text">在bsp_i2c.c中编写Sequential Read方式的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8bsp_i2cc%E4%B8%AD%E7%BC%96%E5%86%99%E7%A1%AE%E8%AE%A4%E8%AF%A2%E9%97%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.9.</span> <span class="nav-text">在bsp_i2c.c中编写确认询问函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8mainc%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95"><span class="nav-number">1.18.11.10.</span> <span class="nav-text">在main.c中进行读写测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1"><span class="nav-number">1.18.11.11.</span> <span class="nav-text">串口实验现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%96%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.18.11.12.</span> <span class="nav-text">完善功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.18.11.12.1.</span> <span class="nav-text">增加的宏定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="nav-number">1.18.11.12.2.</span> <span class="nav-text">调试功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.3.</span> <span class="nav-text">超时处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.18.11.12.3.1.</span> <span class="nav-text">超时处理相关宏定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.18.11.12.3.2.</span> <span class="nav-text">超时处理相关变量声明</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.3.3.</span> <span class="nav-text">超时状态函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E5%86%99%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.4.</span> <span class="nav-text">多字节写入函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%AD%97%E8%8A%82%E5%86%99%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.5.</span> <span class="nav-text">单字节写入函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E9%A1%B5%E5%86%99%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.6.</span> <span class="nav-text">单页写入函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.7.</span> <span class="nav-text">读取数据函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E5%BE%85eeprom%E5%87%BD%E6%95%B0"><span class="nav-number">1.18.11.12.8.</span> <span class="nav-text">等待EEPROM函数</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Eric Ellis</p>
  <div class="site-description" itemprop="description">记录生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/See-YouL" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;See-YouL" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:seeyoulater2023@duck.com" title="E-Mail → mailto:seeyoulater2023@duck.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Ellis</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

  

    </div>
</body>
</html>
